<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.sysctl.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":320,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="安装期间的存储注意事项许多存储设备和文件系统设置只能在安装时进行配置。其他设置（如文件系统类型）只能在不需要重新格式化的情况下进行修改。因此，在安装红帽企业版Linux 7之前，谨慎的规划您的存储配置。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux存储管理">
<meta property="og:url" content="https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/index.html">
<meta property="og:site_name" content="Sysctl">
<meta property="og:description" content="安装期间的存储注意事项许多存储设备和文件系统设置只能在安装时进行配置。其他设置（如文件系统类型）只能在不需要重新格式化的情况下进行修改。因此，在安装红帽企业版Linux 7之前，谨慎的规划您的存储配置。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-image.nos-eastchina1.126.net/J3Ke3j2Iid.png?imageslim">
<meta property="article:published_time" content="2017-12-30T02:23:48.000Z">
<meta property="article:modified_time" content="2020-01-22T14:36:13.365Z">
<meta property="article:author" content="Goooo">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Storage">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-image.nos-eastchina1.126.net/J3Ke3j2Iid.png?imageslim">

<link rel="canonical" href="https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Linux存储管理 | Sysctl</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Sysctl" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sysctl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Too young, too simple. Sometimes, naive & stupid</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xth0331" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/img.png">
      <meta itemprop="name" content="Goooo">
      <meta itemprop="description" content="真正的粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sysctl">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux存储管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-30 10:23:48" itemprop="dateCreated datePublished" datetime="2017-12-30T10:23:48+08:00">2017-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-22 22:36:13" itemprop="dateModified" datetime="2020-01-22T22:36:13+08:00">2020-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/12/30/Linux/storage/LocalStorage/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/30/Linux/storage/LocalStorage/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="安装期间的存储注意事项"><a href="#安装期间的存储注意事项" class="headerlink" title="安装期间的存储注意事项"></a>安装期间的存储注意事项</h1><p>许多存储设备和文件系统设置只能在安装时进行配置。其他设置（如文件系统类型）只能在不需要重新格式化的情况下进行修改。因此，在安装红帽企业版Linux 7之前，谨慎的规划您的存储配置。<br><a id="more"></a></p>
<h2 id="特别注意事项"><a href="#特别注意事项" class="headerlink" title="特别注意事项"></a>特别注意事项</h2><p>列举了特定存储配置需要考虑的几个问题和因素。</p>
<h3 id="单独分区为-home-opt-usr-local"><a href="#单独分区为-home-opt-usr-local" class="headerlink" title="单独分区为 /home, /opt, /usr/local"></a>单独分区为 /home, /opt, /usr/local</h3><p>If it is likely that you will upgrade your system in the future, place <code>/home</code>, <code>/opt</code>, and <code>/usr/local</code> on a separate device. This will allow you to reformat the devices/file systems containing the operating system while preserving your user and application data.</p>
<h3 id="IBM-System-Z-上的-DASD和zFCP设备"><a href="#IBM-System-Z-上的-DASD和zFCP设备" class="headerlink" title="IBM System Z 上的 DASD和zFCP设备"></a>IBM System Z 上的 DASD和zFCP设备</h3><p>在IBM System Z平台上, DASD 和 zFCP 设备通过 <em>Channel Command Word</em> (CCW) 机制进行配置. CCW路径必须显式添加到系统中，然后才能联机。 对于DASD设备， 这只是意味着列出设备号码（或设备号码范围）， <code>DASD=</code> 参数在引导命令行或CMS配置文件中。</p>
<p>对于zFCP设备，必须列出设备号， <em>逻辑单元号</em> (LUN), and <em>全球端口名</em> (WWPN). 一旦zFCP设备被初始化，它被映射到CCW路径。 The <code>FCP_x=</code> 启动命令行（或在CMS配置文件）上线，您可以指定该信息的安装程序。</p>
<h3 id="使用LUKS加密块设备"><a href="#使用LUKS加密块设备" class="headerlink" title="使用LUKS加密块设备"></a>使用LUKS加密块设备</h3><p>使用LUKS /格式化块设备进行加密<code>dm-crypt</code>将会破坏该设备上的任何现有格式。因此，在新系统的存储配置作为安装过程的一部分被激活之前，您应该决定要加密哪些设备（如果有的话）。</p>
<h3 id="陈旧的BIOS-RAID元数据"><a href="#陈旧的BIOS-RAID元数据" class="headerlink" title="陈旧的BIOS RAID元数据"></a>陈旧的BIOS RAID元数据</h3><p>从配置为固件RAID的系统移动磁盘<em>而不</em>从磁盘中移除RAID元数据可能会阻止<strong>Anaconda</strong>正确检测磁盘。</p>
<p>从磁盘删除/删除RAID元数据可能会破坏任何存储的数据。红帽建议您在继续之前备份您的数据。</p>
<p>要从磁盘删除RAID元数据，请使用以下命令：</p>
<p><code>dmraid -r -E /*device*/</code></p>
<h3 id="iSCSI检测和配置"><a href="#iSCSI检测和配置" class="headerlink" title="iSCSI检测和配置"></a>iSCSI检测和配置</h3><p>对于iSCSI驱动器的即插即用检测，请将其配置在具有iBFT启动功能的<em>网络接口卡</em>（NIC）的固件中。在安装过程中支持iSCSI目标的CHAP身份验证。但是，安装期间不支持iSNS发现。</p>
<h3 id="FCoE检测和配置"><a href="#FCoE检测和配置" class="headerlink" title="FCoE检测和配置"></a>FCoE检测和配置</h3><p>对于<em>以太网光纤通道</em>（FCoE）驱动器的即插即用检测，请在具有EDD引导功能的NIC的固件中对其进行配置。</p>
<h3 id="DASD"><a href="#DASD" class="headerlink" title="DASD"></a>DASD</h3><p><em>直接访问存储设备</em>（DASD）不能在安装过程中添加/配置。这些设备在CMS配置文件中指定。</p>
<h3 id="块设备启用DIF-DIX"><a href="#块设备启用DIF-DIX" class="headerlink" title="块设备启用DIF/DIX"></a>块设备启用DIF/DIX</h3><p>DIF/DIX 是某些SCSI主机总线适配器和块设备提供的硬件校验和功能. 启用 DIF/DIX 时, 如果块设备用作通用块设备，则会发生错误。 缓冲的 I/O 或 <code>mmap(2)</code>-基于 I/O 将无法可靠地工作，因为在缓冲写入路径中没有互锁，以防止在计算了 DIF/DIX 校验和之后缓冲的数据被覆盖。</p>
<p>这将导致 I/O 稍后失败并出现校验和错误。这个问题对所有块设备（或基于文件系统）缓冲的 I/O 或 <code>mmap(2)</code> I/O, 都很常见，所以不可能解决这些由覆盖造成的错误。</p>
<p>因此，启用了 DIF/DIX 的块设备只能与使用的应用程序一起使用 <code>O_DIRECT</code>. 这样的应用程序应该使用原始块设备。或者，只要在文件系统中只发出 <code>O_DIRECT</code> I/O . 在启用了DIF/DIX的块设备上使用XFS文件系统也是安全的。XFS是唯一一个在执行某些分配操作时不会回退到缓冲I/O的文件系统。</p>
<p>在计算完 DIF/DIX 校验和之后，确保I/O数据不会改变的责任始终在于应用程序，因此只有为 <code>O_DIRECT</code> I/O 和 DIF/DIX 硬件设计的应用程序才能使用 DIF/DIX.</p>
<h1 id="文件系统检查"><a href="#文件系统检查" class="headerlink" title="文件系统检查"></a>文件系统检查</h1><p>可以使用文件系统特定的用户空间工具检查文件系统的一致性，并可以选择修复。这些工具通常被称为<code>fsck</code>工具，其中<code>fsck</code>是缩短版本的<em>文件系统检查</em>。</p>
<p><strong>注意</strong></p>
<p>文件系统不一致可能由于各种原因而发生，包括但不限于硬件错误，存储管理错误和软件错误。</p>
<p>这些文件系统检查程序只保证整个文件系统的元数据一致性; 他们没有意识到文件系统中包含的实际数据，而不是数据恢复工具。</p>
<p>在现代元数据记录文件系统变得普遍之前，系统崩溃或断电时都需要进行文件系统检查。这是因为文件系统更新可能被中断，导致状态不一致。因此，文件系统检查通常<code>/etc/fstab</code>在引导时列出的每个文件系统上运行。对于日志文件系统，这通常是非常短的操作，因为文件系统的元数据日志记录即使在崩溃之后也能确保一致性。</p>
<p>但是，即使对于日志记录文件系统，有时甚至可能发生文件系统不一致或损坏。发生这种情况时，必须使用文件系统检查程序修复文件系统。以下内容将提供执行此过程时的最佳实践和其他有用信息。</p>
<p>除非计算机无法启动，文件系统非常大或者文件系统位于远程存储中，否则Red Hat不建议使用此功能。通过将/etc/fstab中的第六个字段设置为0，可以在启动时禁用文件系统检查。</p>
<h2 id="fsck最佳实践"><a href="#fsck最佳实践" class="headerlink" title="fsck最佳实践"></a>fsck最佳实践</h2><p>一般来说，运行文件系统检查和修复工具可以自动修复至少一些找到的不一致之处。在某些情况下，严重损坏的索引节点或目录如果无法修复，可能会被丢弃。文件系统的重大更改可能会发生。为确保不会永久性发生意想不到的变化，请执行以下预防措施：</p>
<ul>
<li><p>演习</p>
<p>大多数文件系统检查程序有一个操作模式，可以检查文件系统，但不会修复文件系统。在这种模式下，检查器将打印它找到的任何错误和应该采取的操作，而不实际修改文件系统。</p>
<p>一致性检查的后续阶段可能会打印额外的错误，因为它发现了不一致的情况，如果在修复模式下运行，它们在早期阶段就会被修复。</p>
</li>
<li><p>首先在文件系统映像上运行</p>
<p>大多数文件系统都支持创建<em>元数据映像</em>，这是一个只包含元数据的文件系统的稀疏副本。由于文件系统检查程序仅对元数据进行操作，因此可以使用此映像执行实际文件系统修复的空运行，以评估实际进行的更改。如果更改是可接受的，则修复可以在文件系统上执行。</p>
<p>严重损坏的文件系统可能会导致元数据映像创建出现问题。</p>
</li>
<li><p>保存文件系统映像以进行支持调查</p>
<p>修复前的文件系统元数据映像通常可以用于支持调查，如果有可能是由于软件错误引起的。修复前图像中存在的腐败模式可能有助于根源分析。</p>
</li>
<li><p>仅在卸载的文件系统上运行</p>
<p>文件系统的修复只能在未安装的文件系统上运行。该工具必须能够唯一访问文件系统，否则可能会导致进一步的损坏。大多数文件系统工具在修复模式下强制执行此要求，尽管某些文件系统仅支持在已安装的文件系统上进行只检查模式。如果在已安装的文件系统上运行只检查模式，则可能会发现在卸载的文件系统上运行时不会发现的虚假错误。</p>
</li>
<li><p>磁盘错误</p>
<p>文件系统检查工具不能修复硬件问题。如果修复成功，文件系统必须完全可读写。如果文件系统由于硬件错误而损坏，则必须首先将文件系统移动到合适的磁盘上，例如使用 <code>dd(8)</code> 实用程序.</p>
</li>
</ul>
<h2 id="FSCK的文件系统特定信息"><a href="#FSCK的文件系统特定信息" class="headerlink" title="FSCK的文件系统特定信息"></a>FSCK的文件系统特定信息</h2><h3 id="ext2-ext3-和-ext4"><a href="#ext2-ext3-和-ext4" class="headerlink" title="ext2, ext3, 和 ext4"></a>ext2, ext3, 和 ext4</h3><p>所有这些文件系统都使用 <code>e2fsck</code> 二进制来执行文件系统检查和修复. 文件名 <code>fsck.ext2</code>, <code>fsck.ext3</code>, 和 <code>fsck.ext4</code> 都硬链接到这个相同的二进制文件. 这些二进制文件在启动时自动运行，其行为根据被检查的文件系统和文件系统的状态而不同。</p>
<p>对ext2（不是元数据日志文件系统）和ext4文件系统（不带日志）调用完整的文件系统检查和修复.</p>
<p>对于具有元数据日记功能的ext3和ext4文件系统，将在用户空间中重播日志，并退出二进制文件。这是默认操作，因为日志重播确保崩溃后的文件系统一致</p>
<p>如果这些文件系统在挂载时遇到元数据不一致的情况，他们会将这个事实记录在文件系统超级块中。 如果 <code>e2fsck</code> 发现文件系统标有这样的错误 <code>e2fsck</code> 将在重播日志（如果存在）后执行完整检查。</p>
<p><code>e2fsck</code> 如果没有指定<code>-p</code>选项 ，则可以在运行期间询问用户输入。   <code>-p</code>项告诉 <code>e2fsck</code> 自动执行所有可能安全完成的修理。如果需要用户干预， <code>e2fsck</code> 将在其输出中指示未固定的问题，并在退出代码中反映此状态。</p>
<p>常用的 <code>e2fsck</code> 运行时选项包括：</p>
<ul>
<li><p><code>-n</code></p>
<p>无修改模式。只检查操作。</p>
</li>
<li><p><code>-b</code> superblock</p>
<p>如果主要的损坏，指定一个备用的suprerblock的块号。</p>
</li>
<li><p><code>-f</code></p>
<p>即使超级块没有记录错误，也强制进行全面检查。</p>
</li>
<li><p><code>-j</code> journal-dev</p>
<p>指定外部日志设备（如果有）。</p>
</li>
<li><p><code>-p</code></p>
<p>在没有用户输入的情况下自动修复或“修改”文件系统。</p>
</li>
<li><p><code>-y</code></p>
<p>对所有问题都回答“是”。</p>
<p><code>e2fsck</code>所有选项都在 <code>e2fsck(8)</code> 手册页中。</p>
</li>
</ul>
<p><code>e2fsck</code> 运行时 执行以下五个基本阶段：</p>
<ol>
<li>Inode, block,和大小检查。</li>
<li>目录结构检查。</li>
<li>目录连接检查。</li>
<li>引用计数检查。</li>
<li><p>小组汇总信息检查。</p>
<p><code>e2image(8)</code> 在修复之前， 该实用程序可用于创建元数据映像以用于诊断或测试目的。  <code>-r</code> 选项应该用于测试目的，以创建一个与文件系统本身相同大小的稀疏文件。 <code>e2fsck</code> 然后可以直接对结果文件进行操作。 如果要将图像归档或提供用于诊断，应指定<code>-Q</code>选项  ，这创建了一个适合传输的更紧凑的文件格式。</p>
</li>
</ol>
<h3 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h3><p>在启动时不会自动执行修复。要启动文件系统检查或修复，使用 <code>xfs_repair</code> 工具。</p>
<p><strong>注意</strong></p>
<p>尽管xfsprogs包中有一个二进制文件 <code>fsck.xfs</code> ，但它只是为了满足在启动时查找二进制文件 <code>fsck.*filesystem*</code>的初始化脚本 . <code>fsck.xfs</code> 立即退出，退出代码为0.</p>
<p>另一件需要注意的是旧的xfsprogs包包含一个 <code>xfs_check</code> 工具。这个工具非常慢，对于大型文件系统来说效果不好。因此, 它已被弃用，推荐使用xfs_repair -n`.</p>
<p> <code>xfs_repair</code> 操作，文件系统上必须是干净的日志， 如果文件系统没有完全卸载, 在使用 <code>xfs_repair</code>之前应该挂载和卸载. 如果日志损坏且无法重播, 可以使用 <code>-L</code> 选项将日志归零.</p>
<p><strong>重要</strong></p>
<p> <code>-L</code> 选项 只有在日志无法重播的情况下才能使用. 该选项会丢弃日志中的所有元数据更新，并将导致进一步的不一致.</p>
<p>可以在演习运行 <code>xfs_repair</code> , 运行check-only模式通过 <code>-n</code> 选项. 不会对文件系统进行更改。</p>
<p><code>xfs_repair</code> 需要很少的选项。常用的选项包括:</p>
<ul>
<li><p><code>-n</code></p>
<p>没有修改模式。只检查操作。</p>
</li>
<li><p><code>-L</code></p>
<p>零元数据日志。只有在日志不能用mount重放时才使用。</p>
</li>
<li><p><code>-m</code> maxmem</p>
<p>将运行期间使用的内存限制为 maxmem MB. 可以指定0来获得所需最小内存的粗略估计。</p>
</li>
<li><p><code>-l</code> logdev</p>
<p>指定外部日志设备（如果存在）。</p>
<p><code>xfs_repair</code> 的所有选项都在 <code>xfs_repair(8)</code> 手册页中指定.</p>
</li>
</ul>
<p><code>xfs_repair</code> 运行时 执行以下八个基本阶段:</p>
<ol>
<li>Inode 和 inode 块映射 (寻址) 检查.</li>
<li>Inode 分配映射检查.</li>
<li>Inode 大小检查.</li>
<li>目录检查.</li>
<li>路径名检查.</li>
<li>链接计数检查.</li>
<li>Freemap检查.</li>
<li>超级块检查.</li>
</ol>
<p><code>xfs_repair</code> 不是交互的. 所有的操作都是在没有用户输入的情况下自动执行的.</p>
<p>如果希望在修复之前创建元数据映像以用于诊断或测试目的，可以使用<code>xfs_metadump(8)</code> 和 <code>xfs_mdrestore(8)</code> 。</p>
<h4 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h4><p> <code>btrfsck</code> 工具用于检查和修复btrfs文件系统。此工具仍处于早期开发阶段，可能无法检测或修复所有类型的文件系统损坏。</p>
<p>默认情况下, <code>btrfsck</code> 不对文件系统进行更改; 也就是说，它默认运行只检查模式。如果需要修复，必须指定 <code>--repair</code> 选项。</p>
<p> <code>btrfsck</code>运行时 执行以下三个基本阶段 :</p>
<ol>
<li>范围检查。</li>
<li>文件系统根检查。</li>
<li>根引用计数检查。</li>
</ol>
<p>在修复之前<code>btrfs-image(8)</code> 可用于创建元数据映像以用于诊断或测试目的。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>使用 <strong>parted</strong> 程序，您可以：</p>
<ul>
<li>查看现有的分区表。</li>
<li>改变现有分区的大小。</li>
<li>从可用空间或其他硬盘添加分区。</li>
</ul>
<p>Parted软件包默认安装在Red Hat Enterprise Linux 7上. 启动 <strong>parted</strong>, 以root身份登录 ，在shell下运行 <code>parted */dev/sda*</code> </p>
<p>其中 <em>/dev/sda</em> 是要配置的驱动器设备名称。</p>
<h2 id="在正在使用的设备上操作分区"><a href="#在正在使用的设备上操作分区" class="headerlink" title="在正在使用的设备上操作分区"></a>在正在使用的设备上操作分区</h2><p>对于不使用的设备，不能使用设备上的分区进行挂载，也不能使能设备的交换空间。</p>
<p>如果要删除或调整分区的大小，则不得使用该分区所在的设备。</p>
<p>在正在使用的设备上创建新分区是可能的，但不推荐使用。</p>
<h2 id="修改分区表"><a href="#修改分区表" class="headerlink" title="修改分区表"></a>修改分区表</h2><p>通常不建议在同一磁盘上的另一个分区正在使用的同时修改分区表，因为内核无法重新读取分区表。因此，更改不适用于正在运行的系统。在描述的情况下，重新启动系统，或使用以下命令使系统注册新的或修改的分区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># partx --update --nr partition-number disk</span></span><br></pre></td></tr></table></figure>
<p>修改当前正在使用的磁盘的最简单方法是，如果无法卸载磁盘上的分区（例如在系统磁盘的情况下），则以救援模式引导系统。当提示安装文件系统时，请选择<strong>跳过</strong>。</p>
<p>如果驱动器不包含任何正在使用的分区，也就是没有使用或锁定文件系统的系统进程被卸载，则可以使用<code>umount</code>命令卸载分区，并使用<code>swapoff</code>命令关闭硬盘上的所有交换空间。</p>
<p>不要使用<strong>parted</strong>实用程序来创建文件系统。改用<strong>mkfs</strong>工具。</p>
<p><strong>parted Commands</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check</code> <em><code>minor-num</code></em></td>
<td>执行文件系统的简单检查</td>
</tr>
<tr>
<td><code>cp</code> <em><code>from to</code></em></td>
<td>从一个分区复制文件系统到另一个分区; <em>从</em>和<em>到</em>是分区的次要数字</td>
</tr>
<tr>
<td><code>help</code></td>
<td>显示可用命令的列表</td>
</tr>
<tr>
<td><code>mklabel</code> <em><code>label</code></em></td>
<td>为分区表创建一个磁盘标签</td>
</tr>
<tr>
<td><code>mkfs</code> <em><code>minor-num</code></em> <em><code>file-system-type</code></em></td>
<td>创建一个文件系统类型的<em>文件系统</em></td>
</tr>
<tr>
<td><code>mkpart</code> <em><code>part-type</code></em> [<em><code>fs-type</code></em>] <em><code>start-mb**end-mb</code></em></td>
<td>创建一个分区而不创建新的文件系统</td>
</tr>
<tr>
<td><code>mkpartfs</code> <em><code>part-type</code></em> <em><code>fs-type</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>创建一个分区并创建指定的文件系统</td>
</tr>
<tr>
<td><code>move</code> <em><code>minor-num</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>移动分区</td>
</tr>
<tr>
<td><code>name</code> <em><code>minor-num</code></em> <em><code>name</code></em></td>
<td>只为Mac和PC98磁盘标签命名分区</td>
</tr>
<tr>
<td><code>print</code></td>
<td>显示分区表</td>
</tr>
<tr>
<td><code>quit</code></td>
<td>退出 <strong>parted</strong></td>
</tr>
<tr>
<td><code>rescue</code> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>从<em>start-mb</em>到<em>end-mb</em>挽救一个丢失的分区</td>
</tr>
<tr>
<td><code>resize</code> <em><code>minor-num</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>调整分区从<em>start-mb</em>到<em>end-mb的大小</em></td>
</tr>
<tr>
<td><code>rm</code> <em><code>minor-num</code></em></td>
<td>删除分区</td>
</tr>
<tr>
<td><code>select</code> <em><code>device</code></em></td>
<td>选择一个不同的设备进行配置</td>
</tr>
<tr>
<td><code>set</code> <em><code>minor-num</code></em> <em><code>flag</code></em> <em><code>state</code></em></td>
<td>在分区上设置标志; <em>状态</em>是打开还是关闭</td>
</tr>
<tr>
<td><code>toggle</code> [<em><code>NUMBER</code></em> [<em><code>FLAG</code></em>]</td>
<td>在<em>NUMBER</em>分区上切换<em>FLAG</em>的状态</td>
</tr>
<tr>
<td><code>unit</code> <em><code>UNIT</code></em></td>
<td>将默认单位设置为<em>UNIT</em></td>
</tr>
</tbody>
</table>
</div>
<h2 id="查看分区表"><a href="#查看分区表" class="headerlink" title="查看分区表"></a>查看分区表</h2><p>启动parted, 使用 <code>print</code> 命令来查看分区表。出现类似如下的表格：</p>
<p><strong>分区表</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Model: ATA ST3160812AS (scsi)</span><br><span class="line">Disk /dev/sda: 160GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line"></span><br><span class="line">Number  Start   End    Size    Type      File system  Flags</span><br><span class="line"> 1      32.3kB  107MB  107MB   primary   ext3         boot</span><br><span class="line"> 2      107MB   105GB  105GB   primary   ext3</span><br><span class="line"> 3      105GB   107GB  2147MB  primary   linux-swap</span><br><span class="line"> 4      107GB   160GB  52.9GB  extended		      root</span><br><span class="line"> 5      107GB   133GB  26.2GB  logical   ext3</span><br><span class="line"> 6      133GB   133GB  107MB   logical   ext3</span><br><span class="line"> 7      133GB   160GB  26.6GB  logical                lvm</span><br></pre></td></tr></table></figure>
<p>第一行包含磁盘类型，制造商，型号和接口，第二行显示磁盘标签类型。第四行下面的剩余输出显示分区表。</p>
<p>在分区表中, <em>次要</em>号码是分区 <code>number</code>. 例如，次号为1的分区对应于 <code>/dev/sda1</code>.  <code>Start</code> 和 <code>End</code> 值以MB为单位。 有效的 <code>Type</code> 是元数据, free（空闲）, primary（主）, extended（扩展）, or logical（逻辑）.  <code>Filesystem</code> 是文件系统的类型，其可以是任何以下的：</p>
<ul>
<li>ext2</li>
<li>ext3</li>
<li>fat16</li>
<li>fat32</li>
<li>hfs</li>
<li>jfs</li>
<li>linux-swap</li>
<li>ntfs</li>
<li>reiserfs</li>
<li>hp-ufs</li>
<li>sun-ufs</li>
<li>xfs</li>
</ul>
<p>如果某个<code>Filesystem</code>设备没有显示任何值，则表示其文件系统类型未知。</p>
<p><strong>标志</strong>列列出了分区被设置的标志。可用的标志有 boot, root, swap, hidden, raid, lvm, or lba.</p>
<p>要选择不同的设备而不必重新启动<code>parted</code>，请使用<code>select</code>命令后跟设备名称（例如<code>/dev/sda</code>）。这样做可以让您查看或配置设备的分区表。</p>
<h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><p>==不要尝试在正在使用的设备上创建分区。==</p>
<p><strong>创建分区</strong></p>
<ol>
<li><p>在创建分区之前，启动进入救援模式（或卸载设备上的任何分区，并关闭设备上的交换空间）。</p>
</li>
<li><p>开始<code>parted</code>，在哪里创建分区的设备： <code>/dev/sda</code></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># parted /dev/sda</span></span><br></pre></td></tr></table></figure>
<ol>
<li>查看当前分区表以确定是否有足够的可用空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print</span></span><br></pre></td></tr></table></figure>
<p>如果没有足够的可用空间，则可以调整现有分区的大小。</p>
<h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><p>从分区表中，确定新分区的起点和终点以及它应该是什么分区类型。设备上只能有四个主分区（没有扩展分区）。如果您需要四个以上的分区，则扩展中可以有三个主分区，一个扩展分区和多个逻辑分区。</p>
<p>例如，要创建一个ext3文件系统从1024兆字节到2048兆字节的硬盘上的主分区，请键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkpart primary 1024 2048</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果使用该<code>mkpartfs</code>命令，则在创建分区后创建文件系统。但是，<code>parted</code>不支持创建ext3文件系统。因此，如果您希望创建一个ext3文件系统，请按照稍后所述使用<code>mkpart</code>和创建文件系统<code>mkfs</code>。</p>
<p>按<strong>Enter键后</strong>，所做的更改就会开始，因此在执行命令之前先查看命令。</p>
<p>创建分区后，使用该<code>print</code>命令确认它在正确的分区类型，文件系统类型和大小的分区表中。还要记住新分区的次要号码，以便您可以在其上标记任何文件系统。您还应该查看<code>cat /proc/partitions</code>关闭后的输出，以确保内核识别新分区。</p>
<p>分区分区的最大数量将为128.尽管<em>GUID分区表</em>（GPT）规范允许通过增加为分区表保留的区域来增加分区，但分区使用的常见做法是将其限制为足够的区域用于128个分区。</p>
<h3 id="格式化和标记分区"><a href="#格式化和标记分区" class="headerlink" title="格式化和标记分区"></a>格式化和标记分区</h3><p>要格式化和标记分区，请使用以下过程：</p>
<p><strong>格式化和标记分区</strong></p>
<ol>
<li>该分区没有文件系统。要创建<code>ext4</code>文件系统，请使用：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 /dev/sda6</span></span><br></pre></td></tr></table></figure>
<p>   <strong>警告</strong></p>
<p>   格式化分区将永久销毁分区上当前存在的任何数据。</p>
<ol>
<li><p>接下来，给分区上的文件系统一个标签。例如，如果新分区上的文件系统是<code>/dev/sda6</code>并且要标记它<code>/work</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e2label /dev/sda6 /work</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认情况下，安装程序使用分区的挂载点作为标签来确保标签是唯一的。你可以使用任何你想要的标签。</p>
<p>之后，以root身份创建一个安装点（例如<code>/work</code>）。</p>
<h4 id="添加-etc-fstab"><a href="#添加-etc-fstab" class="headerlink" title="添加/etc/fstab"></a>添加<code>/etc/fstab</code></h4><p>以root <code>/etc/fstab</code>身份，使用分区的UUID 编辑文件以包含新的分区。使用该命令<code>blkid -o list</code>可以获得分区UUID的完整列表，也可以<code>blkid device</code>查看各个设备的详细信息。</p>
<p>第一列应该包含<code>UUID=</code>文件系统的UUID。第二列应包含新分区的挂载点，下一列应为文件系统类型（例如，ext3或swap）。如果您需要更多关于格式的信息，请使用该命令阅读手册页<code>man fstab</code>。</p>
<p>如果第四列是该字<code>defaults</code>，则在引导时挂载分区。要挂载分区而不重新启动，请以超级用户身份键入以下命令：</p>
<p><code>mount /work</code></p>
<h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><p>==不要尝试删除正在使用的设备上的分区。==</p>
<p><strong>删除分区</strong></p>
<ol>
<li><p>在删除分区之前，启动进入救援模式（或卸载设备上的任何分区，并关闭设备上的交换空间）.</p>
</li>
<li><p>启动 <code>parted</code>, 删除sda设备上的分区。</p>
</li>
</ol>
<p>​```bash</p>
<h1 id="parted-dev-sda"><a href="#parted-dev-sda" class="headerlink" title="parted /dev/sda"></a>parted /dev/sda</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 查看当前分区表以确定要删除的分区的次号码：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">   # print</span><br></pre></td></tr></table></figure>
<ol>
<li>用命令<code>rm</code>删除分区 . 例如，要删除次编号为3的分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm 3</span></span><br></pre></td></tr></table></figure>
<p>   按<strong>Enter键</strong>，所做的更改就会开始，因此在提交之前先查看命令。</p>
<ol>
<li>删除分区后，使用 <code>print</code> 命令确认它已从分区表中删除。您还应该查看输出<code>/proc/partitions</code>以确保内核知道分区已被删除。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/partitions</span></span><br></pre></td></tr></table></figure>
<ol>
<li>最后一步是从<code>/etc/fstab</code>文件中删除它。找到声明已删除分区的行，并将其从文件中删除。</li>
</ol>
<h2 id="设置分区类型"><a href="#设置分区类型" class="headerlink" title="设置分区类型"></a>设置分区类型</h2><p>分区类型，不要与文件系统类型混淆，很少被运行的系统使用。但是，分区类型对即时生成器很重要，例如<code>systemd-gpt-auto-generator</code>使用分区类型来自动识别和挂载设备。</p>
<p>您可以启动该<code>fdisk</code>实用程序并使用该<code>t</code>命令来设置分区类型。以下示例显示如何将第一个分区的分区类型更改为0x83，在Linux上是default：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/sdc</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 83</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux LVM'</span> to <span class="string">'Linux'</span>.</span><br></pre></td></tr></table></figure>
<p><code>parted</code> 程序通过尝试将分区类型映射到“标志”来提供对分区类型的一些控制，这对最终用户不方便。该<code>parted</code>实用程序只能处理某些分区类型，例如LVM或RAID。例如，要删除第一个分区的lvm标志<code>parted</code>，使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted</span><br><span class="line"><span class="comment"># parted /dev/sdc 'set 1 lvm off'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用FDISK调整分区大小"><a href="#使用FDISK调整分区大小" class="headerlink" title="使用FDISK调整分区大小"></a>使用FDISK调整分区大小</h2><p><code>fdisk</code>实用程序允许您创建和操作GPT，MBR，Sun，SGI和BSD分区表。在具有GUID分区表（GPT）的磁盘上，<code>parted</code>建议使用该实用程序，因为<code>fdisk</code>GPT支持处于试验阶段。</p>
<p>在调整分区大小之前，<em>备份</em>存储在文件系统<em>上</em>的数据并测试过程，因为使用的唯一方法是更改分区大小，方法<code>fdisk</code>是删除并重新创建分区。</p>
<p><strong>重要</strong></p>
<p>您正在调整大小的分区必须是特定磁盘上的最后一个分区。</p>
<p>红帽只支持扩展和调整LVM分区的大小。</p>
<p><strong>调整分区大小</strong></p>
<p>以下程序仅供参考。要使用<code>fdisk</code>以下命令调整分区大小：</p>
<ol>
<li>卸载设备:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /dev/vda</span></span><br></pre></td></tr></table></figure>
<ol>
<li>运行 <code>fdisk *disk_name*</code>. 例如:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/vda</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them. Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>p</code> 选项确定要删除的分区的行号。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/vda: 16.1 GB, 16106127360 bytes, 31457280 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0006d09a</span><br><span class="line"></span><br><span class="line">Device    Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/vda2         1026048    31457279    15215616   8e  Linux LVM</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用 <code>d</code> 选项删除分区. 如果有多个可用的分区，<code>fdisk</code>则会提示您提供一个要删除的分区的编号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line">Partition 2 is deleted</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>使用 <code>n</code> 选项创建分区并按照提示进行操作。留出足够的空间用于将来调整大小.  <code>fdisk</code> 默认行为 (输入 <code>Enter</code>) 是使用设备上的所有空间. 您可以按扇区指定分区的末尾, 也可以使用 <code>+*&lt;size&gt;**&lt;suffix&gt;*</code>, 例如 +500M, 或者 +10G.</p>
<p>如果您不想使用全部可用空间，则Red Hat建议使用可读大小的规范<code>fdisk</code>，将分区的末尾与物理扇区对齐。如果通过提供确切的数字（扇区）来指定大小，<code>fdisk</code>则不会对齐分区的末尾。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): *Enter*</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (2-4, default 2): *Enter*</span><br><span class="line">First sector (1026048-31457279, default 1026048): *Enter*</span><br><span class="line">Using default value 1026048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (1026048-31457279, default 31457279): +500M</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 500 MiB is <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将分区类型设置为LVM:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): *Enter*     </span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果确定所做的更改是正确的 请使用<code>w</code>选项编写更改 , 因为错误可能会导致所选分区不稳定。</p>
</li>
<li><p>运行 <code>e2fsck</code> 在设备上 运行以检查一致性:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e2fsck /dev/vda</span><br><span class="line">e2fsck 1.41.12 (17-May-2010)</span><br><span class="line">Pass 1:Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2:Checking directory structure</span><br><span class="line">Pass 3:Checking directory connectivity</span><br><span class="line">Pass 4:Checking reference counts</span><br><span class="line">Pass 5:Checking group summary information</span><br><span class="line">ext4-1:11/131072 files (0.0% non-contiguous),27050/524128 blocks</span><br></pre></td></tr></table></figure>
<ol>
<li>挂载设备:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/vda</span><br></pre></td></tr></table></figure>
<h1 id="使用快照程序创建和维护快照"><a href="#使用快照程序创建和维护快照" class="headerlink" title="使用快照程序创建和维护快照"></a>使用快照程序创建和维护快照</h1><p>快照卷是目标卷的时间点副本，它提供了将文件系统恢复到早期状态的方法。Snapper是一个命令行工具，用于为Btrfs和精简配置的LVM文件系统创建和维护快照。</p>
<h2 id="创建初始快照程序配置"><a href="#创建初始快照程序配置" class="headerlink" title="创建初始快照程序配置"></a>创建初始快照程序配置</h2><p>Snapper需要为其运行的每个卷设置独立的配置文件。您必须手动设置配置文件。默认情况下，只有root用户才能执行snapper命令。</p>
<p>Red Hat建议在Red Hat Enterprise Linux 7上使用带有Snapper的ext4文件系统。只有在监视池中的可用空间量时，才能在lvm-thin卷上使用XFS文件系统，以防止出现空间不足的问题导致失败。</p>
<p>请注意，Btrfs工具和文件系统是作为技术预览提供的，这使得它们不适用于生产系统。</p>
<p>虽然可以允许用户或根以外的组使用某些命令鲷鱼，红帽建议您不要<em>不</em>提升的权限添加到非特权否则用户或组。这样的配置绕过SELinux，可能会造成安全风险。红帽建议您与安全团队一起审核这些功能，并考虑使用<code>sudo</code>基础架构。</p>
<p><strong>创建快照程序配置文件</strong></p>
<ol>
<li><p>创建或选择:</p>
<ul>
<li>一个配置了红帽支持文件系统的精简配置逻辑卷，或者</li>
<li>Btrfs子卷.</li>
</ul>
</li>
<li><p>安装文件系统.</p>
</li>
<li><p>创建定义这个卷的配置文件.</p>
<p>对于 LVM2:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create-config -f "lvm(fs_type)" /mount-point</span></span><br></pre></td></tr></table></figure>
<p>   对于 Btrfs:</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create-config -f btrfs /mount-point</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code> <em><code>config_name</code></em> 选项指定配置文件的名称.</li>
<li><code>create-config</code> 选项告诉 snapper创建一个配置文件.</li>
<li><code>-f</code> <em><code>file_system</code></em> 选项告诉 snapper 所使用的文件系统；如果省略将尝试检测文件系统</li>
<li><p><em><code>/mount-point</code></em> 是安装子卷或精简配置的LVM2文件系统的位置</p>
<p>例如，要创建<code>lvm_config</code>在具有ext4文件系统的LVM2子卷上调用的配置文件（安装在）<code>/lvm_mount</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create-config -f "lvm(ext4)" /lvm_mount</span></span><br></pre></td></tr></table></figure>
<p>或者，要创建名为的配置文件<code>btrfs_config</code>，请在挂载的Btrfs子卷上<code>/btrfs_mount</code>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c btrfs_config create-config -f btrfs /btrfs_mount</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置文件存储在<code>/etc/snapper/configs/</code>目录中。</p>
<h2 id="创建快照程序快照"><a href="#创建快照程序快照" class="headerlink" title="创建快照程序快照"></a>创建快照程序快照</h2><p>Snapper可以创建以下类型的快照：</p>
<ul>
<li><p>快照前</p>
<p>预先快照作为发布后快照的起点。两者紧密联系，旨在跟踪两点之间的文件系统修改。必须在发布快照之前创建预先快照。</p>
</li>
<li><p>张贴快照</p>
<p>后快照被用作快照的终点。快照结合前后快照定义了一个比较范围。默认情况下，每个新的快照程序卷都被配置为在成功创建相关的快照后创建背景比较。</p>
</li>
<li><p>单一快照</p>
<p>单个快照是在特定时刻创建的独立快照。这些可以用来跟踪修改的时间线，并有一个普遍的观点返回到稍后。</p>
</li>
</ul>
<h3 id="创建前置和后置快照对"><a href="#创建前置和后置快照对" class="headerlink" title="创建前置和后置快照对"></a>创建前置和后置快照对</h3><h4 id="使用Snapper创建前期快照"><a href="#使用Snapper创建前期快照" class="headerlink" title="使用Snapper创建前期快照"></a>使用Snapper创建前期快照</h4><p>要创建预览快照，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create -t pre</span></span><br></pre></td></tr></table></figure>
<p> <code>-c *config_name*</code> 选项根据指定配置文件中的规范创建快照。</p>
<p><code>create -t</code> 选项指定要创建的快照类型。接受条目 <code>pre</code>, <code>post</code>, 或 <code>single</code>.</p>
<p>例如, ，使用<code>lvm_config</code> 配置文件创建一个快照前，使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c SnapperExample create -t pre -p</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p> <code>-p</code> 选项将打印创建的快照的编号，并且是可选的。</p>
<h4 id="使用Snapper创建帖子快照"><a href="#使用Snapper创建帖子快照" class="headerlink" title="使用Snapper创建帖子快照"></a>使用Snapper创建帖子快照</h4><p><strong>创建一个快照</strong></p>
<ol>
<li><p>确定快照编号:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name list</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   例如，要显示使用配置文件创建的快照列表<code>lvm_config</code>, 请使用以下命令：</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config list</span></span><br><span class="line">Type   | <span class="comment"># | Pre # | Date              | User | Cleanup  | Description | Userdata</span></span><br><span class="line">-------+---+-------+-------------------+------+----------+-------------+---------</span><br><span class="line">single | 0 |       |                   | root |          | current     |</span><br><span class="line">pre    | 1 |       | Mon 06&lt;...&gt;       | root |          |             |</span><br></pre></td></tr></table></figure>
<p>   上面的输出显示前快照是编号1。</p>
<ol>
<li>创建链接到先前创建的预先快照的后快照：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file create -t post --pre-num pre_snapshot_number</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t post</code> 选项指定创建快照类型.</li>
<li><p><code>--pre-num</code> 选项指定相应的预先快照.</p>
<p>例如，要使用 <code>lvm_config</code> 配置文件创建后期快照并将其链接到预先快照编号1，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create -t post --pre-num 1 -p</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>-p</code> 选项将打印创建的快照的编号，并且是可选的。</p>
</li>
</ul>
<ol>
<li><p>快照1和快照2现在已创建并配对。验证这个<code>list</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config list</span></span><br><span class="line">Type   | <span class="comment"># | Pre # | Date              | User | Cleanup  | Description | Userdata</span></span><br><span class="line">-------+---+-------+-------------------+------+----------+-------------+---------</span><br><span class="line">single | 0 |       |                   | root |          | current     |</span><br><span class="line">pre    | 1 |       | Mon 06&lt;...&gt;       | root |          |             |</span><br><span class="line">post   | 2 | 1     | Mon 06&lt;...&gt;       | root |          |             |</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="在快照前后包装一个命令"><a href="#在快照前后包装一个命令" class="headerlink" title="在快照前后包装一个命令"></a>在快照前后包装一个命令</h4><p> 您也可以在快照之前和之后包装一个命令，这在测试时很有用。这是以下步骤的快捷方式：</p>
<ol>
<li>运行<code>snapper create pre snapshot</code>命令。</li>
<li>运行命令或命令列表来执行可能影响文件系统内容的操作。</li>
<li>运行<code>snapper create post snapshot</code>命令。</li>
</ol>
<p><strong>在快照前后包装一个命令</strong></p>
<ol>
<li>在前后快照中包装命令:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create --command "command_to_be_tracked"</span></span><br></pre></td></tr></table></figure>
<p>例如，要跟踪 <code>/lvm_mount/hello_file</code> 文件的创建:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create --command "echo Hello &gt; /lvm_mount/hello_file"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>要验证这一点，请使用 <code>status</code> 命令:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file status first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>例如，要跟踪第一步中所做的更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config status 3..4</span></span><br><span class="line">+..... /lvm_mount/hello_file</span><br></pre></td></tr></table></figure>
<p>如果需要， 使用<code>list</code>命令验证快照的编号。</p>
<p>请注意，不能保证上述示例中的命令是快照捕获的唯一内容。Snapper还记录系统修改的任何内容，而不仅仅是用户修改的内容。</p>
<h3 id="创建单个快照程序快照"><a href="#创建单个快照程序快照" class="headerlink" title="创建单个快照程序快照"></a>创建单个快照程序快照</h3><p>创建单个快照快照与创建快照前或快照后类似，只有create <code>-t</code>选项指定single。单个快照用于创建一个单一的快照，而不会与任何其他快照相关联。但是，如果您有兴趣直接创建LVM2精简卷的快照，而无需自动生成比较或列出附加信息，则红帽建议使用系统存储管理器而不是Snapper来实现此目的，</p>
<p>要创建单个快照，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create -t single</span></span><br></pre></td></tr></table></figure>
<p>例如，以下命令使用<code>lvm_config</code>配置文件创建单个快照。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create -t single</span></span><br></pre></td></tr></table></figure>
<p>虽然单个快照并非专为跟踪变化，您可以使用<code>snapper diff</code>，<code>xadiff</code>和<code>status</code>命令任何两个快照进行比较.</p>
<h3 id="配置快照程序以获取自动快照"><a href="#配置快照程序以获取自动快照" class="headerlink" title="配置快照程序以获取自动快照"></a>配置快照程序以获取自动快照</h3><p>拍摄自动快照是Snapper的主要功能之一。默认情况下，当为Snapper配置卷时，Snapper将开始每小时拍摄卷的快照。</p>
<p>在默认配置下，Snapper保留：</p>
<ul>
<li>每小时10张快照，最终每小时快照保存为“每日”快照。</li>
<li>10个每日快照，并且一个月的最终每日快照被保存为“每月”快照。</li>
<li>每月10次快照，最终每月快照保存为“年度”快照。</li>
<li>每年10个快照。</li>
</ul>
<p>请注意，Snapper默认保持不超过50个快照。但是，Snapper会默认保留不到1800秒前创建的所有快照。</p>
<p>默认配置在<code>/etc/snapper/config-templates/default</code>文件中指定。使用该<code>snapper create-config</code>命令创建配置时，将根据默认配置设置任何未指定的值。您可以编辑文件中任何定义的卷的配置。 <code>/etc/snapper/configs/*config_name*</code></p>
<h2 id="跟踪SNAPPER快照之间的更改"><a href="#跟踪SNAPPER快照之间的更改" class="headerlink" title="跟踪SNAPPER快照之间的更改"></a>跟踪SNAPPER快照之间的更改</h2><p>使用 <code>status</code>, <code>diff</code>, 和 <code>xadiff</code> 指令跟踪快照之间的子卷所做的更改：</p>
<ul>
<li><p>status</p>
<p><code>status</code> 命令显示在两个快照之间创建，修改或删除的文件和目录的列表，这是两个快照之间更改的完整列表。您可以使用此命令来获取更改的概述，而不会有过多的细节。</p>
</li>
<li><p>diff</p>
<p>如果至少检测到一个修改，则 <code>diff</code> 命令显示从 <code>status</code> 命令接收到的两个快照之间的已修改文件和目录的差异。</p>
</li>
<li><p>xadiff</p>
<p> <code>xadiff</code> 命令比较文件或目录的扩展属性在两个快照之间的变化。</p>
</li>
</ul>
<h3 id="比较变更与status命令"><a href="#比较变更与status命令" class="headerlink" title="比较变更与status命令"></a>比较变更与<code>status</code>命令</h3><p> <code>status</code> 命令显示在两个快照之间创建，修改或删除的文件和目录的列表。</p>
<p>要显示两个快照之间的文件状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file status first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要，使用 <code>list</code> 命令确定快照编号。</p>
<p>例如，以下命令使用配置文件<code>lvm_config</code>显示快照1和2之间所做的更改 .</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">snapper -c lvm_config status 1..2</span><br><span class="line">tp.... /lvm_mount/dir1</span><br><span class="line">-..... /lvm_mount/dir1/file_a</span><br><span class="line">c.ug.. /lvm_mount/file2</span><br><span class="line">+..... /lvm_mount/file3</span><br><span class="line">....x. /lvm_mount/file4</span><br><span class="line">cp..xa /lvm_mount/file5</span><br></pre></td></tr></table></figure>
<p>在输出的第一部分中以字母的形式读取字母和圆点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+..... /lvm_mount/file3</span><br><span class="line">||||||</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>列1指示文件（目录条目）类型的任何修改。可能的值是：</p>
<p><strong>Column 1</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>什么也没有变.</td>
</tr>
<tr>
<td>+</td>
<td>创建文件.</td>
</tr>
<tr>
<td>-</td>
<td>文件已删除.</td>
</tr>
<tr>
<td>c</td>
<td>内容已更改.</td>
</tr>
<tr>
<td>t</td>
<td>目录条目的类型已更改。例如，以前的符号链接已经更改为具有相同文件名的常规文件.</td>
</tr>
</tbody>
</table>
</div>
<p>列2指示文件权限的任何更改。可能的值是：</p>
<p><strong>Column 2</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有权限更改.</td>
</tr>
<tr>
<td>p</td>
<td>权限已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>第3列表示用户所有权的任何变化。可能的值是：</p>
<p><strong>Column 3</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有用户所有权更改.</td>
</tr>
<tr>
<td>u</td>
<td>用户所有权已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>第4列表示组所有权的任何变化。可能的值是：</p>
<p><strong>Column 4</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有组的所有权改变.</td>
</tr>
<tr>
<td>g</td>
<td>集体所有权已经改变.</td>
</tr>
</tbody>
</table>
</div>
<p>列5指示扩展属性中的任何更改。可能的值是：</p>
<p><strong>Column 5</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有扩展的属性改变.</td>
</tr>
<tr>
<td>x</td>
<td>扩展属性已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>列6指示访问控制列表（ACL）中的任何更改。可能的值是：</p>
<p><strong>Column 6</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有ACL改变。</td>
</tr>
<tr>
<td>a</td>
<td>ACL被修改。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="比较变更与diff命令"><a href="#比较变更与diff命令" class="headerlink" title="比较变更与diff命令"></a>比较变更与<code>diff</code>命令</h3><p><code>diff</code> 命令显示两个快照之间修改的文件和目录的更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name diff first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要 ,使用<code>list</code> 命令确定快照的编号。</p>
<p>例如，要比较使用<code>lvm_config</code>配置文件创建的快照1和快照2之间的文件更改，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config diff 1..2</span></span><br><span class="line">--- /lvm_mount/.snapshots/13/snapshot/file4	19&lt;...&gt;</span><br><span class="line">+++ /lvm_mount/.snapshots/14/snapshot/file4	20&lt;...&gt;</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+words</span><br></pre></td></tr></table></figure>
<p>上面的输出显示<code>file4</code>已被修改为将“单词”添加到文件中。</p>
<h3 id="比较变更与xadiff命令"><a href="#比较变更与xadiff命令" class="headerlink" title="比较变更与xadiff命令"></a>比较变更与<code>xadiff</code>命令</h3><p> <code>xadiff</code> 命令比较文件或目录的扩展属性在两个快照之间的变化情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name xadiff first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要， 使用<code>list</code>命令确定快照的编号。 </p>
<p>例如，要显示使用<code>lvm_config</code>配置文件创建的快照号码1和快照号码2之间的<code>xadiff</code>输出，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config xadiff 1..2</span></span><br></pre></td></tr></table></figure>
<h2 id="反转快照之间的更改"><a href="#反转快照之间的更改" class="headerlink" title="反转快照之间的更改"></a>反转快照之间的更改</h2><p>要反转两个现有Snapper快照之间所做的更改，请使用<code>undochange</code>以下格式的命令，其中<code>1</code>第一个快照<code>2</code>是第二个快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snapper -c config_name undochange 1..2</span><br></pre></td></tr></table></figure>
<p><strong>Important</strong></p>
<p>使用 <code>undochange</code> 命令不会将Snapper卷恢复到其原始状态，也不会提供数据一致性。发生在指定范围之外的任何文件修改（例如，在快照2之后）将在恢复之后保持不变，例如，恢复到快照1的状态。例如，如果<code>undochange</code>运行以撤消创建用户，则拥有的任何文件由用户仍然可以保持。</p>
<p>在创建快照时也没有确保文件一致性的机制，所以当使用<code>undochange</code>命令时，任何已经存在的不一致都可以传回快照。</p>
<p>不要使用 Snapper <code>undochange</code> 命令 在根文件系统中, 否则可能会导致失败。</p>
<p>下图演示了该<code>undochange</code>命令的工作原理：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/J3Ke3j2Iid.png?imageslim" alt="mark"></p>
<p><strong>快照状态随着时间的推移</strong></p>
<p>该图显示了<code>snapshot_1</code>创建，<code>file_a</code>创建和<code>file_b</code>删除的时间点。<code>Snapshot_2</code>然后创建，然后<code>file_a</code>编辑和<code>file_c</code>创建。这是现在系统的当前状态。目前的系统有一个编辑版本<code>file_a</code>，不<code>file_b</code>，和一个新创建的<code>file_c</code>。</p>
<p>当<code>undochange</code>调用该命令时，Snapper将生成第一个列出的快照和第二个快照之间的已修改文件的列表。在该图中，如果使用该<code>snapper -c SnapperExample undochange 1..2</code>命令，Snapper将创建一个修改文件列表（即已创建<code>file_a</code>;将<code>file_b</code>被删除）并将其应用于当前系统。因此：</p>
<ul>
<li>目前的系统将不会有<code>file_a</code>，因为它创建时还<code>snapshot_1</code>没有创建。</li>
<li><code>file_b</code>将存在，从<code>snapshot_1</code>当前系统复制而来。</li>
<li><code>file_c</code> 将会存在，因为它的创造超出了规定的时间。</li>
</ul>
<p>请注意，如果<code>file_b</code>和<code>file_c</code>冲突，系统可能会损坏。</p>
<p>您也可以使用该<code>snapper -c SnapperExample undochange 2..1</code>命令。在这种情况下，当前的系统会用<code>file_a</code>从中复制的一个版本替换编辑后的版本，而这个编辑版本是在创建<code>snapshot_1</code>之后取消该文件的编辑<code>snapshot_2</code>。</p>
<p><strong>使用挂载和卸载命令来反转更改</strong></p>
<p><code>undochange</code>命令并不总是恢复修改的最佳方式. 使用<code>status</code>和<code>diff</code>命令，您可以做出合格的决定, and use the <code>mount</code> and <code>unmount</code> 而不是 Snapper. 在 <code>mount</code> and <code>unmount</code> 命令仅在您要装载快照并独立于Snapper工作流程浏览其内容时才有用。</p>
<p>如果需要，该<code>mount</code>命令将在安装之前激活相应的LVM Snapper快照。例如，使用<code>mount</code>和<code>unmount</code>命令（例如，有兴趣加载快照并手动提取几个文件的旧版本）。要手动还原文件，请将其从装入的快照复制到当前文件系统</p>
<p>system. The current file system, snapshot 0, is the live file system created in <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-snapper#p-creating-a-snapper-configuration-file" target="_blank" rel="noopener">Procedure 14.1, “Creating a Snapper Configuration File”</a>. Copy the files to the subtree of the original /mount-point.</p>
<p>使用 <code>mount</code> and <code>unmount</code> 命令显式的客户端请求 文件</p>
<p> <code>/etc/snapper/configs/*config_name*</code> 包含  ALLOW_USERS= and ALLOW_GROUPS= variables 您可以在其中添加用户和组.  然后<code>snapperd</code> ，允许您为添加的用户和组执行安装操作</p>
<h2 id="删除快照程序快照"><a href="#删除快照程序快照" class="headerlink" title="删除快照程序快照"></a>删除快照程序快照</h2><p>删除快照：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name delete snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>list</code> 命令来验证快照是否已成功删除。</p>
<h1 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h1><p>Linux中的<em>交换空间</em>在物理内存（RAM）数量已满时使用。如果系统需要更多的内存资源并且RAM已满，则内存中的不活动页面将移至交换空间。虽然交换空间可以帮助具有少量RAM的机器，但不应该被视为更多RAM的替代品。交换空间位于硬盘上，其访问时间比物理内存慢。交换空间可以是专用交换分区（推荐），交换文件或交换分区和交换文件的组合。需要注意的是<em>增加了Btrfs</em>并<em>没有</em>支持的交换空间。</p>
<p>过去几年，交换空间的建议数量随着系统内存量的增加而线性增加。但是，现代系统通常包含数百GB的RAM。因此，建议的交换空间被视为系统内存工作负载的函数，而不是系统内存。</p>
<p>交换分区的推荐大小，具体取决于系统中RAM的数量，以及是否需要足够的内存供系统休眠。建议的交换分区大小在安装过程中自动建立。但是，要允许休眠，您需要在自定义分区阶段编辑交换空间。</p>
<p>建议在系统低内存（1 GB以下）尤其重要。未能在这些系统上分配足够的交换空间可能会导致问题，如不稳定甚至导致安装的系统无法启动。</p>
<p><strong>推荐的系统交换空间</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统中的RAM数量</th>
<th>建议交换空间</th>
<th>如果允许休眠，建议使用交换空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>⩽ 2 GB</td>
<td>RAM的2倍</td>
<td>RAM数量的3倍</td>
</tr>
<tr>
<td>&gt; 2 GB – 8 GB</td>
<td>等于RAM的数量</td>
<td>RAM的2倍</td>
</tr>
<tr>
<td>&gt; 8 GB – 64 GB</td>
<td>至少4 GB</td>
<td>RAM的1.5倍</td>
</tr>
<tr>
<td>&gt; 64 GB</td>
<td>至少4 GB</td>
<td>不建议休眠</td>
</tr>
</tbody>
</table>
</div>
<p>列出的每个范围的边界处（例如具有2 GB，8 GB或64 GB系统RAM的系统），可以选择交换空间和休眠支持。如果您的系统资源允许，增加交换空间可能会导致更好的性能。对于超过140个逻辑处理器或超过3 TB RAM的系统，建议至少100 GB的交换空间。</p>
<p>请注意，通过多个存储设备分配交换空间也会提高交换空间性能，特别是在具有快速驱动器，控制器和接口的系统上。</p>
<p>分配为交换空间的文件系统和LVM2卷在修改时<em>不应</em>使用。如果系统进程或内核正在使用交换空间，则任何修改交换的尝试都将失败。使用<code>free</code>和<code>cat /proc/swaps</code>命令来验证多少和交换在哪里使用。</p>
<p>您应修改交换空间，而系统在引导<code>rescue</code>模式下,当提示安装文件系统时，请选择<strong>跳过</strong>。</p>
<h2 id="添加交换空间"><a href="#添加交换空间" class="headerlink" title="添加交换空间"></a>添加交换空间</h2><p>有时需要在安装后添加更多的交换空间。例如，您可以将系统中的RAM数量从1 GB升级到2 GB，但只有2 GB的交换空间。如果执行内存密集型操作或运行需要大量内存的应用程序，则将交换空间量增加到4 GB可能会有所帮助。</p>
<p>您有三种选择：创建新的交换分区，创建新的交换文件或在现有的LVM2逻辑卷上扩展交换。建议您扩展现有的逻辑卷。</p>
<h3 id="在LVM2逻辑卷上扩展交换"><a href="#在LVM2逻辑卷上扩展交换" class="headerlink" title="在LVM2逻辑卷上扩展交换"></a>在LVM2逻辑卷上扩展交换</h3><p>默认情况下，红帽企业版Linux 7在安装过程中使用所有可用的空间。如果系统出现这种情况，则必须先将新的物理卷添加到交换空间使用的卷组中。</p>
<p>向交换空间的卷组添加额外的存储之后，现在可以扩展它。为此，请执行以下步骤（假定<code>/dev/VolGroup00/LogVol01</code>是要扩展2 GB的卷）：</p>
<p><strong>在LVM2逻辑卷上扩展交换</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将LVM2逻辑卷调整大小2 GB：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvresize /dev/VolGroup00/LogVol01 -L +2G</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<p>要测试逻辑卷是否成功扩展，请使用 <code>cat /proc/swaps</code> 或<code>free</code> 检查交换空间。</p>
<h3 id="为交换创建一个LVM2逻辑卷"><a href="#为交换创建一个LVM2逻辑卷" class="headerlink" title="为交换创建一个LVM2逻辑卷"></a>为交换创建一个LVM2逻辑卷</h3><p>要添加交换卷组（假设<code>/dev/VolGroup00/LogVol02</code>是要添加的交换卷）：</p>
<ol>
<li>创建大小为2 GB的LVM2逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvcreate VolGroup00 -n LogVol02 -L 2G</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将以下条目添加到 <code>/etc/fstab</code> 文件中：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /dev/VolGroup00/LogVol02 swap swap defaults 0 0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<p>要测试逻辑卷是否成功创建，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="创建一个交换文件"><a href="#创建一个交换文件" class="headerlink" title="创建一个交换文件"></a>创建一个交换文件</h3><p>要添加交换文件：</p>
<p><strong>添加一个交换文件</strong></p>
<ol>
<li><p>以兆字节确定新的交换文件的大小并乘以1024来确定块的数量。例如，一个64 MB交换文件的块大小是65536。</p>
</li>
<li><p>在shell中，输入以下命令，<code>count</code>并等于所需的块大小：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dd if=/dev/zero of=/swapfile bs=1024 count=65536</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用以下命令设置交换文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkswap /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li>更改交换文件的安全性，使其不是世界上可读的。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod 0600 /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li>要在启动时立即启用交换文件，但不能自动启用：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapon /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>要在引导时启用它，请编辑<code>/etc/fstab</code>以包含以下条目：</p>
<p><code>/swapfile swap swap defaults 0 0</code></p>
<p>系统下次启动时，将启用新的交换文件。</p>
</li>
</ol>
<p>要测试新的交换文件是否成功创建，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h2 id="删除交换空间"><a href="#删除交换空间" class="headerlink" title="删除交换空间"></a>删除交换空间</h2><p>有时在安装之后可以谨慎的减少交换空间。例如，假设您将系统中的RAM数量从1 GB降级到512 MB，但仍有2 GB的交换空间仍在分配。将交换空间量减少到1 GB可能是有利的，因为较大的2 GB可能会浪费磁盘空间。</p>
<p>您有三种选择：删除用于交换的整个LVM2逻辑卷，删除交换文件或减少现有LVM2逻辑卷上的交换空间。</p>
<h3 id="减少LVM2逻辑卷上的交换"><a href="#减少LVM2逻辑卷上的交换" class="headerlink" title="减少LVM2逻辑卷上的交换"></a>减少LVM2逻辑卷上的交换</h3><p>减少LVM2交换逻辑卷（假定<code>/dev/VolGroup00/LogVol01</code>是要减少的卷）：</p>
<p><strong>减少LVM2交换逻辑卷</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将LVM2逻辑卷减少512 MB：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvreduce /dev/VolGroup00/LogVol01 -L -512M</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<p>要测试交换的逻辑卷大小是否成功减少，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="删除交换的LVM2逻辑卷"><a href="#删除交换的LVM2逻辑卷" class="headerlink" title="删除交换的LVM2逻辑卷"></a>删除交换的LVM2逻辑卷</h3><p>要除去交换卷组（假设<code>/dev/VolGroup00/LogVol02</code>是要除去的交换卷）：</p>
<p><strong>删除交换卷组</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>删除大小为512 MB的LVM2逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lvremove /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>从<code>/etc/fstab</code>文件中删除以下条目：</p>
<p><code>/dev/VolGroup00/LogVol02 swap swap defaults 0 0</code></p>
</li>
</ol>
<p>要测试逻辑卷大小是否已成功删除，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="删除交换文件"><a href="#删除交换文件" class="headerlink" title="删除交换文件"></a>删除交换文件</h3><p><strong>删除交换文件</strong></p>
<ol>
<li>在shell提示下，执行以下命令来禁用交换文件（其中<code>/swapfile</code>是交换文件）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>从<code>/etc/fstab</code>文件中删除它的条目。</p>
</li>
<li><p>删除实际的文件：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm /swapfile</span></span><br></pre></td></tr></table></figure>
<h2 id="移动交换空间"><a href="#移动交换空间" class="headerlink" title="移动交换空间"></a>移动交换空间</h2><p>要将交换空间从一个位置移动到另一个位置，请执行删除交换空间的步骤，然后按照添加交换空间的步骤进行操作。</p>
<h2 id="SSM后端"><a href="#SSM后端" class="headerlink" title="SSM后端"></a>SSM后端</h2><p>SSM使用<code>ssmlib/main.py</code>符合设备，池和卷抽象的核心抽象层，忽略底层技术的细节。后端可以被注册在<code>ssmlib/main.py</code>处理特定的存储技术方法，如<code>create</code>，<code>snapshot</code>或到<code>remove</code>卷和池。</p>
<p>SSM已经有多个后端注册。以下部分将提供关于它们的基本信息以及如何处理池，卷，快照和设备的定义。</p>
<h3 id="Btrfs后端"><a href="#Btrfs后端" class="headerlink" title="Btrfs后端"></a>Btrfs后端</h3><p><strong>注意</strong></p>
<p>Btrfs在红帽企业版Linux 7中作为技术预览功能提供，但自从红帽企业版Linux 7.4发行版以来已经被弃用了。它将在未来的红帽企业Linux主要版本中被删除。</p>
<p>Btrfs是一个具有许多高级功能的文件系统，在SSM中用作卷管理后端。可以使用Btrfs后端创建池，卷和快照。</p>
<h4 id="Btrfs池"><a href="#Btrfs池" class="headerlink" title="Btrfs池"></a>Btrfs池</h4><p>Btrfs文件系统本身就是池。可以通过添加更多设备来扩展，也可以通过删除设备来缩小。创建Btrfs池时，SSM将创建一个Btrfs文件系统。这意味着每个新的Btrfs池都有一个与池相同的卷，如果不删除整个池，则不能删除该卷。默认的Btrfs池名称是<code>btrfs_pool</code>。</p>
<p>池的名称用作文件系统标签。如果系统中已经存在一个没有标签的Btrfs文件系统，则Btrfs池将以格式生成一个内部使用的名称 <code>btrfs_device_base_name</code></p>
<h4 id="Btrfs卷"><a href="#Btrfs卷" class="headerlink" title="Btrfs卷"></a>Btrfs卷</h4><p>在池中的第一个卷之后创建的卷与子卷相同。如果未安装Btrfs文件系统以创建子卷，SSM将临时安装Btrfs文件系统。</p>
<p>卷的名称用作Btrfs文件系统中的子卷路径。例如，一个子卷显示为<code>/dev/lvm_pool/lvol001</code>。该路径中的每个对象都必须存在才能创建卷。卷也可以用它的挂载点来引用。</p>
<h4 id="Btrfs快照"><a href="#Btrfs快照" class="headerlink" title="Btrfs快照"></a>Btrfs快照</h4><p>可以使用SSM在系统中的任何Btrfs卷上拍摄快照。请注意，Btrfs不会区分子卷和快照。虽然这意味着SSM无法识别Btrfs快照目标，但它会尝试识别特殊的名称格式。如果创建快照时指定的名称执行了特定的模式，则快照将不会被识别，而是被列为常规Btrfs卷。</p>
<h4 id="Btrfs设备"><a href="#Btrfs设备" class="headerlink" title="Btrfs设备"></a>Btrfs设备</h4><p>Btrfs不需要创建任何特殊的设备。</p>
<h3 id="LVM后端"><a href="#LVM后端" class="headerlink" title="LVM后端"></a>LVM后端</h3><p>可以使用LVM创建池，卷和快照。以下定义来自LVM的观点。</p>
<h4 id="LVM池"><a href="#LVM池" class="headerlink" title="LVM池"></a>LVM池</h4><p>LVM池与LVM卷组相同。这意味着可以在LVM池外创建分组设备和新逻辑卷。默认的LVM池名称是<code>lvm_pool</code>。</p>
<h4 id="LVM卷"><a href="#LVM卷" class="headerlink" title="LVM卷"></a>LVM卷</h4><p>LVM卷与普通逻辑卷相同。</p>
<h4 id="LVM快照"><a href="#LVM快照" class="headerlink" title="LVM快照"></a>LVM快照</h4><p>当从LVM卷创建快照时，会创建一个新<code>snapshot</code>卷，然后可以像处理其他任何LVM卷一样处理该卷。与Btrfs不同的是，LVM能够区分常规卷的快照，因此不需要快照名称来匹配特定的模式。</p>
<h4 id="LVM设备"><a href="#LVM设备" class="headerlink" title="LVM设备"></a>LVM设备</h4><p>SSM使得需要在对用户透明的物理设备上创建LVM后端。</p>
<h3 id="Crypt-后端"><a href="#Crypt-后端" class="headerlink" title="Crypt 后端"></a>Crypt 后端</h3><p>SSM中的隐藏后端使用<code>cryptsetup</code>并<code>dm-crypt target</code>管理加密卷。加密后端可用作常规后端，用于在常规块设备（或其他卷（如LVM或MD卷）上）上创建加密卷，或者在一个步骤中创建加密的LVM卷。</p>
<p>只有卷可以用隐藏后端创建; 不支持共享，不需要特殊的设备。</p>
<p>以下几节从crypt的角度定义了卷和快照。</p>
<h4 id="地穴容积"><a href="#地穴容积" class="headerlink" title="地穴容积"></a>地穴容积</h4><p><code>dm-crypt</code>加密 卷由未加密的形式创建并代表原始加密设备上的数据。它不支持RAID或任何设备连接。</p>
<p>支持两种模式或扩展：luks和plain。Luks默认使用。有关扩展的更多信息，请参阅<code>man cryptsetup</code>。</p>
<h4 id="Crypt-快照"><a href="#Crypt-快照" class="headerlink" title="Crypt 快照"></a>Crypt 快照</h4><p>虽然crypt后端不支持快照，但如果在LVM卷上创建加密卷，则卷本身可以被快照。快照可以通过使用打开<code>cryptsetup</code>。</p>
<h3 id="多个设备（MD）后端"><a href="#多个设备（MD）后端" class="headerlink" title="多个设备（MD）后端"></a>多个设备（MD）后端</h3><p>MD后端目前仅限于收集有关系统中MD卷的信息。</p>
<h2 id="常见的SSM任务"><a href="#常见的SSM任务" class="headerlink" title="常见的SSM任务"></a>常见的SSM任务</h2><p>以下部分将介绍基本用例，介绍如何安装SSM，然后显示有关所有检测到的设备，池和卷的信息。接下来，将使用两个卷和一个XFS文件系统创建一个池。然后将检查文件系统的一致性，然后卷的大小将会增加。然后创建一个快照。最后其中一卷将被删除。</p>
<h3 id="安装-SSM"><a href="#安装-SSM" class="headerlink" title="安装 SSM"></a>安装 SSM</h3><p>要安装SSM，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum install system-storage-manager</span></span><br></pre></td></tr></table></figure>
<p>只有在安装了支持包的情况下，才会启用多个后端：</p>
<ul>
<li>LVM后端需要<code>lvm2</code>包。</li>
<li>Btrfs后端需要<code>btrfs-progs</code>包。</li>
<li>Crypt后端需要<code>device-mapper</code>和<code>cryptsetup</code>包装。</li>
</ul>
<h3 id="显示有关所有检测到的设备的信息"><a href="#显示有关所有检测到的设备的信息" class="headerlink" title="显示有关所有检测到的设备的信息"></a>显示有关所有检测到的设备的信息</h3><p>使用该<code>list</code>命令显示有关所有检测到的设备，池，卷和快照的信息。运行<code>ssm list</code>没有选项将显示以下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Device        Free      Used      Total  Pool  Mount point</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">/dev/sda                        2.00 GB        PARTITIONED</span><br><span class="line">/dev/sda1                      47.83 MB        /<span class="built_in">test</span></span><br><span class="line">/dev/vda                       15.00 GB        PARTITIONED</span><br><span class="line">/dev/vda1                     500.00 MB        /boot</span><br><span class="line">/dev/vda2  0.00 KB  14.51 GB   14.51 GB  rhel</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">------------------------------------------------</span><br><span class="line">Pool  Type  Devices     Free      Used     Total</span><br><span class="line">------------------------------------------------</span><br><span class="line">rhel  lvm   1        0.00 KB  14.51 GB  14.51 GB</span><br><span class="line">------------------------------------------------</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">Volume          Pool  Volume size  FS     FS size       Free  Type    Mount point</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root  rhel     13.53 GB  xfs   13.52 GB    9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap  rhel   1000.00 MB                             linear</span><br><span class="line">/dev/sda1                47.83 MB  xfs   44.50 MB   44.41 MB  part    /<span class="built_in">test</span></span><br><span class="line">/dev/vda1               500.00 MB  xfs  496.67 MB  403.56 MB  part    /boot</span><br><span class="line">---------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>通过使用参数来指定显示内容，可以进一步缩小显示范围。可用的选项列表可以通过<code>ssm list --help</code>命令找到。</p>
<p>根据给出的参数，SSM可能不会显示所有内容。</p>
<ul>
<li>运行<code>devices</code>或<code>dev</code>参数将省略一些设备。例如，CDRoms和DM / MD设备被故意隐藏，因为它们被列为卷。</li>
<li>某些后端不支持快照，无法区分快照和常规卷。<code>snapshot</code>在其中一个后端运行参数将导致SSM尝试识别卷名以识别快照。如果SSM正则表达式与快照模式不匹配，则不会识别快照。</li>
<li>除了主Btrfs卷（文件系统本身）外，任何未安装的Btrfs卷都不会显示.</li>
</ul>
<h3 id="创建新池，逻辑卷和文件系统"><a href="#创建新池，逻辑卷和文件系统" class="headerlink" title="创建新池，逻辑卷和文件系统"></a>创建新池，逻辑卷和文件系统</h3><p>在本节中，将使用默认名称创建一个新池。它将具有1G 的设备<code>/dev/vdb</code>和<code>/dev/vdc</code>逻辑卷以及XFS文件系统。</p>
<p>创建这个场景的命令是<code>ssm create --fs xfs -s 1G /dev/vdb /dev/vdc</code>。使用以下选项：</p>
<ul>
<li><code>--fs</code> 选项指定所需的文件系统类型。当前支持的文件系统类型是：<ul>
<li>ext3</li>
<li>ext4</li>
<li>xfs</li>
<li>btrfs</li>
</ul>
</li>
<li>所述<code>-s</code>指定逻辑卷的大小。定义单位支持以下后缀<ul>
<li><code>K</code> or <code>k</code>  千字节</li>
<li><code>M</code> or <code>m</code>  兆字节</li>
<li><code>G</code> or <code>g</code>  千兆字节</li>
<li><code>T</code> or <code>t</code>  TB</li>
<li><code>P</code> or <code>p</code>  PB</li>
<li><code>E</code> or <code>e</code>  EB字节</li>
</ul>
</li>
<li>这两个列出的设备，<code>/dev/vdb</code>并且<code>/dev/vdc</code>，是我希望创建的两个设备。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm create --fs xfs -s 1G /dev/vdb /dev/vdc</span></span><br><span class="line">  Physical volume <span class="string">"/dev/vdb"</span> successfully created</span><br><span class="line">  Physical volume <span class="string">"/dev/vdc"</span> successfully created</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully created</span><br><span class="line">  Logical volume <span class="string">"lvol001"</span> created</span><br></pre></td></tr></table></figure>
<p>还有其他两个 <code>ssm command</code> 可能有用的选项. 第一个是 <code>-p</code><em><code>pool</code></em> . 这指定了要在其上创建卷的池。如果还不存在，那么SSM将创建它. 在上面的例子中这被省略了，导致SSM使用默认名称 <code>lvm_pool</code>. 但是，要使用特定的名称来适应任何现有的命名约定，应该使用该选项 <code>-p</code> .</p>
<p>第二个有用的选项是 <code>-n</code> <em><code>name</code></em>. 这将命名新创建的逻辑卷. 与之一样 <code>-p</code>, 为了使用特定的名称来适应现有的命名约定，这是必要的。</p>
<p>以下是这两个选项的一个例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># ssm create --fs xfs -p new_pool -n XFS_Volume /dev/vdd</span></span><br><span class="line">  Volume group <span class="string">"new_pool"</span> successfully created</span><br><span class="line">  Logical volume <span class="string">"XFS_Volume"</span> created</span><br></pre></td></tr></table></figure>
<p>现在SSM已经创建了两个物理卷，一个池和一个逻辑卷，只需要一个命令。</p>
<h4 id="检查文件系统的一致性"><a href="#检查文件系统的一致性" class="headerlink" title="检查文件系统的一致性"></a>检查文件系统的一致性</h4><p> <code>ssm check</code> 命令检查卷上的文件系统一致性。可以指定多个卷来检查。如果卷上没有文件系统，则该卷将被跳过。</p>
<p>要检查卷中的所有设备<code>lvol001</code>，请运行。 <code>ssm check /dev/lvm_pool/lvol001</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm check /dev/lvm_pool/lvol001</span></span><br><span class="line">Checking xfs file system on <span class="string">'/dev/mapper/lvm_pool-lvol001'</span>.</span><br><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal <span class="built_in">log</span></span><br><span class="line">        - scan filesystem freespace and inode maps...</span><br><span class="line">        - found root inode chunk</span><br><span class="line">Phase 3 - <span class="keyword">for</span> each AG...</span><br><span class="line">        - scan (but don<span class="string">'t clear) agi unlinked lists...</span></span><br><span class="line"><span class="string">        - process known inodes and perform inode discovery...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - agno = 4</span></span><br><span class="line"><span class="string">        - agno = 5</span></span><br><span class="line"><span class="string">        - agno = 6</span></span><br><span class="line"><span class="string">        - process newly discovered inodes...</span></span><br><span class="line"><span class="string">Phase 4 - check for duplicate blocks...</span></span><br><span class="line"><span class="string">        - setting up duplicate extent list...</span></span><br><span class="line"><span class="string">        - check for inodes claiming duplicate blocks...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - agno = 4</span></span><br><span class="line"><span class="string">        - agno = 5</span></span><br><span class="line"><span class="string">        - agno = 6</span></span><br><span class="line"><span class="string">No modify flag set, skipping phase 5</span></span><br><span class="line"><span class="string">Phase 6 - check inode connectivity...</span></span><br><span class="line"><span class="string">        - traversing filesystem ...</span></span><br><span class="line"><span class="string">        - traversal finished ...</span></span><br><span class="line"><span class="string">        - moving disconnected inodes to lost+found ...</span></span><br><span class="line"><span class="string">Phase 7 - verify link counts...</span></span><br><span class="line"><span class="string">No modify flag set, skipping filesystem flush and exiting.</span></span><br></pre></td></tr></table></figure>
<h3 id="增加卷的大小"><a href="#增加卷的大小" class="headerlink" title="增加卷的大小"></a>增加卷的大小</h3><p><code>ssm resize</code> 命令将更改指定的卷和文件系统的大小。如果没有文件系统，那么只有卷本身将被调整大小。</p>
<p>对于这个例子， 我们目前有一个逻辑卷 <code>/dev/vdb</code> , 900MB 命令为 <code>lvol001</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">Device          Free       Used      Total  Pool      Mount point</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">/dev/vda                          15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                        500.00 MB            /boot</span><br><span class="line">/dev/vda2    0.00 KB   14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb   120.00 MB  900.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc                           1.00 GB</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">Pool      Type  Devices       Free       Used       Total</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   1        120.00 MB  900.00 MB  1020.00 MB</span><br><span class="line">rhel      lvm   1          0.00 KB   14.51 GB    14.51 GB</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS     FS size       Free  Type    Mount point</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs   13.52 GB    9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                             linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool    900.00 MB  xfs  896.67 MB  896.54 MB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs  496.67 MB  403.56 MB  part    /boot</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>逻辑卷需要增加500MB。要做到这一点，我们需要添加一个额外的设备到池中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm resize -s +500M /dev/lvm_pool/lvol001 /dev/vdc</span></span><br><span class="line">  Physical volume <span class="string">"/dev/vdc"</span> successfully created</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully extended</span><br><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal <span class="built_in">log</span></span><br><span class="line">        - scan filesystem freespace and inode maps...</span><br><span class="line">        - found root inode chunk</span><br><span class="line">Phase 3 - <span class="keyword">for</span> each AG...</span><br><span class="line">        - scan (but don<span class="string">'t clear) agi unlinked lists...</span></span><br><span class="line"><span class="string">        - process known inodes and perform inode discovery...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - process newly discovered inodes...</span></span><br><span class="line"><span class="string">Phase 4 - check for duplicate blocks...</span></span><br><span class="line"><span class="string">        - setting up duplicate extent list...</span></span><br><span class="line"><span class="string">        - check for inodes claiming duplicate blocks...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">No modify flag set, skipping phase 5</span></span><br><span class="line"><span class="string">Phase 6 - check inode connectivity...</span></span><br><span class="line"><span class="string">        - traversing filesystem ...</span></span><br><span class="line"><span class="string">        - traversal finished ...</span></span><br><span class="line"><span class="string">        - moving disconnected inodes to lost+found ...</span></span><br><span class="line"><span class="string">Phase 7 - verify link counts...</span></span><br><span class="line"><span class="string">No modify flag set, skipping filesystem flush and exiting.</span></span><br><span class="line"><span class="string">  Extending logical volume lvol001 to 1.37 GiB</span></span><br><span class="line"><span class="string">  Logical volume lvol001 successfully resized</span></span><br><span class="line"><span class="string">meta-data=/dev/mapper/lvm_pool-lvol001 isize=256    agcount=4, agsize=57600 blks</span></span><br><span class="line"><span class="string">         =                       sectsz=512   attr=2, projid32bit=1</span></span><br><span class="line"><span class="string">         =                       crc=0</span></span><br><span class="line"><span class="string">data     =                       bsize=4096   blocks=230400, imaxpct=25</span></span><br><span class="line"><span class="string">         =                       sunit=0      swidth=0 blks</span></span><br><span class="line"><span class="string">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span></span><br><span class="line"><span class="string">log      =internal               bsize=4096   blocks=853, version=2</span></span><br><span class="line"><span class="string">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span></span><br><span class="line"><span class="string">realtime =none                   extsz=4096   blocks=0, rtextents=0</span></span><br><span class="line"><span class="string">data blocks changed from 230400 to 358400</span></span><br></pre></td></tr></table></figure>
<p>SSM在设备上运行检查，然后按指定的数量扩展音量。这可以通过<code>ssm list</code>命令来验证.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Device          Free        Used      Total  Pool      Mount point</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">/dev/vda                           15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                         500.00 MB            /boot</span><br><span class="line">/dev/vda2    0.00 KB    14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb     0.00 KB  1020.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc   640.00 MB   380.00 MB    1.00 GB  lvm_pool</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">------------------------------------------------------</span><br><span class="line">Pool      Type  Devices       Free      Used     Total</span><br><span class="line">------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   2        640.00 MB   1.37 GB   1.99 GB</span><br><span class="line">rhel      lvm   1          0.00 KB  14.51 GB  14.51 GB</span><br><span class="line">------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS      FS size        Free  Type    Mount point</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs    13.52 GB     9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                               linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool      1.37 GB  xfs     1.36 GB     1.36 GB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs   496.67 MB   403.56 MB  part    /boot</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>只能降低LVM卷的大小; 其他卷类型不支持。这是通过使用一个<code>-</code>而不是一个<code>+</code>。例如，要将LVM卷的大小减小50M，该命令将是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~]<span class="comment"># ssm resize -s-50M /dev/lvm_pool/lvol002</span></span><br><span class="line">  Rounding size to boundary between physical extents: 972.00 MiB</span><br><span class="line">  WARNING: Reducing active logical volume to 972.00 MiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce lvol002? [y/n]: y</span><br><span class="line">  Reducing logical volume lvol002 to 972.00 MiB</span><br><span class="line">  Logical volume lvol002 successfully resized</span><br></pre></td></tr></table></figure>
<p>没有<code>+</code>或者<code>-</code>，被视为绝对的。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>要获取现有卷的快照，请使用该<code>ssm snapshot</code>命令。</p>
<p>如果后端卷所属的卷不支持快照，则该操作将失败。</p>
<p>要创建快照<code>lvol001</code>，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm snapshot /dev/lvm_pool/lvol001</span></span><br><span class="line">  Logical volume <span class="string">"snap20150519T130900"</span> created</span><br></pre></td></tr></table></figure>
<p>要验证这一点，使用<code>ssm list</code>，并注意额外的快照部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Device        Free        Used      Total  Pool      Mount point</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">/dev/vda                         15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                       500.00 MB            /boot</span><br><span class="line">/dev/vda2  0.00 KB    14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb   0.00 KB  1020.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc                          1.00 GB</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">Pool      Type  Devices     Free        Used       Total</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   1        0.00 KB  1020.00 MB  1020.00 MB</span><br><span class="line">rhel      lvm   1        0.00 KB    14.51 GB    14.51 GB</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS      FS size        Free  Type    Mount point</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs    13.52 GB     9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                               linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool    900.00 MB  xfs   896.67 MB   896.54 MB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs   496.67 MB   403.56 MB  part    /boot</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">Snapshot                           Origin   Pool      Volume size     Size  Type</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">/dev/lvm_pool/snap20150519T130900  lvol001  lvm_pool    120.00 MB  0.00 KB  linear</span><br><span class="line">----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="删除一个项目"><a href="#删除一个项目" class="headerlink" title="删除一个项目"></a>删除一个项目</h3><p>该<code>ssm remove</code>用于删除的项目，或者是设备，游泳池或体积。</p>
<p>如果某个设备在移除时正在被池使用，则会失败。这可以被迫使用<code>-f</code>参数。</p>
<p>如果在卸下卷时安装，则会失败。与设备不同，它不能被强制使用<code>-f</code>。</p>
<p>要删除其中的<code>lvm_pool</code>所有内容，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssm remove lvm_pool</span></span><br><span class="line">Do you really want to remove volume group <span class="string">"lvm_pool"</span> containing 2 logical volumes? [y/n]: y</span><br><span class="line">Do you really want to remove active logical volume snap20150519T130900? [y/n]: y</span><br><span class="line">  Logical volume <span class="string">"snap20150519T130900"</span> successfully removed</span><br><span class="line">Do you really want to remove active logical volume lvol001? [y/n]: y</span><br><span class="line">  Logical volume <span class="string">"lvol001"</span> successfully removed</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully removed</span><br></pre></td></tr></table></figure>
<h1 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h1><p>磁盘空间可以通过在用户占用太多磁盘空间或分区变满之前实现提醒系统管理员的磁盘配额来限制。</p>
<p>可以为个人用户和用户组配置磁盘配额。这使得可以与分配给用户工作的项目的空间（假设项目被赋予它们自己的组）分开管理分配给用户特定文件（例如电子邮件）的空间。</p>
<p>另外，可以设置配额，不仅可以控制所使用的磁盘块数量，还可以控制inode数量（包含UNIX文件系统中的文件信息的数据结构）。由于inode用于包含与文件相关的信息，因此可以控制可以创建的文件的数量。</p>
<p>将<code>quota</code>必须安装RPM来实现磁盘配额。</p>
<h2 id="配置磁盘配额"><a href="#配置磁盘配额" class="headerlink" title="配置磁盘配额"></a>配置磁盘配额</h2><p>要实施磁盘配额，请使用以下步骤：</p>
<ol>
<li>通过修改<code>/etc/fstab</code>文件来启用每个文件系统的配额。</li>
<li>重新安装文件系统。</li>
<li>创建配额数据库文件并生成磁盘使用情况表。</li>
<li>分配配额策略。</li>
</ol>
<p>以下各节将详细讨论这些步骤。</p>
<h3 id="启用配额"><a href="#启用配额" class="headerlink" title="启用配额"></a>启用配额</h3><p>以root身份使用文本编辑器编辑<code>/etc/fstab</code>文件。</p>
<p><strong>编辑/etc/fstab</strong></p>
<p>例如，要使用文本编辑器，<code>vim</code>键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br></pre></td></tr></table></figure>
<p>添加<code>usrquota</code>和 <code>/</code> 或<code>grpquota</code>选项到需要配额的文件系统：</p>
<p><strong>添加配额</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dev/VolGroup00/LogVol00 /         ext3    defaults        1 1 </span><br><span class="line">LABEL=/boot              /boot     ext3    defaults        1 2 </span><br><span class="line">none                     /dev/pts  devpts  gid=5,mode=620  0 0 </span><br><span class="line">none                     /dev/shm  tmpfs   defaults        0 0 </span><br><span class="line">none                     /proc     proc    defaults        0 0 </span><br><span class="line">none                     /sys      sysfs   defaults        0 0 </span><br><span class="line">/dev/VolGroup00/LogVol02 /home     ext3    defaults,usrquota,grpquota  1 2 </span><br><span class="line">/dev/VolGroup00/LogVol01 swap      swap    defaults        0 0 . . .</span><br></pre></td></tr></table></figure>
<p>在本例中，<code>/home</code>文件系统同时启用了用户和组配额。</p>
<p>以下示例假定<code>/home</code>在安装红帽企业版Linux期间创建了单独的分区。root（<code>/</code>）分区可用于在<code>/etc/fstab</code>文件中设置配额策略。</p>
<h3 id="重新挂载文件系统"><a href="#重新挂载文件系统" class="headerlink" title="重新挂载文件系统"></a>重新挂载文件系统</h3><p>在添加<code>usrquota</code>和/或<code>grpquota</code>选项后，重新装入其<code>fstab</code>条目已被修改的每个文件系统。如果文件系统未被任何进程使用，请使用以下方法之一：</p>
<ul>
<li>发出<code>umount</code>命令后再执行该<code>mount</code>命令以重新挂载文件系统。请参阅<code>man</code>这两个页面<code>umount</code>以及<code>mount</code>有关安装和卸载各种文件系统类型的特定语法。</li>
<li><code>mount -o remount</code> <em><code>file-system</code></em> 命令 (其中 <em><code>file-system</code></em> 是文件系统的名称) 来挂载文件系统. 例如, 要重新挂载 <code>/home</code> 文件系统, 要使用命令 <code>mount -o remount /home</code>.</li>
</ul>
<p>如果文件系统当前正在使用，则重新安装文件系统的最简单方法是重新引导系统。</p>
<h3 id="创建配额数据库文件"><a href="#创建配额数据库文件" class="headerlink" title="创建配额数据库文件"></a>创建配额数据库文件</h3><p>在每个启用配额的文件系统重新安装后，运行该<code>quotacheck</code>命令。</p>
<p>该<code>quotacheck</code>命令检查启用配额的文件系统，并构建每个文件系统当前磁盘使用情况的表。该表然后用于更新操作系统的磁盘使用情况的副本。另外，文件系统的磁盘配额文件也被更新。</p>
<p>该<code>quotacheck</code>命令对XFS没有影响，因为磁盘使用情况在安装时自动完成。<code>xfs_quota(8)</code>有关更多信息，请参阅手册页。</p>
<p>要在文件系统上创建配额文件(<code>aquota.user</code> 和 <code>aquota.group</code>) , 使用  <code>quotacheck</code> <code>-c</code>。</p>
<p><strong>创建配额文件</strong></p>
<p>例如，如果为 <code>/home</code> 文件系统启用了用户和组配额, 请在<code>/home</code>目录中创建文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quotacheck -cug /home</span></span><br></pre></td></tr></table></figure>
<p> <code>-c</code> 项指定应为每个启用了配额的文件系统创建配额文件, <code>-u</code> o选项指定检查用户配额, <code>-g</code> 选项指定检查组配额。</p>
<p>如果没有指定 <code>-u</code> 或 <code>-g</code> 选项，则只创建用户配额文件。 如果仅指定 <code>-g</code> ，则只创建组配额文件。</p>
<p>创建文件后，运行以下命令以生成启用了配额的每个文件系统的当前磁盘使用情况表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quotacheck -avug</span></span><br></pre></td></tr></table></figure>
<p>使用的选项如下：</p>
<ul>
<li><p>a</p>
<p>检查所有配额启用的本地安装的文件系统</p>
</li>
<li><p>v</p>
<p>随着配额检查的进行，显示详细的状态信息</p>
</li>
<li><p>u</p>
<p>检查用户磁盘配额信息</p>
</li>
<li><p>g</p>
<p>检查组磁盘配额信息</p>
<p><code>quotacheck</code> 运行完毕后, 对应于启用配额（用户和/或组）被填充以用于每个启用了配额的本地安装的文件系统，例如数据配额文件 <code>/home</code>.</p>
</li>
</ul>
<h3 id="为每个用户分配配额"><a href="#为每个用户分配配额" class="headerlink" title="为每个用户分配配额"></a>为每个用户分配配额</h3><p>最后一步是用<code>edquota</code>命令分配磁盘配额。</p>
<p>要为用户配置配额，请以root用户身份在shell提示符下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edquota username</span></span><br></pre></td></tr></table></figure>
<p>为需要配额的每个用户执行此步骤。例如， 如果 <code>/etc/fstab</code> 为 <code>/home</code> 分区启用了配额  (<code>/dev/VolGroup00/LogVol02</code>在下面的示例中) 并且执行<code>edquota testuser</code>命令 ,则以下内容将显示在配置为系统默认值的编辑器中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> user testuser (uid 501):   </span><br><span class="line">Filesystem                blocks     soft     hard    inodes   soft   hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440436        0        0     37418      0      0</span><br></pre></td></tr></table></figure>
<p>由<code>EDITOR</code>环境变量定义的文本编辑器被使用<code>edquota</code>。要更改编辑器，请将文件中的<code>EDITOR</code>环境变量设置为所选<code>~/.bash_profile</code>编辑器的完整路径。</p>
<p>第一列是启用了配额的文件系统的名称。第二列显示用户当前使用的块数。接下来的两列用于为文件系统上的用户设置软硬限制。该<code>inodes</code>列显示用户当前使用了多少个inode。最后两列用于设置文件系统上用户的软硬节点限制。</p>
<p>硬块限制是用户或组可以使用的绝对最大磁盘空间量。达到此限制后，不能使用其他磁盘空间。</p>
<p>软块限制定义了可以使用的最大磁盘空间量。但是，与硬限制不同，软限制可以超过一定的时间。那个时候被称为<em>宽限期</em>。宽限期可以用秒，分，小时，天，星期或月来表示。</p>
<p>如果任何值被设置为0，则不设置该限制。在文本编辑器中，更改所需的限制。</p>
<p><strong>更改所需限制</strong></p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> user testuser (uid 501):   </span><br><span class="line">Filesystem                blocks     soft     hard   inodes   soft   hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440436   500000   550000    37418      0      0</span><br></pre></td></tr></table></figure>
<p>要验证是否已设置用户的配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quota username</span></span><br><span class="line">Disk quotas <span class="keyword">for</span> user username (uid 501): </span><br><span class="line">   Filesystem  blocks   quota   <span class="built_in">limit</span>   grace   files   quota   <span class="built_in">limit</span>   grace</span><br><span class="line">     /dev/sdb    1000*   1000    1000               0       0       0</span><br></pre></td></tr></table></figure>
<h2 id="为每组分配配额"><a href="#为每组分配配额" class="headerlink" title="为每组分配配额"></a>为每组分配配额</h2><p>配额也可以按组分配。例如，要为组设置组配额<code>devel</code>（该组必须在设置组配额之前存在），请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edquota -g devel</span></span><br></pre></td></tr></table></figure>
<p>该命令在文本编辑器中显示组的现有配额：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group devel (gid 505):   </span><br><span class="line">Filesystem                blocks    soft     hard    inodes    soft    hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440400       0        0     37418       0       0</span><br></pre></td></tr></table></figure>
<p>修改限制，然后保存文件。</p>
<p>要验证组配额是否已设置，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quota -g devel</span></span><br></pre></td></tr></table></figure>
<h3 id="设置软极限的宽限期"><a href="#设置软极限的宽限期" class="headerlink" title="设置软极限的宽限期"></a>设置软极限的宽限期</h3><p>如果给定的配额具有软限制，则可以使用以下命令编辑宽限期（即，可以超过软限制的时间量）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edquota -t</span></span><br></pre></td></tr></table></figure>
<p>此命令适用于用户或组的inode或块的配额。</p>
<p>当其他<code>edquota</code>命令对特定用户或组执行配额操作时，该<code>-t</code>选项将在启用配额的每个文件系统上运行。</p>
<h2 id="管理磁盘配额"><a href="#管理磁盘配额" class="headerlink" title="管理磁盘配额"></a>管理磁盘配额</h2><p>如果实施配额，他们需要一些维护 - 主要是看配额是否超出，并确保配额是准确的形式。</p>
<p>当然，如果用户反复超出配额或一直达到软限制，系统管理员可以根据他们的用户类型以及磁盘空间的多少来影响他们的工作。管理员可以帮助用户确定如何使用更少的磁盘空间或增加用户的磁盘配额。</p>
<h3 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h3><p>可以禁用配额而不将其设置为0.要关闭所有用户和组配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quotaoff -vaug</span></span><br></pre></td></tr></table></figure>
<p>如果没有指定<code>-u</code>或<code>-g</code>选项， 则只有用户配额被禁用。如果仅<code>-g</code>指定，则仅禁用组配额。当<code>-v</code>命令执行时，交换机会导致详细的状态信息显示。</p>
<p>要再次启用配额，请使用<code>quotaon</code>具有相同选项的命令。</p>
<p>例如，要为所有文件系统启用用户和组配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quotaon -vaug</span></span><br></pre></td></tr></table></figure>
<p>要为特定文件系统启用配额<code>/home</code>，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quotaon -vug /home</span></span><br></pre></td></tr></table></figure>
<p>如果没有指定<code>-u</code>或<code>-g</code>选项，则只启用用户配额。如果仅<code>-g</code>指定，则只启用组配额。</p>
<p><code>quotaon</code>XFS并不总是需要 该命令，因为它在安装时自动执行</p>
<h3 id="报告磁盘配额"><a href="#报告磁盘配额" class="headerlink" title="报告磁盘配额"></a>报告磁盘配额</h3><p>创建磁盘使用情况报告需要运行该<code>repquota</code>实用程序。</p>
<p><strong>repquota命令的输出</strong></p>
<p>例如，该命令<code>repquota /home</code>产生这个输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*** Report <span class="keyword">for</span> user quotas on device /dev/mapper/VolGroup00-LogVol02 </span><br><span class="line">Block grace time: 7days; Inode grace time: 7days</span><br><span class="line">			Block limits			File limits		</span><br><span class="line">User		used	soft	hard	grace	used	soft	hard	grace </span><br><span class="line">---------------------------------------------------------------------- </span><br><span class="line">root      --      36       0       0              4     0     0 </span><br><span class="line">kristin   --     540       0       0            125     0     0 </span><br><span class="line">testuser  --  440400  500000  550000          37418     0     0</span><br></pre></td></tr></table></figure>
<p>要查看所有（可选<code>-a</code>）启用配额的文件系统的磁盘使用情况报告，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repquota -a</span></span><br></pre></td></tr></table></figure>
<p>报告很容易阅读，应该解释几点。在<code>--</code>每个用户之后显示是一个快速的方法来确定块或i节点限制是否已经被超过。如果超出软限制，<code>+</code>则会出现a 代替相应的代码<code>-</code>; 第一个<code>-</code>表示块限制，第二个表示inode限制。</p>
<p>该<code>grace</code>栏目是空白正常。如果软限制已超出，则该列包含的时间规格等于宽限期内剩余的时间量。如果宽限期已经过期，则<code>none</code>出现在其位置上。</p>
<h3 id="保持配额准确"><a href="#保持配额准确" class="headerlink" title="保持配额准确"></a>保持配额准确</h3><p>当文件系统无法完全卸载（例如，由于系统崩溃），则需要运行<code>quotacheck</code>。但是，<code>quotacheck</code>即使系统没有崩溃，也可以定期运行。定期运行的安全方法<code>quotacheck</code>包括：</p>
<p>确保在下次重新启动时运行quotacheck</p>
<p>以root用户身份，将一个shell脚本放到<code>/etc/cron.daily/</code>或<code>/etc/cron.weekly/</code>目录中 - 或者使用<code>crontab -e</code>包含该<code>touch /forcequotacheck</code>命令的命令来安排一个shell脚本。这将<code>forcequotacheck</code>在根目录中创建一个空文件，系统启动脚本将在启动时查找该文件。如果找到，则运行init脚本<code>quotacheck</code>。之后，init脚本删除<code>/forcequotacheck</code>文件; 因此，调度此文件定期创建，以<code>cron</code>确保<code>quotacheck</code>在下次重新启动时运行。</p>
<p>Refer to <code>man cron</code> for more information about configuring <code>cron</code>.</p>
<p>在单用户模式下运行quotacheck</p>
<p>另一种安全运行的方法<code>quotacheck</code>是将系统引导到单用户模式，以防止配额文件中数据损坏的可能性并运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ quotaoff -vug /file_system</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ quotacheck -vug /file_system</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ quotaon -vug /file_system</span><br></pre></td></tr></table></figure>
<p>在正在运行的系统上运行quotacheck</p>
<p>如果有必要，可以<code>quotacheck</code>在没有用户登录的时间在机器上运行，因此在被检查的文件系统上没有打开的文件。运行命令; 如果无法将给定的<em>file_system</em>重新挂载为只读，则此命令将失败。请注意，在检查之后，文件系统将被重新读写。 <code>quotacheck -vug*file_system*``quotacheck</code>**</p>
<p><strong>警告</strong></p>
<p><code>quotacheck</code>由于配额文件损坏的可能性，建议不要使用挂载的读写方式 运行实时文件系统。</p>
<h2 id="磁盘配额参考"><a href="#磁盘配额参考" class="headerlink" title="磁盘配额参考"></a>磁盘配额参考</h2><p>有关磁盘配额的更多信息，请参阅</p>
<ul>
<li><code>quotacheck</code></li>
<li><code>edquota</code></li>
<li><code>repquota</code></li>
<li><code>quota</code></li>
<li><code>quotaon</code></li>
<li><code>quotaoff</code></li>
</ul>
<h1 id="独立磁盘冗余阵列（RAID）"><a href="#独立磁盘冗余阵列（RAID）" class="headerlink" title="独立磁盘冗余阵列（RAID）"></a>独立磁盘冗余阵列（RAID）</h1><p>RAID背后的基本思想是将多个小型，廉价的磁盘驱动器组合成一个阵列，以实现一个大而昂贵的驱动器无法实现的性能或冗余目标。该驱动器阵列在计算机上显示为单个逻辑存储单元或驱动器。</p>
<p>RAID允许信息分布在多个磁盘上。RAID使用诸如<em>磁盘分条</em>（RAID 0级），<em>磁盘镜像</em>（RAID 1）和<em>带有奇偶校验</em>（RAID Level 5）的<em>磁盘分条等技术</em>来实现冗余，更低的延迟，增加的带宽以及最大限度地从硬盘崩溃中恢复的能力。</p>
<p>RAID通过将数据分解成一致大小的块（通常为256K或512k，尽管其他值是可接受的）来将数据分布到阵列中的每个驱动器上。然后根据所使用的RAID级别将每个块写入RAID阵列中的硬盘驱动器。当数据被读取时，这个过程被颠倒过来，给出这样的错觉：阵列中的多个驱动器实际上是一个大驱动器。</p>
<p>系统管理员和其他管理大量数据的人员将从使用RAID技术中受益。部署RAID的主要原因包括：</p>
<ul>
<li>提高速度</li>
<li>使用单个虚拟磁盘提高存储容量</li>
<li>最大限度减少磁盘故障造成的数据丢失</li>
</ul>
<h2 id="RAID类型"><a href="#RAID类型" class="headerlink" title="RAID类型"></a>RAID类型</h2><p>有三种可能的RAID方法：固件RAID，硬件RAID和软件RAID。</p>
<h3 id="固件RAID"><a href="#固件RAID" class="headerlink" title="固件RAID"></a>固件RAID</h3><p><em>固件RAID</em>（也称为ATARAID）是一种软件RAID，可以使用基于固件的菜单对RAID集进行配置。这种类型的RAID所使用的固件也会挂接到BIOS中，允许您从RAID设置中进行引导。不同的供应商使用不同的磁盘元数据格式来标记RAID组成员。Intel Matrix RAID是固件RAID系统的一个很好的例子。</p>
<h3 id="硬件RAID"><a href="#硬件RAID" class="headerlink" title="硬件RAID"></a>硬件RAID</h3><p>基于硬件的阵列独立于主机管理RAID子系统。它为主机提供每个RAID阵列的单个磁盘。</p>
<p>硬件RAID设备可以在系统的内部或外部，内部设备通常由专用控制器卡组成，该卡对操作系统透明地处理RAID任务，并且通常通过SCSI，光纤通道，iSCSI等连接到系统的外部设备。 InfiniBand或其他高速网络互连，并向系统呈现逻辑卷。</p>
<p>RAID控制卡的功能类似于操作系统的SCSI控制器，并处理所有实际的驱动器通信。用户将驱动器插入RAID控制器（就像普通的SCSI控制器一样），然后将它们添加到RAID控制器配置中。操作系统将无法区分。</p>
<h3 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h3><p>软件RAID实现内核磁盘（块设备）代码中的各种RAID级别。它提供了最便宜的解决方案，因为不需要昂贵的磁盘控制器卡或热插拔机箱</p>
<p>软件RAID也适用于更便宜的IDE磁盘以及SCSI磁盘。有了如今更快的CPU，软件RAID通常也比硬件RAID更好。</p>
<p>Linux内核包含一个<em>多磁盘</em>（MD）驱动程序，使RAID解决方案完全独立于硬件。基于软件的阵列的性能取决于服务器的CPU性能和负载。</p>
<p>以下是Linux软件RAID堆栈的一些主要特性：</p>
<ul>
<li>多线程设计</li>
<li>Linux机器之间的阵列可移植性，无需重建</li>
<li>使用空闲系统资源的背景阵列重建</li>
<li>支持热插拔驱动器</li>
<li>自动CPU检测，以利用某些CPU功能，如流SIMD支持</li>
<li>自动更正阵列中磁盘上的坏扇区</li>
<li>定期对RAID数据进行一致性检查，以确保阵列的健康</li>
<li>通过电子邮件警报主动监控阵列，将其发送到重要事件的指定电子邮件地址</li>
<li>写意图位图通过允许内核精确地知道磁盘的哪些部分需要重新同步而不必重新同步整个阵列，从而大大提高了重新同步事件的速度</li>
<li>重新同步点校验，以便在重新同步期间重新启动计算机时，在启动时，重新同步将会停止，并且不会重新开始</li>
<li>安装后更改数组参数的功能。例如，当您添加新磁盘时，可以将4磁盘RAID5阵列增长为5磁盘RAID5阵列。这种增长操作是实时完成的，不需要您在新阵列上重新安装。</li>
</ul>
<hr>
<h2 id="RAID级别和线性支持"><a href="#RAID级别和线性支持" class="headerlink" title="RAID级别和线性支持"></a>RAID级别和线性支持</h2><p>RAID支持各种配置，包括级别0,1,4,5,6,10和线性。这些RAID类型定义如下：</p>
<ul>
<li><p>0级</p>
<p>RAID级别0通常称为“分条”，是一种面向性能的分条数据映射技术。这意味着写入阵列的数据被分解为条带并写入阵列的成员磁盘，从而以较低的固有成本实现高I / O性能，但不提供冗余。许多RAID级别0的实现将只将成员设备上的数据分条到阵列中最小的设备的大小。这意味着，如果您有多个尺寸略有不同的设备，则每个设备都将被视为与最小驱动器的尺寸相同。因此，0级阵列的公共存储容量等于硬件RAID中最小成员磁盘的容量，或软件RAID中最小成员分区的容量乘以阵列中磁盘或分区的数量。</p>
</li>
<li><p>1级</p>
<p>RAID级别1（或“镜像”）的使用时间比任何其他形式的RAID都要长。级别1通过将相同的数据写入阵列的每个成员磁盘来提供冗余，在每个磁盘上留下“镜像”副本。由于其简单和高水平的数据可用性，镜像依然流行。级别1使用两个或更多磁盘运行，并提供非常好的数据可靠性，并提高读取密集型应用程序的性能，但成本相对较高。级别1阵列的存储容量等于硬件RAID中最小镜像硬盘的容量或软件RAID中最小镜像分区的容量。在所有RAID类型中，1级冗余是最高的可能性，阵列只能在单个磁盘上运行。</p>
</li>
<li><p>4级</p>
<p>级别4使用奇偶校验集中在单个磁盘驱动器上来保护数据。由于专用奇偶校验磁盘代表了对RAID阵列的所有写入事务的固有瓶颈，因此级别4很少没有附带的技术（如回写缓存）使用，或者在系统管理员有意用此设计软件RAID设备的特定情况下记住瓶颈（例如，一旦阵列填充数据，将会有几乎没有写入事务的数组）。RAID级别4很少使用，因此在Anaconda中不可用。但是，如果真的需要，可以由用户手动创建。硬件RAID级别4的存储容量等于最小成员分区的容量乘以分区数<em>减一</em>。RAID级别4阵列的性能总是不对称的，这意味着读取将优于写入。这是因为在产生奇偶校验时，写入操作会消耗额外的CPU和主存储器带宽，并且在将实际数据写入磁盘时也消耗额外的总线带宽，因为您不仅正在写入数据，而且正在写入奇偶校验。除非阵列处于降级状态，否则只需要读取数据而不是奇偶校验。因此，在正常操作条件下，读取操作产生的驱动器和计算机总线上的流量减少了相同的数据传输量。</p>
</li>
<li><p>5级</p>
<p>这是最常见的RAID类型。通过在阵列的所有成员磁盘驱动器中分配奇偶校验，RAID级别5消除了级别4固有的写入瓶颈。唯一的性能瓶颈是奇偶校验计算过程本身。随着现代CPU和软件RAID，这通常不是一个瓶颈，因为现代的CPU可以非常快速地产生奇偶校验。但是，如果软件RAID5阵列中的成员设备数量足够多，以至于所有设备的汇总数据传输总速度足够高，则此瓶颈可能开始起作用。与第4级一样，第5级的表现也是不对称的，读取效果明显优于写入。RAID级别5的存储容量的计算方式与级别4相同。</p>
</li>
<li><p>6级</p>
<p>当数据冗余和保存（而不是性能）是最重要的问题时，这是RAID的普通级别，但是级别1的空间低效率是不可接受的。级别6使用复杂的奇偶校验方案能够从阵列中任何两个驱动器的丢失中恢复。这种复杂的奇偶校验方案在软件RAID设备上造成了显着更高的CPU负担，并且在写入事务期间也增加了负担。因此，6级在性能上比4级和5级更为不对称。除了必须从额外奇偶校验存储空间的设备计数中减去2个设备（而不是1个）之外，RAID级别6阵列的总容量的计算与RAID级别5和4相似。</p>
</li>
<li><p>10级</p>
<p>此RAID级别尝试将级别0的性能优势与级别1的冗余相结合。它还有助于减轻2级以上设备在1级阵列中浪费的部分空间。通过级别10，可以创建一个3驱动器阵列，每个数据只能存储2个副本，然后允许整个阵列大小为最小器件大小的1.5倍，而不是等于最小值设备（就像3设备，1级阵列一样）。创建10级阵列时可用的选项数量（以及为特定用例选择正确选项的复杂性）使安装过程中创建不切实际。可以使用命令行<code>mdadm</code>工具手动创建一个。有关选项及其各自性能折衷的详细信息，请参阅<code>man md</code>。</p>
</li>
<li><p>线性RAID</p>
<p>线性RAID是一个简单的驱动器分组来创建一个更大的虚拟驱动器。在线性RAID中，块是从一个成员驱动器中顺序分配的，只有当第一个完全填满时才会进入下一个驱动器。这个分组没有提供性能优势，因为任何I / O操作都不太可能在成员驱动器之间进行分割。线性RAID也不提供冗余，实际上降低了可靠性 - 如果任何一个成员驱动器发生故障，整个阵列将无法使用。容量是所有成员磁盘的总和。</p>
</li>
</ul>
<h2 id="LINUX-RAID子系统"><a href="#LINUX-RAID子系统" class="headerlink" title="LINUX RAID子系统"></a>LINUX RAID子系统</h2><p>Linux中的RAID由以下子系统组成：</p>
<h3 id="Linux硬件RAID控制器驱动程序"><a href="#Linux硬件RAID控制器驱动程序" class="headerlink" title="Linux硬件RAID控制器驱动程序"></a>Linux硬件RAID控制器驱动程序</h3><p>硬件RAID控制器在Linux中没有特定的RAID子系统。由于他们使用特殊的RAID芯片组，硬件RAID控制器带有自己的驱动程序; 这些驱动程序允许系统将RAID设置检测为常规磁盘。</p>
<h4 id="mdraid"><a href="#mdraid" class="headerlink" title="mdraid"></a>mdraid</h4><p>该<code>mdraid</code>子系统被设计为Linux的软件RAID解决方案; 它也是Linux下软件RAID的首选解决方案。该子系统使用其自己的元数据格式，通常称为本地<code>mdraid</code>元数据。</p>
<p><code>mdraid</code>还支持其他元数据格式，称为外部元数据。红帽企业Linux 7使用<code>mdraid</code>外部元数据来访问ISW / IMSM（英特尔固件RAID）集。<code>mdraid</code>套件通过<code>mdadm</code>电力公司进行配置和控制。</p>
<h4 id="dmraid的"><a href="#dmraid的" class="headerlink" title="dmraid的"></a>dmraid的</h4><p><em>设备映射程序RAID</em>或<code>dmraid</code>指设备映射程序内核代码，它提供了将磁盘组合成RAID组的机制。相同的内核代码不提供任何RAID配置机制。</p>
<p><code>dmraid</code>完全在用户空间中配置，使得支持各种磁盘上的元数据格式变得容易。因此，<code>dmraid</code>用于各种固件RAID实现。<code>dmraid</code>也支持英特尔固件RAID，尽管红帽企业Linux 7使用<code>mdraid</code>英特尔固件RAID集。</p>
<h2 id="ANACONDA安装程序中的RAID支持"><a href="#ANACONDA安装程序中的RAID支持" class="headerlink" title="ANACONDA安装程序中的RAID支持"></a>ANACONDA安装程序中的RAID支持</h2><p>该<strong>Anaconda</strong>安装程序会自动检测系统中的任何硬件和固件的RAID集，使其可用于安装。<strong>Anaconda</strong>还支持使用软件RAID <code>mdraid</code>，并可以识别现有的<code>mdraid</code>设置。</p>
<p><strong>Anaconda</strong>提供了用于在安装期间创建RAID集的实用程序; 但是，这些实用程序只允许分区（而不是整个磁盘）成为新集的成员。要将整个磁盘用于集合，只需在整个磁盘上创建一个分区，然后将该分区用作RAID集成员。</p>
<p>当根文件系统使用RAID集时，<strong>Anaconda</strong>会在启动加载程序配置中添加特殊的内核命令行选项，告诉<code>initrd</code>在搜索根文件系统之前要激活哪个RAID集。</p>
<h2 id="安装后将根磁盘转换为RAID1"><a href="#安装后将根磁盘转换为RAID1" class="headerlink" title="安装后将根磁盘转换为RAID1"></a>安装后将根磁盘转换为RAID1</h2><p>在PowerPC（PPC）体系结构上，执行以下附加步骤：</p>
<ol>
<li>将PowerPC参考平台（PReP）引导分区的内容复制<code>/dev/sda1</code>到<code>/dev/sdb1</code>：</li>
</ol>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># dd if&#x3D;&#x2F;dev&#x2F;sda1 of&#x3D;&#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新两个磁盘上第一个分区上的准备和启动标志：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ parted /dev/sda <span class="built_in">set</span> 1 prep on</span><br><span class="line">$ parted /dev/sda <span class="built_in">set</span> 1 boot on</span><br><span class="line"></span><br><span class="line">$ parted /dev/sdb <span class="built_in">set</span> 1 prep on</span><br><span class="line">$ parted /dev/sdb <span class="built_in">set</span> 1 boot on</span><br></pre></td></tr></table></figure>
<p>请注意，<code>grub2-install /dev/sda</code> 在PowerPC机器上运行该命令不起作用，并返回一个错误，但是系统按预期方式启动。</p>
<h2 id="配置RAID集"><a href="#配置RAID集" class="headerlink" title="配置RAID集"></a>配置RAID集</h2><p>大多数RAID组在创建时都会配置，通常通过固件菜单或安装程序进行配置。在某些情况下，您可能需要在安装系统后创建或修改RAID集，最好不必重新启动机器并进入固件菜单。</p>
<p>某些硬件RAID控制器允许您即时配置RAID集，甚至可以在添加额外的磁盘后定义全新的集。这需要使用驱动程序特定的实用程序，因为没有标准的API。有关这方面的信息，请参阅您的硬件RAID控制器的驱动程序文档。</p>
<h2 id="mdadm的"><a href="#mdadm的" class="headerlink" title="mdadm的"></a>mdadm的</h2><p>该<code>mdadm</code>命令行工具来管理Linux软件RAID，即<code>mdraid</code>。有关不同<code>mdadm</code>模式和选项的信息，请参阅<code>man mdadm</code>。该<code>man</code>页面还包含常用操作的有用示例，如创建，监视和组装软件RAID阵列。</p>
<h2 id="dmraid的-1"><a href="#dmraid的-1" class="headerlink" title="dmraid的"></a>dmraid的</h2><p>顾名思义，<code>dmraid</code>用于管理设备映射器RAID集。该<code>dmraid</code>工具使用多个元数据格式处理程序查找ATARAID设备，每个处理程序支持各种格式。有关支持的格式的完整列表，请运行<code>dmraid -l</code>。</p>
<h2 id="创建高级RAID设备"><a href="#创建高级RAID设备" class="headerlink" title="创建高级RAID设备"></a>创建高级RAID设备</h2><p>在某些情况下，您可能希望将操作系统安装在安装完成后无法创建的阵列上。通常，这意味着<code>/boot</code>在一个复杂的RAID设备上设置或根文件系统阵列; 在这种情况下，您可能需要使用<strong>Anaconda</strong>不支持的数组选项。要解决此问题，请执行以下步骤：</p>
<p><strong>创建高级RAID设备</strong></p>
<ol>
<li>像平常一样插入安装盘。</li>
<li>在初始启动过程中，请选择“ <strong>救援模式”，</strong>而不是“ <strong>安装”</strong>或“ <strong>升级”</strong>。当系统完全进入<em>Rescue模式时</em>，用户将会看到一个命令行终端。</li>
<li>从此终端上，使用<code>parted</code>在目标硬盘驱动器上创建RAID分区。然后，使用<code>mdadm</code>任何和所有可用的设置和选项，从这些分区手动创建RAID阵列。</li>
<li>一旦创建了数组，您也可以选择在数组上创建文件系统。</li>
<li>重新启动计算机，这次选择<strong>安装</strong>或<strong>升级</strong>以正常安装。当<strong>Anaconda</strong>搜索系统中的磁盘时，它将找到预先存在的RAID设备。</li>
<li>当询问如何使用系统中的磁盘时，请选择“ <strong>自定义布局”</strong>，然后单击“ <strong>下一步”</strong>。在设备列表中，将列出预先存在的MD RAID设备。</li>
<li>选择一个RAID设备，单击<strong>编辑</strong>并配置其安装点和（可选）它应该使用的文件系统的类型（如果您以前没有创建），然后单击<strong>完成</strong>。<strong>Anaconda</strong>将执行安装到这个预先存在的RAID设备，保留您在<em>救援模式下</em>创建它时选择的自定义选项。</li>
</ol>
<p><strong>注意</strong></p>
<p>安装程序 的有限<em>救援模式</em>不包括<code>man</code>页面。无论是<code>man mdadm</code>和<code>man md</code>包含用于创建自定义RAID阵列的有用信息，并且可能需要在整个解决方法。因此，可以访问带有这些<code>man</code>页面的机器，或者在启动进入<em>救援模式</em>并创建自定义阵列之前将其打印出来。</p>
<h2 id="使用MOUNT命令"><a href="#使用MOUNT命令" class="headerlink" title="使用MOUNT命令"></a>使用MOUNT命令</h2><p>在Linux，UNIX和类似操作系统上，可以将不同分区和可移动设备（例如CD，DVD或USB闪存驱动器）上的文件系统附加到目录树中的某个点（<em>装入点</em>），然后分离再次。要附加或分离文件系统，请分别使用<code>mount</code>或<code>umount</code>命令。本章介绍这些命令的基本用法，以及一些高级主题，如移动挂载点或创建共享子树。</p>
<h3 id="列出当前已安装的文件系统"><a href="#列出当前已安装的文件系统" class="headerlink" title="列出当前已安装的文件系统"></a>列出当前已安装的文件系统</h3><p>要显示所有当前连接的文件系统，<code>mount</code>不带其他参数运行该命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>该命令显示已知挂载点的列表。每行提供有关设备名称，文件系统类型，安装目录以及相关安装选项的重要信息，格式如下：</p>
<blockquote>
<p><em>device</em> on <em>directory</em> type <em>type</em> (<em>options</em>)</p>
</blockquote>
<p>The <code>findmnt</code> u工具允许用户以树状形式列出已安装的文件系统, 要显示所有当前连接的文件系统，<code>findmnt</code>不带其他参数运行该命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findmnt</span><br></pre></td></tr></table></figure>
<h3 id="指定文件系统类型"><a href="#指定文件系统类型" class="headerlink" title="指定文件系统类型"></a>指定文件系统类型</h3><p>缺省情况下，输出<code>mount</code>命令包括各种虚拟文件系统，如<code>sysfs</code>和<code>tmpfs</code>。要仅显示具有特定文件系统类型的设备，请<code>-t</code>在命令行上提供该选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p>同样，要使用该<code>findmnt</code>命令仅显示具有特定文件系统类型的设备，请键入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findmnt -t <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p><strong>列出当前已安装的ext4文件系统</strong></p>
<p>通常情况下，这两个<code>/</code>和<code>/boot</code>分区格式化使用<code>ext4</code>。要仅显示使用此文件系统的安装点，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t ext4</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br></pre></td></tr></table></figure>
<p>要使用该<code>findmnt</code>命令列出此类安装点，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ findmnt -t ext4</span><br><span class="line">TARGET SOURCE    FSTYPE OPTIONS</span><br><span class="line">/      /dev/sda2 ext4   rw,realtime,seclabel,barrier=1,data=ordered</span><br><span class="line">/boot  /dev/sda1 ext4   rw,realtime,seclabel,barrier=1,data=ordered</span><br></pre></td></tr></table></figure>
<h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><p>要附加某个文件系统，请使用<code>mount</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [option…] device directory</span><br></pre></td></tr></table></figure>
<p><em>设备</em>可以通过以下方式识别：</p>
<ul>
<li><em>块设备</em> 的完整路径：例如，<code>/dev/sda3</code></li>
<li>一个<em>通用唯一标识符</em>（UUID）：例如，<code>UUID=34795a28-ca6d-4fd8-a347-73671d0c19cb</code></li>
<li>一个<em>卷标</em>：例如，<code>LABEL=home</code></li>
</ul>
<p>请注意，挂载文件系统时，不能访问<em>目录</em>的原始内容。</p>
<p>Linux不阻止用户将文件系统挂载到已连接文件系统的目录。要确定一个特定的目录是否作为挂载点，运行<code>findmnt</code>该目录作为参数的实用程序并验证退出代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findmnt directory; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>如果没有文件系统连接到目录，则上述命令返回<code>1</code>。</p>
<p>如果运行<code>mount</code>命令时没有提供所有必需信息（即没有设备名称，目标目录或文件系统类型），则<code>mount</code>读取<code>/etc/fstab</code>文件的内容以检查是否列出了给定的文件系统。该<code>/etc/fstab</code>文件包含设备名称的列表以及所选文件系统设置为要装入的目录以及文件系统类型和装入选项。因此，在安装指定的文件系统时<code>/etc/fstab</code>，可以选择以下选项之一：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount [option…] directory</span><br><span class="line">mount [option…] device</span><br></pre></td></tr></table></figure>
<p>请注意，除非命令运行为<code>root</code>，否则安装文件系统需要权限。</p>
<p><strong>注意</strong></p>
<p>要确定UUID并且（如果设备使用它）特定设备的标签，请使用<code>blkid</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid device</span><br></pre></td></tr></table></figure>
<p>例如，要显示有关的信息<code>/dev/sda3</code>，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># blkid /dev/sda3</span></span><br><span class="line">/dev/sda3: LABEL=<span class="string">"home"</span> UUID=<span class="string">"34795a28-ca6d-4fd8-a347-73671d0c19cb"</span> TYPE=<span class="string">"ext3"</span></span><br></pre></td></tr></table></figure>
<h4 id="指定文件系统类型-1"><a href="#指定文件系统类型-1" class="headerlink" title="指定文件系统类型"></a>指定文件系统类型</h4><p>在大多数情况下，<code>mount</code>自动检测文件系统。但是，某些文件系统（例如<code>NFS</code>（网络文件系统）或<code>CIFS</code>（通用Internet文件系统））无法识别，需要手动指定。要指定文件系统类型，请使用<code>mount</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t <span class="built_in">type</span> device directory</span><br></pre></td></tr></table></figure>
<p><strong>通用文件系统类型</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ext2</code></td>
<td><code>ext2</code>文件系统。</td>
</tr>
<tr>
<td><code>ext3</code></td>
<td><code>ext3</code>文件系统。</td>
</tr>
<tr>
<td><code>ext4</code></td>
<td><code>ext4</code>文件系统。</td>
</tr>
<tr>
<td><code>btrfs</code></td>
<td><code>btrfs</code>文件系统。</td>
</tr>
<tr>
<td><code>xfs</code></td>
<td><code>xfs</code>文件系统。</td>
</tr>
<tr>
<td><code>iso9660</code></td>
<td><code>ISO 9660</code>文件系统。它通常被光学媒体使用，通常是CD。</td>
</tr>
<tr>
<td><code>jfs</code></td>
<td><code>JFS</code>由IBM创建的文件系统。</td>
</tr>
<tr>
<td><code>nfs</code></td>
<td><code>NFS</code>文件系统。它通常用于通过网络访问文件。</td>
</tr>
<tr>
<td><code>nfs4</code></td>
<td><code>NFSv4</code>文件系统。它通常用于通过网络访问文件。</td>
</tr>
<tr>
<td><code>ntfs</code></td>
<td><code>NTFS</code>文件系统。它通常用于运行Windows操作系统的机器上。</td>
</tr>
<tr>
<td><code>udf</code></td>
<td><code>UDF</code>文件系统。它通常用于光学媒体，通常是DVD。</td>
</tr>
<tr>
<td><code>vfat</code></td>
<td><code>FAT</code>文件系统。它通常用于运行Windows操作系统的机器，以及某些数字媒体，如USB闪存驱动器或软盘。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>挂载USB闪存驱动器</strong></p>
<p>较旧的USB闪存驱动器通常使用FAT文件系统。假设这样的驱动器使用该<code>/dev/sdc1</code>设备并且该<code>/media/flashdisk/</code>目录存在，请通过在shell提示符处键入以下命令将其挂载到此目录<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -t vfat /dev/sdc1 /media/flashdisk</span></span><br></pre></td></tr></table></figure>
<h3 id="指定挂载选项"><a href="#指定挂载选项" class="headerlink" title="指定挂载选项"></a>指定挂载选项</h3><p>要指定其他挂载选项，请使用以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o options device directory</span><br></pre></td></tr></table></figure>
<p>提供多个选项时，不要在逗号后面插入空格，否则<code>mount</code>会错误地将空格后面的值解释为附加参数</p>
<p><strong>常见的安装选项</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async</code></td>
<td>允许在文件系统上进行异步输入/输出操作。</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>允许使用该<code>mount -a</code>命令自动安装文件系统。</td>
</tr>
<tr>
<td><code>defaults</code></td>
<td>提供一个别名<code>async,auto,dev,exec,nouser,rw,suid</code>。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td>允许在特定文件系统上执行二进制文件。</td>
</tr>
<tr>
<td><code>loop</code></td>
<td>将图像作为循环设备装入。</td>
</tr>
<tr>
<td><code>noauto</code></td>
<td>默认行为禁止使用该<code>mount -a</code>命令自动安装文件系统。</td>
</tr>
<tr>
<td><code>noexec</code></td>
<td>不允许在特定文件系统上执行二进制文件。</td>
</tr>
<tr>
<td><code>nouser</code></td>
<td>不允许普通用户（即非<code>root</code>）挂载和卸载文件系统。</td>
</tr>
<tr>
<td><code>remount</code></td>
<td>重新装入文件系统，以防已安装。</td>
</tr>
<tr>
<td><code>ro</code></td>
<td>将文件系统安装为只读。</td>
</tr>
<tr>
<td><code>rw</code></td>
<td>安装文件系统进行读取和写入。</td>
</tr>
<tr>
<td><code>user</code></td>
<td>允许普通用户（即非<code>root</code>）挂载和卸载文件系统。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>挂载 ISO 镜像</strong></p>
<p>可以使用循环设备挂载ISO映像（或通常的磁盘映像）。假设Fedora 14安装光盘的ISO映像存在于当前工作目录中，并且该<code>/media/cdrom/</code>目录存在，请通过运行以下命令将映像挂载到此目录<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -o ro,loop Fedora-14-x86_64-Live-Desktop.iso /media/cdrom</span></span><br></pre></td></tr></table></figure>
<p>请注意，ISO 9660设计为只读文件系统。</p>
<h3 id="共享挂载"><a href="#共享挂载" class="headerlink" title="共享挂载"></a>共享挂载</h3><p>偶尔，某些系统管理任务需要从目录树中的多个位置（例如，在准备chroot环境时）访问同一个文件系统。这是可能的，并且Linux允许您根据需要将相同的文件系统安装到多个目录。另外，该<code>mount</code>命令实现了<code>--bind</code>提供复制特定坐骑的方法的选项。其用法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> old_directory new_directory</span><br></pre></td></tr></table></figure>
<p>尽管此命令允许用户从两个位置访问文件系统，但它不适用于原始目录中安装的文件系统。要包括这些安装，请输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --rbind old_directory new_directory</span><br></pre></td></tr></table></figure>
<p>另外，为了提供尽可能大的灵活性，红帽企业版Linux 7实现了被称为<em>共享子树</em>的功能。该功能允许使用以下四种安装类型：</p>
<p><strong>共享挂载</strong></p>
<p>共享挂载允许创建给定挂载点的精确副本。当挂载点被标记为共享挂载时，原始挂载点内的任何挂载都会反映在其中，反之亦然。要将安装点的类型更改为共享安装，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-shared mount_point</span><br></pre></td></tr></table></figure>
<p>或者，要更改所选安装点和其下的所有安装点的安装类型，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rshared mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建共享安装点</strong></p>
<p>其他文件系统通常挂载在两个位置：<code>/media/</code>可移动介质的<code>/mnt/</code>目录以及临时挂载的文件系统的目录。通过使用共享挂载，可以使这两个目录共享相同的内容。为此<code>root</code>，将<code>/media/</code>目录标记为共享：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /media</span></span><br><span class="line"><span class="comment"># mount --make-shared /media</span></span><br></pre></td></tr></table></figure>
<p>然后<code>/mnt/</code>使用以下命令创建它的重复项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ mount --<span class="built_in">bind</span> /media /mnt</span><br></pre></td></tr></table></figure>
<p>现在可以验证在一个挂载<code>/media/</code>也出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount /dev/cdrom /media/cdrom</span></span><br><span class="line"><span class="comment"># ls /media/cdrom</span></span><br><span class="line">EFI  GPL  isolinux  LiveOS</span><br><span class="line"><span class="comment"># ls /mnt/cdrom</span></span><br><span class="line">EFI  GPL  isolinux  LiveOS</span><br></pre></td></tr></table></figure>
<p>同样，也可以验证安装在<code>/mnt/</code>目录中的任何文件系统是否被反映<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount /dev/sdc1 /mnt/flashdisk</span></span><br><span class="line"><span class="comment"># ls /media/flashdisk</span></span><br><span class="line">en-US  publican.cfg</span><br><span class="line"><span class="comment"># ls /mnt/flashdisk</span></span><br><span class="line">en-US  publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>从属挂载</strong></p>
<p>从属安装允许创建给定挂载点的有限副本。当挂载点被标记为从属挂载时，原始挂载点内的任何挂载都会反映到挂载点中，但挂载挂载中的挂载不会反映在其原始映像中。要将挂载点的类型更改为从属安装，请在shell提示下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-slave mount_point</span><br></pre></td></tr></table></figure>
<p>或者，也可以通过输入以下命令来更改所选安装点及其下的所有挂载点的挂载类型：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rslave mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个从站挂载点</strong></p>
<p>这个例子展示了如何让<code>/media/</code>目录的内容也出现在目录中<code>/mnt/</code>，但是没有在<code>/mnt/</code>目录中的任何坐标被反映到<code>/media/</code>。因为<code>root</code>，首先将该<code>/media/</code>目录标记为共享：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /media</span><br><span class="line">＃mount --make-shared /media</span><br></pre></td></tr></table></figure>
<p>然后创建它的副本<code>/mnt/</code>，但将其标记为“slave”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /mnt</span><br><span class="line">＃mount --make-slave /mnt</span><br></pre></td></tr></table></figure>
<p>现在验证一个挂载<code>/media/</code>也出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/cdrom /media/cdrom</span><br><span class="line">ls /media/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS〜</span><br><span class="line">ls /mnt/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS</span><br></pre></td></tr></table></figure>
<p>还要验证<code>/mnt/</code>目录中装载的文件系统没有被反映到<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃mount /dev/sdc1 /mnt/flashdisk</span><br><span class="line">＃ls /media/flashdisk</span><br><span class="line">＃ls /mnt/flashdisk</span><br><span class="line">en-US publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>私有挂载</strong></p>
<p>私有挂载是挂载的默认类型，与共享或从属挂载不同，它不接收或转发任何传播事件。要明确地将安装点标记为私有安装，请在shell提示符处输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-private mount_point</span><br></pre></td></tr></table></figure>
<p>或者，可以更改所选安装点的装载类型及其下的所有装入点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-rprivate mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个私有安装点</strong></p>
<p>假定共享挂载点先前是通过使用以下命令创建的<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /media</span><br><span class="line">＃mount --make-shared /media</span><br><span class="line">＃mount --<span class="built_in">bind</span> /media /mnt</span><br></pre></td></tr></table></figure>
<p>要将该<code>/mnt/</code>目录标记为私有，请输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ mount --make-private /mnt</span><br></pre></td></tr></table></figure>
<p>现在可以确认没有内的坐骑<code>/media/</code>出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">＃mount /dev/cdrom /media/cdrom</span><br><span class="line"> ls /media/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS〜</span><br><span class="line">＃ls /mnt/cdrom</span><br><span class="line">＃</span><br></pre></td></tr></table></figure>
<p>也可以验证安装在<code>/mnt/</code>目录中的文件系统没有被反映<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃mount /dev/sdc1 /mnt/flashdisk</span><br><span class="line">＃ls /media/flashdisk</span><br><span class="line">＃ls /mnt/flashdisk</span><br><span class="line">en-US publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>不可绑定的挂载点</strong></p>
<p>为了防止给定的挂载点被复制，使用一个不可绑定的挂载点。要将安装点的类型更改为不可绑定安装，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-unbindable mount_point</span><br></pre></td></tr></table></figure>
<p>或者，可以更改所选安装点的装载类型及其下的所有装入点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --make-runbindable mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个不可绑定的挂载点</strong></p>
<p>要防止<code>/media/</code>共享目录<code>root</code>，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /media</span></span><br><span class="line"><span class="comment"># mount --make-unbindable /media</span></span><br></pre></td></tr></table></figure>
<p>这样，任何后续尝试重复此挂载将失败并出现错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /mnt</span></span><br><span class="line">mount: wrong fs <span class="built_in">type</span>, bad option, bad superblock on /media,</span><br><span class="line">missing codepage or helper program, or other error</span><br><span class="line">In some cases useful info is found <span class="keyword">in</span> syslog - try</span><br><span class="line">dmesg | tail  or so</span><br></pre></td></tr></table></figure>
<h3 id="移动一个挂载点"><a href="#移动一个挂载点" class="headerlink" title="移动一个挂载点"></a>移动一个挂载点</h3><p>要更改安装文件系统的目录，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --move old_directory new_directory</span><br></pre></td></tr></table></figure>
<p><strong>移动现有的NFS挂载点</strong></p>
<p>一个NFS存储包含用户目录，并已被挂载<code>/mnt/userdirs/</code>。作为<code>root</code>，<code>/home</code>通过使用以下命令移动此安装点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ mount --move /mnt/userdirs /home</span><br></pre></td></tr></table></figure>
<p>要验证装入点已被移动，请列出两个目录的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃ls /mnt/userdirs</span><br><span class="line"> ls /home</span><br><span class="line">jill joe</span><br></pre></td></tr></table></figure>
<h3 id="设置只读权限root"><a href="#设置只读权限root" class="headerlink" title="设置只读权限root"></a>设置只读权限<code>root</code></h3><p>有时，您需要以只读权限安装根文件系统。示例用例包括增强安全性或在系统意外断电后确保数据完整性。</p>
<h4 id="配置root为在引导时使用只读权限进行挂载"><a href="#配置root为在引导时使用只读权限进行挂载" class="headerlink" title="配置root为在引导时使用只读权限进行挂载"></a>配置<code>root</code>为在引导时使用只读权限进行挂载</h4><ol>
<li>在<code>/etc/sysconfig/readonly-root</code> 文件中, 更改 <code>READONLY</code> 为<code>yes</code>:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set to 'yes' to mount the system file systems read-only.</span></span><br><span class="line">READONLY=yes</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <code>/etc/fstab</code>文件的根条目(<code>/</code>)中将缺省值 <code>defaults</code> 更改为 <code>ro</code> ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/mapper/luks-c376919e... / ext4 ro,x-systemd.device-timeout=0 1 1</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>/etc/default/grub</code>中，添加<code>ro</code> 到文件中的 <code>GRUB_CMDLINE_LINUX</code> 指令 并确保它不包含 <code>rw</code>:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet ro"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>重新创建 GRUB2 配置文件:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果需要在<code>tmpfs</code>文件系统中添加要以写入权限挂载的文件和目录，请在该<code>/etc/rwtab.d/</code>目录中创建一个文本文件，并将配置置于该文件中。例如，要<code>/etc/example/file</code>使用写入权限进行挂载，请将以下行添加到文件中：<code>/etc/rwtab.d/</code><em><code>example</code></em></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">files /etc/example/file</span><br></pre></td></tr></table></figure>
<p>对文件和目录所做的更改<code>tmpfs</code>不会保留在各个引导程序中.</p>
<ol>
<li>重启操作系统</li>
</ol>
<h3 id="root立即重新挂载"><a href="#root立即重新挂载" class="headerlink" title="root立即重新挂载"></a><code>root</code>立即重新挂载</h3><p>如果root（<code>/</code>）在系统引导时以只读权限挂载，则可以使用写入权限重新挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃ mount -o remount,rw /</span><br></pre></td></tr></table></figure>
<p>要<code>/</code>使用只读权限重新装入，请运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -o remount,ro /</span></span><br></pre></td></tr></table></figure>
<p>这个命令装载<em>整个</em> <code>/</code>只读权限。更好的方法是通过将某些文件和目录复制到RAM中来保留写入权限</p>
<h3 id="保留写权限的文件和目录"><a href="#保留写权限的文件和目录" class="headerlink" title="保留写权限的文件和目录"></a>保留写权限的文件和目录</h3><p>为了使系统正常工作，某些文件和目录需要保留写权限。root在只读模式下，它们被安装在<code>tmpfs</code>临时文件系统的RAM中。从<code>/etc/rwtab</code>文件读取这些文件和目录的默认设置，其中包含：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dirs</span>	/var/cache/man</span><br><span class="line"><span class="built_in">dirs</span>	/var/gdm</span><br><span class="line">[output truncated]</span><br><span class="line">empty	/tmp</span><br><span class="line">empty	/var/cache/foomatic</span><br><span class="line">[output truncated]</span><br><span class="line">files	/etc/adjtime</span><br><span class="line">files	/etc/ntp.conf</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<p><code>/etc/rwtab</code>文件中的 条目遵循以下格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">how the file or directory is copied to tmpfs       	path to the file or directory</span><br></pre></td></tr></table></figure>
<p>文件或目录可以通过<code>tmpfs</code>三种方式复制，因此有三种类型的条目：</p>
<ul>
<li><code>empty</code> <em><code>path</code></em>: 空的路径被复制到 <code>tmpfs</code>. 例如: <code>empty /tmp</code></li>
<li><code>dirs</code> <em><code>path</code></em>: 目录树被复制到 <code>tmpfs</code>, 为空. 例如: <code>dirs /var/run</code></li>
<li><code>files</code> <em><code>path</code></em>: 文件或目录被 <code>tmpfs</code> 完整复制. 例如: <code>files /etc/resolv.conf</code></li>
</ul>
<p>添加自定义路径时适用相同的格式<code>/etc/rwtab.d/</code>。</p>
<h2 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h2><p>要分离先前安装的文件系统，请使用以下任一种<code>umount</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umount directory</span><br><span class="line">umount device</span><br></pre></td></tr></table></figure>
<p>当一个文件系统正在使用（例如，当一个进程正在读取这个文件系统上的一个文件，或者当它被内核使用的时候），运行这个<code>umount</code>命令将会失败并报错。要确定哪些进程正在访问文件系统，请使用<code>fuser</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -m directory</span><br></pre></td></tr></table></figure>
<p>例如，要列出正在访问挂载到<code>/media/cdrom/</code>目录的文件系统的进程，请键入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fuser -m /media/cdrom</span><br><span class="line">/media/cdrom:         1793  2013  2022  2435 10532c 10672c</span><br></pre></td></tr></table></figure>
<p><strong> 卸载CD</strong></p>
<p>要卸载先前安装到该<code>/media/cdrom/</code>目录的CD，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umount /media/cdrom</span><br></pre></td></tr></table></figure>
<h1 id="VOLUME-KEY函数"><a href="#VOLUME-KEY函数" class="headerlink" title="VOLUME_KEY函数"></a>VOLUME_KEY函数</h1><p>volume_key 函数提供了两个工具， libvolume_key and <code>volume_key</code>. libvolume_key 是一个用于处理存储卷加密密钥并将其与卷分开存储的库。<code>volume_key</code>是一个相关的命令行工具，用于提取密钥和密码以恢复对加密硬盘的访问。</p>
<p>当主要用户忘记密钥和密码，员工突然离职后，或者在硬件或软件故障破坏加密卷的标题后提取数据时，这一点很有用。在公司设置中，IT帮助台可以<code>volume_key</code>在将计算机交付给最终用户之前用于备份加密密钥。</p>
<p>目前<code>volume_key</code>只支持LUKS卷加密格式。</p>
<h2 id="volume-key-命令"><a href="#volume-key-命令" class="headerlink" title="volume_key` 命令"></a>volume_key` 命令</h2><p> <code>volume_key</code> 格式是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key [OPTION]... OPERAND</span><br></pre></td></tr></table></figure>
<p><code>volume_key</code>通过指定以下选项之一来确定 操作数和操作模式:</p>
<ul>
<li><p><code>--save</code></p>
<p>该命令期望操作数<em>卷</em> [ <em>包</em> ]。如果提供了<em>数据包，</em><code>volume_key</code>则会从中提取密钥和密码。如果没有提供<em>数据包</em>，<code>volume_key</code>则会从<em>卷中</em>提取密钥和密码，在必要时提示用户。这些密钥和密码将被存储在一个或多个输出数据包中。</p>
</li>
<li><p><code>--restore</code></p>
<p>该命令期望操作数<em>卷数据包</em>。然后，它会打开<em>音量</em>，并使用密钥和密码短语中的<em>数据包</em>，使<em>音量</em>再次访问，提示用户在必要时，例如允许用户输入新的密码，例如。</p>
</li>
<li><p><code>--setup-volume</code></p>
<p>该命令期望操作数 <em>volume packet name</em>. 然后打开 <em>volume</em> 并使用  <em>packet</em> t中的密钥和密码设置 <em>volume</em> 来解密数据 ，<em>name</em>.<em>Name</em> 是 dm-crypt volume的名称. 此操作是解密卷可用例如  <code>/dev/mapper/*name*</code>.此操作不会通过添加新的密码来永久性更改 <em>volume</em>  for example. 用户可以访问和修改解密卷，修改过程中的劵.</p>
</li>
<li><p><code>--reencrypt</code>, <code>--secrets</code>, and <code>--dump</code></p>
<p>这三个命令使用不同的输出方法执行类似的功能。他们每个都需要操作数<em>数据包</em>，每个都打开<em>数据包</em>，在必要时解密<em>数据包</em>。<code>--reencrypt</code>然后将信息存储在一个或多个新的输出分组中。<code>--secrets</code>输出<em>包中</em>包含的密钥和密码短语。<code>--dump</code>输出<em>数据包</em>的内容，尽管默认情况下不输出密钥和密码。这可以通过追加<code>--with-secrets</code>命令来改变。也可以通过使用<code>--unencrypted</code>命令转储数据包的未加密部分（如果有的话）。这不需要任何密码或私钥访问。</p>
</li>
</ul>
<p>每个这些可以附加以下选项：</p>
<ul>
<li><p><code>-o</code>, <code>--output</code> <em><code>packet</code></em></p>
<p>该命令将默认密钥或密码写入<em>数据包</em>。默认密钥或密码短语取决于音量格式。确保它不可能过期，并允许<code>--restore</code>恢复对卷的访问。</p>
</li>
<li><p><code>--output-format</code> <em><code>format</code></em></p>
<p>此命令对所有输出数据包使用指定的<em>格式</em>。目前，<em>格式</em>可以是以下之一：</p>
<ul>
<li><code>asymmetric</code>：使用CMS来加密整个数据包，并且需要一个证书</li>
<li><code>asymmetric_wrap_secret_only</code>：只包装秘密，或密钥和密码，并且需要证书</li>
<li><code>passphrase</code>：使用GPG加密整个数据包，并需要密码</li>
</ul>
</li>
<li><p><code>--create-random-passphrase</code> <em><code>packet</code></em></p>
<p>此命令会生成一个随机的字母数字密码，将其添加到<em>音量</em>（不影响其他密码），然后将此随机密码存储到<em>数据包中</em>。</p>
</li>
</ul>
<h2 id="使用VOLUME-KEY作为个人用户"><a href="#使用VOLUME-KEY作为个人用户" class="headerlink" title="使用VOLUME_KEY作为个人用户"></a>使用VOLUME_KEY作为个人用户</h2><p>作为个人用户，<code>volume_key</code>可以使用以下过程来保存加密密钥。</p>
<p>对于这个文件中的所有例子, <em><code>/path/to/volume</code></em>  是一个LUKS设备, 而不是其中包含的纯文本设备. <code>blkid -s</code> <em><code>type /path/to/volume</code></em> 应该报告 <em><code>type</code></em> <code>`=&quot;crypto_LUKS&quot;</code>.</p>
<p><strong>使用独立volume_key</strong></p>
<ol>
<li>运行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --save /path/to/volume -o escrow-packet</span><br></pre></td></tr></table></figure>
<p>   随后会出现提示，要求托管数据包密码来保护密钥。</p>
<ol>
<li>保存生成的<code>escrow-packet</code>文件，确保密码不会被遗忘。</li>
</ol>
<p>如果忘记密码短语，请使用保存的托管数据包恢复对数据的访问。</p>
<p><strong>使用托管数据包恢复对数据的访问</strong></p>
<ol>
<li><p>在<code>volume_key</code>可以运行的环境中启动系统，并且托管数据包可用（例如救援模式）。</p>
</li>
<li><p>运行：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --restore /path/to/volume escrow-packet</span><br></pre></td></tr></table></figure>
<p>在创建托管数据包时使用的托管数据包密码以及卷的新密码会显示提示。</p>
<ol>
<li>使用所选密码安装音量。</li>
</ol>
<p>要释放加密卷的LUKS标头中的密码槽，请使用该命令删除旧的，被遗忘的密码<code>cryptsetup luksKillSlot</code>。</p>
<h2 id="在较大的组织中使用VOLUME-KEY"><a href="#在较大的组织中使用VOLUME-KEY" class="headerlink" title="在较大的组织中使用VOLUME_KEY"></a>在较大的组织中使用VOLUME_KEY</h2><p>在一个更大的组织中，使用每个系统管理员都知道的单个密码并且为每个系统记录一个单独的密码是不切实际的和安全的风险。为了解决这个问题，<code>volume_key</code>可以使用非对称加密技术来减少知道在任何计算机上访问加密数据所需的密码的人数。</p>
<p>本节将介绍在保存加密密钥，如何保存加密密钥，恢复对卷的访问以及设置紧急密码之前所需的准备步骤。</p>
<h3 id="准备保存加密密钥"><a href="#准备保存加密密钥" class="headerlink" title="准备保存加密密钥"></a>准备保存加密密钥</h3><p>为了开始保存加密密钥，需要做一些准备。</p>
<p><strong>准备</strong></p>
<ol>
<li><p>创建一个X509证书/私人对.</p>
</li>
<li><p>指定值得信任的可信用户不要危及私钥。这些用户将能够解密托管数据包。</p>
</li>
<li><p>选择将使用哪些系统来解密托管数据包。在这些系统上，建立一个包含私钥的NSS数据库。</p>
<p>如果私钥没有在NSS数据库中创建，请按照下列步骤操作：</p>
<ul>
<li><p>将证书和私钥存储在一个<code>PKCS#12</code>文件中。</p>
</li>
<li><p>运行:</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -d /the/nss/directory -N</span><br></pre></td></tr></table></figure>
<p>此时可以选择NSS数据库密码。每个NSS数据库可以有不同的密码，因此如果每个用户使用一个单独的NSS数据库，指定的用户不需要共享一个密码。</p>
<ul>
<li>运行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pk12util -d /the/nss/directory -i the-pkcs12-file</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将证书分发给任何安装系统或在现有系统上保存密钥的人员。</p>
</li>
<li><p>对于保存的专用密钥，请准备存储空间，以便通过机器和音量来查找。例如，这可以是一个简单的目录，每个机器有一个子目录，也可以是用于其他系统管理任务的数据库。</p>
</li>
</ol>
<h4 id="保存加密密钥"><a href="#保存加密密钥" class="headerlink" title="保存加密密钥"></a>保存加密密钥</h4><p>完成所需的准备工作后，现在可以使用以下步骤保存加密密钥。</p>
<p><strong>保存加密秘钥</strong></p>
<ol>
<li>运行:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --save /path/to/volume -c /path/to/cert escrow-packet</span><br></pre></td></tr></table></figure>
<ol>
<li>将生成的<code>escrow-packet</code>文件保存在准备好的存储中，将其与系统和卷相关联.</li>
</ol>
<p>这些步骤可以手动执行，或者作为系统安装的一部分编写脚本。</p>
<h3 id="恢复对卷的访问"><a href="#恢复对卷的访问" class="headerlink" title="恢复对卷的访问"></a>恢复对卷的访问</h3><p>加密密钥保存后，可以根据需要将访问权恢复到驱动程序。</p>
<p><strong>恢复对卷的访问</strong></p>
<ol>
<li><p>从数据包存储器获取卷的托管数据包，并将其发送给指定用户之一进行解密。</p>
</li>
<li><p>指定的用户运行：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --reencrypt -d /the/nss/directory escrow-packet-in -o escrow-packet-out</span><br></pre></td></tr></table></figure>
<p>   提供NSS数据库密码后，指定用户选择密码进行加密<code>escrow-packet-out</code>。该密码可以每次都不同，只有在密钥从指定用户移动到目标系统时才能保护密码。</p>
<ol>
<li><p><code>escrow-packet-out</code>从指定的用户 获取文件和密码。</p>
</li>
<li><p>在可运行的环境中启动目标系统，<code>volume_key</code>并使<code>escrow-packet-out</code>文件可用，例如在救援模式下。</p>
</li>
<li><p>运行:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --restore /path/to/volume escrow-packet-out</span><br></pre></td></tr></table></figure>
<p>将出现提示，指定用户选择的数据包密码以及该卷的新密码。</p>
<ol>
<li>使用所选的卷密码安装卷。</li>
</ol>
<p>例如，可以使用 <code>cryptsetup luksKillSlot</code>删除忘记的旧密码, 以释放加密卷的LUKS标头中的密码插槽。这是用命令完成的。<code>cryptsetup luksKillSlot</code> <em><code>device key-slot</code></em>.</p>
<h3 id="设置紧急密码"><a href="#设置紧急密码" class="headerlink" title="设置紧急密码"></a>设置紧急密码</h3><p>在某些情况下（如出差旅行），系统管理员直接与受影响的系统协作是不切实际的，但用户仍然需要访问其数据。在这种情况下，<code>volume_key</code>可以使用密码和加密密钥。</p>
<p>在系统安装过程中，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --save /path/to/volume -c /path/to/ert --create-random-passphrase passphrase-packet</span><br></pre></td></tr></table></figure>
<p>这将生成一个随机密码，将其添加到指定的卷，并将其存储到<em><code>passphrase-packet</code></em> 。也可以将选项<code>--create-random-passphrase</code>和<code>-o</code>选项组合在一起生成两个数据包。</p>
<p>如果用户忘记了密码，指定的用户运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volume_key --secrets -d /your/nss/directory passphrase-packet</span><br></pre></td></tr></table></figure>
<p>这显示了随机密码。将此密码提供给最终用户。</p>
<h1 id="固态硬盘部署指南"><a href="#固态硬盘部署指南" class="headerlink" title="固态硬盘部署指南"></a>固态硬盘部署指南</h1><p><em>固态硬盘</em>（SSD）是使用NAND闪存芯片来持久存储数据的存储设备。这使得它们与上一代磁盘存储器不同，磁盘存储旋转磁盘中的数据。在SSD中，整个逻辑块地址（LBA）范围内的数据访问时间不变; 而使用旋转媒体的较旧的磁盘，跨越大地址范围的访问模式会招致成本。因此，SSD设备具有更好的延迟和吞吐量。</p>
<p>随着使用块的数量接近磁盘容量，性能下降。供应商对性能的影响程度差异很大。但是，所有设备都会经历一些降级。</p>
<p>为了解决退化问题，主机系统（例如，Linux内核）可以使用丢弃请求来通知存储器给定范围的块不再被使用。SSD可以使用这些信息来释放内部空间，使用空闲块进行磨损平衡。只有当存储广告支持存储协议（不管是ATA还是SCSI）时才会发放丢弃。丢弃请求使用特定于存储协议协商的丢弃命令发布到存储装置（<code>TRIM</code>用于ATA命令，和<code>WRITE SAME</code>与<code>UNMAP</code>一组，或<code>UNMAP</code>用于SCSI命令）。</p>
<p><code>discard</code>当满足以下两点时， 启用支持是最有用的：</p>
<ul>
<li>文件系统上的可用空间仍然可用。</li>
<li>底层存储设备上的大多数逻辑块已被写入。</li>
</ul>
<p>并非市场上所有的固态器件都有<code>discard</code>支持。要确定您的固态设备是否<code>discard</code>支持，请检查<code>/sys/block/sda/queue/discard_granularity</code>。</p>
<h2 id="部署注意事项"><a href="#部署注意事项" class="headerlink" title="部署注意事项"></a>部署注意事项</h2><p>由于SSD的内部布局和操作，最好在内部<em>擦除块边界</em>上对器件进行分区。如果SSD导出拓扑信息，红帽企业版Linux 7中的分区工具会选择合理的默认值。</p>
<p>然而，如果该设备不会<em>不</em>导出拓扑信息，红帽建议的第一个分区在1MB边界创建。</p>
<p>逻辑卷管理器（LVM），设备映射程序（DM）目标以及LVM使用支持丢弃的MD（软件RAID）目标。唯一不支持丢弃的DM目标是dm-snapshot，dm-crypt和dm-raid45。在Red Hat Enterprise Linux 6.1中添加了对dm-mirror的支持，从7.0开始，MD支持丢弃。</p>
<p>如果SSD不能<code>discard</code>正确处理，则在SSD上使用RAID级别5会导致性能低下。您可以在<code>raid456.conf</code>文件中或在GRUB2配置中设置放弃。有关说明，请参阅以下过程。</p>
<p><strong>在raid456.conf中设置放弃</strong></p>
<p>该<em>devices_handle_discard_safely</em>模块参数的设定中的<code>raid456</code>模块。要在<code>raid456.conf</code>文件中启用丢弃：</p>
<ol>
<li>确认您的硬件支持丢弃：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/disk-name/queue/discard_zeroes_data</span></span><br></pre></td></tr></table></figure>
<p>如果返回值是<code>1</code>，则支持丢弃。如果命令返回<code>0</code>，则RAID代码必须将磁盘清零，这需要更多的时间。</p>
<ol>
<li>创建该<code>/etc/modprobe.d/raid456.conf</code>文件，并包含以下行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options raid456 devices_handle_discard_safely = Y</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用该<code>dracut -f</code>命令重建初始ramdisk（<code>initrd</code>）。</p>
</li>
<li><p>重新启动系统以使更改生效。</p>
</li>
</ol>
<p><strong>在GRUB2配置中设置放弃</strong></p>
<p>该<em>devices_handle_discard_safely</em>模块参数的设定中的<code>raid456</code>模块。要在GRUB2配置中启用丢弃，请执行以下操作：</p>
<ol>
<li>确认您的硬件支持丢弃：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/disk-name/queue/discard_zeroes_data</span></span><br></pre></td></tr></table></figure>
<p>   如果返回值是<code>1</code>，则支持丢弃。如果命令返回<code>0</code>，则RAID代码必须将磁盘清零，这需要更多的时间。</p>
<ol>
<li>将以下行添加到<code>/etc/default/grub</code>文件中：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raid456.devices_handle_discard_safely = Y</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在具有BIOS固件的系统和具有UEFI的系统上，GRUB2配置文件的位置不同。使用以下命令之一重新创建GRUB2配置文件。</p>
<ul>
<li>在具有BIOS固件的系统上，使用：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在具有UEFI固件的系统上，使用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ol>
<li>重新启动系统以使更改生效。</li>
</ol>
<p><strong>注意</strong></p>
<p>在红帽企业版Linux 7中，只有ext4和XFS文件系统完全支持丢弃。</p>
<p>在Red Hat Enterprise Linux 6.3及更早版本中，只有ext4文件系统完全支持丢弃。从红帽企业版Linux 6.4开始，ext4和XFS文件系统完全支持丢弃。要在设备上启用丢弃命令，请使用<code>discard</code>该<code>mount</code>命令的选项。例如，安装<code>/dev/sda2</code>到<code>/mnt</code>与丢弃启用，使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -t ext4 -o discard /dev/sda2 /mnt</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，ext4不会发出<code>discard</code>命令，主要是避免可能无法正确执行丢弃的设备上的问题。Linux <code>swap</code>代码发出<code>discard</code>命令丢弃启用设备，并没有选项来控制这种行为。</p>
<h1 id="写障碍"><a href="#写障碍" class="headerlink" title="写障碍"></a>写障碍</h1><p>一个<em>写屏障</em>是用来确保文件系统元数据被正确地写入，并下令永久存储内核机制，即使与性写高速缓存存储设备断电。启用了写入屏障的文件系统还确保通过传输的数据<code>fsync()</code>在整个功率损耗期间保持不变。</p>
<p>启用写入障碍会对某些应用程序造成显着的性能损失。特别是，<code>fsync()</code>大量使用或者创建和删除很多小文件的应用程序可能运行速度要慢得多。</p>
<h2 id="写障碍的重要性"><a href="#写障碍的重要性" class="headerlink" title="写障碍的重要性"></a>写障碍的重要性</h2><p>文件系统非常谨慎地安全地更新元数据，确保一致性。已记录的文件系统将元数据更新绑定到事务中，并按以下方式将其发送到永久存储：</p>
<ol>
<li>首先，文件系统将事务主体发送给存储设备。</li>
<li>然后，文件系统发送一个提交块。</li>
<li>如果将事务及其相应的提交块写入磁盘，则文件系统假定事务将在任何电源故障之后存活。</li>
</ol>
<p>但是，对于具有额外缓存的存储设备，断电期间的文件系统完整性会变得更加复杂。存储目标设备（如本地S-ATA或SAS驱动器）的写入缓存范围可以从32MB到64MB（使用现代驱动器）。硬件RAID控制器通常包含内部写入缓存。而且，高端阵列（如NetApp，IBM，Hitachi和EMC等）也拥有大量缓存。</p>
<p>当数据处于缓存时，具有写入缓存的存储设备将I / O报告为“完成”; 如果缓存失去能力，它也会丢失数据。更糟糕的是，当缓存取消暂存到永久性存储时，它可能会更改原始的元数据排序。发生这种情况时，提交块可能存在于磁盘上，而没有完整的关联事务。结果，日志可能会在断电恢复期间将这些未初始化的事务块重放到文件系统中; 这将导致数据不一致和腐败。</p>
<h2 id="如何写障碍的工作"><a href="#如何写障碍的工作" class="headerlink" title="如何写障碍的工作"></a>如何写障碍的工作</h2><p>写入障碍在Linux内核中通过在I / O之前和之后的存储写入缓存刷新来实现，这对<em>订单来说至关重要</em>。事务写入后，刷新存储缓存，写入提交块，并重新刷新缓存。这确保：</p>
<ul>
<li>该磁盘包含所有的数据。</li>
<li>没有重新排序发生。</li>
</ul>
<p>启用屏障后，<code>fsync()</code>调用也将发出存储缓存刷新。这可以确保文件数据在磁盘上保留，即使在<code>fsync()</code>返回后不久也会发生掉电。</p>
<h2 id="启用-禁用写障碍"><a href="#启用-禁用写障碍" class="headerlink" title="启用/禁用写障碍"></a>启用/禁用写障碍</h2><p>为了降低掉电时数据损坏的风险，一些存储设备使用电池供电的写缓存。通常，高端阵列和一些硬件控制器使用电池供电的写入缓存。但是，由于内核不可见缓存的波动性，红帽企业版Linux 7默认在所有支持的日志文件系统上启用了写障碍。</p>
<p><strong>注意</strong></p>
<p>写高速缓存旨在提高I / O性能。但是，启用写屏障意味着不断刷新这些缓存，这会显着降低性能。</p>
<p>对于具有非易失性，电池支持的写入缓存和禁止写入缓存的设备，可以使用<code>-o nobarrier</code>选项在安装时安全地禁用写入屏障<code>mount</code>。但是，有些设备不支持写入屏障; 这些设备将记录一条错误消息<code>/var/log/messages</code></p>
<p><strong>为每个文件系统写入屏障错误消息</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件系统</th>
<th>错误信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXT3 / EXT4</td>
<td><code>JBD: barrier-based sync failed on *device* - disabling barriers</code></td>
</tr>
<tr>
<td>XFS</td>
<td><code>Filesystem *device* - Disabling barriers, trial barrier write failed</code></td>
</tr>
<tr>
<td>BTRFS</td>
<td><code>btrfs: disabling barriers on dev *device*</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="写入障碍注意事项"><a href="#写入障碍注意事项" class="headerlink" title="写入障碍注意事项"></a>写入障碍注意事项</h2><p>一些系统配置不需要写入屏障来保护数据。在大多数情况下，其他方法比写障碍更好，因为写障碍会导致显着的性能损失。</p>
<h3 id="禁用写入缓存"><a href="#禁用写入缓存" class="headerlink" title="禁用写入缓存"></a>禁用写入缓存</h3><p>避免数据完整性问题的一种方法是确保写入缓存在电源故障时不会丢失数据。如果可能的话，配置这个的最好方法是简单地禁用写缓存。在具有一个或多个SATA驱动器的简单服务器或台式机（不包括本地SATA控制器Intel AHCI部分）上，可以使用以下<code>hdparm</code>命令禁用目标SATA驱动器上的写入缓存：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃hdparm -W0 / device /</span><br></pre></td></tr></table></figure>
<h3 id="电池支持的写入缓存"><a href="#电池支持的写入缓存" class="headerlink" title="电池支持的写入缓存"></a>电池支持的写入缓存</h3><p>只要系统使用硬件RAID控制器和带有电池供电的写缓存，写屏障也是不必要的。如果系统配备了这样的控制器，并且如果其组件驱动器禁止了写入缓存，则控制器将宣告自己为直写式缓存; 这将通知内核写入缓存数据将在掉电时存活。</p>
<p>大多数控制器使用特定于供应商的工具来查询和操作目标驱动器。例如，LSI Megaraid SAS控制器使用电池支持的写入缓存; 这种类型的控制器需要该<code>MegaCli64</code>工具来管理目标驱动器。要显示LSI Megaraid SAS所有后端驱动器的状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃MegaCli64 -LDGetProp -DskCache -LAll -aALL</span><br></pre></td></tr></table></figure>
<p>要禁用LSI Megaraid SAS所有后端驱动器的写缓存，请使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃MegaCli64 -LDSetProp -DisDskCache -Lall -aALL</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>硬件RAID卡在系统运行时为电池充电。如果系统长时间关闭电源，电池将会失去充电功能，在电源出现故障时，储存的数据会变得易受攻击。</p>
<h3 id="高端数组"><a href="#高端数组" class="headerlink" title="高端数组"></a>高端数组</h3><p>高端阵列在发生电源故障时有多种保护数据的方式。因此，不需要验证外部RAID存储器中的内部驱动器的状态。</p>
<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>NFS客户端不需要启用写入障碍，因为数据完整性是由NFS服务器端处理的。因此，应该配置NFS服务器以确保在整个电力损失期间（无论是通过编写屏障还是通过其他方式）数据持久化。</p>
<h1 id="存储I-O对齐和大小"><a href="#存储I-O对齐和大小" class="headerlink" title="存储I/O对齐和大小"></a>存储I/O对齐和大小</h1><p>最近对SCSI和ATA标准的增强允许存储设备指示其首选（并且在某些情况下是所需的）<em>I/O对齐</em>和<em>I/O大小</em>。此信息对于较新的磁盘驱动器特别有用，可将物理扇区大小从512字节增加到4k字节。此信息对于RAID设备也可能是有益的，其中块大小和条带大小可能会影响性能。</p>
<p>在Linux I/O栈已经增强处理供应商提供的 I/O 对齐和 I/O 大小信息, 从而允许存储管理工具 (<code>parted</code>, <code>lvm</code>, <code>mkfs.*</code>, 等等) 以优化数据放置和访问。如果传统设备不能导出I / O对齐和大小数据，那么红帽企业版Linux 7中的存储管理工具将在4k（或2的更大幂）边界上保守地对齐I / O。这将确保4k扇区设备即使没有指示任何所需的/首选的I / O对齐和尺寸，也能正常工作.</p>
<p>红帽企业版Linux 7的IO调度程序已更改。默认IO调度程序现在是<em>截止日期</em>，SATA驱动器除外。CFQ是SATA驱动器的默认IO调度程序。为了更快速的存储，截止日期优于CFQ，并且在使用时可以提高性能，而不需要特殊的调整。</p>
<p>如果某些磁盘（例如SAS旋转磁盘）的默认值不正确，则将IO调度程序更改为CFQ。这个实例将取决于工作量。</p>
<h2 id="存储访问参数"><a href="#存储访问参数" class="headerlink" title="存储访问参数"></a>存储访问参数</h2><p>操作系统使用以下信息来确定I/O对齐和大小：</p>
<ul>
<li><p>physical_block_size</p>
<p>设备可以运行的最小的内部单元</p>
</li>
<li><p>logical_block_size</p>
<p>用于外部寻址设备上的某个位置</p>
</li>
<li><p>alignment_offset</p>
<p>Linux块设备(partition/MD/LVM device)开始的字节数与基础物理对齐偏移量</p>
</li>
<li><p>minimum_io_size</p>
<p>该设备的首选最小单位为随机I/O</p>
</li>
<li><p>optimal_io_size</p>
<p>该设备的流式 I/O的首选单位</p>
</li>
</ul>
<p>例如，某些4K扇区设备可能会在<code>physical_block_size</code>内部使用4K，但会<code>logical_block_size</code>向Linux发布更细粒度的512字节。这种差异引起了I/O错位的可能性。为了解决这个问题，红帽企业Linux 7 I/O堆栈将尝试启动自然对齐的边界上的所有数据区域（<code>physical_block_size</code>），如果块设备的开始偏离底层物理，确保它占到任何alignment_offset对准。</p>
<p>存储供应商还可以提供有关设备的随机 *I/O 和流 I/O (<code>minimum_io_size</code>) 的首选最小单位的 I/O (<code>optimal_io_size</code>) . 例如, <code>minimum_io_size</code> 和 <code>optimal_io_size</code> 可能分别对应于RAID设备的块大小和条带大小.</p>
<h2 id="用户空间访问"><a href="#用户空间访问" class="headerlink" title="用户空间访问"></a>用户空间访问</h2><p>始终注意使用正确对齐和大小的I/O。这对于直接I/O访问尤为重要。直接I/O应该在一个<code>logical_block_size</code>边界上对齐，并在多个边界上对齐<code>logical_block_size</code>。</p>
<p>对于原生4K设备（即<code>logical_block_size</code>是4K），应用程序执行多个设备的直接I/O现在至关重要<code>logical_block_size</code>。这意味着应用程序将会失败，原生4k设备执行512字节对齐的I/O而不是4k对齐的I/O。</p>
<p>为避免这种情况，应用程序应该查询设备的I/O参数，以确保使用正确的I/O对齐和大小。如前所述，I/O参数通过两个<code>sysfs</code>和块设备<code>ioctl</code>接口公开。</p>
<p>有关更多详细信息，请参阅<code>man libblkid</code>。该<code>man</code>页面由<code>libblkid-devel</code>软件包提供。</p>
<h3 id="sysfs-Interface"><a href="#sysfs-Interface" class="headerlink" title="sysfs Interface"></a>sysfs Interface</h3><ul>
<li><p>/sys/block/<em><code>disk</code></em>/alignment_offset</p>
<p>或者</p>
<p>/sys/block/<em><code>disk</code></em><code>/</code><em><code>partition</code></em> /alignment_offset</p>
<p>​</p>
<p>文件位置取决于磁盘是物理磁盘（是本地磁盘，本地RAID还是多路径LUN）还是虚拟磁盘。第一个文件位置适用于物理磁盘，而第二个文件位置适用于虚拟磁盘。这是因为virtio-blk将始终报告分区的对齐值。物理磁盘可能会或可能不会报告对齐值。</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/physical_block_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/logical_block_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/minimum_io_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/optimal_io_size</p>
</li>
</ul>
<p>内核仍将<code>sysfs</code>为不提供I / O参数信息的“传统”设备导出这些属性，例如：</p>
<p><strong>sysfs Interface</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alignment_offset:    0</span><br><span class="line">physical_block_size: 512</span><br><span class="line">logical_block_size:  512</span><br><span class="line">minimum_io_size:     512</span><br><span class="line">optimal_io_size:     0</span><br></pre></td></tr></table></figure>
<h2 id="Block-Device-ioctls块设备ioctls"><a href="#Block-Device-ioctls块设备ioctls" class="headerlink" title="Block Device ioctls块设备ioctls"></a>Block Device ioctls块设备ioctls</h2><ul>
<li><code>BLKALIGNOFF</code>: <code>alignment_offset</code></li>
<li><code>BLKPBSZGET</code>: <code>physical_block_size</code></li>
<li><code>BLKSSZGET</code>: <code>logical_block_size</code></li>
<li><code>BLKIOMIN</code>: <code>minimum_io_size</code></li>
<li><code>BLKIOOPT</code>: <code>optimal_io_size</code></li>
</ul>
<h2 id="I-O标准"><a href="#I-O标准" class="headerlink" title="I/O标准"></a>I/O标准</h2><p>本节介绍ATA和SCSI设备使用的I/O标准。</p>
<h3 id="ATA"><a href="#ATA" class="headerlink" title="ATA"></a>ATA</h3><p>ATA设备必须通过<code>IDENTIFY DEVICE</code>命令报告适当的信息。ATA设备只报告I / O参数<code>physical_block_size</code>，<code>logical_block_size</code>和<code>alignment_offset</code>。额外的I / O提示超出了ATA命令集的范围。</p>
<h3 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h3><p>红帽企业版Linux 7中的I / O参数支持至少需要<em>版本3</em>的<em>SCSI主命令</em>（SPC-3）协议。内核只会发送一个<em>扩展查询</em>（可以访问该<code>BLOCK LIMITS VPD</code>页面），并<code>READ CAPACITY(16)</code>命令那些声称符合SPC-3的设备。</p>
<p>该<code>READ CAPACITY(16)</code>命令提供块大小和对齐偏移：</p>
<ul>
<li><code>LOGICAL BLOCK LENGTH IN BYTES</code> 被用来派生 <code>/sys/block/*disk*/queue/physical_block_size</code></li>
<li><code>LOGICAL BLOCKS PER PHYSICAL BLOCK EXPONENT</code> 被用来派生 <code>/sys/block/*disk*/queue/logical_block_size</code></li>
<li><code>LOWEST ALIGNED LOGICAL BLOCK ADDRESS</code> 用来派生：<ul>
<li><code>/sys/block/*disk*/alignment_offset</code></li>
<li><code>/sys/block/*disk*/*partition*/alignment_offset</code></li>
</ul>
</li>
</ul>
<p>该<code>BLOCK LIMITS VPD</code>页面（<code>0xb0</code>）提供了I/O提示。它也使用<code>OPTIMAL TRANSFER LENGTH GRANULARITY</code>并<code>OPTIMAL TRANSFER LENGTH</code>导出：</p>
<ul>
<li><code>/sys/block/*disk*/queue/minimum_io_size</code></li>
<li><code>/sys/block/*disk*/queue/optimal_io_size</code></li>
</ul>
<p>该<code>sg3_utils</code>软件包提供了<code>sg_inq</code>可用于访问该<code>BLOCK LIMITS VPD</code>页面的实用程序。为此，请运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sg_inq -p 0xb0 disk</span></span><br></pre></td></tr></table></figure>
<h2 id="堆叠I-O参数"><a href="#堆叠I-O参数" class="headerlink" title="堆叠I/O参数"></a>堆叠I/O参数</h2><p>Linux I/O堆栈的所有层都被设计为将各种I/O参数传播到堆栈中。当一个图层消耗一个属性或聚合很多设备时，该图层必须公开适当的I/O参数，以便上层设备或工具在转换后可以准确查看存储。一些实际的例子是：</p>
<ul>
<li>I/O堆栈中只有一层应该调整为非零值<code>alignment_offset</code>; 一旦相应地调整一层，它将输出一个<code>alignment_offset</code>零的设备。</li>
<li>使用LVM创建的条纹设备映射（DM）设备必须导出<code>minimum_io_size</code>并<code>optimal_io_size</code>相对于所述条纹计数（盘数）和用户提供的块大小。</li>
</ul>
<p>在红帽企业版Linux 7中，Device Mapper和Software Raid（MD）设备驱动程序可以用来任意组合具有不同I / O参数的设备。内核的块层将尝试合理地组合各个设备的I / O参数。内核不会阻止组合异构设备; 但是，请注意与此相关的风险。</p>
<p>例如，一个512字节的设备和一个4K设备可以组合成一个逻辑DM设备，其具有<code>logical_block_size</code>4K的。分布在这种混合设备上的文件系统假设4K将被原子写入，但实际上，当发送到512字节的设备时，它将跨越8个逻辑块地址。<code>logical_block_size</code>如果系统崩溃，则使用4K 更高级DM设备可能会增加对512字节设备的部分写入的可能性。</p>
<p>如果组合多个设备的I/O参数导致冲突，则块层可以发出设备容易受到部分写入和/或未对准的警告。</p>
<h2 id="逻辑卷管理器"><a href="#逻辑卷管理器" class="headerlink" title="逻辑卷管理器"></a>逻辑卷管理器</h2><p>LVM提供用于管理内核DM设备的用户空间工具。LVM将移动数据区的开始（给定的DM设备将使用）来说明<code>alignment_offset</code>与由LVM管理的任何设备相关的非零值。这意味着逻辑卷将正确对齐（<code>alignment_offset=0</code>）。</p>
<p>默认情况下，LVM将调整为任何<code>alignment_offset</code>，但是可以通过设置<code>data_alignment_offset_detection</code>为<code>0</code>in 来禁用此行为<code>/etc/lvm/lvm.conf</code>。不建议禁用此功能。</p>
<p>LVM还将检测设备的I/O提示。设备数据区域的开始将是sysfs中的一个倍数<code>minimum_io_size</code>或<code>optimal_io_size</code>暴露的数量。LVM将使用<code>minimum_io_size</code>if <code>optimal_io_size</code>是未定义的（即<code>0</code>）。</p>
<p>默认情况下，LVM将自动确定这些I/O提示，但是可以通过设置<code>data_alignment_detection</code>为<code>0</code>in 来禁用此行为<code>/etc/lvm/lvm.conf</code>。不建议禁用此功能。</p>
<h2 id="分区和文件系统工具"><a href="#分区和文件系统工具" class="headerlink" title="分区和文件系统工具"></a>分区和文件系统工具</h2><p>本节介绍不同的分区和文件系统管理工具如何与设备的I/O参数进行交互。</p>
<h3 id="util-linux-ng的libblkid和fdisk"><a href="#util-linux-ng的libblkid和fdisk" class="headerlink" title="util-linux-ng的libblkid和fdisk"></a>util-linux-ng的libblkid和fdisk</h3><p>在<code>libblkid</code>设置有库<code>util-linux-ng</code>包包括一个编程API来访问设备的I/O参数。<code>libblkid</code>允许应用程序（尤其是使用Direct I/O的应用程序）正确调整I/O请求的大小。在<code>fdisk</code>从公用<code>util-linux-ng</code>的用途<code>libblkid</code>来确定用于所有分区的最佳放置的设备的I/O参数。该<code>fdisk</code>实用程序将对齐1MB边界上的所有分区。</p>
<h2 id="分开和libparted"><a href="#分开和libparted" class="headerlink" title="分开和libparted"></a>分开和libparted</h2><p>该<code>libparted</code>库<code>parted</code>也使用I/O参数API <code>libblkid</code>。红帽企业Linux 7安装程序（<strong>Anaconda</strong>）使用<code>libparted</code>，这意味着由安装程序创建的所有分区或<code>parted</code>将被正确对齐。对于似乎不提供I/O参数的设备上创建的所有分区，默认对齐将为1MB。</p>
<p>启发式<code>parted</code>使用如下：</p>
<ul>
<li><p>始终使用报告<code>alignment_offset</code>作为第一个主分区启动的偏移量。</p>
</li>
<li><p>如果<code>optimal_io_size</code>定义（即不是<code>0</code>），则对齐<code>optimal_io_size</code>边界上的所有分区。</p>
</li>
<li><p>如果<code>optimal_io_size</code>是未定义的（即<code>0</code>），<code>alignment_offset</code>是<code>0</code>和<code>minimum_io_size</code>是2的幂，使用默认1MB对准。</p>
<p>对于那些看似不提供I / O提示的“传统”设备来说，这是最好的办法。因此，默认情况下，所有分区将在1MB边界上对齐。</p>
<hr>
<p>红帽企业版Linux 7无法区分不提供I/O提示的设备，以及使用<code>alignment_offset=0</code>和提供此功能的设备<code>optimal_io_size=0</code>。这样的设备可能是一个单一的SAS 4K设备; 因此，在磁盘启动时，最坏的情况是1MB的空间丢失。</p>
</li>
</ul>
<h3 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h3><p>不同的 <code>mkfs.*filesystem*</code>实用程序也被增强以消耗设备的I/O参数. 这些实用程序将不允许将文件系统格式化为使用<code>logical_block_size</code>小于底层存储设备的块大小 </p>
<p>除了 <code>mkfs.gfs2</code>, 所有 <code>mkfs.*filesystem*</code> 实用程序还使用  I/O 提示布局相对于<code>minimum_io_size</code> 磁盘上的数据结构和数据区<code>optimal_io_size</code> 和底层存储设备 ,这使得文件系统可以针对各种RAID（条纹）布局进行最佳格式化。</p>
<h1 id="远程无盘系统"><a href="#远程无盘系统" class="headerlink" title="远程无盘系统"></a>远程无盘系统</h1><p>要设置通过PXE引导的基本远程无盘系统，需要以下软件包：</p>
<ul>
<li><p><code>tftp-server</code></p>
</li>
<li><p><code>xinetd</code></p>
</li>
<li><p><code>dhcp</code></p>
</li>
<li><p><code>syslinux</code></p>
</li>
<li><p><code>dracut-network</code></p>
<p><strong>注意</strong></p>
<p>安装<code>dracut-network</code>包后，将以下行添加到<code>/etc/dracut.conf</code>：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_dracutmodules+=<span class="string">"nfs"</span></span><br></pre></td></tr></table></figure>
<p>远程无盘系统启动需要<code>tftp</code>服务（由提供<code>tftp-server</code>）和DHCP服务（由提供<code>dhcp</code>）。该<code>tftp</code>服务用于<code>initrd</code>通过PXE加载程序检索内核映像并通过网络进行检索。</p>
<p>SELinux仅支持NFSv4.2。要使用SELinux，必须<code>/etc/sysconfig/nfs</code>通过添加以下行来显式启用NFS ：</p>
<p><code>RPCNFSDARGS=&quot;-V 4.2&quot;</code></p>
<p>然后,在<code>/var/lib/tftpboot/pxelinux.cfg/default</code>, 更改 <code>root=nfs:server-ip:/exported/root/directory</code>为 <code>root=nfs:server-ip:/exported/root/directory,vers=4.2</code>.</p>
<p>最后，重新启动NFS服务器。</p>
<p>以下各节概述了在网络环境中部署远程无盘系统的必要步骤。</p>
<p>些RPM软件包已经开始使用文件功能（比如<code>setcap</code>和<code>getcap</code>）。但是，NFS目前不支持这些，所以试图安装或更新任何使用文件功能的软件包将会失败。</p>
<h2 id="为无盘客户机配置tftp服务"><a href="#为无盘客户机配置tftp服务" class="headerlink" title="为无盘客户机配置tftp服务"></a>为无盘客户机配置tftp服务</h2><p>该<code>tftp</code>服务默认是禁用的。要启用它并允许通过网络启动PXE，请将该<code>Disabled</code>选项设置<code>/etc/xinetd.d/tftp</code>为<code>no</code>。要进行配置<code>tftp</code>，请执行以下步骤：</p>
<p><strong>配置<code>tftp</code></strong></p>
<ol>
<li><p><code>tftp</code>根目录 (<code>chroot</code>) 位于 <code>/var/lib/tftpboot</code>. 复制 <code>/usr/share/syslinux/pxelinux.0</code>到<code>/var/lib/tftpboot/</code>, 例如:</p>
<p><code>cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</code></p>
</li>
<li><p>在tftp根目录下创建目录 <code>pxelinux.cfg</code> :</p>
<p><code>mkdir -p /var/lib/tftpboot/pxelinux.cfg/</code></p>
</li>
</ol>
<p>还需要正确配置防火墙规则以允许<code>tftp</code>通信; 作为<code>tftp</code>对TCP封装器的支持，你可以配置主机对<code>tftp</code>via的访问<code>/etc/hosts.allow</code></p>
<h2 id="为无盘客户机配置DHCP"><a href="#为无盘客户机配置DHCP" class="headerlink" title="为无盘客户机配置DHCP"></a>为无盘客户机配置DHCP</h2><p>配置好<code>tftp</code>服务器后，需要在同一台主机上设置DHCP服务。有关如何设置DHCP服务器的说明，请参阅“Red Hat Enterprise Linux 7 <em>部署指南”</em>。另外，您应该在DHCP服务器上启用PXE引导; 为此，请将以下配置添加到<code>/etc/dhcp/dhcp.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">class <span class="string">"pxeclients"</span> &#123;</span><br><span class="line">   match <span class="keyword">if</span> substring(option vendor-class-identifier, 0, 9) = <span class="string">"PXEClient"</span>;</span><br><span class="line">   next-server server-ip;</span><br><span class="line">   filename <span class="string">"pxelinux.0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换<code>*server-ip*</code>为<code>tftp</code>DHCP服务所在主机的IP地址。现在，<code>tftp</code>配置了DHCP，剩下的就是配置NFS和导出的文件系统。</p>
<h2 id="为无盘客户机配置导出的文件系统"><a href="#为无盘客户机配置导出的文件系统" class="headerlink" title="为无盘客户机配置导出的文件系统"></a>为无盘客户机配置导出的文件系统</h2><p>导出文件系统的根目录（由网络中的无盘客户机使用）通过NFS共享。配置NFS服务以将其添加到根目录<code>/etc/exports</code></p>
<p>为了适应完全无盘的客户端，根目录应该包含完整的红帽企业Linux安装。您可以通过以下方式将其与正在运行的系统<code>rsync</code>同步：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃rsync -a -e ssh --exclude =<span class="string">'/ proc / *'</span>--exclude =<span class="string">'/ sys / *'</span> hostname.com：/ / exported / root / directory</span><br></pre></td></tr></table></figure>
<p>替换为要<em><code>hostname.com</code></em>与之同步的正在运行的系统的主机名<code>rsync</code>。<em><code>/exported/root/directory</code></em>是导出文件系统的路径。</p>
<p>另外，您还可以使用<code>yum</code>与<code>--installroot</code>选项来安装Red Hat Enterprise Linux的特定位置。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall Base --installroot=/exported/root/directory --releasever=/</span><br></pre></td></tr></table></figure>
<p>要导出的文件系统在无盘客户机可以使用之前，仍然需要进一步配置。为此，请执行以下步骤：</p>
<p><strong>配置文件系统</strong></p>
<ol>
<li>配置导出的文件系统<code>/etc/fstab</code>包含（至少）以下配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">none		/tmp		tmpfs	defaults	0 0</span><br><span class="line">tmpfs		/dev/shm	tmpfs	defaults	0 0</span><br><span class="line">sysfs		/sys		sysfs	defaults	0 0</span><br><span class="line">proc		/proc		proc 	defaults	0 0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>选择无盘客户机应该使用的内核 (<code>vmlinuz-*kernel-version*</code>) 并将其复制到</p>
<p><code>tftp</code>启动目录:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cp /boot/vmlinuz-kernel-version /var/lib/tftpboot/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建 <code>initrd</code> (即, <code>initramfs-kernel-version.img</code>) 与网络支持:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dracut initramfs-kernel-version.img kernel-version</span></span><br></pre></td></tr></table></figure>
<ol>
<li>initrd的文件权限需要更改为600或<code>pxelinux.0</code>引导加载程序将失败，并出现“文件未找到”错误。使用以下命令执行此操作:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod go-r initramfs-kernel-version.img</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>将结果复制到引导目录中<code>initramfs-kernel-version.img到</code> tftp启动目录.</p>
</li>
<li><p>编辑默认的启动配置以使用<code>initrd</code>里面的内核<code>/var/lib/tftpboot</code>。此配置应该指示无盘客户机的root用户将导出的文件系统（<code>/exported/root/directory</code>）挂载为读写。为此，请<code>/var/lib/tftpboot/pxelinux.cfg/default</code>使用以下配置：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default rhel7</span><br><span class="line"></span><br><span class="line">label rhel7</span><br><span class="line">  kernel vmlinuz-kernel-version</span><br><span class="line">  append initrd=initramfs-kernel-version.img root=nfs:server-ip:/exported/root/directory rw</span><br></pre></td></tr></table></figure>
<p>   替换 <code>server-ip</code> 为<code>tftp</code> and DHCP 服务器地址.</p>
<p>NFS共享现在已准备好导出到无盘客户端。这些客户端可以通过PXE通过网络启动。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Goooo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/" title="Linux存储管理">https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/Storage/" rel="tag"># Storage</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/12/10/Linux/storage/filesystem/" rel="prev" title="Linux文件系统管理">
      <i class="fa fa-chevron-left"></i> Linux文件系统管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/01/24/Linux/storage/OnlineStorage/" rel="next" title="Linux网络存储管理">
      Linux网络存储管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#安装期间的存储注意事项"><span class="nav-number">1.</span> <span class="nav-text">安装期间的存储注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#特别注意事项"><span class="nav-number">1.1.</span> <span class="nav-text">特别注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单独分区为-home-opt-usr-local"><span class="nav-number">1.1.1.</span> <span class="nav-text">单独分区为 &#x2F;home, &#x2F;opt, &#x2F;usr&#x2F;local</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IBM-System-Z-上的-DASD和zFCP设备"><span class="nav-number">1.1.2.</span> <span class="nav-text">IBM System Z 上的 DASD和zFCP设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用LUKS加密块设备"><span class="nav-number">1.1.3.</span> <span class="nav-text">使用LUKS加密块设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#陈旧的BIOS-RAID元数据"><span class="nav-number">1.1.4.</span> <span class="nav-text">陈旧的BIOS RAID元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iSCSI检测和配置"><span class="nav-number">1.1.5.</span> <span class="nav-text">iSCSI检测和配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FCoE检测和配置"><span class="nav-number">1.1.6.</span> <span class="nav-text">FCoE检测和配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DASD"><span class="nav-number">1.1.7.</span> <span class="nav-text">DASD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块设备启用DIF-DIX"><span class="nav-number">1.1.8.</span> <span class="nav-text">块设备启用DIF&#x2F;DIX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统检查"><span class="nav-number">2.</span> <span class="nav-text">文件系统检查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fsck最佳实践"><span class="nav-number">2.1.</span> <span class="nav-text">fsck最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FSCK的文件系统特定信息"><span class="nav-number">2.2.</span> <span class="nav-text">FSCK的文件系统特定信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ext2-ext3-和-ext4"><span class="nav-number">2.2.1.</span> <span class="nav-text">ext2, ext3, 和 ext4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XFS"><span class="nav-number">2.2.2.</span> <span class="nav-text">XFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Btrfs"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">Btrfs</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分区"><span class="nav-number">3.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在正在使用的设备上操作分区"><span class="nav-number">3.1.</span> <span class="nav-text">在正在使用的设备上操作分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改分区表"><span class="nav-number">3.2.</span> <span class="nav-text">修改分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看分区表"><span class="nav-number">3.3.</span> <span class="nav-text">查看分区表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建分区"><span class="nav-number">3.4.</span> <span class="nav-text">创建分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化和标记分区"><span class="nav-number">3.4.2.</span> <span class="nav-text">格式化和标记分区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#添加-etc-fstab"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">添加&#x2F;etc&#x2F;fstab</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除分区"><span class="nav-number">3.5.</span> <span class="nav-text">删除分区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#parted-dev-sda"><span class="nav-number">4.</span> <span class="nav-text">parted &#x2F;dev&#x2F;sda</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#设置分区类型"><span class="nav-number">4.1.</span> <span class="nav-text">设置分区类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用FDISK调整分区大小"><span class="nav-number">4.2.</span> <span class="nav-text">使用FDISK调整分区大小</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用快照程序创建和维护快照"><span class="nav-number">5.</span> <span class="nav-text">使用快照程序创建和维护快照</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建初始快照程序配置"><span class="nav-number">5.1.</span> <span class="nav-text">创建初始快照程序配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建快照程序快照"><span class="nav-number">5.2.</span> <span class="nav-text">创建快照程序快照</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建前置和后置快照对"><span class="nav-number">5.2.1.</span> <span class="nav-text">创建前置和后置快照对</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Snapper创建前期快照"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">使用Snapper创建前期快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Snapper创建帖子快照"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">使用Snapper创建帖子快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在快照前后包装一个命令"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">在快照前后包装一个命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建单个快照程序快照"><span class="nav-number">5.2.2.</span> <span class="nav-text">创建单个快照程序快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#配置快照程序以获取自动快照"><span class="nav-number">5.2.3.</span> <span class="nav-text">配置快照程序以获取自动快照</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跟踪SNAPPER快照之间的更改"><span class="nav-number">5.3.</span> <span class="nav-text">跟踪SNAPPER快照之间的更改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#比较变更与status命令"><span class="nav-number">5.3.1.</span> <span class="nav-text">比较变更与status命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较变更与diff命令"><span class="nav-number">5.3.2.</span> <span class="nav-text">比较变更与diff命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较变更与xadiff命令"><span class="nav-number">5.3.3.</span> <span class="nav-text">比较变更与xadiff命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反转快照之间的更改"><span class="nav-number">5.4.</span> <span class="nav-text">反转快照之间的更改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除快照程序快照"><span class="nav-number">5.5.</span> <span class="nav-text">删除快照程序快照</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交换空间"><span class="nav-number">6.</span> <span class="nav-text">交换空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加交换空间"><span class="nav-number">6.1.</span> <span class="nav-text">添加交换空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在LVM2逻辑卷上扩展交换"><span class="nav-number">6.1.1.</span> <span class="nav-text">在LVM2逻辑卷上扩展交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为交换创建一个LVM2逻辑卷"><span class="nav-number">6.1.2.</span> <span class="nav-text">为交换创建一个LVM2逻辑卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个交换文件"><span class="nav-number">6.1.3.</span> <span class="nav-text">创建一个交换文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除交换空间"><span class="nav-number">6.2.</span> <span class="nav-text">删除交换空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减少LVM2逻辑卷上的交换"><span class="nav-number">6.2.1.</span> <span class="nav-text">减少LVM2逻辑卷上的交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除交换的LVM2逻辑卷"><span class="nav-number">6.2.2.</span> <span class="nav-text">删除交换的LVM2逻辑卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除交换文件"><span class="nav-number">6.2.3.</span> <span class="nav-text">删除交换文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动交换空间"><span class="nav-number">6.3.</span> <span class="nav-text">移动交换空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSM后端"><span class="nav-number">6.4.</span> <span class="nav-text">SSM后端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Btrfs后端"><span class="nav-number">6.4.1.</span> <span class="nav-text">Btrfs后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Btrfs池"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">Btrfs池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Btrfs卷"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">Btrfs卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Btrfs快照"><span class="nav-number">6.4.1.3.</span> <span class="nav-text">Btrfs快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Btrfs设备"><span class="nav-number">6.4.1.4.</span> <span class="nav-text">Btrfs设备</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVM后端"><span class="nav-number">6.4.2.</span> <span class="nav-text">LVM后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LVM池"><span class="nav-number">6.4.2.1.</span> <span class="nav-text">LVM池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVM卷"><span class="nav-number">6.4.2.2.</span> <span class="nav-text">LVM卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVM快照"><span class="nav-number">6.4.2.3.</span> <span class="nav-text">LVM快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVM设备"><span class="nav-number">6.4.2.4.</span> <span class="nav-text">LVM设备</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Crypt-后端"><span class="nav-number">6.4.3.</span> <span class="nav-text">Crypt 后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#地穴容积"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">地穴容积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Crypt-快照"><span class="nav-number">6.4.3.2.</span> <span class="nav-text">Crypt 快照</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个设备（MD）后端"><span class="nav-number">6.4.4.</span> <span class="nav-text">多个设备（MD）后端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的SSM任务"><span class="nav-number">6.5.</span> <span class="nav-text">常见的SSM任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-SSM"><span class="nav-number">6.5.1.</span> <span class="nav-text">安装 SSM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示有关所有检测到的设备的信息"><span class="nav-number">6.5.2.</span> <span class="nav-text">显示有关所有检测到的设备的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建新池，逻辑卷和文件系统"><span class="nav-number">6.5.3.</span> <span class="nav-text">创建新池，逻辑卷和文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查文件系统的一致性"><span class="nav-number">6.5.3.1.</span> <span class="nav-text">检查文件系统的一致性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加卷的大小"><span class="nav-number">6.5.4.</span> <span class="nav-text">增加卷的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快照"><span class="nav-number">6.5.5.</span> <span class="nav-text">快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除一个项目"><span class="nav-number">6.5.6.</span> <span class="nav-text">删除一个项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#磁盘配额"><span class="nav-number">7.</span> <span class="nav-text">磁盘配额</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置磁盘配额"><span class="nav-number">7.1.</span> <span class="nav-text">配置磁盘配额</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用配额"><span class="nav-number">7.1.1.</span> <span class="nav-text">启用配额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重新挂载文件系统"><span class="nav-number">7.1.2.</span> <span class="nav-text">重新挂载文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建配额数据库文件"><span class="nav-number">7.1.3.</span> <span class="nav-text">创建配额数据库文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为每个用户分配配额"><span class="nav-number">7.1.4.</span> <span class="nav-text">为每个用户分配配额</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为每组分配配额"><span class="nav-number">7.2.</span> <span class="nav-text">为每组分配配额</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设置软极限的宽限期"><span class="nav-number">7.2.1.</span> <span class="nav-text">设置软极限的宽限期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理磁盘配额"><span class="nav-number">7.3.</span> <span class="nav-text">管理磁盘配额</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启用和禁用"><span class="nav-number">7.3.1.</span> <span class="nav-text">启用和禁用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#报告磁盘配额"><span class="nav-number">7.3.2.</span> <span class="nav-text">报告磁盘配额</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保持配额准确"><span class="nav-number">7.3.3.</span> <span class="nav-text">保持配额准确</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘配额参考"><span class="nav-number">7.4.</span> <span class="nav-text">磁盘配额参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#独立磁盘冗余阵列（RAID）"><span class="nav-number">8.</span> <span class="nav-text">独立磁盘冗余阵列（RAID）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RAID类型"><span class="nav-number">8.1.</span> <span class="nav-text">RAID类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#固件RAID"><span class="nav-number">8.1.1.</span> <span class="nav-text">固件RAID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件RAID"><span class="nav-number">8.1.2.</span> <span class="nav-text">硬件RAID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件RAID"><span class="nav-number">8.1.3.</span> <span class="nav-text">软件RAID</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RAID级别和线性支持"><span class="nav-number">8.2.</span> <span class="nav-text">RAID级别和线性支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LINUX-RAID子系统"><span class="nav-number">8.3.</span> <span class="nav-text">LINUX RAID子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux硬件RAID控制器驱动程序"><span class="nav-number">8.3.1.</span> <span class="nav-text">Linux硬件RAID控制器驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mdraid"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">mdraid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dmraid的"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">dmraid的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ANACONDA安装程序中的RAID支持"><span class="nav-number">8.4.</span> <span class="nav-text">ANACONDA安装程序中的RAID支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装后将根磁盘转换为RAID1"><span class="nav-number">8.5.</span> <span class="nav-text">安装后将根磁盘转换为RAID1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置RAID集"><span class="nav-number">8.6.</span> <span class="nav-text">配置RAID集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mdadm的"><span class="nav-number">8.7.</span> <span class="nav-text">mdadm的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dmraid的-1"><span class="nav-number">8.8.</span> <span class="nav-text">dmraid的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建高级RAID设备"><span class="nav-number">8.9.</span> <span class="nav-text">创建高级RAID设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用MOUNT命令"><span class="nav-number">8.10.</span> <span class="nav-text">使用MOUNT命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#列出当前已安装的文件系统"><span class="nav-number">8.10.1.</span> <span class="nav-text">列出当前已安装的文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定文件系统类型"><span class="nav-number">8.10.2.</span> <span class="nav-text">指定文件系统类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂载文件系统"><span class="nav-number">8.10.3.</span> <span class="nav-text">挂载文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指定文件系统类型-1"><span class="nav-number">8.10.3.1.</span> <span class="nav-text">指定文件系统类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定挂载选项"><span class="nav-number">8.10.4.</span> <span class="nav-text">指定挂载选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享挂载"><span class="nav-number">8.10.5.</span> <span class="nav-text">共享挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动一个挂载点"><span class="nav-number">8.10.6.</span> <span class="nav-text">移动一个挂载点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置只读权限root"><span class="nav-number">8.10.7.</span> <span class="nav-text">设置只读权限root</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#配置root为在引导时使用只读权限进行挂载"><span class="nav-number">8.10.7.1.</span> <span class="nav-text">配置root为在引导时使用只读权限进行挂载</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#root立即重新挂载"><span class="nav-number">8.10.8.</span> <span class="nav-text">root立即重新挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保留写权限的文件和目录"><span class="nav-number">8.10.9.</span> <span class="nav-text">保留写权限的文件和目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卸载文件系统"><span class="nav-number">8.11.</span> <span class="nav-text">卸载文件系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VOLUME-KEY函数"><span class="nav-number">9.</span> <span class="nav-text">VOLUME_KEY函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#volume-key-命令"><span class="nav-number">9.1.</span> <span class="nav-text">volume_key&#96; 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用VOLUME-KEY作为个人用户"><span class="nav-number">9.2.</span> <span class="nav-text">使用VOLUME_KEY作为个人用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在较大的组织中使用VOLUME-KEY"><span class="nav-number">9.3.</span> <span class="nav-text">在较大的组织中使用VOLUME_KEY</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备保存加密密钥"><span class="nav-number">9.3.1.</span> <span class="nav-text">准备保存加密密钥</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#保存加密密钥"><span class="nav-number">9.3.1.1.</span> <span class="nav-text">保存加密密钥</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#恢复对卷的访问"><span class="nav-number">9.3.2.</span> <span class="nav-text">恢复对卷的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置紧急密码"><span class="nav-number">9.3.3.</span> <span class="nav-text">设置紧急密码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#固态硬盘部署指南"><span class="nav-number">10.</span> <span class="nav-text">固态硬盘部署指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#部署注意事项"><span class="nav-number">10.1.</span> <span class="nav-text">部署注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#写障碍"><span class="nav-number">11.</span> <span class="nav-text">写障碍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#写障碍的重要性"><span class="nav-number">11.1.</span> <span class="nav-text">写障碍的重要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何写障碍的工作"><span class="nav-number">11.2.</span> <span class="nav-text">如何写障碍的工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启用-禁用写障碍"><span class="nav-number">11.3.</span> <span class="nav-text">启用&#x2F;禁用写障碍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写入障碍注意事项"><span class="nav-number">11.4.</span> <span class="nav-text">写入障碍注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#禁用写入缓存"><span class="nav-number">11.4.1.</span> <span class="nav-text">禁用写入缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电池支持的写入缓存"><span class="nav-number">11.4.2.</span> <span class="nav-text">电池支持的写入缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高端数组"><span class="nav-number">11.4.3.</span> <span class="nav-text">高端数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NFS"><span class="nav-number">11.4.4.</span> <span class="nav-text">NFS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储I-O对齐和大小"><span class="nav-number">12.</span> <span class="nav-text">存储I&#x2F;O对齐和大小</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储访问参数"><span class="nav-number">12.1.</span> <span class="nav-text">存储访问参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户空间访问"><span class="nav-number">12.2.</span> <span class="nav-text">用户空间访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sysfs-Interface"><span class="nav-number">12.2.1.</span> <span class="nav-text">sysfs Interface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Block-Device-ioctls块设备ioctls"><span class="nav-number">12.3.</span> <span class="nav-text">Block Device ioctls块设备ioctls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O标准"><span class="nav-number">12.4.</span> <span class="nav-text">I&#x2F;O标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ATA"><span class="nav-number">12.4.1.</span> <span class="nav-text">ATA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCSI"><span class="nav-number">12.4.2.</span> <span class="nav-text">SCSI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆叠I-O参数"><span class="nav-number">12.5.</span> <span class="nav-text">堆叠I&#x2F;O参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑卷管理器"><span class="nav-number">12.6.</span> <span class="nav-text">逻辑卷管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区和文件系统工具"><span class="nav-number">12.7.</span> <span class="nav-text">分区和文件系统工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#util-linux-ng的libblkid和fdisk"><span class="nav-number">12.7.1.</span> <span class="nav-text">util-linux-ng的libblkid和fdisk</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分开和libparted"><span class="nav-number">12.8.</span> <span class="nav-text">分开和libparted</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统工具"><span class="nav-number">12.8.1.</span> <span class="nav-text">文件系统工具</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#远程无盘系统"><span class="nav-number">13.</span> <span class="nav-text">远程无盘系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为无盘客户机配置tftp服务"><span class="nav-number">13.1.</span> <span class="nav-text">为无盘客户机配置tftp服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为无盘客户机配置DHCP"><span class="nav-number">13.2.</span> <span class="nav-text">为无盘客户机配置DHCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为无盘客户机配置导出的文件系统"><span class="nav-number">13.3.</span> <span class="nav-text">为无盘客户机配置导出的文件系统</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Goooo"
      src="/images/img.png">
  <p class="site-author-name" itemprop="name">Goooo</p>
  <div class="site-description" itemprop="description">真正的粉丝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xth0331" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xth0331" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xietianhao0331@gmail.com" title="E-Mail → mailto:xietianhao0331@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
        
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
            <h3 class="widget-title">标签们</h3>
            <div id="myCanvasContainer" class="widget tagcloud">
                <canvas width="250" height="250" id="resCanvas" style="width=100%">
                    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/" rel="tag">Ansible</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backup/" rel="tag">Backup</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bond/" rel="tag">Bond</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU/" rel="tag">CPU</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ceph/" rel="tag">Ceph</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cobbler/" rel="tag">Cobbler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coffee/" rel="tag">Coffee</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Corosync/" rel="tag">Corosync</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cyclic-invariant/" rel="tag">Cyclic invariant</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effectiveness/" rel="tag">Effectiveness</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exhaustion/" rel="tag">Exhaustion</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Filesystem/" rel="tag">Filesystem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HAProxy/" rel="tag">HAProxy</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hardware/" rel="tag">Hardware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Https/" rel="tag">Https</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICMP/" rel="tag">ICMP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/" rel="tag">Jenkins</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JunOS/" rel="tag">JunOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KEEPALIVED/" rel="tag">KEEPALIVED</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keepalived/" rel="tag">Keepalived</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log/" rel="tag">Log</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modular-Programming/" rel="tag">Modular Programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monitoring/" rel="tag">Monitoring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netconf/" rel="tag">Netconf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Networking/" rel="tag">Networking</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenStack/" rel="tag">OpenStack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Package-Manager/" rel="tag">Package Manager</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Partition/" rel="tag">Partition</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming/" rel="tag">Programming</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAM/" rel="tag">RAM</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RHCS/" rel="tag">RHCS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPM/" rel="tag">RPM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recursion/" rel="tag">Recursion</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recursive/" rel="tag">Recursive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redirect/" rel="tag">Redirect</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Route/" rel="tag">Route</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage/" rel="tag">Storage</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage-and-Filesystem/" rel="tag">Storage and Filesystem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swap/" rel="tag">Swap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sys/" rel="tag">Sys</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Systemd/" rel="tag">Systemd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terminal/" rel="tag">Terminal</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/" rel="tag">Tools</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Veeam/" rel="tag">Veeam</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtualization/" rel="tag">Virtualization</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vmware/" rel="tag">Vmware</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vsphere/" rel="tag">Vsphere</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yum/" rel="tag">Yum</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apple/" rel="tag">apple</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iteration/" rel="tag">iteration</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logs/" rel="tag">logs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oop/" rel="tag">oop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" rel="tag">数据压缩</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%84%99%E8%A7%86%E9%93%BE/" rel="tag">鄙视链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4/" rel="tag">重复数据删除</a><span class="tag-list-count">1</span></li></ul>
                </canvas>
            </div>
        </div>
        
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goooo</span>
</div>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://www-sysctl-me-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.sysctl.me/2017/12/30/Linux/storage/LocalStorage/";
    this.page.identifier = "2017/12/30/Linux/storage/LocalStorage/";
    this.page.title = "Linux存储管理";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://www-sysctl-me-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":300,"height":600},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>
