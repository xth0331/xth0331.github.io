<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.sysctl.me').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":320,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="用法docker build命令Dockerfile根据上下文构建image。构建的上下文是指定位置PATH或的文件URL。这PATH是本地文件系统上的目录。URL是一个Git存储库位置。 递归处理上下文。因此，a PATH包括所有子目录，URL包括存储库及其子模块。此示例显示了使用当前目录作为上下文的构建命令：">
<meta property="og:type" content="article">
<meta property="og:title" content="Dockerfile参考">
<meta property="og:url" content="https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/index.html">
<meta property="og:site_name" content="Sysctl">
<meta property="og:description" content="用法docker build命令Dockerfile根据上下文构建image。构建的上下文是指定位置PATH或的文件URL。这PATH是本地文件系统上的目录。URL是一个Git存储库位置。 递归处理上下文。因此，a PATH包括所有子目录，URL包括存储库及其子模块。此示例显示了使用当前目录作为上下文的构建命令：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-09-16T01:20:00.000Z">
<meta property="article:modified_time" content="2020-01-22T14:33:05.214Z">
<meta property="article:author" content="Goooo">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Dockerfile参考 | Sysctl</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Sysctl" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sysctl</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Too young, too simple. Sometimes, naive & stupid</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xth0331" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/img.png">
      <meta itemprop="name" content="Goooo">
      <meta itemprop="description" content="真正的粉丝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sysctl">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Dockerfile参考
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-16 09:20:00" itemprop="dateCreated datePublished" datetime="2018-09-16T09:20:00+08:00">2018-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-22 22:33:05" itemprop="dateModified" datetime="2020-01-22T22:33:05+08:00">2020-01-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Container/" itemprop="url" rel="index">
                    <span itemprop="name">Container</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/09/16/Linux/container/docker/Dockerfile/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/16/Linux/container/docker/Dockerfile/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><code>docker build</code>命令<code>Dockerfile</code>根据<em>上下文</em>构建image。构建的上下文是指定位置<code>PATH</code>或的文件<code>URL</code>。这<code>PATH</code>是本地文件系统上的目录。<code>URL</code>是一个Git存储库位置。</p>
<p>递归处理上下文。因此，a <code>PATH</code>包括所有子目录，<code>URL</code>包括存储库及其子模块。此示例显示了使用当前目录作为上下文的构建命令：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>构建由Docker守护程序运行，而不是由CLI运行。构建过程的第一件事是将整个上下文（递归地）发送到守护进程。在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保存在该目录中。仅添加构建Dockerfile所需的文件。</p>
<blockquote>
<p><strong>警告</strong>：不要用你的根目录下，<code>/</code>作为<code>PATH</code>因为它会导致生成到您的硬盘驱动器的全部内容传输到docker守护进程。</p>
</blockquote>
<p>要在构建上下文中使用文件，请<code>Dockerfile</code>引用指令中指定的文件，例如<code>COPY</code>指令。要提高构建的性能，请通过向<code>.dockerignore</code>上下文目录添加文件来排除文件和目录。</p>
<p>它<code>Dockerfile</code>被调用<code>Dockerfile</code>并位于上下文的根中。您可以使用<code>-f</code>标志<code>docker build</code>指向文件系统中任何位置的Dockerfile。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<p>如果构建成功，您可以指定存储库和标记以保存新image：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure>
<p>要在构建后将映像标记为多个存储库，请在<code>-t</code>运行<code>build</code>命令时添加多个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure>
<p>在Docker守护程序运行其中的指令之前<code>Dockerfile</code>，它会执行初步验证<code>Dockerfile</code>并在语法不正确时返回错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span>/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<p>Docker守护程序<code>Dockerfile</code>逐个运行指令，在必要时将每条指令的结果提交给新image，最后输出新image的ID。Docker守护程序将自动清理您发送的上下文。</p>
<p>请注意，每条指令都是独立运行的，会导致创建新image - 因此<code>RUN cd /tmp</code>不会对下一条指令产生任何影响。</p>
<p>只要有可能，Docker将重新使用中间image（缓存），以<code>docker build</code>显着加速该过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER xxx@xxx.xx</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed <span class="string">'s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/'</span> &amp;&amp; <span class="built_in">echo</span> <span class="built_in">wait</span>) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>
<p>构建缓存仅用于具有本地父链的。这意味着这些image是由以前的版本创建的，或者加载了整个image链<code>docker load</code>。如果您希望使用特定image的构建缓存，可以使用<code>--cache-from</code>选项指定它。指定的image <code>--cache-from</code>不需要具有父链，可以从其他注册表中提取。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>这是以下格式<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>
<p><em>该指令不区分大小写。但是，惯例是让它们成为大写的，以便更容易地将它们与参数区分开来。</em></p>
<p>Docker <code>Dockerfile</code>按顺序运行指令。一个<code>Dockerfile</code> <strong>必须用<code>FROM</code>指令启动</strong>。该<code>FROM</code>指令指定您正在构建的<em>Baseimage</em>。<code>FROM</code>可以仅由一个或多个前面<code>ARG</code>的指令，其声明了在使用的参数<code>FROM</code>中的行<code>Dockerfile</code>。</p>
<p>Docker 将以条目<em>开头的</em>行<code>#</code>视为注释，除非该行是有效的<code>parser-directives</code>。<code>#</code>行中任何其他位置的标记都被视为参数。这允许这样的陈述：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'we are running some # of cool things'</span></span></span><br></pre></td></tr></table></figure>
<p>注释中不支持行继续符。</p>
<h1 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h1><p>解析器指令是可选的，并且影响<code>Dockerfile</code>处理a 中后续行的方式。解析器指令不会向构建添加图层，也不会显示为构建步骤。解析器指令在表单中被写为特殊类型的注释<code># directive=value</code>。单个指令只能使用一次。</p>
<p>一旦处理了注释，空行或构建器指令，Docker就不再查找解析器指令。相反，它将格式化为解析器指令的任何内容视为注释，并且不会尝试验证它是否可能是解析器指令。因此，所有解析器指令必须位于a的顶部<code>Dockerfile</code>。</p>
<p>解析器器指令不区分大小写。但是，惯例是它们是小写的。约定还包括任何解析器指令后面的空行。解析器指令不支持行继续符。</p>
<p>由于这些规则，以下示例均无效：</p>
<p>由于行继续而无效：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># direc \</span></span><br><span class="line">tive=value</span><br></pre></td></tr></table></figure>
<p>由于出现两次无效：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directive=value1</span></span><br><span class="line"><span class="comment"># directive=value2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>由于在构建器指令后出现而被视为注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ImageName</span><br><span class="line"><span class="comment"># directive=value</span></span><br></pre></td></tr></table></figure>
<p>由于在不是解析器指令的注释之后出现而被视为注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># About my dockerfile</span></span><br><span class="line"><span class="comment"># directive=value</span></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>由于未被识别，未知指令被视为注释。此外，由于出现在不是解析器指令的注释之后，已知指令被视为注释。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unknowndirective=value</span></span><br><span class="line"><span class="comment"># knowndirective=value</span></span><br></pre></td></tr></table></figure>
<p>解析器指令中允许使用非换行空格。因此，以下几行都是相同的：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#directive=value</span></span><br><span class="line"><span class="comment"># directive =value</span></span><br><span class="line"><span class="comment">#	directive= value</span></span><br><span class="line"><span class="comment"># directive = value</span></span><br><span class="line"><span class="comment">#	  dIrEcTiVe=value</span></span><br></pre></td></tr></table></figure>
<p>支持以下解析器指令：</p>
<ul>
<li><code>escape</code></li>
</ul>
<h1 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=\ (backslash)</span></span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=` (backtick)</span></span><br></pre></td></tr></table></figure>
<p><code>escape</code>指令设置用于转义字符的字符 <code>Dockerfile</code>。如果未指定，则默认转义字符为<code>\</code>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> testfile.txt c:\\</span></span><br><span class="line"><span class="bash">RUN dir c:\</span></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t cmd .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;2 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;2 : COPY testfile.txt c:\RUN dir c:</span><br><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>
<p>上面的一个解决方案是<code>/</code>用作<code>COPY</code> 指令的目标，和<code>dir</code>。但是，这种语法充其量是令人困惑的，因为对于路径来说并不自然<code>Windows</code>，并且最坏的情况是容易出错，因为并非所有命令都 作为路径分隔符<code>Windows</code>支持<code>/</code>。</p>
<p>通过添加<code>escape</code>解析器指令，以下<code>Dockerfile</code>成功使用文件路径的自然平台语义<code>Windows</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> testfile.txt c:\</span></span><br><span class="line"><span class="bash">RUN dir c:\</span></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache&#x3D;true .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;3 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;3 : COPY testfile.txt c:\</span><br><span class="line"> ---&gt; 96655de338de</span><br><span class="line">Removing intermediate container 4db9acbb1682</span><br><span class="line">Step 3&#x2F;3 : RUN dir c:\</span><br><span class="line"> ---&gt; Running in a2c157f842f5</span><br><span class="line"> Volume in drive C has no label.</span><br><span class="line"> Volume Serial Number is 7E6D-E0F7</span><br><span class="line"></span><br><span class="line"> Directory of c:\</span><br><span class="line"></span><br><span class="line">10&#x2F;05&#x2F;2016  05:04 PM             1,894 License.txt</span><br><span class="line">10&#x2F;05&#x2F;2016  02:22 PM    &lt;DIR&gt;          Program Files</span><br><span class="line">10&#x2F;05&#x2F;2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">10&#x2F;28&#x2F;2016  11:18 AM                62 testfile.txt</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Users</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Windows</span><br><span class="line">           2 File(s)          1,956 bytes</span><br><span class="line">           4 Dir(s)  21,259,096,064 bytes free</span><br><span class="line"> ---&gt; 01c7f3bef04f</span><br><span class="line">Removing intermediate container a2c157f842f5</span><br><span class="line">Successfully built 01c7f3bef04f</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Environment-replacement"><a href="#Environment-replacement" class="headerlink" title="Environment replacement"></a>Environment replacement</h1><p>环境变量（声明的<code>ENV</code>），也可以在特定指令作为变量用来被解释 <code>Dockerfile</code>。还会处理转义，以便将类似变量的语法包含在字面上。</p>
<p>环境变量<code>Dockerfile</code>用 <code>$variable_name</code>or表示<code>${variable_name}</code>。它们被等效地处理，并且括号语法通常用于解决具有没有空格的变量名称的问题，例如<code>${foo}_bar</code>。</p>
<p>该<code>${variable_name}</code>语法还支持一些标准的<code>bash</code> 修饰如下规定：</p>
<ul>
<li><code>${variable:-word}</code>表示如果<code>variable</code>设置后，结果将是该值。如果<code>variable</code>未设置则结果将是<code>word</code>。</li>
<li><code>${variable:+word}</code>表示如果<code>variable</code>设置，那么<code>word</code>将是结果，否则结果是空字符串。</li>
</ul>
<p>在所有情况下，<code>word</code>可以是任何字符串，包括其他环境变量。</p>
<p>通过<code>\</code>在变量之前添加来实现转义：<code>\$foo</code>或者<code>\${foo}</code>，例如，将分别转换为<code>$foo</code>和<code>${foo}</code>文本。</p>
<p>示例（解析后的表示显示在<code>#</code>）之后：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENV</span> foo /bar</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;foo&#125;</span>   <span class="comment"># WORKDIR /bar</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . <span class="variable">$foo</span>       <span class="comment"># ADD . /bar</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> \<span class="variable">$foo</span> /quux <span class="comment"># COPY $foo /quux</span></span></span><br></pre></td></tr></table></figure>
<p>以下指令列表支持环境变量<code>Dockerfile</code>：</p>
<ul>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENV</code></li>
<li><code>EXPOSE</code></li>
<li><code>FROM</code></li>
<li><code>LABEL</code></li>
<li><code>STOPSIGNAL</code></li>
<li><code>USER</code></li>
<li><code>VOLUME</code></li>
<li><code>WORKDIR</code></li>
</ul>
<p>以及：</p>
<ul>
<li><code>ONBUILD</code> （当与上面支持的指令之一结合使用时）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在1.4之前，<code>ONBUILD</code>指令<strong>不</strong>支持环境变量，即使与上面列出的任何指令结合使用也是如此。</p>
</blockquote>
<p>环境变量替换将在整个指令中对每个变量使用相同的值。换句话说，在这个例子中：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc</span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc</span><br></pre></td></tr></table></figure>
<p>将导致<code>def</code>具有值<code>hello</code>，而不是<code>bye</code>。但是， <code>ghi</code>将具有值，<code>bye</code>因为它不是设置<code>abc</code>为的相同指令的一部分<code>bye</code>。</p>
<h1 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h1><p>在docker CLI将上下文发送到docker守护程序之前，它会查找<code>.dockerignore</code>在上下文的根目录中指定的文件。如果此文件存在，CLI将修改上下文以排除与其中的模式匹配的文件和目录。这有助于避免不必要地将大型或敏感文件和目录发送到守护程序，并可能使用<code>ADD</code>或将它们添加到映像中<code>COPY</code>。</p>
<p>CLI将<code>.dockerignore</code>文件解释为新行分隔的模式列表，类似于Unix shell的文件globs。出于匹配的目的，上下文的根被认为是工作目录和根目录。例如，模式 <code>/foo/bar</code>和<code>foo/bar</code>两者都排除<code>bar</code> 在位于的git存储库的<code>foo</code>子目录<code>PATH</code>或根目录中命名的文件或目录<code>URL</code>。两者都不包括任何其他内容。</p>
<p>如果<code>.dockerignore</code>文件中的行以第<code>#</code>1列开头，则此行被视为注释，并在CLI解释之前被忽略。</p>
<p>这是一个示例<code>.dockerignore</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># comment</span></span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>
<p>此文件导致以下构建行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>规则</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code># comment</code></td>
<td>忽略。</td>
</tr>
<tr>
<td><code>*/temp*</code></td>
<td>排除名称以<code>temp</code>根目录的任何直接子目录开头的文件和目录。例如，<code>/somedir/temporary.txt</code>排除普通文件，目录也是如此<code>/somedir/temp</code>。</td>
</tr>
<tr>
<td><code>*/*/temp*</code></td>
<td>排除<code>temp</code>从根目录下两级开始的任何子目录开始的文件和目录。例如，<code>/somedir/subdir/temporary.txt</code>被排除在外。</td>
</tr>
<tr>
<td><code>temp?</code></td>
<td>排除根目录中的文件和目录，其名称是单字符扩展名<code>temp</code>。例如，<code>/tempa</code>与<code>/tempb</code>被排除在外。</td>
</tr>
</tbody>
</table>
</div>
<p>匹配是使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成的。预处理步骤去除了开头和结尾的空白，并消除<code>.</code>与<code>..</code>使用Go的元素 <a href="http://golang.org/pkg/path/filepath/#Clean" target="_blank" rel="noopener">filepath.Clean</a>。预处理后为空的行将被忽略。</p>
<p>除了Go的filepath.Match规则，Docker还支持一个<code>**</code>匹配任意数量目录（包括零）的特殊通配符字符串。例如，<code>**/*.go</code>将排除<code>.go</code> 在所有目录中找到的以该结尾的所有文件，包括构建上下文的根。</p>
<p>以<code>!</code>（感叹号）开头的行可用于对排除项进行例外处理。以下是<code>.dockerignore</code>使用此机制的示例文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure>
<p><em>除</em> <code>README.md</code>上下文<em>外</em>，所有降价文件<em>除外</em>。</p>
<p><code>!</code>异常规则的放置会影响行为：<code>.dockerignore</code>匹配特定文件的最后一行确定是包含还是排除。请考虑以下示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README*.md</span><br><span class="line">README-secret.md</span><br></pre></td></tr></table></figure>
<p>除了以外的README文件，上下文中不包含markdown文件 <code>README-secret.md</code>。</p>
<p>现在考虑这个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">README-secret.md</span><br><span class="line">!README*.md</span><br></pre></td></tr></table></figure>
<p>包含所有README文件。中间线没有效果，因为 <code>!README*.md</code>匹配<code>README-secret.md</code>并且最后。</p>
<p>您甚至可以使用<code>.dockerignore</code>文件来排除<code>Dockerfile</code> 和<code>.dockerignore</code>文件。这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。但是<code>ADD</code>和<code>COPY</code>指令不会将它们复制到image中。</p>
<p>最后，您可能希望指定要包含在上下文中的文件，而不是要排除的文件。要实现此目的，请指定<code>*</code>第一个模式，然后指定一个或多个<code>!</code>异常模式。</p>
<p><strong>注意</strong>：由于历史原因，将<code>.</code>忽略该模式。</p>
<h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt; [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>该<code>FROM</code>指令初始化新的构建阶段并为后续指令设置<em>Baseimage</em>。因此，有效<code>Dockerfile</code>必须以<code>FROM</code>指令开始。image可以是任何有效image - 通过从<em>dockerrepos</em>提取<em>image</em>来启动它尤其容易。</p>
<ul>
<li><code>ARG</code>是先于仅指示<code>FROM</code>在<code>Dockerfile</code>。</li>
<li><code>FROM</code>可以在单个内容中多次出现<code>Dockerfile</code>以创建多个image，或者使用一个构建阶段作为另一个构建阶段的依赖项。只需在每条新<code>FROM</code>指令之前记下提交输出的最后一个imageID 。每条<code>FROM</code>指令都清除先前指令创建的任何状态。</li>
<li>可选地，可以通过添加<code>AS name</code>到<code>FROM</code>指令来将 名称赋予新的构建阶段。该名称可用于后续<code>FROM</code>和 <code>COPY --from=&lt;name|index&gt;</code>指令，以引用此阶段构建的image。</li>
<li>该<code>tag</code>或<code>digest</code>值是可选的。如果省略其中任何一个，则构建器默认采用<code>latest</code>标记。如果找不到<code>tag</code>值，构建器将返回错误。</li>
</ul>
<h2 id="了解ARG和FROM如何交互"><a href="#了解ARG和FROM如何交互" class="headerlink" title="了解ARG和FROM如何交互"></a>了解ARG和FROM如何交互</h2><p><code>FROM</code>说明支持由<code>ARG</code> 第一个之前发生的任何指令声明的变量<code>FROM</code>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>
<p>在<code>ARG</code>生命之前，<code>FROM</code>是一个构建阶段之外，因此它不能在之后的任何指令使用<code>FROM</code>。要<code>ARG</code>在第一次<code>FROM</code>使用之前使用声明的默认值，请在<code>ARG</code>构建阶段内使用没有值的指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>
<h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p>RUN有两种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code>（<em>shell</em>表单，该命令在shell中运行，默认情况下<code>/bin/sh -c</code>在Linux或<code>cmd /S /C</code>Windows 上运行）</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>（<em>执行</em>形式）</li>
</ul>
<p>该<code>RUN</code>指令将在当前image之上的新层中执行任何命令并提交结果。生成的提交image将用于下一步<code>Dockerfile</code>。</p>
<p>分层<code>RUN</code>指令和生成提交符合Docker的核心概念，可以从image历史中的任何点创建容器，就像源代码控制一样。</p>
<p>在<em>EXEC</em>形式使得能够避免壳串改写（munging），<code>RUN</code> 使用不包含指定壳可执行基本image命令。</p>
<p>可以使用 <code>SHELL</code>命令更改<em>shell</em>表单的默认shell。</p>
<p>在<em>shell</em>形式中，您可以使用<code>\</code>（反斜杠）将单个RUN指令继续到下一行。例如，考虑以下两行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">'source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="variable">$HOME</span><span class="string">'</span></span></span><br></pre></td></tr></table></figure>
<p>它们一起相当于这一行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">'source $HOME/.bashrc; echo $HOME'</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：要使用除“/ bin / sh”之外的其他shell，请使用传入所需shell 的<em>exec</em>表单。例如，<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
<p><strong>注意</strong>：在<em>JSON</em>表单中，必须转义反斜杠。这在反斜杠是路径分隔符的Windows上尤为重要。由于不是有效的JSON，以下行将被视为<em>shell</em>表单，并以意外方式失败：<code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code> 此示例的正确语法是：<code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code></p>
</blockquote>
<p><code>RUN</code>在下一次构建期间，指令的缓存不会自动失效。类似指令的缓存<code>RUN apt-get dist-upgrade -y</code>将在下一次构建期间重用。例如，<code>RUN</code>可以通过使用<code>--no-cache</code> 标志使指令的高速缓存无效<code>docker build --no-cache</code>。</p>
<p><code>RUN</code>指令的高速缓存可以通过<code>ADD</code></p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>该<code>CMD</code>指令有三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>（<em>执行</em>形式，这是首选形式）</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>（作为<em>ENTRYPOINT的默认参数</em>）</li>
<li><code>CMD command param1 param2</code>（<em>贝壳</em>形式）</li>
</ul>
<p>a中只能有一条<code>CMD</code>指令<code>Dockerfile</code>。如果列出多个，<code>CMD</code> 则只有最后一个<code>CMD</code>生效。</p>
<p><strong>a的主要目的CMD是为执行容器提供默认值。</strong>这些默认值可以包含可执行文件，也可以省略可执行文件，在这种情况下，您还必须指定一条<code>ENTRYPOINT</code> 指令。</p>
<blockquote>
<p><strong>注意</strong>：如果<code>CMD</code>用于为<code>ENTRYPOINT</code> 指令提供默认参数，则应使用JSON数组格式指定<code>CMD</code>和<code>ENTRYPOINT</code>指令。</p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
</blockquote>
<p>在shell或exec格式中使用时，该<code>CMD</code>指令设置在运行映像时要执行的命令。</p>
<p>如果你使用的是<em>shell的</em>形式<code>CMD</code>，那么<code>&lt;command&gt;</code>将执行 <code>/bin/sh -c</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"This is a test."</span> | wc -</span></span><br></pre></td></tr></table></figure>
<p>如果要在 <code>&lt;command&gt;</code> 没有 <strong>shell</strong> 的情况下运行，则必须将该命令表示为JSON数组，并提供可执行文件的完整路径。 此数组形式是首选格式CMD。任何其他参数必须在数组中单独表示为字符串：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/bin/wc"</span>,<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果您希望容器每次都运行相同的可执行文件，那么您应该考虑<code>ENTRYPOINT</code>结合使用<code>CMD</code>。</p>
<p>如果用户指定了参数，<code>docker run</code>那么它们将覆盖指定的默认值<code>CMD</code>。</p>
<blockquote>
<p><strong>注意</strong>：不要混淆<code>RUN</code>使用<code>CMD</code>。<code>RUN</code>实际上运行一个命令并提交结果; <code>CMD</code>在构建时不执行任何操作，但指定image的预期命令。</p>
</blockquote>
<h1 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>
<p><code>LABEL</code>指令将元数据添加到image。 <code>LABEL</code>是键值对。要在<code>LABEL</code>值中包含空格，请使用引号和反斜杠，就像在命令行解析中一样。一些用法示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> <span class="string">"com.example.vendor"</span>=<span class="string">"ACME Incorporated"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.label-with-value=<span class="string">"foo"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"This text illustrates \</span></span></span><br><span class="line"><span class="bash">that label-values can span multiple lines.<span class="string">"</span></span></span><br></pre></td></tr></table></figure>
<p>image可以有多个标签。您可以在一行中指定多个标签。在Docker 1.10之前，这减小了最终image的大小，但现在不再是这种情况了。您仍然可以选择在单个指令中指定多个标签，方法有以下两种：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> multi.label2=<span class="string">"value2"</span> other=<span class="string">"value3"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> \</span></span><br><span class="line"><span class="bash">      multi.label2=<span class="string">"value2"</span> \</span></span><br><span class="line"><span class="bash">      other=<span class="string">"value3"</span></span></span><br></pre></td></tr></table></figure>
<p>基本或父image中包含的标签（<code>FROM</code>线中的image）由image继承。如果标签已存在但具有不同的值，则最近应用的值将覆盖任何先前设置的值。</p>
<p>要查看image的标签，请使用该<code>docker inspect</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;</span><br><span class="line">    &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span><br><span class="line">    &quot;multi.label1&quot;: &quot;value1&quot;,</span><br><span class="line">    &quot;multi.label2&quot;: &quot;value2&quot;,</span><br><span class="line">    &quot;other&quot;: &quot;value3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<p><code>EXPOSE</code>指令通知Docker容器在运行时侦听指定的网络端口。您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认为TCP。</p>
<p>该<code>EXPOSE</code>指令实际上没有发布端口。它作为构建映像的人和运行容器的人之间的一种文档，用于发布要发布的端口。要在运行容器时实际发布端口，请使用<code>-p</code>标志on <code>docker run</code> 来发布和映射一个或多个端口，或使用<code>-P</code>标志发布所有公开的端口并将它们映射到高阶端口。</p>
<p>默认情况下，<code>EXPOSE</code>假定为TCP。您还可以指定UDP：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>要在TCP和UDP上公开，请包含两行：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果使用<code>docker run</code> <code>-P</code> ，端口将为TCP暴露一次，对UDP则暴露一次。请记住，<code>-P</code>在主机上使用短暂的高阶主机端口，因此TCP和UDP的端口不同。</p>
<p>无论<code>EXPOSE</code>设置如何，您都可以使用<code>-p</code>标志在运行时覆盖它们。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure>
<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>该<code>ENV</code>指令将环境变量<code>&lt;key&gt;</code>设置为该值 <code>&lt;value&gt;</code>。此值将在构建阶段中所有后续指令的环境中。</p>
<p><code>ENV</code>指令有两种形式。第一种形式，<code>ENV &lt;key&gt; &lt;value&gt;</code>将一个变量设置为一个值。第一个空格后的整个字符串将被视为<code>&lt;value&gt;</code>- 包括空格字符。该值将针对其他环境变量进行解释，因此如果未对其进行转义，则将删除引号字符。</p>
<p>第二种形式<code>ENV &lt;key&gt;=&lt;value&gt; ...</code>允许一次设置多个变量。请注意，第二种形式在语法中使用等号（=），而第一种形式则不然。与命令行解析一样，引号和反斜杠可用于在值内包含空格。</p>
<p>例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName=<span class="string">"John Doe"</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br></pre></td></tr></table></figure>
<p>将在最终image中产生相同的结果。</p>
<p><code>ENV</code>当从生成的image运行容器时，使用的环境变量将保持不变。您可以使用<code>docker inspect</code>，查看值，并使用它们进行更改<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>。</p>
<blockquote>
<p><strong>注意</strong>：环境持久性可能会导致意外的副作用。例如，设置<code>ENV DEBIAN_FRONTEND noninteractive</code>可能会使基于Debian的image上的apt-get用户感到困惑。要为单个命令设置值，请使用 <code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>。</p>
</blockquote>
<h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><p>ADD有两种形式：</p>
<ul>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> （包含空格的路径需要此表单）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：该<code>--chown</code>功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用<code>/etc/passwd</code>和<code>/etc/group</code>将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
</blockquote>
<p>该<code>ADD</code>指令从中复制新文件，目录或远程文件URL <code>&lt;src&gt;</code> ，并将它们添加到路径上image的文件系统中<code>&lt;dest&gt;</code>。</p>
<p><code>&lt;src&gt;</code>可以指定多个资源，但如果它们是文件或目录，则它们的路径将被解释为相对于构建上下文的源。</p>
<p>每个都<code>&lt;src&gt;</code>可能包含通配符，匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/        <span class="comment"># adds all files starting with "hom"</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/    <span class="comment"># ? is replaced with any single character, e.g., "home.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>的<code>&lt;dest&gt;</code>是一个绝对路径，或相对于一个路径<code>WORKDIR</code>，到其中的源将在目标容器内进行复制。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> relativeDir/          <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> /absoluteDir/         <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure>
<p>添加包含特殊字符（例如<code>[</code> 和<code>]</code>）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。例如，要添加名为的文件<code>arr[0].txt</code>，请使用以下命令;</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> arr[[]0].txt /mydir/    <span class="comment"># copy a file named "arr[0].txt" to /mydir/</span></span></span><br></pre></td></tr></table></figure>
<p>除非可选<code>--chown</code>标志指定给定用户名，组名或UID / GID组合以请求所添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。<code>--chown</code>标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。如果提供了用户名或组名，则容器的根文件系统 <code>/etc/passwd</code>和<code>/etc/group</code>文件将分别用于执行从名称到整数UID或GID的转换。以下示例显示了该<code>--chown</code>标志的有效定义：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=bin files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=1 files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=10:11 files* /somedir/</span></span><br></pre></td></tr></table></figure>
<p>如果容器根文件系统不包含任何文件<code>/etc/passwd</code>或 <code>/etc/group</code>文件，并且<code>--chown</code> 标志中使用了用户名或组名，则构建将在<code>ADD</code>操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<p>在<code>&lt;src&gt;</code>远程文件URL 的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP<code>Last-Modified</code>标头，则来自该标头的时间戳将用于设置<code>mtime</code>目标文件。但是，与在处理期间处理的任何其他文件一样<code>ADD</code>，<code>mtime</code>将不包括在确定文件是否已更改且应更新缓存中。</p>
<blockquote>
<p><strong>注意</strong>：如果通过传递<code>Dockerfile</code>STDIN（<code>docker build - &lt; somefile</code>）进行构建，则没有构建上下文，因此<code>Dockerfile</code> 只能包含基于URL的<code>ADD</code>指令。您还可以通过STDIN :( <code>docker build - &lt; archive.tar.gz</code>）传递压缩存档<code>Dockerfile</code>，该存档位于存档的根目录，其余存档将用作构建的上下文。</p>
<p><strong>注意</strong>：如果您的网址文件都使用认证保护，您将需要使用<code>RUN wget</code>，<code>RUN curl</code>或使用其它工具从容器内的<code>ADD</code>指令不支持验证。</p>
<p><strong>注意</strong>：<code>ADD</code>如果内容<code>&lt;src&gt;</code>已更改，则第一个遇到的指令将使来自Dockerfile的所有后续指令的高速缓存无效。这包括使缓存无效以获取<code>RUN</code>指令。</p>
</blockquote>
<p><code>ADD</code> 遵守以下规则：</p>
<ul>
<li>该<code>&lt;src&gt;</code>路径必须是内部<em>语境</em>的构建; 你不能<code>ADD ../something /something</code>，因为a的第一步 <code>docker build</code>是将上下文目录（和子目录）发送到docker守护程序。</li>
<li>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>不以尾部斜杠结尾，则从URL下载文件并将其复制到<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>以尾部斜杠结尾，则从URL推断文件名并将文件下载到<code>&lt;dest&gt;/&lt;filename&gt;</code>。例如，<code>ADD http://example.com/foobar /</code>将创建该文件<code>/foobar</code>。URL必须具有非常重要的路径，以便在这种情况下可以发现适当的文件名（<code>http://example.com</code> 不起作用）。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li><p>如果<code>&lt;src&gt;</code>是以可识别的压缩格式（identity，gzip，bzip2或xz）的<em>本地</em> tar存档，则将其解压缩为目录。从资源<em>远程</em>网址<strong>不</strong>解压。复制或解压缩目录时，它具有与之相同的行为<code>tar -x</code>，结果是：</p>
<ol>
<li>无论在目的地路径上存在什么，</li>
<li>源树的内容，在逐个文件的基础上解决了有利于“2.”的冲突。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：文件是否被识别为可识别的压缩格式仅基于文件的内容而不是文件的名称来完成。例如，如果一个空文件碰巧结束，<code>.tar.gz</code>这将不会被识别为压缩文件，并且<strong>不会</strong>生成任何类型的解压缩错误消息，而是将文件简单地复制到目标。</p>
</blockquote>
</li>
<li><p>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠结尾<code>/</code>，则将其视为目录，<code>&lt;src&gt;</code>并将写入内容<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</p>
</li>
<li><p>如果<code>&lt;src&gt;</code>直接或由于使用通配符指定了多个资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</p>
</li>
<li><p>如果<code>&lt;dest&gt;</code>不以尾部斜杠结束，则将其视为常规文件，<code>&lt;src&gt;</code>并将写入其中的内容<code>&lt;dest&gt;</code>。</p>
</li>
<li><p>如果<code>&lt;dest&gt;</code>不存在，则会在其路径中创建所有缺少的目录。</p>
</li>
</ul>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>COPY有两种形式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> （包含空格的路径需要此表单）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：该<code>--chown</code>功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用<code>/etc/passwd</code>和<code>/etc/group</code>将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
</blockquote>
<p>该<code>COPY</code>指令从中复制新文件或目录<code>&lt;src&gt;</code> ，并将它们添加到路径中容器的文件系统中<code>&lt;dest&gt;</code>。</p>
<p><code>&lt;src&gt;</code>可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p>
<p>每个都<code>&lt;src&gt;</code>可能包含通配符，匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/        <span class="comment"># adds all files starting with "hom"</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/    <span class="comment"># ? is replaced with any single character, e.g., "home.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>的<code>&lt;dest&gt;</code>是一个绝对路径，或相对于一个路径<code>WORKDIR</code>，到其中的源将在目标容器内进行复制。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="built_in">test</span> relativeDir/   <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="built_in">test</span> /absoluteDir/  <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure>
<p>复制包含特殊字符（例如<code>[</code> 和<code>]</code>）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。例如，要复制名为的文件<code>arr[0].txt</code>，请使用以下命令;</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> arr[[]0].txt /mydir/    <span class="comment"># copy a file named "arr[0].txt" to /mydir/</span></span></span><br></pre></td></tr></table></figure>
<p>除非可选<code>--chown</code>标志指定给定用户名，组名或UID / GID组合以请求复制内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。<code>--chown</code>标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。如果提供了用户名或组名，则容器的根文件系统 <code>/etc/passwd</code>和<code>/etc/group</code>文件将分别用于执行从名称到整数UID或GID的转换。以下示例显示了该<code>--chown</code>标志的有效定义：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=55:mygroup files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=bin files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=1 files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /somedir/</span></span><br></pre></td></tr></table></figure>
<p>如果容器根文件系统不包含任何文件<code>/etc/passwd</code>或 <code>/etc/group</code>文件，并且<code>--chown</code> 标志中使用了用户名或组名，则构建将在<code>COPY</code>操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<blockquote>
<p><strong>注意</strong>：如果使用STDIN（<code>docker build - &lt; somefile</code>）构建，则没有构建上下文，因此<code>COPY</code>无法使用。</p>
</blockquote>
<p>（可选）<code>COPY</code>接受一个标志<code>--from=&lt;name|index&gt;</code>，该标志可用于将源位置设置为<code>FROM .. AS &lt;name&gt;</code>将用于替代用户发送的构建上下文的先前构建阶段（使用其创建）。该标志还接受为<code>FROM</code>指令启动的所有先前构建阶段分配的数字索引 。如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的image。</p>
<p><code>COPY</code> 遵守以下规则：</p>
<ul>
<li>该<code>&lt;src&gt;</code>路径必须是内部<em>语境</em>的构建; 你不能<code>COPY ../something /something</code>，因为a的第一步 <code>docker build</code>是将上下文目录（和子目录）发送到docker守护程序。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠结尾<code>/</code>，则将其视为目录，<code>&lt;src&gt;</code>并将写入内容<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li>如果<code>&lt;src&gt;</code>直接或由于使用通配符指定了多个资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不以尾部斜杠结束，则将其视为常规文件，<code>&lt;src&gt;</code>并将写入其中的内容<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，则会在其路径中创建所有缺少的目录。</li>
</ul>
<h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p>ENTRYPOINT有两种形式：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> （<em>exec</em>形式，首选）</li>
<li><code>ENTRYPOINT command param1 param2</code> （<em>shell</em>形式）</li>
</ul>
<p><code>ENTRYPOINT</code>允许您配置将作为可执行文件运行的容器。</p>
<p>例如，以下将使用其默认内容启动nginx，侦听端口80：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t --rm -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>命令行参数<code>docker run &lt;image&gt;</code>将附加在<em>exec</em>表单中的所有元素之后<code>ENTRYPOINT</code>，并将覆盖使用的所有指定元素<code>CMD</code>。这允许将参数传递给入口点，<code>docker run &lt;image&gt; -d</code> 即将<code>-d</code>参数传递给入口点。您可以<code>ENTRYPOINT</code>使用<code>docker run --entrypoint</code> 标志覆盖指令。</p>
<p>所述<em>shell</em>形式防止任何<code>CMD</code>或<code>run</code>被使用命令行参数，但是具有你的缺点<code>ENTRYPOINT</code>将被开始作为一个子命令<code>/bin/sh -c</code>，其不通过信号。这意味着可执行文件将不是容器<code>PID 1</code>- 并且不会收到Unix信号 - 因此您的可执行文件将不会收到 <code>SIGTERM</code>来自<code>docker stop &lt;container&gt;</code>。</p>
<p>只有意志中的最后一条<code>ENTRYPOINT</code>指令<code>Dockerfile</code>才有效。</p>
<h2 id="exec-ENTRYPOINT示例"><a href="#exec-ENTRYPOINT示例" class="headerlink" title="exec ENTRYPOINT示例"></a>exec ENTRYPOINT示例</h2><p>您可以使用<em>exec</em>形式<code>ENTRYPOINT</code>设置相当稳定的默认命令和参数，然后使用任一形式<code>CMD</code>设置更可能更改的其他默认值。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"-c"</span>]</span></span><br></pre></td></tr></table></figure>
<p>运行容器时，您可以看到这<code>top</code>是唯一的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name <span class="built_in">test</span>  top -H</span><br><span class="line">top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers</span><br><span class="line">KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top</span><br></pre></td></tr></table></figure>
<p>要进一步检查结果，您可以使用<code>docker exec</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H</span><br><span class="line">root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux</span><br></pre></td></tr></table></figure>
<p>并且您可以优雅地请求<code>docker stop test</code>来关闭<code>top</code>。</p>
<p>以下<code>Dockerfile</code>显示使用<code>ENTRYPOINT</code>在前台运行Apache（即as <code>PID 1</code>）：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stable</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/var/www"</span>, <span class="string">"/var/log/apache2"</span>, <span class="string">"/etc/apache2"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/sbin/apache2ctl"</span>, <span class="string">"-D"</span>, <span class="string">"FOREGROUND"</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果需要为单个可执行文件编写启动脚本，可以使用<code>exec</code>和<code>gosu</code> 命令确保最终的可执行文件接收Unix信号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>最后，如果您需要在关机时进行一些额外的清理（或与其他容器通信），或者协调多个可执行文件，您可能需要确保<code>ENTRYPOINT</code>脚本接收Unix信号，传递它们，然后执行一些更多的工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Note: I've written this using sh so it works in the busybox container too</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># USE the trap if you need to also do manual cleanup after the service is stopped,</span></span><br><span class="line"><span class="comment">#     or need to start multiple services in the one container</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo TRAPed signal"</span> HUP INT QUIT TERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># start service in background here</span></span><br><span class="line">/usr/sbin/apachectl start</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[hit enter key to exit] or run 'docker stop &lt;container&gt;'"</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop service and clean up here</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"stopping apache"</span></span><br><span class="line">/usr/sbin/apachectl stop</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exited <span class="variable">$0</span>"</span></span><br></pre></td></tr></table></figure>
<p>如果运行此映像<code>docker run -it --rm -p 80:80 --name test apache</code>，则可以使用<code>docker exec</code>，或检查容器的进程<code>docker top</code>，然后请求脚本停止Apache：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux</span><br><span class="line">$ docker top <span class="built_in">test</span></span><br><span class="line">PID                 USER                COMMAND</span><br><span class="line">10035               root                &#123;run.sh&#125; /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">10054               root                /usr/sbin/apache2 -k start</span><br><span class="line">10055               33                  /usr/sbin/apache2 -k start</span><br><span class="line">10056               33                  /usr/sbin/apache2 -k start</span><br><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 0.27s</span><br><span class="line">user	0m 0.03s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>您可以使用覆盖<code>ENTRYPOINT</code>设置<code>--entrypoint</code>，但这只能将二进制设置为<em>exec</em>（不会<code>sh -c</code>使用）。</p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
</blockquote>
<h2 id="Shell-ENTRYPOINT示例"><a href="#Shell-ENTRYPOINT示例" class="headerlink" title="Shell ENTRYPOINT示例"></a>Shell ENTRYPOINT示例</h2><p>您可以为<code>ENTRYPOINT</code>它指定一个纯字符串，它将在其中执行<code>/bin/sh -c</code>。此表单将使用shell处理来替换shell环境变量，并将忽略任何<code>CMD</code>或<code>docker run</code>命令行参数。为了确保能够正确地<code>docker stop</code>发出任何长时间运行的<code>ENTRYPOINT</code>可执行文件，您需要记住启动它<code>exec</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">exec</span> top -b</span></span><br></pre></td></tr></table></figure>
<p>运行此image时，您将看到单个<code>PID 1</code>进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name <span class="built_in">test</span> top</span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2/98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>
<p>哪个将彻底退出<code>docker stop</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 0.20s</span><br><span class="line">user	0m 0.02s</span><br><span class="line">sys	0m 0.04s</span><br></pre></td></tr></table></figure>
<p>如果您忘记添加<code>exec</code>到您的开头<code>ENTRYPOINT</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> top -b</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> --ignored-param1</span></span><br></pre></td></tr></table></figure>
<p>然后，您可以运行它（为下一步命名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name <span class="built_in">test</span> top --ignored-param2</span><br><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span><br><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.01 0.02 0.05 2/101 7</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7     1 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>
<p>您可以从输出中<code>top</code>看到指定<code>ENTRYPOINT</code>的不是<code>PID 1</code>。</p>
<p>如果然后运行<code>docker stop test</code>，容器将不会干净地退出 - <code>stop</code>命令将被强制<code>SIGKILL</code>在超时后发送：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">PID   USER     COMMAND</span><br><span class="line">    1 root     /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7 root     top -b</span><br><span class="line">    8 root     ps aux</span><br><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 10.19s</span><br><span class="line">user	0m 0.04s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>
<h2 id="了解CMD和ENTRYPOINT如何相互作用"><a href="#了解CMD和ENTRYPOINT如何相互作用" class="headerlink" title="了解CMD和ENTRYPOINT如何相互作用"></a>了解CMD和ENTRYPOINT如何相互作用</h2><p> <code>CMD</code>和<code>ENTRYPOINT</code>指定运行容器时执行的命令。很少有规则描述他们的合作。</p>
<ol>
<li>Dockerfile应至少指定一个<code>CMD</code>或<code>ENTRYPOINT</code>命令。</li>
<li><code>ENTRYPOINT</code> 应该在将容器用作可执行文件时定义。</li>
<li><code>CMD</code>应该用作定义<code>ENTRYPOINT</code>命令的默认参数或在容器中执行ad-hoc命令的方法。</li>
<li><code>CMD</code> 在使用替代参数运行容器时将被覆盖。</li>
</ol>
<p>下表显示了针对不同<code>ENTRYPOINT</code>/ <code>CMD</code>组合执行的命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>No ENTRYPOINT</th>
<th>ENTRYPOINT exec_entry p1_entry</th>
<th>ENTRYPOINT [“exec_entry”，“p1_entry”]</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>No CMD</strong></td>
<td><em>error，not allowed</em></td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr>
<td><strong>CMD [“exec_cmd”，“p1_cmd”]</strong></td>
<td>exec_cmd p1_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr>
<td><strong>CMD [“p1_cmd”，“p2_cmd”]</strong></td>
<td>p1_cmd p2_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr>
<td><strong>CMD exec_cmd p1_cmd</strong></td>
<td>/ bin / sh -c exec_cmd p1_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry / bin / sh -c exec_cmd p1_cmd</td>
</tr>
</tbody>
</table>
</div>
<h1 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>VOLUME</code>指令创建具有指定名称的安装点，并将其标记为从本机主机或其他容器保存外部安装的卷。该值可以是JSON数组，<code>VOLUME [&quot;/var/log/&quot;]</code>或具有多个参数的普通字符串，例如<code>VOLUME /var/log</code>或<code>VOLUME /var/log /var/db</code>。</p>
<p><code>docker run</code>命令使用基础映像中指定位置存在的任何数据初始化新创建的卷。例如，请考虑以下Dockerfile片段：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /myvol</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /myvol</span></span><br></pre></td></tr></table></figure>
<p>此Dockerfile会<code>docker run</code>生成一个image，该image将导致创建新的挂载点<code>/myvol</code>并将<code>greeting</code>文件复制到新创建的卷中。</p>
<h2 id="有关指定卷的说明"><a href="#有关指定卷的说明" class="headerlink" title="有关指定卷的说明"></a>有关指定卷的说明</h2><p>关于卷中的卷，请记住以下事项<code>Dockerfile</code>。</p>
<ul>
<li><strong>基于Windows的容器上的卷</strong>：使用基于Windows的容器时，容器中卷的目标必须是以下之一：<ul>
<li>不存在或空目录</li>
<li>除了之外的驱动器 <code>C:</code></li>
</ul>
</li>
<li><strong>从Dockerfile中更改卷</strong>：如果任何构建步骤在声明后<strong>更改卷内的</strong>数据，那么这些更改将被丢弃。</li>
<li><strong>JSON格式</strong>：列表被解析为JSON数组。您必须用双引号（<code>&quot;</code>）而不是单引号（<code>&#39;</code>）括起单词。</li>
<li><strong>主机目录在容器运行时声明</strong>：主机目录（mountpoint）本质上是依赖于主机的。这是为了保持image的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此，您无法从Dockerfile中安装主机目录。该<code>VOLUME</code>指令不支持指定<code>host-dir</code> 参数。您必须在创建或运行容器时指定安装点。</li>
</ul>
<h1 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;] or</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>
<p><code>USER</code>运行的image和用于当任何指令设置的用户名（或UID）和任选的所述用户组（或GID）使用<code>RUN</code>，<code>CMD</code>和 <code>ENTRYPOINT</code>它后面的指令<code>Dockerfile</code>。</p>
<blockquote>
<p><strong>警告</strong>：当用户没有主要组时，image（或下一个说明）将与该<code>root</code>组一起运行。</p>
<p>在Windows上，如果用户不是内置帐户，则必须先创建用户。这可以通过<code>net user</code>作为Dockerfile的一部分调用的命令来完成。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"><span class="comment"># Create Windows user in the container</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> net user /add patrick</span></span><br><span class="line"><span class="comment"># Set it for subsequent commands</span></span><br><span class="line"><span class="keyword">USER</span> patrick</span><br></pre></td></tr></table></figure>
<h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>
<p><code>WORKDIR</code>指令集的工作目录对任何<code>RUN</code>，<code>CMD</code>， <code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code>它后面的说明<code>Dockerfile</code>。如果<code>WORKDIR</code>不存在，即使它未在任何后续<code>Dockerfile</code>指令中使用，也将创建它。</p>
<p><code>WORKDIR</code>指令可以在a中多次使用<code>Dockerfile</code>。如果提供了相对路径，则它将相对于前一条<code>WORKDIR</code>指令的路径 。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p>最终<code>pwd</code>命令的输出<code>Dockerfile</code>将是 <code>/a/b/c</code>。</p>
<p><code>WORKDIR</code>指令可以解析先前使用的环境变量 <code>ENV</code>。您只能使用显式设置的环境变量<code>Dockerfile</code>。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p>最终<code>pwd</code>命令的输出<code>Dockerfile</code>将是 <code>/path/$DIRNAME</code></p>
<h1 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p><code>ARG</code>指令定义了一个变量，用户可以<code>docker build</code>使用该<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志在构建时将该变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure>
<p>Dockerfile可以包括一个或多个<code>ARG</code>指令。例如，以下是有效的Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1</span><br><span class="line"><span class="keyword">ARG</span> buildno</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告：</strong>建议不要使用构建时变量来传递密码，例如github密钥，用户凭据等<code>docker history</code>。使用该命令，构建时变量值对于映像的任何用户都是可见的。</p>
</blockquote>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>的<code>ARG</code>指令可以可选地包括一个默认值：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br><span class="line"><span class="keyword">ARG</span> buildno=<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果<code>ARG</code>指令具有默认值，并且在构建时没有传递值，则构建器将使用默认值。</p>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>一个<code>ARG</code>变量定义进入从在其上在限定的线效果<code>Dockerfile</code>不从参数对命令行或其他地方使用。例如，考虑这个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="number">2</span> <span class="keyword">USER</span> $&#123;<span class="keyword">user</span>:-some_user&#125;</span><br><span class="line"><span class="number">3</span> <span class="keyword">ARG</span> <span class="keyword">user</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">USER</span> $<span class="keyword">user</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>用户通过调用以下内容构建此文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --build-arg user=what_user .</span><br></pre></td></tr></table></figure>
<p>第2行计算<code>USER``some_user</code>为<code>user</code>变量在后续第3行定义。第4行<code>USER</code>计算结果<code>what_user</code>为<code>user</code>定义，并<code>what_user</code>在命令行上传递值。在通过<code>ARG</code>指令定义之前 ，对变量的任何使用都会导致空字符串。</p>
<p>一个<code>ARG</code>指令超出范围在它被定义的构建阶段结束。要在多个阶段中使用arg，每个阶段都必须包含该<code>ARG</code>指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> SETTINGS</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./run/setup <span class="variable">$SETTINGS</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> SETTINGS</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./run/other <span class="variable">$SETTINGS</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用ARG变量"><a href="#使用ARG变量" class="headerlink" title="使用ARG变量"></a>使用ARG变量</h2><p>您可以使用<code>ARG</code>或<code>ENV</code>指令指定指令可用的变量<code>RUN</code>。使用该<code>ENV</code>指令定义的环境变量 始终覆盖<code>ARG</code>同名指令。考虑这个Dockerfile和一个<code>ENV</code>和<code>ARG</code>指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER v1.<span class="number">0.0</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>然后，假设使用此命令构建此映像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --build-arg CONT_IMG_VER=v2.0.1 .</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>RUN</code>指令使用<code>v1.0.0</code>而不是<code>ARG</code>用户传递的设置：<code>v2.0.1</code>此行为类似于shell脚本，其中本地范围的变量覆盖作为参数传递的变量或从其定义的环境继承的变量。</p>
<p>使用上面的示例但不同的<code>ENV</code>规范，您可以在指令<code>ARG</code>和<code>ENV</code>指令之间创建更有用的交互：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.<span class="number">0.0</span>&#125;</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>与<code>ARG</code>指令不同，<code>ENV</code>值始终保留在构建的image中。考虑没有<code>--build-arg</code>标志的docker构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br></pre></td></tr></table></figure>
<p>使用此Dockerfile示例<code>CONT_IMG_VER</code>仍然保留在image中，但其值将是指令<code>v1.0.0</code>中第3行的默认值<code>ENV</code>。</p>
<h2 id="预定义的ARG"><a href="#预定义的ARG" class="headerlink" title="预定义的ARG"></a>预定义的ARG</h2><p>Docker有一组预定义<code>ARG</code>变量，您可以<code>ARG</code>在Dockerfile中使用相应的指令。</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<p>要使用它们，只需使用标志在命令行上传递它们：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--build-arg &lt;varname&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，这些预定义变量将从输出中排除 <code>docker history</code>。排除它们可以降低在<code>HTTP_PROXY</code>变量中意外泄露敏感验证信息的风险。</p>
<p>例如，考虑使用构建以下Dockerfile<code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>HTTP_PROXY</code>变量的值在<code>docker history</code>和中不可用， 并且不会被缓存。如果您要更改位置，并且您的代理服务器已更改为<code>http://user:pass@proxy.sfo.example.com</code>，则后续构建不会导致缓存未命中。</p>
<p>如果需要覆盖此行为，则可以通过<code>ARG</code> 在Dockerfile中添加语句来执行此操作，如下所示：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ARG</span> HTTP_PROXY</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure>
<p>构建此Dockerfile时，<code>HTTP_PROXY</code>会保留在其中 <code>docker history</code>，并且更改其值会使构建缓存无效。</p>
<h2 id="对构建缓存的影响"><a href="#对构建缓存的影响" class="headerlink" title="对构建缓存的影响"></a>对构建缓存的影响</h2><p><code>ARG</code>变量不会像<code>ENV</code>变量那样持久保存在构建的image中。但是，<code>ARG</code>变量确实以类似的方式影响构建缓存。如果Dockerfile定义了一个<code>ARG</code>值与前一个版本不同的变量，则在第一次使用时会发生“缓存未命中”，而不是其定义。特别是，<code>RUN</code>指令后面的所有指令都 隐式<code>ARG</code>使用<code>ARG</code>变量（作为环境变量），因此可能导致高速缓存未命中。<code>ARG</code>除非在中包含匹配的<code>ARG</code>语句，否则所有预定义变量都将免于缓存<code>Dockerfile</code>。</p>
<p>例如，考虑这两个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure>
<p>如果<code>--build-arg CONT_IMG_VER=&lt;value&gt;</code>在命令行中指定，则在两种情况下，第2行上的规范都不会导致高速缓存未命中; 第3行确实导致缓存未命中。<code>ARG CONT_IMG_VER</code>导致RUN行被识别为与运行<code>CONT_IMG_VER=&lt;value&gt;</code>echo hello 相同，因此如果<code>&lt;value&gt;</code> 更改，我们将获得缓存未命中。</p>
<p>考虑同一命令行下的另一个示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER $CONT_IMG_VER</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>在此示例中，高速缓存未命中发生在第3行。发生未命中是因为<code>ENV</code>引用<code>ARG</code>变量的变量值和通过命令行更改了该变量。在此示例中，该<code>ENV</code> 命令使image包含该值。</p>
<p>如果一条<code>ENV</code>指令覆盖了一个<code>ARG</code>同名的指令，比如这个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER hello</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>第3行不会导致缓存未命中，因为值为<code>CONT_IMG_VER</code>常量（<code>hello</code>）。因此，<code>RUN</code>（第4行）上使用的环境变量和值在构建之间不会发生变化。</p>
<h1 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<p>当image用作另一个构建的基础时，该<code>ONBUILD</code>指令向image添加将在稍后执行的<em>触发</em>指令。触发器将在下游构建的上下文中执行，就好像它已经<code>FROM</code>在下游指令之后立即插入一样<code>Dockerfile</code>。</p>
<p>任何构建指令都可以注册为触发器。</p>
<p>如果要构建将用作构建其他映像的基础的映像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。</p>
<p>例如，如果您的映像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要<em>在</em> 此<em>之后</em>调用构建脚本。你不能只是打电话<code>ADD</code>和<code>RUN</code>现在，因为你还没有访问应用程序的源代码，这将是为每个应用程序生成不同的。您可以简单地为应用程序开发人员提供<code>Dockerfile</code>复制粘贴到他们的应用程序中的样板，但这样做效率低，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。</p>
<p>解决方案是用于<code>ONBUILD</code>在下一个构建阶段注册预先指令以便稍后运行。</p>
<p>以下是它的工作原理：</p>
<ol>
<li>当遇到<code>ONBUILD</code>指令时，构建器会向正在构建的image的元数据添加触发器。该指令不会影响当前构建。</li>
<li>在构建结束时，所有触发器的列表存储在键下的image清单中<code>OnBuild</code>。可以使用该<code>docker inspect</code>命令检查它们。</li>
<li>稍后，可以使用该<code>FROM</code>指令将image用作新构建的基础 。作为处理<code>FROM</code>指令的一部分，下游构建器查找<code>ONBUILD</code>触发器，并按照它们注册的顺序执行它们。如果任何触发器失败，<code>FROM</code>则中止指令，这反过来导致构建失败。如果所有触发器都成功，则<code>FROM</code>指令完成并且构建继续照常进行。</li>
<li>执行后，触发器将从最终image中清除。换句话说，它们不是由“大孩子”构建继承的。</li>
</ol>
<p>例如，您可以添加以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong>：不允许<code>ONBUILD</code>使用链接指令<code>ONBUILD ONBUILD</code>。</p>
<p><strong>警告</strong>：<code>ONBUILD</code>指令可能不会触发<code>FROM</code>或<code>MAINTAINER</code>指令。</p>
</blockquote>
<h1 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br></pre></td></tr></table></figure>
<p>该<code>STOPSIGNAL</code>指令设置将发送到容器的系统调用信号以退出。此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，例如9，或SIGNAME格式的信号名，例如SIGKILL。</p>
<h1 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h1><p><code>HEALTHCHECK</code>指令有两种形式：</p>
<ul>
<li><code>HEALTHCHECK [OPTIONS] CMD command</code> （通过在容器内运行命令来检查容器运行状况）</li>
<li><code>HEALTHCHECK NONE</code> （禁用从基础映像继承的任何运行状况检查）</li>
</ul>
<p>该<code>HEALTHCHECK</code>指令告诉Docker如何测试容器以检查它是否仍在工作。即使服务器进程仍在运行，这也可以检测到陷入无限循环且无法处理新连接的Web服务器等情况。</p>
<p>当容器指定了<em>运行状况检查时</em>，除了正常状态外，它还具有<em>运行</em>状况。这个状态最初是<code>starting</code>。每当健康检查通过时，它就会变成<code>healthy</code>（以前的状态）。经过一定数量的连续失败后，它就变成了<code>unhealthy</code>。</p>
<p>之前可以出现的选项<code>CMD</code>是：</p>
<ul>
<li><code>--interval=DURATION</code>（默认值：<code>30s</code>）</li>
<li><code>--timeout=DURATION</code>（默认值：<code>30s</code>）</li>
<li><code>--start-period=DURATION</code>（默认值：<code>0s</code>）</li>
<li><code>--retries=N</code>（默认值：<code>3</code>）</li>
</ul>
<p>运行状况检查将首先在容器启动后的<strong>间隔</strong>秒运行，然后在每次上一次检查完成后再<strong>间隔</strong>秒。</p>
<p>如果单次运行的检查花费的时间超过<strong>超时</strong>秒数，那么检查将被视为失败。</p>
<p>它需要<strong>重试</strong>连续的健康检查失败才能考虑容器<code>unhealthy</code>。</p>
<p><strong>start period</strong>为需要时间引导的容器提供初始化时间。在此期间探测失败将不计入最大重试次数。但是，如果在启动期间运行状况检查成功，则会将容器视为已启动，并且所有连续失败将计入最大重试次数。</p>
<p><code>HEALTHCHECK</code>Dockerfile中只能有一条指令。如果列出多个，则只有最后一个<code>HEALTHCHECK</code>生效。</p>
<p><code>CMD</code>关键字后面的命令可以是shell命令（例如<code>HEALTHCHECK CMD /bin/check-running</code>）或<em>exec</em>数组（与其他Dockerfile命令一样; <code>ENTRYPOINT</code>有关详细信息，请参阅参考资料）。</p>
<p>命令的退出状态指示容器的运行状况。可能的值是：</p>
<ul>
<li>0：成功 - 容器健康且随时可用</li>
<li>1：不健康 - 容器无法正常工作</li>
<li>2：保留 - 不要使用此退出代码</li>
</ul>
<p>例如，要检查每五分钟左右网络服务器能够在三秒钟内为网站的主页面提供服务：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5m --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）将存储在运行状况中并可以使用查询 <code>docker inspect</code>。此类输出应保持较短（目前仅存储前4096个字节）。</p>
<p>当容器的运行状况更改时，将<code>health_status</code>生成具有新状态的事件。</p>
<p>该<code>HEALTHCHECK</code>功能已添加到Docker 1.12中。</p>
<h1 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"parameters"</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>指令允许覆盖用于<em>shell</em>形式的命令的默认shell 。Linux上的默认shell是<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>，而在Windows上<code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>。该<code>SHELL</code>指令<em>必须</em>以JSON格式写入Dockerfile。</p>
<p>的<code>SHELL</code>：其中有两个常用的和完全不同的原生贝壳指令是在Windows上特别有用<code>cmd</code>和<code>powershell</code>，以及提供包括候补炮弹<code>sh</code>。</p>
<p>该<code>SHELL</code>指令可以多次出现。每条<code>SHELL</code>指令都会覆盖所有先前的<code>SHELL</code>指令，并影响所有后续指令。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C powershell -command Write-Host default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> powershell -<span class="built_in">command</span> Write-Host default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as powershell -command Write-Host hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"powershell"</span>, <span class="string">"-command"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> Write-Host hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"cmd"</span>, <span class="string">"/S"</span>, <span class="string">"/C"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure>
<p>以下说明可以通过影响<code>SHELL</code>指令时， <em>壳</em>他们的形式在一个Dockerfile使用：<code>RUN</code>，<code>CMD</code>和<code>ENTRYPOINT</code>。</p>
<p>以下示例是在Windows上找到的常见模式，可以使用以下<code>SHELL</code>指令简化：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> powershell -<span class="built_in">command</span> Execute-MyCmdlet -param1 <span class="string">"c:\foo.txt"</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>docker调用的命令将是：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmd</span><span class="bash"> /S /C powershell -<span class="built_in">command</span> Execute-MyCmdlet -param1 <span class="string">"c:\foo.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>由于两个原因，这是低效的。首先，调用一个不必要的cmd.exe命令处理器（也就是shell）。其次，<em>shell</em> 形式的每条<code>RUN</code>指令都需要额外的命令前缀。<code>powershell -command</code></p>
<p>为了提高效率，可以采用两种机制中的一种。一种是使用RUN命令的JSON形式，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"powershell"</span>, <span class="string">"-command"</span>, <span class="string">"Execute-MyCmdlet"</span>, <span class="string">"-param1 \"c:\\foo.txt\""</span>]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>虽然JSON表单是明确的，并且不使用不必要的cmd.exe，但它确实需要通过双引号和转义更加详细。替代机制是使用<code>SHELL</code>指令和<em>shell</em>表单，为Windows用户创建更自然的语法，尤其是与<code>escape</code>解析器指令结合使用时：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"powershell"</span>,<span class="string">"-command"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> New-Item -ItemType Directory C:\Example</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> Execute-MyCmdlet.ps1 c:\example\</span></span><br><span class="line"><span class="bash">RUN c:\example\Execute-MyCmdlet -sample <span class="string">'hello world'</span></span></span><br></pre></td></tr></table></figure>
<p>导致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt; docker build -t shell .</span><br><span class="line">Sending build context to Docker daemon 4.096 kB</span><br><span class="line">Step 1&#x2F;5 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;5 : SHELL powershell -command</span><br><span class="line"> ---&gt; Running in 6fcdb6855ae2</span><br><span class="line"> ---&gt; 6331462d4300</span><br><span class="line">Removing intermediate container 6fcdb6855ae2</span><br><span class="line">Step 3&#x2F;5 : RUN New-Item -ItemType Directory C:\Example</span><br><span class="line"> ---&gt; Running in d0eef8386e97</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: C:\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----       10&#x2F;28&#x2F;2016  11:26 AM                Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ---&gt; 3f2fbf1395d9</span><br><span class="line">Removing intermediate container d0eef8386e97</span><br><span class="line">Step 4&#x2F;5 : ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line"> ---&gt; a955b2621c31</span><br><span class="line">Removing intermediate container b825593d39fc</span><br><span class="line">Step 5&#x2F;5 : RUN c:\example\Execute-MyCmdlet &#39;hello world&#39;</span><br><span class="line"> ---&gt; Running in be6d8e63fe75</span><br><span class="line">hello world</span><br><span class="line"> ---&gt; 8e559e9bf424</span><br><span class="line">Removing intermediate container be6d8e63fe75</span><br><span class="line">Successfully built 8e559e9bf424</span><br><span class="line">PS E:\docker\build\shell&gt;</span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>指令还可用于修改shell的运行方式。例如，<code>SHELL cmd /S /C /V:ON|OFF</code>在Windows上使用，可以修改延迟的环境变量扩展语义。</p>
<p>的<code>SHELL</code>，也可以在Linux上使用的指令应当替代壳需要如<code>zsh</code>，<code>csh</code>，<code>tcsh</code>和其他。</p>
<p>该<code>SHELL</code>功能已添加到Docker 1.12中。</p>
<h1 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nginx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span>      ubuntu</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> Description=<span class="string">"This image is used to start the foobar executable"</span> Vendor=<span class="string">"ACME Products"</span> Version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></span><br><span class="line"><span class="comment"># Firefox over VNC</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install vnc, xvfb in order to create a 'fake' display and firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir ~/.vnc</span></span><br><span class="line"><span class="comment"># Setup a password</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> x11vnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class="line"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">'echo "firefox" &gt;&gt; /.bashrc'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5900</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">    [<span class="string">"x11vnc"</span>, <span class="string">"-forever"</span>, <span class="string">"-usepw"</span>, <span class="string">"-create"</span>]</span></span><br><span class="line"><span class="comment"># Multiple images example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> foo &gt; bar</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 907ad6c2736f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> moo &gt; oink</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 695d7793cbe4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You'll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span><br><span class="line"><span class="comment"># /oink.</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Goooo
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/" title="Dockerfile参考">https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/15/Linux/container/docker/Building-applications-with-docker/" rel="prev" title="使用docker构建应用">
      <i class="fa fa-chevron-left"></i> 使用docker构建应用
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/10/03/Program-design/Recursive/" rel="next" title="递归">
      递归 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#用法"><span class="nav-number">1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#格式"><span class="nav-number">2.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#directive"><span class="nav-number">3.</span> <span class="nav-text">directive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#escape"><span class="nav-number">4.</span> <span class="nav-text">escape</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Environment-replacement"><span class="nav-number">5.</span> <span class="nav-text">Environment replacement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dockerignore"><span class="nav-number">6.</span> <span class="nav-text">.dockerignore</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FROM"><span class="nav-number">7.</span> <span class="nav-text">FROM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#了解ARG和FROM如何交互"><span class="nav-number">7.1.</span> <span class="nav-text">了解ARG和FROM如何交互</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RUN"><span class="nav-number">8.</span> <span class="nav-text">RUN</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CMD"><span class="nav-number">8.1.</span> <span class="nav-text">CMD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LABEL"><span class="nav-number">9.</span> <span class="nav-text">LABEL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EXPOSE"><span class="nav-number">10.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ENV"><span class="nav-number">11.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ADD"><span class="nav-number">12.</span> <span class="nav-text">ADD</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#COPY"><span class="nav-number">12.1.</span> <span class="nav-text">COPY</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">13.</span> <span class="nav-text">ENTRYPOINT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#exec-ENTRYPOINT示例"><span class="nav-number">13.1.</span> <span class="nav-text">exec ENTRYPOINT示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-ENTRYPOINT示例"><span class="nav-number">13.2.</span> <span class="nav-text">Shell ENTRYPOINT示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解CMD和ENTRYPOINT如何相互作用"><span class="nav-number">13.3.</span> <span class="nav-text">了解CMD和ENTRYPOINT如何相互作用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VOLUME"><span class="nav-number">14.</span> <span class="nav-text">VOLUME</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有关指定卷的说明"><span class="nav-number">14.1.</span> <span class="nav-text">有关指定卷的说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#USER"><span class="nav-number">15.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WORKDIR"><span class="nav-number">16.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARG"><span class="nav-number">17.</span> <span class="nav-text">ARG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#默认值"><span class="nav-number">17.1.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#范围"><span class="nav-number">17.2.</span> <span class="nav-text">范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用ARG变量"><span class="nav-number">17.3.</span> <span class="nav-text">使用ARG变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义的ARG"><span class="nav-number">17.4.</span> <span class="nav-text">预定义的ARG</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对构建缓存的影响"><span class="nav-number">17.5.</span> <span class="nav-text">对构建缓存的影响</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ONBUILD"><span class="nav-number">18.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STOPSIGNAL"><span class="nav-number">19.</span> <span class="nav-text">STOPSIGNAL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">20.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SHELL"><span class="nav-number">21.</span> <span class="nav-text">SHELL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dockerfile示例"><span class="nav-number">22.</span> <span class="nav-text">Dockerfile示例</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Goooo"
      src="/images/img.png">
  <p class="site-author-name" itemprop="name">Goooo</p>
  <div class="site-description" itemprop="description">真正的粉丝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xth0331" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xth0331" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xietianhao0331@gmail.com" title="E-Mail → mailto:xietianhao0331@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
        
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
            <h3 class="widget-title">标签们</h3>
            <div id="myCanvasContainer" class="widget tagcloud">
                <canvas width="250" height="250" id="resCanvas" style="width=100%">
                    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/" rel="tag">Ansible</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backup/" rel="tag">Backup</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bond/" rel="tag">Bond</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU/" rel="tag">CPU</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ceph/" rel="tag">Ceph</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cobbler/" rel="tag">Cobbler</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coffee/" rel="tag">Coffee</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Corosync/" rel="tag">Corosync</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cyclic-invariant/" rel="tag">Cyclic invariant</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effectiveness/" rel="tag">Effectiveness</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exhaustion/" rel="tag">Exhaustion</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Filesystem/" rel="tag">Filesystem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HAProxy/" rel="tag">HAProxy</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hardware/" rel="tag">Hardware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Https/" rel="tag">Https</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ICMP/" rel="tag">ICMP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JDK/" rel="tag">JDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jenkins/" rel="tag">Jenkins</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JunOS/" rel="tag">JunOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KEEPALIVED/" rel="tag">KEEPALIVED</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Keepalived/" rel="tag">Keepalived</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Log/" rel="tag">Log</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modular-Programming/" rel="tag">Modular Programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Monitoring/" rel="tag">Monitoring</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netconf/" rel="tag">Netconf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Network/" rel="tag">Network</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Networking/" rel="tag">Networking</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OS/" rel="tag">OS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenStack/" rel="tag">OpenStack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Package-Manager/" rel="tag">Package Manager</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Partition/" rel="tag">Partition</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Programming/" rel="tag">Programming</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAM/" rel="tag">RAM</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RHCS/" rel="tag">RHCS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPM/" rel="tag">RPM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recursion/" rel="tag">Recursion</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Recursive/" rel="tag">Recursive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redirect/" rel="tag">Redirect</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Route/" rel="tag">Route</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage/" rel="tag">Storage</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Storage-and-Filesystem/" rel="tag">Storage and Filesystem</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swap/" rel="tag">Swap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sys/" rel="tag">Sys</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Systemd/" rel="tag">Systemd</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terminal/" rel="tag">Terminal</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Terraform/" rel="tag">Terraform</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tools/" rel="tag">Tools</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Veeam/" rel="tag">Veeam</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtualization/" rel="tag">Virtualization</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vmware/" rel="tag">Vmware</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vsphere/" rel="tag">Vsphere</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Yum/" rel="tag">Yum</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apple/" rel="tag">apple</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/complaints/" rel="tag">complaints</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/" rel="tag">elasticsearch</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iteration/" rel="tag">iteration</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logs/" rel="tag">logs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oop/" rel="tag">oop</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/talking/" rel="tag">talking</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9/" rel="tag">数据压缩</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%84%99%E8%A7%86%E9%93%BE/" rel="tag">鄙视链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4/" rel="tag">重复数据删除</a><span class="tag-list-count">1</span></li></ul>
                </canvas>
            </div>
        </div>
        
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Goooo</span>
</div>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://www-sysctl-me-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.sysctl.me/2018/09/16/Linux/container/docker/Dockerfile/";
    this.page.identifier = "2018/09/16/Linux/container/docker/Dockerfile/";
    this.page.title = "Dockerfile参考";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://www-sysctl-me-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":300,"height":600},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>
