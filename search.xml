<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title> 解决某厂交换机无法“can’t load kernel”的问题</title>
    <url>/2020/10/24/Networking/Fix-ex2300-can-not-load-kernel/</url>
    <content><![CDATA[<h1 id="故障现象描述"><a href="#故障现象描述" class="headerlink" title="故障现象描述"></a>故障现象描述</h1><ol>
<li><p>尝试升级交换机版本（这里应该因为某种原因导致升级失败）。</p>
</li>
<li><p>尝试进入所谓的<code>recover</code>模式 ，也就是<code>FreeBSD</code>的<code>loader</code>，并尝试使用<code>install --format</code>将已有的文件系统重写（也叫格式化安装）。</p>
</li>
<li><p>这时候会得到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">panic: free: guard1 fail @ 0x45c40 from /.amd/svl-engdata1vs1/occamdev/build/freebsd/head/20160518.183540_fbsd-builder_head.327854/src/lib/libstand/dosfs.c:248</span><br><span class="line">--&gt; Press a key on the console to reboot &lt;--</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h1><p>此处省略砍价过程…</p>
<p>我：你文档是盲流子文档，有没有官方文档。</p>
<p>K：这就是官方文档。</p>
<p>我：肯定不是，我自己找吧。</p>
<hr>
<p>十分钟后，我确实遇到同样的错误，再次扯皮。</p>
<p>我：你这包不对吧？</p>
<p>K：肯定对。</p>
<p>我：你有没有别的，img格式的。</p>
<p>K：下载中。</p>
<hr>
<blockquote>
<p>这时基本是确定了包不对，文档也不是解决这个问题的文档，使用Google大法。基本定位是<code>loader</code>模式的状态下，并没有从<code>USB</code>设备引导，由于对BSD不熟悉，但是应该原因类似<code>GRUB</code>引导设备不对差不了多少😂。</p>
</blockquote>
<hr>
<p>我：拿到IMG包。</p>
<h1 id="名词描述"><a href="#名词描述" class="headerlink" title="名词描述"></a>名词描述</h1><h2 id="load模式"><a href="#load模式" class="headerlink" title="load模式"></a><code>load</code>模式</h2><p>这个就是<code>FreeBSD</code>内核引导的最后阶段，会检测控制台和磁盘，识别从哪块盘引导。</p>
<h3 id="currdev"><a href="#currdev" class="headerlink" title="currdev"></a>currdev</h3><p>选择默认设备。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>处理脚本文件。依次读取每个文件进入内存，然后将其中的每一行传递。</p>
<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>convert and copy a file。</p>
<h1 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h1><ul>
<li><p>首先将img.gz包解压，并将其写入到usb设备（win直接解压就好）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gzip -d xxx.img.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定USB是哪个，此处仅写Mac上的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diskutil list <span class="comment"># 找到你的usb，我这是disk2</span></span><br><span class="line">diskutil umountDisk /dev/disk2 <span class="comment"># 卸载</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将img镜像写入usb设备(其他刻录软件也可)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/path/to/file.img of=/dev/disk2 bs=1m</span><br></pre></td></tr></table></figure>
</li>
<li><p>拔掉USB。</p>
</li>
<li><p>接到某厂坏了的交换机。</p>
</li>
<li><p>插上什么<code>console</code>线。</p>
</li>
<li><p>通过COMx连上。</p>
</li>
<li><p>执行reboot（主要为了重新识别USB设备）。</p>
</li>
<li><p>进入<code>loader</code>模式后。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> currdev=<span class="string">"disk1s1a"</span>   <span class="comment"># 设置引导设备为disk1s1a</span></span><br><span class="line">include /boot/loader.rc  <span class="comment">#　执行/boot/loader.rc脚本文件</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>等待重写完成，就可以通过默认用户名：<code>root</code>，密码：空，进入系统。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>又是拖延的一年，0202</title>
    <url>/2020/10/01/Other/Daily-complaints20200930/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>明天要放假了（虽然只有四天），这一年的工作中充斥的琐事（大于60%），那么琐事是什么呢?</p>
<blockquote>
<p>琐事就是运维服务中手动性的，重复性的，可以被自动化的，战术性，没有持久价值的工作。</p>
<p>​                                                                                       ── Google SRE</p>
</blockquote>
<p>（当然，也包括主观认为不怎么喜欢做但又不得不做的事😂。</p>
<p>回想去年年底也是许了不少愿，包括但不限于把<code>Golang</code>，<code>Kubernetes</code>学个差不多，监控弄得像个人样，<code>Terraform</code>和<code>Ansible</code>去处理些边缘业务的自动化顺带Gitlab，还有就是去看<em>渴望力量系列</em>，现在看，今年的进度四舍五入约等于0。</p>
<p>今年的工作中，扮演的角色就很有趣，之前我其实只要做好自己管理的系统就好了，其余时间可以自己去找些东西学习，搭建测试，去满足需求就好了，所以琐事的比例很小。今年感觉自己需要参与的工作（不是数量，而是类别）变多了，多数也就是配合作用（也就是无法做主），其实也很舒服，但是嘛，毕竟还需要协调资源（传话）去配合其他老师，免不了与人沟通。就贼难受。</p>
<h1 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h1><ol>
<li>堡垒机日常工作</li>
<li>疫情+校庆这段期间虚拟机的交付，虽然用了<code>terraform</code>，但是后端状态并没有持久化，很烦。</li>
<li>需求翻译，我很奇怪这个事，但是也有收获，比如我理解运维与开发之间的矛盾是如何产生的，233333。</li>
<li>写毫无意义的日报（工作记录很有意思，但是我这种，意义：0）。</li>
<li>跟一些工程师沟通，跟你们沟通使我变得更菜。</li>
</ol>
<h1 id="非琐事"><a href="#非琐事" class="headerlink" title="非琐事"></a>非琐事</h1><ol>
<li><code>terraform</code>真香，尝到了甜头。</li>
<li>读《Kubernetes In Action》,K8s大法好，这本书香。</li>
<li>配合大佬。</li>
<li>Netbox</li>
<li>vSphere Tanzu Cluster</li>
<li>有一丁点安全意识了，知道不关防火墙了。</li>
</ol>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ol>
<li>以后不准备用CentOS了。</li>
<li>Kubernetes的理念是真的巧妙。</li>
<li>与人沟通，并非易事。</li>
<li>与人协作，先确认价值观，价值观不符时，做好自己的就好。</li>
<li>找到一个合适的团队很难，不要拿自己的标准衡量别人。</li>
</ol>
<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>有些厂商的工程师，真的差劲。</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>talking</tag>
        <tag>complaints</tag>
      </tags>
  </entry>
  <entry>
    <title>配置OPENSSH</title>
    <url>/2020/06/13/Linux/OPENSSH/Convert-OpenSSH-Key/</url>
    <content><![CDATA[<h1 id="转换OpenSSH-private-key为RSA-private-key"><a href="#转换OpenSSH-private-key为RSA-private-key" class="headerlink" title="转换OpenSSH private key为RSA private key"></a>转换OpenSSH private key为RSA private key</h1><p>今天下午，想把本机的<code>Private KEY</code>添加到堡垒机，倒是也没仔细看，直接复制粘贴到堡垒机中，低能堡垒机提示说私钥格式无效。</p>
<p>==WTF?==</p>
<p>应该是SSH版本太高了，看了下发现第一行有区别（内容也不同）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># OpenSSH_8.1p1</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">xxx</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br><span class="line"># OpenSSH_7.5p1</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">xxx</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p>0202年了，SSH版本也要升级到8.0了，先不管了，转换吧，一条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp ~/.ssh/id_rsa /tmp/path/to/key</span><br><span class="line"><span class="comment"># 就这一条</span></span><br><span class="line">ssh-keygen -p -N <span class="string">""</span> -m pem -f /tmp/path/to/key</span><br><span class="line"><span class="comment"># 记得保管好呀</span></span><br><span class="line">rm -f /tmp/path/to/key</span><br></pre></td></tr></table></figure>
<p>复制<code>private key</code>转换后填到堡垒机，删掉，一定保管好<code>private key</code>。</p>
<p>==堡垒机是真的垃圾，谁家都一样。==</p>
<p>以后在家基本告别电脑了，我家一条是真的爱玩电脑hhhh。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/yitiao01" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/yitiao02" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/yitiao03" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>如何测试一个端口是否可达</title>
    <url>/2020/04/11/Networking/How-to-testing-UDP-port/</url>
    <content><![CDATA[<h1 id="TCP与UDP连接"><a href="#TCP与UDP连接" class="headerlink" title="TCP与UDP连接"></a>TCP与UDP连接</h1><blockquote>
<p> 看结果请直接拉到底↓</p>
</blockquote>
<p><code>TCP</code>和<code>UDP</code>协议是两个不同的协议，用于处理IP网络（Internet）中的客户端之间的数据通信。</p>
<p>在传统<code>OSI</code>模型中，<code>TCP</code>和<code>UDP</code>是<em>传输层协议</em>。其中<code>TCP</code>是<strong>面向连接</strong>的协议，而<code>UDP</code>是<strong>无连接</strong>协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>从理论上讲，传输层协议可以是一个非常简单的，但是不能将TCP协议称为简单协议。为什么要使用与TCP一样复杂的传输层？最重要的原因取决于IP的不可靠性。实际上，TCP下的所有层都不可靠，并且逐跳传递数据报。IP层逐跳传送数据报，并且不能保证传送数据报。这是一个无连接系统。IP只是处理数据报的路由。如果出现问题，IP会立即丢弃该数据包，并在此过程中将错误消息返回给发送方。确定通过网络发送的数据报的状态并在部分已被丢弃的情况下处理信息重发的任务落在TCP上。</p>
<p>大多数用户将TCP和IP视为紧密的对，但是TCP可以并且经常与其他传输协议一起使用。</p>
<p>例如，在文件传输协议（FTP）和简单邮件传输协议（SMTP）中都使用TCP或其中的一部分，它们都不使用IP。</p>
<p>传输控制协议为IP层和上层提供了大量服务。最重要的是，它为上层提供了面向连接的协议，该协议使应用程序可以确保通过网络发送的数据报被完整接收。在此角色下，TCP充当提供可靠通信的消息验证协议。如果数据报已损坏或丢失，则通常由TCP（不是较高层中的应用程序）来处理重传。</p>
<p>TCP管理来自更高层的数据报流，以及来自IP层的传入数据报。它必须确保优先事项和安全得到尊重。TCP必须能够处理其上期望输入数据报的应用程序的终止，以及较低层的故障。TCP还必须维护TCP层内外所有数据流的状态表。将这些服务隔离在一个单独的层中，可以在不考虑流控制或消息可靠性的情况下设计应用程序。没有TCP层，每个应用程序都必须自己实现服务，这是资源的浪费。</p>
<p>TCP位于传输层，位于IP之上，但位于上层及其应用程序之下，如下图所示。TCP仅驻留在实际处理数据报的设备上，以确保数据报已从源计算机传递到目标计算机。它不驻留在仅路由数据报的设备上，因此网关中没有TCP层。这是有道理的，因为在网关上，数据报在分层模型中不需要比IP层更高。</p>
<h3 id="TCP报头结构"><a href="#TCP报头结构" class="headerlink" title="TCP报头结构"></a>TCP报头结构</h3><p>TCP段作为Internet数据报发送。Internet协议报头包含几个信息字段，包括源和目标主机地址。TCP头跟随Internet头，提供特定于TCP协议的信息。这种划分允许存在TCP以外的主机级别协议。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line"></span><br><span class="line">                         TCP Header Format</span><br><span class="line"></span><br><span class="line">       				请注意，一个刻度表示一位位置。</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>Source Port</td>
<td>源端口号</td>
<td>16</td>
</tr>
<tr>
<td>Destination Port</td>
<td>目的端口号</td>
<td>16</td>
</tr>
<tr>
<td>Sequence Number</td>
<td>此段中第一个数据八位位组的序列号（存在SYN时除外）。如果存在SYN，则序列号为初始序列号（ISN），而第一个数据字节为ISN + 1。</td>
<td>32</td>
</tr>
<tr>
<td>Acknowledgment Number</td>
<td>如果设置了ACK控制位，则该字段包含该段的发送者希望接收的下一个序列号的值。建立连接后，将始终发送该连接。</td>
<td>32</td>
</tr>
<tr>
<td>Data Offset</td>
<td>TCP报头中的32位字的数量。这指示数据从何处开始。TCP头（甚至包括选项在内的一个头）的整数是32位长。</td>
<td>4</td>
</tr>
<tr>
<td>Reserved</td>
<td>保留以备将来使用。必须为零。</td>
<td>6</td>
</tr>
<tr>
<td>Control Bits</td>
<td>控制位 — 从左至右</td>
<td>6</td>
</tr>
<tr>
<td>URG</td>
<td>紧急指针字段意义重大</td>
<td>1</td>
</tr>
<tr>
<td>ACK</td>
<td>确认字段有效</td>
<td>1</td>
</tr>
<tr>
<td>PSH</td>
<td>推送功能</td>
<td>1</td>
</tr>
<tr>
<td>RST</td>
<td>重置连接</td>
<td>1</td>
</tr>
<tr>
<td>SYN</td>
<td>同步序列号</td>
<td>1</td>
</tr>
<tr>
<td>FIN</td>
<td>没有来自发件人的更多数据</td>
<td>1</td>
</tr>
<tr>
<td>Window</td>
<td>此字节的数量以该段的发送方愿意接受的确认字段中指示的位数开始。</td>
<td>8</td>
</tr>
<tr>
<td>Checksum</td>
<td>校验和字段是标头和文本中所有16位字的一个人的补码之和的16位一个人的补码。如果段中包含奇数个要校验和的标题和文本八位位组，则最后一个八位组将在右边填充零，以形成一个16位字用于校验和。打击垫不作为片段的一部分发送。在计算校验和时，校验和字段本身将替换为零。<br />校验和还覆盖了概念上以TCP头为前缀的96位伪头。该伪标头包含源地址，目标地址，协议和TCP长度。这样可以为TCP提供保护，以防止路由错误的段。该信息在Internet协议中承载，并通过IP上TCP的调用参数或结果在TCP /网络接口中传输。</td>
<td>16</td>
</tr>
<tr>
<td>Urgent Pointer</td>
<td>此字段传达紧急指针的当前值，作为与该段中序列号的正偏移量。紧急指针指向紧随紧急数据之后的八位位组的序号。仅在设置了URG控制位的段中解释此字段。</td>
<td>16</td>
</tr>
<tr>
<td>Options</td>
<td>选项可能会占用TCP标头末尾的空间，并且是8位长度的倍数。所有选项都包含在校验和中。选项可以在任何八位位组边界上开始。选项的格式有两种情况：</td>
<td>8的倍数</td>
</tr>
<tr>
<td></td>
<td>情况1：一个八位组。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>情况2：八位位组，选项长度的八位位组和实际的选项数据八位位组。选项长度计算选项类型和选项长度的两个八位位组以及选项数据八位位组。请注意，选项列表可能比数据偏移量字段暗示的要短。超出选项结尾选项的标头内容必须为标头填充（即零）。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="TCP通讯"><a href="#TCP通讯" class="headerlink" title="TCP通讯"></a>TCP通讯</h3><p>在将TCP用于任何实际有用的目的（即发送数据）之前，必须在希望通信的两个设备之间建立连接。此过程通常称为连接建立，涉及交换消息，该消息将两个设备从其初始连接状态（CLOSED）转换为正常操作状态（ESTABLISHED）。</p>
<p><strong>连接建立功能</strong></p>
<p>建立连接过程实际上会完成几件事，因为它创建了适合于数据交换的连接：</p>
<p><em>联系和通信：</em> 客户端和服务器相互联系，并通过相互发送消息建立通信。在这一点之前，服务器通常甚至不知道它将与之对话的客户端，因此它在连接建立期间就发现了这一点。</p>
<p><em>序列号同步：</em> 每个设备都让对方知道其首次传输要使用的初始序列号。</p>
<p><em>参数交换：</em> 控制TCP连接操作的某些参数由两个设备交换。</p>
<p><strong>用于建立连接的控制消息：SYN和ACK</strong></p>
<p>TCP使用控制消息来管理联系和通信过程。但是，没有任何特殊的TCP控制消息类型。所有TCP消息均使用相同的段格式。TCP报头中的一组控制标志指示段是用于控制目的还是仅用于承载数据。使用控制消息时，以下标志会更改。</p>
<p><em>SYN：</em> 该位指示该段正在用于初始化连接。参考上面提到的序列号同步，SYN表示同步。</p>
<p><em>ACK：</em> 此位指示发送网段的设备正在传送对其已接收消息（例如SYN）的确认。</p>
<p><strong>正常连接建立：“三次握手”</strong></p>
<p>为了建立连接，每个设备必须发送一个SYN并从另一个设备接收一个ACK。因此，从概念上讲，需要在设备之间传递四个控制消息。但是，当一个人可以同时通信时，在单独的消息中发送SYN和ACK效率很低。因此，在连接建立中的正常事件序列中，通过设置两个相关位（有时称为SYN + ACK的消息）来一起发送SYN之一和ACK之一。这总共产生了三个消息，因此，连接过程称为三次握手。</p>
<blockquote>
<p>关键： 在TCP客户端和服务器之间建立连接的正常过程包括三个步骤：</p>
</blockquote>
<ul>
<li><p>客户端发送SYN消息</p>
</li>
<li><p>服务器发送结合了客户端SYN的ACK并包含服务器SYN的消息</p>
</li>
<li>然后客户端发送针对服务器的SYN的ACK。这称为TCP三次握手。</li>
</ul>
<p><img src="https://blog-image.nos-eastchina1.126.net/tcpfsm.png" alt=""></p>
<p>连接在其生存周期内会经历一系列状态，这包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>状态名称</th>
<th>状态含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>LISTEN</td>
<td>正在等待来自任何远程TCP和端口的连接请求</td>
</tr>
<tr>
<td>SYN-SENT</td>
<td>发送连接请求后等待匹配的连接请求</td>
</tr>
<tr>
<td>SYN-RECEIVED</td>
<td>已接收并发送连接请求后，等待确认连接请求确认</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>一个开放的连接，接收到的数据可以传递给用户。连接的数据传输阶段的正常状态</td>
</tr>
<tr>
<td>FIN-WAIT-1</td>
<td>等待来自远程TCP的连接终止请求，或者等待先前发送的连接终止请求的确认</td>
</tr>
<tr>
<td>FIN-WAIT-2</td>
<td>等待来自远程TCP的连接终止请求</td>
</tr>
<tr>
<td>CLOSE-WAIT</td>
<td>正在等待本地用户的连接终止请求</td>
</tr>
<tr>
<td>CLOSING</td>
<td>等待来自远程TCP的连接终止请求确认</td>
</tr>
<tr>
<td>LAST-ACK</td>
<td>等待先前发送给远程TCP的连接终止请求的确认（包括对它的连接终止请求的确认）。</td>
</tr>
<tr>
<td>TIME-WAIT</td>
<td>等待足够的时间以确保远程TCP收到其连接终止请求的确认。</td>
</tr>
<tr>
<td>CLOSED</td>
<td>完全没有连接状态。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="https://blog-image.nos-eastchina1.126.net/Fig2_UDPwork.jpg" alt=""></p>
<p>UDP是一种无连接且不可靠的传输协议，这两个端口用于标识源计算机和目标计算机内的端点。当不需要可靠的传送时，使用用户数据报协议代替TCP。但是，从不使用UDP发送重要数据，例如网页，数据库信息等。流媒体（例如视频，音频等）使用UDP，因为它提供速度。</p>
<p><strong>为什么UDP比TCP快？</strong></p>
<p>UDP比TCP快的原因是因为没有任何形式的流控制。UDP不会进行错误检查，错误纠正或确认。UDP只与速度有关。因此，当Internet上发送的数据受到冲突的影响时，就会出现错误。</p>
<p>UDP数据包称为8字节标头的用户数据报。用户数据报的格式如图3所示。在用户数据报中，前8个字节包含头信息，其余字节包含数据。</p>
<p><strong>UDP数据报</strong></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/Fig3_udp_userdatagrams.jpg" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Source port number</em></td>
<td>正在传输数据的源主机使用的端口号。它是16位长。因此，端口号的范围是0到65,535。</td>
</tr>
<tr>
<td><em>Destination port number</em></td>
<td>正在获取数据的目标主机使用的端口号。它也是16位长，并且端口范围的数量与源主机相同。</td>
</tr>
<tr>
<td><em>length</em></td>
<td>字段是一个16位字段。它包含用户数据报，标头和数据的总长度。</td>
</tr>
<tr>
<td><em>Checksum</em></td>
<td>UDP校验和是可选的。它用于检测数据错误。如果该字段为零，则不计算校验和。然后计算得出的true字段包含1。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>UDP的特征</strong></p>
<p>UDP的特征如下。</p>
<ul>
<li><p>端到端。UDP可以识别计算机上运行的特定进程。</p>
</li>
<li><p>不可靠的无连接传送</p>
</li>
</ul>
<p>UDP使用无连接通信设置。在这种情况下，UDP无需在发送数据之前建立连接。通信仅由数据段本身组成</p>
<ul>
<li><p>尽力而为</p>
</li>
<li><p>无应答，无顺序，无流量控制</p>
</li>
<li><p>可能会丢失，重复，延迟，乱序或失去连接</p>
</li>
<li><p>快速，低开销</p>
</li>
</ul>
<ol>
<li>适用于可靠的本地网络</li>
<li>RTP（实时传输协议）</li>
</ol>
<h3 id="在通讯中使用端口"><a href="#在通讯中使用端口" class="headerlink" title="在通讯中使用端口"></a>在通讯中使用端口</h3><p>接收到数据之后，计算机必须具有某种处理机制。考虑到用户已打开三个应用程序，例如Web浏览器，telnet会话和FTP会话。这三个应用程序都正在通过网络移动数据。因此，应该有某种机制来确定操作系统将哪些流量绑定到哪个应用程序。要处理这种情况，请使用网络端口。可用端口的范围是0到65535。其中0到1023是众所周知的端口 ，1023到49151是注册端口，49152到65535是动态端口。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/TCP_and_UDP_ports.jpg" alt=""></p>
<p>使用UDP协议的常见端口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>端口</th>
<th>服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>Echo</td>
</tr>
<tr>
<td>9</td>
<td>Discard</td>
</tr>
<tr>
<td>11</td>
<td>Users</td>
</tr>
<tr>
<td>13</td>
<td>Daytime</td>
</tr>
<tr>
<td>17</td>
<td>Quote</td>
</tr>
<tr>
<td>19</td>
<td>Chargen</td>
</tr>
<tr>
<td>53</td>
<td>Nameserver</td>
</tr>
<tr>
<td>67</td>
<td>Bootps</td>
</tr>
<tr>
<td>68</td>
<td>Bootpc</td>
</tr>
<tr>
<td>69</td>
<td>TFTP</td>
</tr>
<tr>
<td>111</td>
<td>RPC</td>
</tr>
<tr>
<td>123</td>
<td>NTP</td>
</tr>
</tbody>
</table>
</div>
<h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><p>在UDP连接中，客户端根据他们开始连接的程序设置唯一的源端口号。UDP不限于一对一交互。可以使用广播或多播寻址提供一对多交互。与单台服务器通信的许多客户端可以提供多对一交互。多对多交互只是这些技术的扩展。</p>
<h1 id="TCP-vs-UDP"><a href="#TCP-vs-UDP" class="headerlink" title="TCP vs UDP"></a>TCP vs UDP</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
</div>
<h1 id="如何测试一个端口是否通信"><a href="#如何测试一个端口是否通信" class="headerlink" title="如何测试一个端口是否通信"></a>如何测试一个端口是否通信</h1><p><code>telnet</code>和一些奇奇怪怪的工具我就不说了，如果您认为某些网站上的工具好用，请<kbd>Alt + F4</kbd>。</p>
<blockquote>
<p>如果是个人电脑，没所谓，用些小工具可以，但是Server的话可不能因为测试就随便装某些奇怪的东西。</p>
</blockquote>
<h2 id="在Windows上测试端口"><a href="#在Windows上测试端口" class="headerlink" title="在Windows上测试端口"></a>在Windows上测试端口</h2><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p><del>不是本文关注内容</del></p>
<h3 id="Test-NetConnection"><a href="#Test-NetConnection" class="headerlink" title="Test-NetConnection"></a>Test-NetConnection</h3><p>这是PowerShell提供的能力，支持<code>ping</code>,<code>TCP</code>，<code>traceroute</code></p>
<ul>
<li><p>ping测试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> www.hit.edu.cn <span class="literal">-InformationLevel</span> Detailed</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由测试(管理员权限运行)：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> www.hit.edu.cn <span class="literal">-DiagnoseRouting</span> <span class="literal">-InformationLevel</span> Detailed</span><br></pre></td></tr></table></figure>
</li>
<li><p>TCP端口连通性测试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> www.hit.edu.cn <span class="literal">-Port</span> <span class="number">80</span>  <span class="literal">-InformationLevel</span> Detailed</span><br></pre></td></tr></table></figure>
</li>
<li><p>Trace测试：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> www.hit.edu.cn <span class="literal">-TraceRoute</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>InformationLevel Detailed</code>参数可选。</p>
<h2 id="在Linux-Unix上测试端口"><a href="#在Linux-Unix上测试端口" class="headerlink" title="在Linux/Unix上测试端口"></a>在Linux/Unix上测试端口</h2><p><del>telnet仍不不关注</del></p>
<h3 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h3><p>需要使用包管理（apt/yum等）安装nc（netcat）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install nc</span><br></pre></td></tr></table></figure>
<p>比如咱们测试192.168.1.1的TCP22端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -vz 192.168.1.1 22</span><br></pre></td></tr></table></figure>
<p>如果可以连通，会在标准输出回显<code>successded</code>。</p>
<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p><code>nmap</code>其实是一个网络扫描工具，但是也可以使用，首先也是安装nmap包,省略步骤，然后咱们继续测试22，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sT -v -p 22 192.168.1.1</span><br></pre></td></tr></table></figure>
<p>具体参数需要养成查阅<code>man</code>手册的好习惯。</p>
<h2 id="UDP端口测试"><a href="#UDP端口测试" class="headerlink" title="UDP端口测试"></a>UDP端口测试</h2><p>这才是写这个文档的目的，这个问题困扰很多人，如果有人问你<code>如何测试一个UDP端口是否可达？</code>其实这个问题就是个错误(虽然某些方式可以验证是否可达)，先说为什么，再说怎么做。</p>
<p>其实没有所谓的<strong>开放UDP端口</strong>，大多数人惯于思考的意义上（这是在回答，确认，我以接受连接，这一类意思）。UDP是无会话的，因此，所谓<code>Port</code>（读取：OS中IP协议栈中的UDP协议）将永远不会自行响应，也就是所谓的三次握手完成后，所响应的成功。（后面会说各种工具对于UDP端口的测试是如何实现的）</p>
<p>UDP端口有两种状态：监听与未监听。其实也就是某些进程是否打开套接字。后一种（未打开套接字）情况比较容易检测，因为系统使用`code=3（端口不可达）<strong>ICMP Destination Unrechable</strong>进行响应。但是，许多防火墙会丢弃这种数据包，因此如果没有得到任何回应，就不能确切知道端口是否处于这种状态。（ICMP也是无会话的，并不会重传），这句话是什么意思呢，就是<strong>ICMP Destination Unrechable</strong>代表的<strong>端口不可达</strong>数据包很有可能在途中某个地方被丢弃或丢失。</p>
<p>处于监听状态的<code>UDP</code>端口也可能根本不响应（正在监听它的进程只是接收数据包，并不传输任何内容），或者将某些内容发送回去。也就是说，如果什么也拿不回来，永远无法确定此端口的状态是什么。</p>
<p>有些啰嗦，说的是啥意思呢，就是不通不代表不通，也没有会话控制，无需重传。</p>
<p>那么测试的办法又是什么呢，像nc，nmap这些工具是如何判断UDP端口是否可达呢?</p>
<p>咱们试验一下：</p>
<p>实验用到的工具： <code>nc</code>、<code>tcpdump/wireshark</code>、<code>nmap</code>。</p>
<p>首先，模拟一个监听的UDP端口，并使用<code>tcpdump</code>或<code>wireshark</code>抓包，另一个客户端请求这个端口。</p>
<ul>
<li><p>服务端使用<code>netcat</code>监听udp端口6666：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -ul 6666 <span class="comment"># 监听udp6666端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端抓包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i enp0s31f6 udp port 6666 -X</span><br></pre></td></tr></table></figure>
</li>
<li><p>防火墙先不开通udp6666：</p>
</li>
</ul>
<p>现在客户端可以使用nc或nmap测试端口了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -uv SERVER_IP 6666</span><br></pre></td></tr></table></figure>
<p><code>Connection to 192.168.1.182 6777 port [udp/*] succeeded!</code></p>
<p>这时可以键入字符，看server端是否接受到对应输入的字符；</p>
<p>抓包同时查看，</p>
<p>具体不贴图了，多个电脑倒来倒去麻烦，其实目的就是看下</p>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>其实UDP端口测试，如无外接因素影响的话，nc nmap都可以简单的检测，不过，如果主机防火墙或链路中存在防火墙，这就不确定了。所以下次，如果有人问你如何测试UDP端口，请送上一枚斜眼币。</p>
<h1 id="基于UDP的可靠传输协议"><a href="#基于UDP的可靠传输协议" class="headerlink" title="基于UDP的可靠传输协议"></a>基于UDP的可靠传输协议</h1><p>TCP/IP协议栈中，TCP和UDP属于传输层，负责实现数据的传输。其中TCP是面向连接的和基于单个字节流的、保证顺序的可靠传输协议，UDP是无连接的、不可靠的、面向报文的协议。</p>
<p>在实际应用中，TCP由于简单可靠，被大部分应用层协议使用，特别是HTTP，所以占据了互联网流量的主要部分。由于TCP的广泛应用，并且是实现在操作系统中，在参数和算法调整上比较受限，难以进行一些激进的改进和定制。另外TCP的NAT穿越比较困难，一些P2P应用也只能使用UDP，所以就有了各种各样的可靠UDP协议。</p>
<h2 id="可靠UDP协议"><a href="#可靠UDP协议" class="headerlink" title="可靠UDP协议"></a>可靠UDP协议</h2><h3 id="UDT-UDP-based-Data-Transfer-Protocol"><a href="#UDT-UDP-based-Data-Transfer-Protocol" class="headerlink" title="UDT(UDP-based Data Transfer Protocol)"></a>UDT(UDP-based Data Transfer Protocol)</h3><p>UDT的主要目的是支持高速广域网上的海量数据传输，所以除了在UDP之上实现类似TCP的协议和算法之外，UDT还对TCP的拥塞算法做了一些细节上的调整，包括Negative-ACK(NAK)、ACK to ACK(ACK2)、基于对数的动态AIMD等。不过UDT的重传效率较低，无效报文，实际效果并不理想。</p>
<h3 id="KCP"><a href="#KCP" class="headerlink" title="KCP"></a>KCP</h3><p>KCP是一个很简单的ARQ的实现，包括选择重传和快重传等机制，对上层提供一个可靠的字节流。应用层可以使用多流复用的框架来实现对多个流的支持。另外，KCP增加了可配置启用的加密和FEC选项，FEC用的是Reed-Solomon纠删码，例如可以配置发送10%的冗余数据，来减少丢包时需要的重传，从而降低数据传输的延时。</p>
<h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>QUIC是Google实现的一种可靠UDP传输协议，并且已经被选择作为HTTP/3的基础。它的特点有：</p>
<ul>
<li>内建安全性，集成TLS</li>
<li>连接建立过程和TLS协商过程合并，减少往返请求次数，提高连接速度</li>
<li>集成多种拥塞算法，包括最新的BBR</li>
<li>多流支持，每个流有独立的拥塞控制，避免单个流中的丢包阻塞其它所有流（Head-of-line Blocking问题），更好的支持类似HTTP/2中的乱序请求</li>
<li>连接迁移：QUIC可以通过连接ID来唯一标识一个连接，当用户在有线、无线、移动网络之间切换时，可以保持上层连接的有效性，不需要再进行重连。</li>
</ul>
<p>另外，早期的QUIC还使用了一种基于异或的FEC算法，不过在新版本中已经去掉。</p>
<h3 id="uTP"><a href="#uTP" class="headerlink" title="uTP"></a>uTP</h3><p>uTP是BitTorrent中新增加的一种UDP传输协议，主要特点是使用了LEDBAT（Low Extra Delay Background Transport）拥塞算法。这种算法基于延时来检测网络拥塞，可以更早的探测到拥塞和更早的以及更大幅度的进行避让，从而避免影响用户上网操作的进行，保持后台下载跟前台操作的和平共处。</p>
<h3 id="FASP-Aspera"><a href="#FASP-Aspera" class="headerlink" title="FASP(Aspera)"></a>FASP(Aspera)</h3><p>FASP是Aspera公司（已被IBM收购）的私有UDP解决方案，提供加密的可靠传输，拥塞算法估计是类似BBR，直接使用RTT和带宽来作为调节速度的参考。但FASP主要用于高速的文件传输，所以不需要保证报文的顺序，避免乱序重组时占用的内存开销，而且也避免了因为内存有限而丢弃的部分乱序报文，从而减少不必要的重传，提高传输速度。也就是说，完全避免了Head-of-line Blocking问题。</p>
<h3 id="SCTP（Stream-Control-Transmission-Protocol，流控制传输协议）"><a href="#SCTP（Stream-Control-Transmission-Protocol，流控制传输协议）" class="headerlink" title="SCTP（Stream Control Transmission Protocol，流控制传输协议）"></a>SCTP（Stream Control Transmission Protocol，流控制传输协议）</h3><p>准确的说，SCTP不是一种可靠UDP协议，而是一种跟TCP/UDP平级的传输层协议，是IETF在2000年指定的标准协议。目前Linux和部分UNIX已经集成，Windows和Mac需要使用第三方包来实现。SCTP最初主要用于电信系统，此外，WebRTC中的DataChannel也用到这个协议。它的特点有：</p>
<ul>
<li>跟TCP一样面向连接，提供可靠传输</li>
<li>跟UDP一样面向消息</li>
<li>多流支持</li>
<li>每个流可以配置成接受有序或无序的消息</li>
<li>Multi-Homing：可以配置多个地址，利用多条网络传输通道</li>
<li>更好的安全性：要求四次握手，避免TCP的SYN Flooding攻击</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm快捷键</title>
    <url>/2020/01/28/iterm-study-notes/</url>
    <content><![CDATA[<h1 id="标签页和Windows"><a href="#标签页和Windows" class="headerlink" title="标签页和Windows"></a>标签页和Windows</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>新标签</td>
<td><code>⌘</code> + <code>T</code></td>
</tr>
<tr>
<td>关闭标签页或窗口</td>
<td><code>⌘</code>+ <code>W</code> （与许多Mac应用程序相同）</td>
</tr>
<tr>
<td>转到标签</td>
<td><code>⌘</code>+ <code>Number Key</code> （即：<code>⌘2</code>是第二个标签）</td>
</tr>
<tr>
<td>转到按方向拆分窗格</td>
<td><code>⌘</code>+ <code>Option</code>+<code>Arrow Key</code></td>
</tr>
<tr>
<td>循环iTerm Windows</td>
<td><code>⌘</code>+ <code>backtick</code> （适用于所有Mac应用程序，可与台式机/任务控制一起使用）</td>
</tr>
<tr>
<td><strong>分裂</strong></td>
<td></td>
</tr>
<tr>
<td>垂直拆分窗口（相同的配置文件）</td>
<td><code>⌘</code> + <code>D</code></td>
</tr>
<tr>
<td>水平分割视窗（相同的设定档）</td>
<td><code>⌘</code>+ <code>Shift</code>+ <code>D</code> （助记符：shift是一个宽水平键）</td>
</tr>
<tr>
<td><strong>移动</strong></td>
<td></td>
</tr>
<tr>
<td>用鼠标移动窗格</td>
<td><code>⌘</code>+ <code>Alt</code>+ <code>Shift</code>，然后从任何地方拖动窗格</td>
</tr>
<tr>
<td><strong>全屏</strong></td>
<td></td>
</tr>
<tr>
<td>全屏</td>
<td><code>⌘</code>+ <code>Enter</code></td>
</tr>
<tr>
<td>最大化窗格</td>
<td><code>⌘</code>+ <code>Shift</code>+ <code>Enter</code> （与全屏一起使用可以使窗格全屏化！）</td>
</tr>
<tr>
<td>调整窗格大小</td>
<td><code>Ctrl</code>+ <code>⌘</code>+ <code>Arrow</code>（假设您尚未将此映射到其他对象）</td>
</tr>
<tr>
<td><strong>较少使用</strong></td>
<td></td>
</tr>
<tr>
<td>按使用顺序转到拆分窗格</td>
<td><code>⌘</code>+ <code>]</code>，<code>⌘</code>+<code>[</code></td>
</tr>
<tr>
<td>水平拆分窗口（新配置文件）</td>
<td><code>Option</code>+ <code>⌘</code>+<code>H</code></td>
</tr>
<tr>
<td>垂直分割窗口（新配置文件）</td>
<td><code>Option</code>+ <code>⌘</code>+<code>V</code></td>
</tr>
<tr>
<td>上一个标签</td>
<td><code>⌘</code>+ <code>Left Arrow</code> （我通常按标签号移动）</td>
</tr>
<tr>
<td>下一个标签</td>
<td><code>⌘</code>+ <code>Right Arrow</code></td>
</tr>
<tr>
<td>转到窗口</td>
<td><code>⌘</code>+ <code>Option</code>+<code>Number</code></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h1 id="最喜欢的Shell键组合"><a href="#最喜欢的Shell键组合" class="headerlink" title="最喜欢的Shell键组合"></a>最喜欢的Shell键组合</h1><p>这些可能有助于使您更快地使用Shell，但实际上这并不是iTerm2特有的。我假设您在Mac上使用bash或zsh。有很多技巧，但是我经常使用这些技巧。有时还有多种方法可以做到，因此请采用您最喜欢的方法。</p>
<p>希望其中一些改变您的生活。:)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
<th><strong>采用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>删除以开始行（收藏夹）</td>
<td><code>Ctrl</code> + <code>U</code></td>
<td>使用它可以重新开始键入而无需按Ctrl-C</td>
</tr>
<tr>
<td>删除到行尾（收藏夹）</td>
<td><code>Ctrl</code> + <code>K</code></td>
<td>将其与命令历史记录一起使用可重复命令并最后更改一件事！</td>
</tr>
<tr>
<td>重复上一条命令</td>
<td><code>Ctrl</code> + <code>Up Arrow</code></td>
<td>上下循环浏览历史记录。 <code>Ctrl-R</code>如果您知道要查找的字符串，则速度会更快。</td>
</tr>
<tr>
<td>在一条线上来回移动</td>
<td><code>Arrow Keys</code></td>
<td>这会让您离开主场，但很容易记住</td>
</tr>
<tr>
<td>一行一行地来回移动</td>
<td><code>Ctrl</code> + <code>Arrow Keys</code></td>
<td>跳到一个单词以纠正拼写错误或稍作更改即可“再次运行”的快速方法</td>
</tr>
<tr>
<td>删除前一个词（在shell中）</td>
<td><code>Ctrl</code> + <code>W</code></td>
<td>用词删除的速度更快。尤其是当您的最后一个命令因单个错字或其他错误而出错时。</td>
</tr>
<tr>
<td>清除萤幕</td>
<td><code>Ctrl</code> + <code>L</code></td>
<td>这是告诉外壳程序执行此操作。如果这不起作用，<code>⌘</code>+ <code>K</code>会告诉iTerm做到这一点，即当您不在外壳中时，它会起作用。使用它而不是<code>clear</code>一遍又一遍地输入。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="更快地移动"><a href="#更快地移动" class="headerlink" title="更快地移动"></a>更快地移动</h1><p>在iterm中，有很多Shell快捷方式都可以使用，因此最好学习这些快捷方式，因为箭头键，Home / End键和Mac等效键并不总是有效。例如，<code>⌘</code>+ <code>Left Arrow</code>通常与<code>Home</code> （转到当前行的开头）相同，但是在shell中不起作用。Home可在许多应用程序中使用，但可以带您离开主行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>移至行首</td>
<td><code>Ctrl</code>+ <code>A</code>或<code>Home</code></td>
</tr>
<tr>
<td>移至行尾</td>
<td><code>Ctrl</code>+ <code>E</code>或<code>End</code></td>
</tr>
<tr>
<td>前进一个字</td>
<td><code>Option</code> + <code>F</code></td>
</tr>
<tr>
<td>向后移动一个字</td>
<td><code>Option</code> + <code>B</code></td>
</tr>
<tr>
<td>设定标记</td>
<td><code>⌘</code> + <code>M</code></td>
</tr>
<tr>
<td>跳至标记</td>
<td><code>⌘</code> + <code>J</code></td>
</tr>
<tr>
<td>逐行移动（这是一个shell程序，但可以通过）</td>
<td><code>Ctrl</code> + <code>Left/Right Arrow</code></td>
</tr>
<tr>
<td>使用鼠标进行光标跳转（shell和vim-可能取决于配置）</td>
<td><code>Option</code> + <code>Left Click</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="使用iTerm复制和粘贴而不使用鼠标"><a href="#使用iTerm复制和粘贴而不使用鼠标" class="headerlink" title="使用iTerm复制和粘贴而不使用鼠标"></a>使用iTerm复制和粘贴而不使用鼠标</h1><p>我不会使用太多此功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>进入复制模式</td>
<td><code>Shift</code>+ <code>⌘</code>+<code>C</code></td>
</tr>
<tr>
<td>在复制模式下进入字符选择模式</td>
<td><code>Ctrl</code> + <code>V</code></td>
</tr>
<tr>
<td>在复制模式下移动光标</td>
<td><code>HJKL</code> vim动作或箭头键</td>
</tr>
<tr>
<td>在复制模式下复制文字</td>
<td><code>Ctrl</code> + <code>K</code></td>
</tr>
</tbody>
</table>
</div>
<p>复制动作进入普通系统剪贴板，您可以像粘贴普通剪贴板那样粘贴。</p>
<h1 id="搜索命令历史"><a href="#搜索命令历史" class="headerlink" title="搜索命令历史"></a>搜索命令历史</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>键入时搜索</td>
<td><code>Ctrl</code>+ <code>R</code>并输入搜索词；重复<code>Ctrl</code>+ <code>R</code>以遍历结果</td>
</tr>
<tr>
<td>搜索最后记住的搜索词</td>
<td><code>Ctrl</code>+ <code>R</code>两次</td>
</tr>
<tr>
<td>在当前历史记录条目中结束搜索</td>
<td><code>Ctrl</code> + <code>Y</code></td>
</tr>
<tr>
<td>取消搜索并恢复原始行</td>
<td><code>Ctrl</code> + <code>G</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><div class="table-container">
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>捷径</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>清除屏幕/窗格（<code>Ctrl + L</code>无法使用时）</td>
<td><code>⌘</code>+ <code>K</code> （我一直都在用）</td>
</tr>
<tr>
<td>将命令广播到窗口中的所有窗格（必要时不错！）</td>
<td><code>⌘</code>+ <code>Alt</code>+ <code>I</code>（再次进行切换）</td>
</tr>
<tr>
<td>查找光标</td>
<td><code>⌘</code>+ <code>/</code> <em>或使用易于查看的主题或光标形状</em></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>Effectiveness</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux之道</title>
    <url>/2020/01/27/The-Tao-of-tmux/</url>
    <content><![CDATA[<p>tmux对控制台而言，桌面对GUI应用而言，这是本文维度内的世界。在tmux中，可以：</p>
<ul>
<li>在终端内部执行多任务，运行多个应用程序。</li>
<li>在同一窗口中有多个命令行（窗格）。</li>
<li>工作区（会话）中有多个窗口（窗口）。</li>
<li>在多个工作区之间切换，例如虚拟桌面。</li>
</ul>
<h1 id="思考TMUX"><a href="#思考TMUX" class="headerlink" title="思考TMUX"></a>思考TMUX</h1><p>基于文本的窗口管理器</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>多路复用器</strong></th>
<th><strong>“桌面”-说</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>复用器</td>
<td>多任务</td>
<td>同时进行多个应用程序。</td>
</tr>
<tr>
<td>届会</td>
<td>桌面</td>
<td>应用程序在这里可见</td>
</tr>
<tr>
<td>窗口</td>
<td>虚拟桌面或应用程序</td>
<td>拥有自己屏幕的台式机</td>
</tr>
<tr>
<td>窗格</td>
<td>应用</td>
<td>执行操作</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/tmux01.gif" alt=""></p>
<ul>
<li>1个服务器。<ul>
<li>有一个或更多会话。<ul>
<li>有一个或更多Window。<ul>
<li>有一个或更多Pane。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CLI-Power"><a href="#CLI-Power" class="headerlink" title="CLI Power"></a>CLI Power</h2><p>通过将一个终端分成多个终端，可以在同一屏幕上运行多个应用程序或终端。</p>
<p>一个屏幕可以用于编辑文件，另一个用户<code>tail -F</code>日志文件。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/tmux02.gif" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/tmux03.gif" alt=""></p>
<p>tmux支持任意数量的终端。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/tmux04.gif" alt=""></p>
<p>可以在创建的窗口之间切换。</p>
<h2 id="然后恢复一切"><a href="#然后恢复一切" class="headerlink" title="然后恢复一切"></a>然后恢复一切</h2><p>可以让tmux和所有应用程序运行（分离），注销，做一个三明治，然后重新（附加），所有应用仍在运行！</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/tmux05.gif" alt=""></p>
<h2 id="管理工作流程"><a href="#管理工作流程" class="headerlink" title="管理工作流程"></a>管理工作流程</h2><ul>
<li>系统管理员监控日志和服务。</li>
<li>程序员喜欢在附近使用cli打开编辑器。</li>
</ul>
<p>可以在tmux会话内部启动运行在远程服务器上的应用程序，将它们分离，然后在下一次重新绑定到您的思路和工作。</p>
<p>多任务处理，保留您的想法。</p>
<h1 id="安装TMUX"><a href="#安装TMUX" class="headerlink" title="安装TMUX"></a>安装TMUX</h1><p>tmux打包在大多数Linux和BSD系统上。</p>
<p>要获得有关如何在系统上安装tmux的最新结果，请执行“如何在<my distro>上安装tmux”，因为方向会有所变化，并且在发行版之间略有不同。</p>
<p>本文档是针对版本<strong>1.8</strong>编写的。重要的是，您必须拥有最新的稳定版tmux。可在<a href="http://tmux.sourceforge.net/" target="_blank" rel="noopener">tmux主页</a>上查看最新的稳定版本。</p>
<p><strong>Mac OS X</strong>用户可以通过<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>，<a href="http://fink.thetis.ig42.org/" target="_blank" rel="noopener">fink</a>或<a href="http://www.brew.sh/" target="_blank" rel="noopener">Homebrew</a>（aka brew）安装最新的tmux稳定版本 。</p>
<p>如果<strong>从源代码编译</strong>，则依赖项为<a href="http://www.monkey.org/~provos/libevent/" target="_blank" rel="noopener">libevent</a>和 <a href="http://invisible-island.net/ncurses/" target="_blank" rel="noopener">ncurses</a>。</p>
<h2 id="使用TMUX"><a href="#使用TMUX" class="headerlink" title="使用TMUX"></a>使用TMUX</h2><p>开始一个新的会话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure>
<p>这就是是您进入tmux会话所需要的全部。</p>
<h3 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h3><p>Tmux热键必须以特殊方式按下。请仔细阅读，然后自己尝试。</p>
<p>首先，按住前缀键。默认是<kbd>ctrl</kbd> + <kbd>b</kbd>。</p>
<p>然后停下来。不到一秒钟，键入下一步。</p>
<p><code>C-b o</code>表示： 同时按住<kbd>ctrl</kbd> + <kbd>b</kbd>。释放，然后按<kbd>o</kbd>。</p>
<p>记住，前缀+快捷键!</p>
<h3 id="会话名称"><a href="#会话名称" class="headerlink" title="会话名称"></a>会话名称</h3><p>会话可以在创建时命名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new-session [-s session-name]</span><br></pre></td></tr></table></figure>
<p>创建后可以重命名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux rename-session &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
<p>快捷键是：<kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>$</kbd></p>
<h3 id="窗口名称"><a href="#窗口名称" class="headerlink" title="窗口名称"></a>窗口名称</h3><p>Windows可以在创建时命名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new-window [-n window-name]</span><br></pre></td></tr></table></figure>
<p>创建后可以重命名windows。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux rename-window &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<p>快捷键是：<kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>,</kbd></p>
<h3 id="创建新的窗口"><a href="#创建新的窗口" class="headerlink" title="创建新的窗口"></a>创建新的窗口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new-window [-n window-name]</span><br></pre></td></tr></table></figure>
<p>快捷键是：<kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>c</kbd></p>
<h3 id="遍历窗口"><a href="#遍历窗口" class="headerlink" title="遍历窗口"></a>遍历窗口</h3><p>按号码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux select-window</span><br></pre></td></tr></table></figure>
<p>下一个:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux next-window</span><br></pre></td></tr></table></figure>
<p>前一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux  previous-window</span><br></pre></td></tr></table></figure>
<p>最后一个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux last-window</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>n</kbd></td>
<td>转到下一个窗口。</td>
</tr>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>p</kbd></td>
<td>转到上一个窗口。</td>
</tr>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>w</kbd></td>
<td>交互选择当前窗口。</td>
</tr>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>0-9</kbd></td>
<td>选择窗口0到9。</td>
</tr>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>M-n</kbd></td>
<td>使用铃声或活动标记移动到下一个窗口。</td>
</tr>
<tr>
<td><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>M-p</kbd></td>
<td>使用铃声或活动标记移到上一个窗口。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="移动窗口"><a href="#移动窗口" class="headerlink" title="移动窗口"></a>移动窗口</h3><p>移动窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux move-window [-t dst-window]</span><br></pre></td></tr></table></figure>
<p>交换窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux swap-window [-t dst-window]</span><br></pre></td></tr></table></figure>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>.</kbd></p>
<h3 id="移动窗格"><a href="#移动窗格" class="headerlink" title="移动窗格"></a>移动窗格</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux move-pane [-t dst-pane]</span><br></pre></td></tr></table></figure>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>{</kbd>或<kbd>}</kbd></p>
<h3 id="遍历窗格"><a href="#遍历窗格" class="headerlink" title="遍历窗格"></a>遍历窗格</h3><p>在窗格之间移动的快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux last-window</span><br><span class="line">tmux next-window</span><br></pre></td></tr></table></figure>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>↑</kbd>或<kbd>↓</kbd><kbd>←</kbd>或<kbd>→</kbd></p>
<h3 id="杀掉窗口"><a href="#杀掉窗口" class="headerlink" title="杀掉窗口"></a>杀掉窗口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">kill</span>-window [-t target-window]</span><br></pre></td></tr></table></figure>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>&amp;</kbd></p>
<h3 id="杀掉窗格"><a href="#杀掉窗格" class="headerlink" title="杀掉窗格"></a>杀掉窗格</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">kill</span>-pane [-t target-pane]</span><br></pre></td></tr></table></figure>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>x</kbd></p>
<h3 id="分隔窗口为窗格"><a href="#分隔窗口为窗格" class="headerlink" title="分隔窗口为窗格"></a>分隔窗口为窗格</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux split-window [-c start-directory] &lt;shell-command&gt;</span><br></pre></td></tr></table></figure>
<p>tmux窗口可以分为多个窗格。</p>
<p><kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>%</kbd>或<kbd>”</kbd></p>
<h2 id="配置TMUX"><a href="#配置TMUX" class="headerlink" title="配置TMUX"></a>配置TMUX</h2><p>tmux可以通过<code>~/.tmux.conf</code>配置文件进行配置。</p>
<h3 id="vi样式复制和粘贴"><a href="#vi样式复制和粘贴" class="headerlink" title="vi样式复制和粘贴"></a>vi样式复制和粘贴</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># VI copypaste mode</span></span><br><span class="line"><span class="built_in">set</span>-window-option -g mode-keys vi</span><br><span class="line"><span class="built_in">bind</span>-key -t vi-copy <span class="string">'v'</span> begin-selection</span><br><span class="line"><span class="built_in">bind</span>-key -t vi-copy <span class="string">'y'</span> copy-selection</span><br></pre></td></tr></table></figure>
<h3 id="积极调整客户端大小"><a href="#积极调整客户端大小" class="headerlink" title="积极调整客户端大小"></a>积极调整客户端大小</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setw -g aggressive-resize on</span><br></pre></td></tr></table></figure>
<h3 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h3><p>绑定快捷键：<kbd>ctrl</kbd> + <kbd>b</kbd>，<kbd>r</kbd></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> r <span class="built_in">source</span>-file ~/.tmux.conf \; display-message <span class="string">"Config reloaded."</span></span><br></pre></td></tr></table></figure>
<h3 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h3><p>mux允许配置状态行，以显示<code>stdout</code>应用程序的系统信息，窗口列表，甚至管道。</p>
<p>您可以将bash命令传递到tmux状态行，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(shell-command)</span><br></pre></td></tr></table></figure>
<p>因此，如果将<code>/usr/local/bin/tmux-mem-cpu-load</code> stats 输出到<code>stdout</code>，则将<code>$(tmux-mem-cpu-load)</code>第一行输出到状态栏，间隔由<code>status-interval</code>决定:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -g status-interval 1</span><br></pre></td></tr></table></figure>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th>捷径</th>
<th>行动</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b</code></td>
<td>将前缀密钥（Cb）发送到应用程序。</td>
</tr>
<tr>
<td><code>o</code></td>
<td>向前旋转当前窗口中的窗格。</td>
</tr>
<tr>
<td><code>z</code></td>
<td>挂起tmux客户端。</td>
</tr>
<tr>
<td><code>!</code></td>
<td>将当前窗格移出窗口。</td>
</tr>
<tr>
<td><code>&quot;</code></td>
<td>将当前窗格分为两个，顶部和底部。</td>
</tr>
<tr>
<td><code>#</code></td>
<td>列出所有粘贴缓冲区。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>重命名当前会话。</td>
</tr>
<tr>
<td><code>%</code></td>
<td>将当前窗格分为左右两部分。</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>杀死当前窗口。</td>
</tr>
<tr>
<td><code>&#39;</code></td>
<td>提示选择窗口索引。</td>
</tr>
<tr>
<td><code>,</code></td>
<td>重命名当前窗口。</td>
</tr>
<tr>
<td><code>-</code></td>
<td>删除最近复制的文本缓冲区。</td>
</tr>
<tr>
<td><code>.</code></td>
<td>提示输入索引以移动当前窗口。</td>
</tr>
<tr>
<td><code>0 to 9</code></td>
<td>选择窗口0到9。</td>
</tr>
<tr>
<td><code>:</code></td>
<td>输入tmux命令提示符。</td>
</tr>
<tr>
<td><code>;</code></td>
<td>移至先前活动的窗格。</td>
</tr>
<tr>
<td><code>=</code></td>
<td>从列表中选择要交互式粘贴的缓冲区。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>列出所有键绑定。</td>
</tr>
<tr>
<td><code>D</code></td>
<td>选择要分离的客户端。</td>
</tr>
<tr>
<td><code>[</code></td>
<td>进入复制模式以复制文本或查看历史记录。</td>
</tr>
<tr>
<td><code>]</code></td>
<td>粘贴最近复制的文本缓冲区。</td>
</tr>
<tr>
<td><code>c</code></td>
<td>创建一个新窗口。</td>
</tr>
<tr>
<td><code>d</code></td>
<td>分离当前客户端。</td>
</tr>
<tr>
<td><code>f</code></td>
<td>提示在打开的窗口中搜索文本。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>显示有关当前窗口的一些信息。</td>
</tr>
<tr>
<td><code>l</code></td>
<td>移至先前选择的窗口。</td>
</tr>
<tr>
<td><code>n</code></td>
<td>转到下一个窗口。</td>
</tr>
<tr>
<td><code>o</code></td>
<td>选择当前窗口中的下一个窗格。</td>
</tr>
<tr>
<td><code>p</code></td>
<td>转到上一个窗口。</td>
</tr>
<tr>
<td><code>q</code></td>
<td>简要显示窗格索引。</td>
</tr>
<tr>
<td><code>r</code></td>
<td>强制重画连接的客户端。</td>
</tr>
<tr>
<td><code>s</code></td>
<td>以交互方式为连接的客户端选择一个新会话。</td>
</tr>
<tr>
<td><code>L</code></td>
<td>将连接的客户端切换回上一个会话。</td>
</tr>
<tr>
<td><code>t</code></td>
<td>显示时间。</td>
</tr>
<tr>
<td><code>w</code></td>
<td>交互选择当前窗口。</td>
</tr>
<tr>
<td><code>x</code></td>
<td>杀死当前窗格。</td>
</tr>
<tr>
<td><code>{</code></td>
<td>将当前窗格与上一个窗格交换。</td>
</tr>
<tr>
<td><code>}</code></td>
<td>将当前窗格与下一个窗格交换。</td>
</tr>
<tr>
<td><code>~</code></td>
<td>显示来自tmux的先前消息（如果有）。</td>
</tr>
<tr>
<td><code>Page Up</code></td>
<td>进入复印模式并向上滚动一页。</td>
</tr>
<tr>
<td><code>Up, Down</code></td>
<td>切换到上方，下方，左侧或左侧的窗格</td>
</tr>
<tr>
<td><code>Left, Right</code></td>
<td>当前窗格的右侧。</td>
</tr>
<tr>
<td><code>M-1 to M-5</code></td>
<td>将窗格按以下五个预设布局之一进行排列：水平，偶数垂直，水平，主垂直或平铺。</td>
</tr>
<tr>
<td><code>M-n</code></td>
<td>使用铃声或活动标记移动到下一个窗口。</td>
</tr>
<tr>
<td><code>M-o</code></td>
<td>向后旋转当前窗口中的窗格。</td>
</tr>
<tr>
<td><code>M-p</code></td>
<td>使用铃声或活动标记移到上一个窗口。</td>
</tr>
<tr>
<td><code>C-Up, C-Down</code></td>
<td>以一个单元格为单位调整当前窗格的大小。</td>
</tr>
<tr>
<td><code>C-Left, C-Right</code></td>
<td></td>
</tr>
<tr>
<td><code>M-Up, M-Down</code></td>
<td>以五个单元格为单位调整当前窗格的大小。</td>
</tr>
<tr>
<td><code>M-Left, M-Right</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>Effectiveness</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux学习笔记</title>
    <url>/2020/01/27/tmux-study-notes/</url>
    <content><![CDATA[<p><code>tmux</code>对我们的工作流程和<code>vim</code>一样重要，它对于会话和窗口的管理，能更高效的工作。</p>
<h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><p>创建一个名为<code>session_name</code>的新<code>tmux</code>会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -s session_name</span><br></pre></td></tr></table></figure>
<p>将现有<code>tmux</code>会话附加到名为<code>session_name</code>的<code>tmux</code>会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux attach -t session_name</span><br></pre></td></tr></table></figure>
<p>切换到名为<code>session_name</code>的现有会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux switch -t session_name</span><br></pre></td></tr></table></figure>
<p>列出现有<code>tmux</code>会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-sessions</span><br></pre></td></tr></table></figure>
<p>分离当前连接的会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>d</kbd></em></p>
<a id="more"></a>
<h1 id="窗口（Window）管理"><a href="#窗口（Window）管理" class="headerlink" title="窗口（Window）管理"></a>窗口（Window）管理</h1><p><code>tmux</code>具有选项卡界面，称为<code>windows</code>，可以重命名使用的所有窗口，这样，可以通过上线文而不是正在运行的程序来识别窗口。</p>
<p>创建一个新窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new-window</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>c</kbd></em></p>
<p>根据索引移至窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux selsec-window -t :0-9</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>Number(0-9)</kbd></em></p>
<p>重命名当前窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux rename-window</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>,</kbd></em></p>
<h1 id="窗格（Pane）管理"><a href="#窗格（Pane）管理" class="headerlink" title="窗格（Pane）管理"></a>窗格（Pane）管理</h1><p>窗口让我们不必切换应用程序即可切换上下文。</p>
<p>将当前窗口分为两个垂直窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux split-window</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>”</kbd></em></p>
<p>将当前窗口分为两个水平窗口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux split-window -h</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>%</kbd></em></p>
<p>在指定方向上将窗口与另一个交换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux swap-pane -[UDLR]</span><br></pre></td></tr></table></figure>
<p><em>快捷键是：<kbd>control</kbd> + <kbd>b</kbd> ，然后键入<kbd>{</kbd>或<kbd>}</kbd></em></p>
<h1 id="有用的命名"><a href="#有用的命名" class="headerlink" title="有用的命名"></a>有用的命名</h1><p>列出每个绑定:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-keys</span><br></pre></td></tr></table></figure>
<p>列出<code>tmux</code>命令及参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-commands</span><br></pre></td></tr></table></figure>
<p>列出每个会话，窗口，窗格，Pid等:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux info</span><br></pre></td></tr></table></figure>
<p>重新加载当前tmux配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">source</span>-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Terminal</tag>
        <tag>Effectiveness</tag>
      </tags>
  </entry>
  <entry>
    <title>非果粉的MacBook Pro 16开箱</title>
    <url>/2020/01/23/macbook-pro-16-out-of-the-box/</url>
    <content><![CDATA[<font color=red size=6> FBI WARNING </font>

<blockquote>
<p> 本文不含性能测试等，实在懒得整理文字排版，不太会写开箱，会慢慢学习！！！</p>
</blockquote>
<p>  由于几乎没有任何移动办公的需求，这是我第二次买笔记本，第一个还是我上学的时候花2000买的二手HP电磁炉。</p>
<h1 id="为什么买它"><a href="#为什么买它" class="headerlink" title="为什么买它"></a>为什么买它</h1><p>之前办公一直是用一台<em>ThinkPad X260</em>，单位没有台式机，也没接显示器，一直装着Ubuntu，直到手贱Upgrade了一个非LTS版本（18.10），彻底GG以后，才意识到需要一台笔记本了。<img src="https://blog-image.nos-eastchina1.126.net/GoldenCuratorPanda00011.gif" style="zoom:25%;" /></p>
<p>本来是很排斥苹果的产品的（主要是看不惯果粉无脑吹，比如2019下半年美帝良心想的LEGION Y9000X，果粉根本不敢承认别家比他们水果强。逃，</p>
<p>想买败家之眼的GX 701，可是待机时间感人，</p>
<p>后来认怂想买个MAC Mini或者NUC8 i5，但也不能拿着去会议室看方案吧。</p>
<p>最后听了大佬一句劝，说买个最起码能用四年，直接下单了，<img src="https://blog-image.nos-eastchina1.126.net/wmyq.gif" style="zoom:25%;" /></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pz1.png" alt=""><br><a id="more"></a></p>
<h1 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h1><p>先仍一脸图：</p>
<p>不会拍照，见笑了<img src="https://blog-image.nos-eastchina1.126.net/zbzy.jpg" style="zoom:25%;" /></p>
<h2 id="纸箱"><a href="#纸箱" class="headerlink" title="纸箱"></a>纸箱</h2><p><img src="https://blog-image.nos-eastchina1.126.net/macbook-wbz1.JPG" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-wbz2.JPG" alt=""></p>
<p>拍到这的时候我就劝退了，我打开ZF，膜拜了<em>Jones</em>大佬下开箱贴，发现没有工作台可以开箱，大佬们对付看吧（其实还缺相机、技术、开箱刀、灯等等。）</p>
<p><strong>继续丢图</strong></p>
<h2 id="开始撕膜"><a href="#开始撕膜" class="headerlink" title="开始撕膜"></a>开始撕膜</h2><p><img src="https://blog-image.nos-eastchina1.126.net/macbook-wbz3.JPG" alt=""></p>
<p>这边光好暗，我换个位置。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-wbz4.JPG" alt=""></p>
<p>翻个面，撕开外包装透明薄膜：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-kx1.JPG" alt=""></p>
<p>MacBook Pro这颜值我真是欣赏不来，还是MateBook X Pro好看。</p>
<h2 id="配件"><a href="#配件" class="headerlink" title="配件"></a>配件</h2><p>取出本尊，看看还有啥东西。<img src="https://blog-image.nos-eastchina1.126.net/ping999.jpg" style="zoom:50%;" /></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pj1.JPG" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pj2.JPG" alt=""></p>
<p>哪位大佬教我拍<strong>毒</strong>！ <strong>德</strong>味！。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pj3.JPG" alt=""></p>
<p>配件如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配件描述</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>96W 电源适配器</td>
<td>1</td>
</tr>
<tr>
<td>USB-C充电线</td>
<td>1</td>
</tr>
<tr>
<td>Logo贴纸</td>
<td>2</td>
</tr>
<tr>
<td>说明书啥的</td>
<td>1包</td>
</tr>
</tbody>
</table>
</div>
<p>没啥小心意（没买过苹果）。<img src="https://blog-image.nos-eastchina1.126.net/glgj.gif" style="zoom:50%;" /></p>
<p>放一起拍个照吧。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-hz1.JPG" alt=""></p>
<h2 id="MacBook"><a href="#MacBook" class="headerlink" title="MacBook"></a>MacBook</h2><p>这东西这么沉，这么贵，咱们打开看看。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pm1.JPG" alt=""></p>
<p>这个膜还行，拿掉看看边框</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pm2.JPG" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-pm3.JPG" alt=""></p>
<p>这个电脑给我的直观感受就是又大，又长… 对又沉。</p>
<p>给键盘一个特写吧。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-jp1.JPG" alt=""></p>
<h1 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h1><p>整半天才开开机，可还行。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-kj1.JPG" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-kj2.JPG" alt=""></p>
<p>一路下一步，吐槽一下，电脑密码不能跟<code>Apple ID</code>的密码一样。</p>
<hr>
<p>配置了几天，<code>touch bar</code>用处不大。</p>
<h2 id="Touch-Bar"><a href="#Touch-Bar" class="headerlink" title="Touch Bar"></a>Touch Bar</h2><p><img src="https://blog-image.nos-eastchina1.126.net/macbook-touch1.jpg" alt=""></p>
<p>这个东西适配也不是特别好，只能去社区找一些随便玩玩，毕竟不是必需品，玩玩还行。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-touch2.jpg" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-touch3.jpg" alt=""></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-touch4.jpg" alt=""></p>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>系统学习成本有点高，还需要找时间慢慢了解，</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-xt1.png" alt=""></p>
<p>桌面也没换呢：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-zm.png" alt=""></p>
<p>iTerm先能用再说：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/macbook-jk.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>音响很好，笔记本中算是第一梯队了，六扬声器音响可真不错。</li>
<li>边框相对之前的版本要好很多了。</li>
<li>回归剪刀脚键盘手感是好了些。</li>
<li>指纹很灵敏</li>
<li>实体<kbd>ESC</kbd>解决了前几款<code>Touch Bar</code>的尴尬。</li>
<li>触摸板从精准度和手势来说，都很强，但有学习成本。</li>
<li>屏幕色彩</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>系统没有什么特别，之前说它比windows好还行，与现阶段的Win10相比，只能说各有输赢，所以求你们别吹MacOS了。</li>
<li>续航一般</li>
<li>温度感人（Chrome瞬间爆炸）</li>
<li>贵</li>
<li>不支持WiFi6</li>
</ol>
<p><del>真正的粉丝，对品牌和产品都很了解，对一个产品的优点缺点都有很明确的认识，知道它适用的范围，不会胡乱传播品牌信仰。</del></p>
<p><del>真粉是从用户角度出发的，所以真粉一般只说缺点，很少说优点，真粉已经为优点掏了自己的真金白银，因此产品有优点是理所当然的，还用吹吗？</del></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/pkq.gif"  style="zoom:50%;" /></p>
<p><del>假的粉丝，完全凭感觉讲述产品，认为感觉好的产品就是完美的，不接受“产品有缺点”的说法。</del></p>
<p><del>所以，真粉的特点总结两句话：产品有优点买买买，产品有缺点骂骂骂。</del></p>
<p>我加了删除线，最后寄出老罗保我平安。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/sgpg.gif"  style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Toys</category>
      </categories>
      <tags>
        <tag>apple</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IaC实现简单的网络自动化</title>
    <url>/2019/12/28/Networking/NetOps/Network-automation-using-IaC/</url>
    <content><![CDATA[<p>基础架构即代码意味着编写代码来配置，管理和部署IT基础架构，这种概念以下几项关键原则：</p>
<ul>
<li>可再生性：基础环境中的任意元素可以再现，复制。</li>
<li>一致性：无论何时，创建在环境各个元素的配置是完全相同的。</li>
<li>快速反馈：能够频繁、简单地进行变更。</li>
<li>可见性：所有对环境的变更都更易读、可接受版本控制的管理。</li>
</ul>
<p>通过IaC，可以将基础设施中的元素和配置标准化、自动化，将基础设施作为软件开发流程中的一个功能，一段代码，实现基础设施的pipeline，从而最终实现CI/CD，NetOps以及DevOps。</p>
<p>本文主要描述配置的声明以及下发示例，通过<code>Ansible</code>和<code>Terraform</code>两种IaC工具，通过<code>Netconf over SSH</code>协议对正在运行<code>JunOS</code>的网络设备进行配置的下发，后期会慢慢记录Pipeline的实现（还没弄）。<br><a id="more"></a></p>
<h1 id="用到的协议和工具"><a href="#用到的协议和工具" class="headerlink" title="用到的协议和工具"></a>用到的协议和工具</h1><ul>
<li><p>Netconf</p>
<p>NETCONF是IETF定义的“安装，操作和删除网络设备的配置”的协议。NETCONF操作是使用XML编码在远程过程调用（RPC）层之上实现的，并且提供了一组基本操作来编辑和查询网络设备上的配置。</p>
<p>在NETCONF之前，CLI脚本是对网络进行自动配置更改的主要方法。CLI脚本具有一些局限性，包括缺乏事务管理，没有结构化的错误管理以及不断变化的命令结构和语法，这使得脚本脆弱且维护成本很高。这些都是因为CLI旨在供人类使用而不是用于程序访问的API的基本事实的所有副作用。</p>
<p>NETCONF协议旨在解决配置管理的现有实践和协议的缺点。在2002 IAB网络管理研讨会的<a href="http://tools.ietf.org/html/rfc3535" target="_blank" rel="noopener">RFC 3535</a>概述中记录了设计阶段之前的背景工作。该工作的设计目标包括：</p>
<ul>
<li>配置和状态数据之间的区别</li>
<li>多个配置数据存储（候选，运行，启动）</li>
<li>配置变更交易</li>
<li>配置测试和验证支持</li>
<li>通过过滤进行选择性数据检索</li>
<li>流和事件通知的播放</li>
<li>可扩展过程调用机制</li>
</ul>
</li>
<li><p>Ansible</p>
<p>Ansible是一个简单的开源软件自动化平台，负责应用程序部署，配置管理，临时任务执行和多节点编排。Ansible本身是用Python编写的，学习曲线相当小。Ansible遵循简单的设置过程，并且不依赖于任何其他软件，服务器或客户端守护程序。它通过SSH管理节点，并且默认情况下是并行的。</p>
</li>
<li><p>Terraform</p>
<p>是一个IT基础架构自动化编排工具，可以用代码来管理维护IT资源（暂时没有支持JunOS的provider，希望官方或大佬完善，目前只在Github找到一个简单的实现，这里用作示范）。</p>
</li>
<li><p>PyEZ</p>
<p>Junos PyEZ是Python的微框架，使您可以管理和自动化运行Junos操作系统（Junos OS）的设备。 Junos PyEZ旨在在为自动化任务构建的环境中提供用户在Junos OS命令行界面（CLI）上所具有的功能。 </p>
</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p><img src="https://blog-image.nos-eastchina1.126.net/g200220.png" alt=""></p>
<p><em>图片摘自Juniper.net</em></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>虽然<code>Terraform</code>可以跨平台，但是<code>Ansible</code>并不支持<code>Windows</code>，所以我们要准备一台Linux（有Macbook就不用啦，逃。</p>
<p>所以我们需要准备以下资源：</p>
<ol>
<li>一台非Windows系统的Controller</li>
<li>一个运行着JunOS的机器（我这边下载一个vSRX）</li>
<li>一个可以互相通信的网络</li>
</ol>
<p>对应的IP地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组件</th>
<th>OS</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ansible&amp;&amp;Terraform控制节点</td>
<td>CentOS7</td>
<td>192.168.1.139</td>
</tr>
<tr>
<td>Juniper vSRX</td>
<td>FreeBSD</td>
<td>192.168.1.105</td>
</tr>
</tbody>
</table>
</div>
<h2 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h2><h3 id="对于控制节点"><a href="#对于控制节点" class="headerlink" title="对于控制节点"></a>对于控制节点</h3><p>所有的请求需要基于SSH协议，虽然Ansible支持在配置文件中声明主机密码变量以及交互式输入密码，但由于JunOS运行在BSD系统上，为了减少奇怪的问题，所以配置SSH免密登陆（生产环境也建议这样）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成SSH认证密钥对</span></span><br><span class="line">ssh-keygen </span><br><span class="line"><span class="comment"># 安装软件Ansible所需的软件,pip版本取决于Ansible使用哪个版本的Python解释器，CentOS7默认是python2</span></span><br><span class="line">yum -y install python ansible python2-pip python3-pip </span><br><span class="line"><span class="comment"># 安装 pip模块</span></span><br><span class="line">pip install ncclient netconf junos-eznc jxmlease</span><br><span class="line"><span class="comment"># 安装 Juniper.junos 的ansible-galaxy Role</span></span><br><span class="line">ansible-galaxy install git+https://github.com/Juniper/ansible-junos-stdlib.git,,Juniper.junos</span><br><span class="line"><span class="comment"># terraform 安装略，二进制文件，直接放在$PATH里面就可以。</span></span><br></pre></td></tr></table></figure>
<h3 id="对于vSRX"><a href="#对于vSRX" class="headerlink" title="对于vSRX"></a>对于vSRX</h3><blockquote>
<p>控制节点已事先SSH密钥对。</p>
</blockquote>
<p>所有的请求需要基于SSH协议，所以需要先开启SSH，以及Netconf，以及一个专用于Netconf的用户，这里临时使用root用作演示，生产环境请不要使用root，应单独声明用户Netconf的用户，且不支持密码登陆，仅允许SSH密钥登陆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启SSH</span></span><br><span class="line"><span class="comment"># cli模式下执行</span></span><br><span class="line">configure <span class="comment"># 软件配置模式</span></span><br><span class="line"><span class="built_in">set</span> system services ssh</span><br><span class="line"><span class="built_in">set</span> system services netconf ssh </span><br><span class="line"><span class="built_in">set</span> system services ssh root-login allow <span class="comment"># 生产请勿使用root</span></span><br><span class="line">commit <span class="comment"># 提交</span></span><br><span class="line">start shell <span class="comment"># 进入shell模式</span></span><br><span class="line"><span class="comment"># shell模式下执行</span></span><br><span class="line">scp 192.168.1.139:/root/.ssh/id_rsa.pub /tmp/ <span class="comment"># copy公钥到本地</span></span><br><span class="line">cli <span class="comment"># 进入cli模式</span></span><br><span class="line"><span class="comment"># cli模式下执行</span></span><br><span class="line">configure <span class="comment"># 软件配置模式</span></span><br><span class="line"><span class="built_in">set</span> system root-authentication load-key-file /tmp/id_rsa.pub <span class="comment"># 免密登陆</span></span><br><span class="line"><span class="comment"># 非root用户请执行：set system login user ...</span></span><br><span class="line">commit <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure>
<p><em>现在使用控制节点测试root登陆是否已经不需要输入密码</em></p>
<h1 id="Ansible配置"><a href="#Ansible配置" class="headerlink" title="Ansible配置"></a>Ansible配置</h1><p>ansible主要有两个配置文件：</p>
<ol>
<li><code>ansible.cfg</code> ,Ansible的配置文件，定义Ansible的行为。未指定的情况下，默认使用<code>/etc/ansible/ansible.cfg</code></li>
<li>hosts，Ansible的清单文件，用来描述受管节点信息。未指定的情况下，默认使用<code>/etc/ansible/hosts</code></li>
</ol>
<p>首先我们先修改<code>/etc/ansible/ansible.cfg</code> 指定刚才生成的SSH密钥：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># if set, always use this private key file for authentication, same as</span></span><br><span class="line"><span class="comment"># if passing --private-key to ansible or ansible-playbook</span></span><br><span class="line"><span class="attr">private_key_file</span> = /root/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<p>然后将vSRX声明到<code>/etc/ansible/hosts</code>这个默认的清单文件中：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[junos]</span></span><br><span class="line">192.168.1.105</span><br><span class="line"><span class="section">[junos:vars]</span></span><br><span class="line"><span class="attr">ansible_connection</span>=netconf</span><br><span class="line"><span class="attr">ansible_network_os</span>=junos</span><br><span class="line"><span class="attr">ansible_user</span>=root</span><br><span class="line"><span class="attr">ansible_ssh_common_args</span>=<span class="string">'-o ProxyCommand="ssh -W %h:%p -q bastion01"'</span></span><br></pre></td></tr></table></figure>
<p>这里我定义了一个名为junos的<code>group</code>，包含一台主机，主机的IP地址是<code>192.168.1.105</code>，同时定义了仅对junos这个<code>group</code>生效的变量。</p>
<h2 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h2><p>Ansible的Playbook是<code>yaml</code>格式的声明式文本文件，可以定义多项操作，下面几个示例可以体验一下。</p>
<h3 id="banner"><a href="#banner" class="headerlink" title="banner"></a>banner</h3><p>首先玩个玩具，也是最简单的，登陆设备的横幅：</p>
<p>写一个，<code>Welcome To HIT-IDC</code>，这时候需要一个神器，<a href="http://www.network-science.de/ascii" target="_blank" rel="noopener">ascii Generator</a>。输入想要变成ASCII的文字，然后粘贴到文本中，命名为<code>/opt/junos-ansible/banner.cfg</code>。</p>
<p>然后写一个简单<code>playbook</code>，命名为<code>banner.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Gather</span> <span class="string">facts</span> <span class="string">from</span> <span class="string">Junos</span> <span class="string">devices</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">banner</span> <span class="string">from</span> <span class="string">file</span></span><br><span class="line">    <span class="attr">junos_banner:</span></span><br><span class="line">      <span class="attr">banner:</span>  <span class="string">motd</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">"<span class="template-variable">&#123;&#123; lookup('file', '/opt/junos-ansible/banner.cfg') &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure>
<p>我们执行这个剧本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook banner.yaml</span><br></pre></td></tr></table></figure>
<p>现在登陆设备，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Last login: Fri Dec 13 17:30:53 2019 from 192.168.1.171</span><br><span class="line">--- JUNOS 19.3R2.9 Kernel 64-bit  JNPR-11.0-20191120.0ebd4bf_buil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">||   / |  / /</span><br><span class="line">||  /  | / /  ___     //  ___      ___      _   __      ___</span><br><span class="line">|| / /||/ / //___) ) // //   ) ) //   ) ) // ) )  ) ) //___) )</span><br><span class="line">||/ / |  / //       // //       //   / / // / /  / / //</span><br><span class="line">|  /  | / ((____   // ((____   ((___/ / // / /  / / ((____</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /__  ___/</span><br><span class="line">   / /   ___</span><br><span class="line">  / /  //   ) )</span><br><span class="line"> / /  //   / /</span><br><span class="line">/ /  ((___/ /</span><br><span class="line"></span><br><span class="line">             ___   ___               ___   ___</span><br><span class="line">    //    / /   / / /__  ___/           / /    //    ) ) //   ) )</span><br><span class="line">   //___ / /   / /    / /              / /    //    / / //</span><br><span class="line">  / ___   /   / /    / /      ____    / /    //    / / //</span><br><span class="line"> //    / /   / /    / /              / /    //    / / //</span><br><span class="line">//    / / __/ /___ / /            __/ /___ //____/ / ((____/ /test_user1@juniper-vsrx-01&gt;</span><br><span class="line"></span><br><span class="line">test_user1@juniper-vsrx-01&gt;</span><br></pre></td></tr></table></figure>
<h4 id="升级JunOS"><a href="#升级JunOS" class="headerlink" title="升级JunOS"></a>升级JunOS</h4><p>首先下载对应的包放在本地，当然也可以放在设备的文件系统上，这个看需求，示例中放在本地：</p>
<p>将文件放在<code>/opt/junos-ansible/junos-vsrx-x86-64-19.3R2.9.tgz</code>。</p>
<p>然后再次编写一个playbook，名为<code>install-os.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Junos</span> <span class="string">OS</span> <span class="comment"># 剧本名称</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span>  <span class="comment"># 配置的组</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span>  <span class="comment"># 调用的roles</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span> <span class="comment"># 连接方式</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">vars:</span>     <span class="comment"># 变量，不解释了</span></span><br><span class="line">    <span class="attr">OS_version:</span> <span class="string">"19.3R2.9"</span></span><br><span class="line">    <span class="attr">OS_package:</span> <span class="string">"junos-vsrx-x86-64-19.3R2.9.tgz"</span></span><br><span class="line">    <span class="attr">pkg_dir:</span> <span class="string">"/opt/junos-ansible"</span></span><br><span class="line">    <span class="attr">log_dir:</span> <span class="string">"/var/log/ansible"</span></span><br><span class="line">    <span class="attr">netconf_port:</span> <span class="number">830</span></span><br><span class="line">    <span class="attr">wait_time:</span> <span class="number">3600</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span>  <span class="comment"># 定义多个任务</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checking</span> <span class="string">NETCONF</span> <span class="string">connectivity</span> <span class="comment"># 任务名称</span></span><br><span class="line">      <span class="attr">wait_for:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">"<span class="template-variable">&#123;&#123; inventory_hostname &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">"<span class="template-variable">&#123;&#123; netconf_port &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="number">5</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Junos</span> <span class="string">OS</span> <span class="string">package</span>  <span class="comment"># 任务名称</span></span><br><span class="line">      <span class="attr">juniper_junos_software:</span> <span class="comment"># 调用的modules</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">"<span class="template-variable">&#123;&#123; OS_version &#125;&#125;</span>"</span> <span class="comment"># 传入vars中定义的变量值</span></span><br><span class="line">        <span class="attr">local_package:</span> <span class="string">"<span class="template-variable">&#123;&#123; pkg_dir &#125;&#125;</span>/<span class="template-variable">&#123;&#123; OS_package &#125;&#125;</span>"</span> <span class="comment"># 包的路径</span></span><br><span class="line">        <span class="attr">reboot:</span> <span class="literal">true</span> <span class="comment"># 是否重启</span></span><br><span class="line">        <span class="attr">validate:</span> <span class="literal">true</span> <span class="comment"># 是否验证</span></span><br><span class="line">        <span class="attr">cleanfs:</span> <span class="literal">true</span> <span class="comment"># 是否清理文件系统</span></span><br><span class="line">        <span class="attr">logfile:</span> <span class="string">"<span class="template-variable">&#123;&#123; log_dir &#125;&#125;</span>/software.log"</span> <span class="comment"># 日志位置</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">sw</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wait_reboot</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Print</span> <span class="string">response</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">response</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wait_reboot</span></span><br><span class="line">      <span class="attr">wait_for:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">"<span class="template-variable">&#123;&#123; inventory_hostname &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">"<span class="template-variable">&#123;&#123; netconf_port &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="string">"<span class="template-variable">&#123;&#123; wait_time &#125;&#125;</span>"</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">not</span> <span class="string">sw.check_mode</span></span><br></pre></td></tr></table></figure>
<p> 我在playbook中描述了大概的注释，运行的时候，请先把注释删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook install-os.yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不知道vSRX什么情况，不能升级，但是我在硬件设备都成功了。</p>
</blockquote>
<p>现在可以看到，JunOS已经倒计时重启，开机后可以执行<code>show version</code></p>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>这里我们将演示如何创建用户：</p>
<p>编写名为<code>user.yaml</code>的<code>playbook</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">User</span> <span class="string">On</span> <span class="string">Junos</span> <span class="string">OS</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">list</span> <span class="string">of</span> <span class="string">users</span></span><br><span class="line">      <span class="attr">junos_user:</span></span><br><span class="line">        <span class="attr">aggregate:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">test_user1,</span> <span class="attr">full_name:</span> <span class="string">test_user2,</span> <span class="attr">role:</span> <span class="string">operator,</span> <span class="attr">state:</span> <span class="string">present&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">test_user2,</span> <span class="attr">full_name:</span> <span class="string">test_user2,</span> <span class="attr">role:</span> <span class="string">read-only,</span> <span class="attr">state:</span> <span class="string">present&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">user1</span> <span class="string">password</span></span><br><span class="line">      <span class="attr">junos_user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test_user1</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">super-user</span></span><br><span class="line">        <span class="attr">encrypted_password:</span> <span class="string">"<span class="template-variable">&#123;&#123; 'my-passwordsdf' | password_hash('sha512') &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">set</span> <span class="string">user2</span> <span class="string">password</span></span><br><span class="line">      <span class="attr">junos_user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test_user2</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">super-user</span></span><br><span class="line">        <span class="attr">encrypted_password:</span> <span class="string">"<span class="template-variable">&#123;&#123; 'my-password43' | password_hash('sha512') &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure>
<p>然后执行这个<code>playbook</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook user.yaml</span><br></pre></td></tr></table></figure>
<p>这将在名为<code>junos</code>的<code>group</code>中创建这些用户，并设置角色和密码。</p>
<p><code>playbook</code>运行完成后，可以登陆设备测试。</p>
<h3 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h3><p>这里再次编写<code>playbook</code>，命名为<code>get-config.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get Junos OS configuration."</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get committed configuration"</span></span><br><span class="line">      <span class="attr">juniper_junos_config:</span></span><br><span class="line">        <span class="attr">retrieve:</span> <span class="string">"committed"</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">response</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Print result"</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">response</span></span><br></pre></td></tr></table></figure>
<p>这将获取设备的配置的信息，也可以将其保存为其他格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get Junos OS configuration."</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span> </span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get configuration in XML format"</span></span><br><span class="line">      <span class="attr">juniper_junos_config:</span></span><br><span class="line">        <span class="attr">retrieve:</span> <span class="string">"committed"</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">"xml"</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">response</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Print result"</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">var:</span> <span class="string">response</span></span><br></pre></td></tr></table></figure>
<p>也可以保存到文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get Junos OS configuration."</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span> </span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get selected configuration hierarchies and save to file"</span></span><br><span class="line">      <span class="attr">juniper_junos_config:</span></span><br><span class="line">        <span class="attr">retrieve:</span> <span class="string">"committed"</span></span><br><span class="line">        <span class="attr">filter:</span> <span class="string">"system/services"</span></span><br><span class="line">        <span class="attr">dest_dir:</span> <span class="string">"<span class="template-variable">&#123;&#123; playbook_dir &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure>
<p>这将保存过滤后的配置信息到本地，内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">system &#123;</span><br><span class="line">    services &#123;</span><br><span class="line">        ssh &#123;</span><br><span class="line">            root-login allow;</span><br><span class="line">            sftp-server;</span><br><span class="line">            hostkey-algorithm &#123;</span><br><span class="line">                ssh-rsa;</span><br><span class="line">                no-ssh-ecdsa;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        netconf &#123;</span><br><span class="line">            ssh;</span><br><span class="line">        &#125;</span><br><span class="line">        web-management &#123;</span><br><span class="line">            http;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对交换机执行<code>set</code>以及<code>delete</code>类的配置</p>
<p>编写示例文件<code>config-irb.10.yaml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"Get Junos OS configuration."</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">junos</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Juniper.junos</span></span><br><span class="line">  <span class="attr">connection:</span> <span class="string">netconf</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">load</span> <span class="string">configure</span> <span class="string">lines</span> <span class="string">into</span> <span class="string">device</span></span><br><span class="line">    <span class="attr">junos_config:</span></span><br><span class="line">      <span class="attr">lines:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">set</span> <span class="string">interfaces</span> <span class="string">ge-0/0/1</span> <span class="string">unit</span> <span class="number">0</span> <span class="string">description</span> <span class="string">"Test interface"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">set</span> <span class="string">vlans</span> <span class="string">vlan01</span> <span class="string">description</span> <span class="string">"Test vlan"</span></span><br><span class="line">      <span class="attr">comment:</span> <span class="string">update</span> <span class="string">config</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">routed</span> <span class="string">VLAN</span> <span class="string">interface</span> <span class="string">(RVI)</span> <span class="string">IPv4</span> <span class="string">address</span></span><br><span class="line">    <span class="attr">junos_config:</span></span><br><span class="line">      <span class="attr">lines:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">set</span> <span class="string">vlans</span> <span class="string">vlan01</span> <span class="string">vlan-id</span> <span class="number">1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">set</span> <span class="string">interfaces</span> <span class="string">irb</span> <span class="string">unit</span> <span class="number">10</span> <span class="string">family</span> <span class="string">inet</span> <span class="string">address</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">/24</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">set</span> <span class="string">vlans</span> <span class="string">vlan01</span> <span class="string">l3-interface</span> <span class="string">irb.10</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">correctness</span> <span class="string">of</span> <span class="string">commit</span> <span class="string">configuration</span></span><br><span class="line">    <span class="attr">junos_config:</span></span><br><span class="line">      <span class="attr">check_commit:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>然后让我们登陆到JunOS上查看配置是否已经生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show |compare rollback 1</span><br></pre></td></tr></table></figure>
<p>回显如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[edit interfaces]</span><br><span class="line">+   irb &#123;</span><br><span class="line">+       unit 10 &#123;</span><br><span class="line">+           family inet &#123;</span><br><span class="line">+               address 10.0.0.1/24;</span><br><span class="line">+           &#125;</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125;</span><br><span class="line">[edit vlans vlan01]</span><br><span class="line">+   vlan-id 1;</span><br><span class="line">+   l3-interface irb.10;</span><br></pre></td></tr></table></figure>
<p>不多介绍功能了，这些功能主要是名为<code>Juniper.junos</code>的Ansible-Galaxy Role，以及Ansible的<code>junos</code>模块，这些依赖于<code>netconf</code>以及<code>JunOS PyEz</code>，以下是对应的文档地址：</p>
<p><a href="https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#junos" target="_blank" rel="noopener">Ansible Junos</a></p>
<p><a href="https://github.com/Juniper/ansible-junos-stdlib" target="_blank" rel="noopener">Ansible-Galaxy Juniper.junos</a></p>
<p><a href="https://junos-ansible-modules.readthedocs.io/en/2.3.0/index.html" target="_blank" rel="noopener">Docs for Juniper.junos</a></p>
<p>具体参数可以查看这几份文档。</p>
<h2 id="Terraform-丝滑体验"><a href="#Terraform-丝滑体验" class="headerlink" title="Terraform 丝滑体验"></a>Terraform 丝滑体验</h2><p><code>Ansible</code>虽然算是比较简单的了，但是对于<code>Jinja2</code>模板变量的编写还是相对难上手的，但<code>Terraform</code>的变量声明可以算是一股清流。</p>
<p>逛论坛和Google半个月也没找到有关Juniper的<code>Terraform Provider</code>，社区插件都没有，Github上倒是找到了一个，不过不太完美，不敢用在生产，这里只做演示，希望以后官方或社区可以贡献一份生产可用的<code>Terraform Provider</code>。</p>
<h2 id="安装Terraform"><a href="#安装Terraform" class="headerlink" title="安装Terraform"></a>安装Terraform</h2><ul>
<li><p>下载<a href="https://releases.hashicorp.com/terraform/0.12.18/terraform_0.12.18_linux_amd64.zip" target="_blank" rel="noopener">二进制文件</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://releases.hashicorp.com/terraform/0.12.18/terraform_0.12.18_linux_amd64.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压到<code>/usr/sbin/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip terraform_0.12.18_linux_amd64.zip -d /usr/sbin/</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试执行<code>terraform --version</code></p>
</li>
</ul>
<h2 id="安装Junos-Priovider（不建议生产，非官方，非社区插件）"><a href="#安装Junos-Priovider（不建议生产，非官方，非社区插件）" class="headerlink" title="安装Junos Priovider（不建议生产，非官方，非社区插件）"></a>安装Junos Priovider（不建议生产，非官方，非社区插件）</h2><ul>
<li><p>下载<a href="https://github.com/jeremmfr/terraform-provider-junos/releases" target="_blank" rel="noopener">二进制文件</a></p>
</li>
<li><p>解压到<code>/usr/sbin/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tfPath=$(<span class="built_in">which</span> terraform | rev | cut -d<span class="string">'/'</span> -f2- | rev)</span><br><span class="line">tar -zxvf terraform-provider-junos*.tar.gz -C <span class="variable">$&#123;tfPath&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="配置-Terraform的JunOS-Provider"><a href="#配置-Terraform的JunOS-Provider" class="headerlink" title="配置 Terraform的JunOS Provider"></a>配置 Terraform的JunOS Provider</h2><p>与<code>Ansible</code>相同，需要在运行<code>JunOS</code>的设备上开启<code>ssh</code>以及<code>netconf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> system services netconf</span><br><span class="line"><span class="built_in">set</span> system login user netconf uid 200?</span><br><span class="line"><span class="built_in">set</span> system login user netconf class xxx</span><br><span class="line"><span class="built_in">set</span> system login user netconf authentication load-key-file /tmp/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Terraform会读取当前目录下的所有以<code>.tf</code>结尾的文件。</p>
<p>首先先创建一个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -pv /opt/terraform-junos-example</span><br><span class="line"><span class="built_in">cd</span> /opt/terraform-junos-example</span><br><span class="line">touch junos-example.tf</span><br></pre></td></tr></table></figure>
<p>现在开始声明 junos-example.tf文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Configure the Junos Provider</span></span><br><span class="line"><span class="string">provider</span> <span class="string">"junos"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">ip</span>         <span class="string">=</span> <span class="string">"192.168.1.105"</span></span><br><span class="line">  <span class="string">username</span> <span class="string">=</span> <span class="string">"root"</span></span><br><span class="line">  <span class="string">sshkeyfile</span> <span class="string">=</span> <span class="string">"/root/.ssh/id_rsa"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a application</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_application</span> <span class="string">"mysql"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>             <span class="string">=</span> <span class="string">"mysql"</span></span><br><span class="line">  <span class="string">protocol</span>         <span class="string">=</span> <span class="string">"tcp"</span></span><br><span class="line">  <span class="string">destination_port</span> <span class="string">=</span> <span class="string">"3306"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a set of applications</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_application_set</span> <span class="string">"ssh_telnet"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>         <span class="string">=</span> <span class="string">"ssh_telnet"</span></span><br><span class="line">  <span class="string">applications</span> <span class="string">=</span> <span class="string">["junos-ssh",</span> <span class="string">"junos-telnet"</span><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure interface of switch</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_interface</span> <span class="string">"interface_switch_demo"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>         <span class="string">=</span> <span class="string">"ge-0/0/0"</span></span><br><span class="line">  <span class="string">description</span>  <span class="string">=</span> <span class="string">"interfaceSwitchDemo"</span></span><br><span class="line">  <span class="string">trunk</span>        <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">vlan_members</span> <span class="string">=</span> <span class="string">["100",</span> <span class="string">"101"</span><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vlan</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_vlan</span> <span class="string">"blue"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>        <span class="string">=</span> <span class="string">"blue"</span></span><br><span class="line">  <span class="string">description</span> <span class="string">=</span> <span class="string">"blue-10"</span></span><br><span class="line">  <span class="string">vlan_id</span>     <span class="string">=</span> <span class="number">10</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configure a L3 interface on Junos Router or firewall</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_interface</span> <span class="string">"interface_fw_demo"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>         <span class="string">=</span> <span class="string">"ge-0/0/0"</span></span><br><span class="line">  <span class="string">description</span>  <span class="string">=</span> <span class="string">"interfaceFwDemo"</span></span><br><span class="line">  <span class="string">vlan_tagging</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_interface</span> <span class="string">"interface_fw_demo_100"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>        <span class="string">=</span> <span class="string">"$&#123;junos_interface.interface_fw_demo.name&#125;.100"</span></span><br><span class="line">  <span class="string">description</span> <span class="string">=</span> <span class="string">"interfaceFwDemo100"</span></span><br><span class="line">  <span class="string">inet_address</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">address</span> <span class="string">=</span> <span class="string">"192.0.2.1/25"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a destination nat pool</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_nat_destination_pool</span> <span class="string">"demo_dnat_pool"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>    <span class="string">=</span> <span class="string">"ip_internal"</span></span><br><span class="line">  <span class="string">address</span> <span class="string">=</span> <span class="string">"192.0.2.2/32"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a destination nat</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_nat_destination</span> <span class="string">"demo_dnat"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span> <span class="string">=</span> <span class="string">"dnat_from_untrust"</span></span><br><span class="line">  <span class="string">from</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">type</span>  <span class="string">=</span> <span class="string">"zone"</span></span><br><span class="line">    <span class="string">value</span> <span class="string">=</span> <span class="string">["untrust"]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">rule</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span>                <span class="string">=</span> <span class="string">"nat_192_0_2_129"</span></span><br><span class="line">    <span class="string">destination_address</span> <span class="string">=</span> <span class="string">"192.0.2.129/32"</span></span><br><span class="line">    <span class="string">then</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">type</span> <span class="string">=</span> <span class="string">"pool"</span></span><br><span class="line">      <span class="string">pool</span> <span class="string">=</span> <span class="string">"pool_trust"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a source nat pool</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_nat_source_pool</span> <span class="string">"demo_snat_pool"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>    <span class="string">=</span> <span class="string">"ip_external"</span></span><br><span class="line">  <span class="string">address</span> <span class="string">=</span> <span class="string">["192.0.2.129/32"]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="comment"># Add a source nat</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_nat_source</span> <span class="string">"demo_snat"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span> <span class="string">=</span> <span class="string">"nat_from_trust_to_untrust"</span></span><br><span class="line">  <span class="string">from</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">type</span>  <span class="string">=</span> <span class="string">"zone"</span></span><br><span class="line">    <span class="string">value</span> <span class="string">=</span> <span class="string">["trust"]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">to</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">type</span>  <span class="string">=</span> <span class="string">"zone"</span></span><br><span class="line">    <span class="string">value</span> <span class="string">=</span> <span class="string">["untrust"]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">rule</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span> <span class="string">=</span> <span class="string">"nat_192_0_2_0_25"</span></span><br><span class="line">    <span class="string">match</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">source_address</span> <span class="string">=</span> <span class="string">["192.0.2.0/25"]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">then</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">type</span> <span class="string">=</span> <span class="string">"pool"</span></span><br><span class="line">      <span class="string">pool</span> <span class="string">=</span> <span class="string">"pool_untrust"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a static nat</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_nat_static</span> <span class="string">"demo_nat"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span> <span class="string">=</span> <span class="string">"nat_from_trust"</span></span><br><span class="line">  <span class="string">from</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">type</span>  <span class="string">=</span> <span class="string">"zone"</span></span><br><span class="line">    <span class="string">value</span> <span class="string">=</span> <span class="string">["trust"]</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">rule</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span>                <span class="string">=</span> <span class="string">"nat_192_0_2_0_25"</span></span><br><span class="line">    <span class="string">destination_address</span> <span class="string">=</span> <span class="string">"192.0.2.0/25"</span></span><br><span class="line">    <span class="string">then</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">type</span>   <span class="string">=</span> <span class="string">"prefix"</span></span><br><span class="line">      <span class="string">prefix</span> <span class="string">=</span> <span class="string">"192.0.2.128/25"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a security policy</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_policy</span> <span class="string">"demo_policy"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">from_zone</span> <span class="string">=</span> <span class="string">"trust"</span></span><br><span class="line">  <span class="string">to_zone</span>   <span class="string">=</span> <span class="string">"untrust"</span></span><br><span class="line">  <span class="string">policy</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span>                      <span class="string">=</span> <span class="string">"allow_trust"</span></span><br><span class="line">    <span class="string">match_source_address</span>      <span class="string">=</span> <span class="string">["any"]</span></span><br><span class="line">    <span class="string">match_destination_address</span> <span class="string">=</span> <span class="string">["any"]</span></span><br><span class="line">    <span class="string">match_application</span>         <span class="string">=</span> <span class="string">["any"]</span></span><br><span class="line">    <span class="string">then</span>                      <span class="string">=</span> <span class="string">"permit"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a security zone</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_security_zone</span> <span class="string">"demo_zone"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">name</span>              <span class="string">=</span> <span class="string">"DemoZone"</span></span><br><span class="line">  <span class="string">inbound_protocols</span> <span class="string">=</span> <span class="string">["bgp"]</span></span><br><span class="line">  <span class="string">address_book</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">name</span>    <span class="string">=</span> <span class="string">"DemoAddress"</span></span><br><span class="line">    <span class="string">network</span> <span class="string">=</span> <span class="string">"192.0.2.0/25"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a static route</span></span><br><span class="line"><span class="string">resource</span> <span class="string">junos_static_route</span> <span class="string">"demo_static_route"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">destination</span>      <span class="string">=</span> <span class="string">"192.0.2.0/25"</span></span><br><span class="line">  <span class="string">routing_instance</span> <span class="string">=</span> <span class="string">"prod-vr"</span></span><br><span class="line">  <span class="string">next_hop</span>         <span class="string">=</span> <span class="string">["st0.0"]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">terraform init</span><br></pre></td></tr></table></figure>
<p>然后构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">terraform apply</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个插件逻辑不太通，所以使用的时候需要浪费很多时间调试。</p>
</blockquote>
<h1 id="如何实现CI-CD"><a href="#如何实现CI-CD" class="headerlink" title="如何实现CI/CD"></a>如何实现CI/CD</h1><p>首先得现有一个CI工具，主流的就是<code>Jenkins</code>，这个还在犹豫，想尝试一下<code>Drone</code>或者<code>Tekton</code>，在Pipeline上调用插件，<code>Ansible</code>或是<code>Terraform</code>，使用git进行版本控制，最后实现业务从申请到上线，不需要人肉传递信息，只需要审批流程+n个动作，不需要或很少需要人工干预实现业务上线，就类似这样：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/8-ci-cd-using-hashicorp-terraform-and-jenkins.png" alt=""></p>
]]></content>
      <categories>
        <category>IaC</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
        <tag>JunOS</tag>
        <tag>Terraform</tag>
        <tag>Netconf</tag>
      </tags>
  </entry>
  <entry>
    <title>部署RHCS</title>
    <url>/2019/07/22/Linux/HA/RHCS/</url>
    <content><![CDATA[<h1 id="基础环境信息"><a href="#基础环境信息" class="headerlink" title="基础环境信息"></a>基础环境信息</h1><p>描述本次基础环境信息：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/9159.png" alt=""></p>
<a id="more"></a>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作系统版本</th>
<th>操作系统镜像</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Red Hat Enterprise Linux Server release 6.8</code></td>
<td><code>rhel-server-6.8-x86_64-dvd.iso</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h2><div class="table-container">
<table>
<thead>
<tr>
<th>主机名</th>
<th>主机IP地址</th>
<th>角色</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fence</code></td>
<td>x.x.x.x</td>
<td>仿真fence设备</td>
</tr>
<tr>
<td><code>RHCE-node1</code></td>
<td><code>192.168.220.221</code></td>
<td>RHCS集群节点-01</td>
</tr>
<tr>
<td><code>RHEL-node2</code></td>
<td><code>192.168.220.222</code></td>
<td>RHCS集群节点-02</td>
</tr>
</tbody>
</table>
</div>
<h2 id="RHCS中启用的IP端口"><a href="#RHCS中启用的IP端口" class="headerlink" title="RHCS中启用的IP端口"></a>RHCS中启用的IP端口</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">IP 端口号</th>
<th style="text-align:left">协议</th>
<th style="text-align:left">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5404, 5405</td>
<td style="text-align:left">UDP</td>
<td style="text-align:left"><code>corosync/cman</code>（集群管理器）</td>
</tr>
<tr>
<td style="text-align:left">11111</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left"><code>ricci</code>（推广更新的集群信息）</td>
</tr>
<tr>
<td style="text-align:left">21064</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left"><code>dlm</code>（发布的锁定管理器）</td>
</tr>
<tr>
<td style="text-align:left">16851</td>
<td style="text-align:left">TCP</td>
<td style="text-align:left"><code>modclusterd</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="存储信息"><a href="#存储信息" class="headerlink" title="存储信息"></a>存储信息</h2><div class="table-container">
<table>
<thead>
<tr>
<th>存储类型</th>
<th>多路径软件</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iSCSI</code></td>
<td><code>device-mapper-multipath</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>iSCSI只需要配置<code>initiator</code>与<code>target</code>可以请求即可，实际环境若为FC-SAN，请将主机的wwpn提供给存储管理员。</strong></p>
<p><strong>查看wwpn的方法</strong>:<code>cat /sys/class/fc_host/host*/port_name</code></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>可使用各种方法配置红帽高可用性附加组件以满足您的需要。当进行计划、配置和实施的部署时，请考虑以下常规注意事项：</p>
<ul>
<li><p>支持的集群节点数</p>
<p>红帽高可用性附加组件最多支持的集群节点数为 16。</p>
</li>
<li><p>单点集群</p>
<p>现在只能完全支持单点集群。</p>
</li>
<li><p>GFS2</p>
<p>虽然 GFS2 文件系统既可作为独立系统使用，也可作为集群配置的一部分，但不支持将 GFS2 作为单节点文件系统使用。红帽支持很多为单节点优化的高性能单节点文件系统，它们相对集群文件系统来说支出更低。红帽将继续为现有客户支持单节点 GFS2 文件系统。当您将 GFS2 文件系统作为集群文件系统配置时，必须确定该集群中的所有节点都可访问共享的文件系统。不支持不对称集群配置，在不对称集群中，有些节点可访问该文件系统，而其他节点则不能。这不要求所有节点确实挂载该 GFS2 文件系统。</p>
</li>
<li><p>无单点故障硬件配置</p>
<p>集群可包括一个双控制器 RAID 阵列、多绑定链路、集群成员和存储间的多路径以及冗余无间断供电（UPS）系统以保证没有单点故障造成的应用程序失败或者数据丢失。另外，可设置一个低消耗集群以提供比无单点故障集群低的可用性。例如：您可以设置一个使用单控制器 RAID 阵列和只使用单以太网链路的集群。某些低消耗备选方案，比如主机 RAID 控制器、无集群支持的软件 RAID 以及多启动器平行 SCSI 配置与共享集群存储不兼容，或者不适合作为共享集群存储使用。</p>
</li>
<li><p>确保数据完整</p>
<p>要保证数据完整，则每次只能有一个节点可运行集群服务和访问集群服务数据。在集群硬件配置中使用电源开关，就可让一个节点在故障切换过程中，重启节点 HA 服务前为另一个节点提供动力。这样就可防止两个节点同时访问同一数据并破坏数据。强烈建议使用 <em>Fence 设备</em>（远程供电、关闭和重启集群节点的硬件或者软件解决方案），以确保在所有失败情况下数据的完整性。</p>
</li>
<li><p>以太网通道绑定</p>
<p>集群仲裁以及节点是否正常运行是由在通过以太网在集群节点间的沟通信息确定的。另外，集群节点使用以太网执行各种重要集群功能（例如：fencing）。使用以太网通道绑定，可将多个以太网接口配置为作为一个接口动作，这样就减小了在集群节点间以及其他集群硬件间典型切换的以太网连接单点故障风险。</p>
</li>
<li><p>IPv4 和 IPv6</p>
<p>高可用性附加组件支持 IPv4 和 IPv6 互联网协议。</p>
</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p><em>暂时关闭，如果需要细化防火墙规则，文档最后会列出详细的防火墙配置</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -F 		<span class="comment"># 清空iptables规则（如果默认策略是Drop，请不要执行此条命令。）</span></span><br><span class="line">iptables-save   <span class="comment"># 保存配置</span></span><br><span class="line">iptables -L -n    <span class="comment"># 查看当前规则</span></span><br></pre></td></tr></table></figure>
<h2 id="禁用或删除NetworkManager"><a href="#禁用或删除NetworkManager" class="headerlink" title="禁用或删除NetworkManager"></a>禁用或删除NetworkManager</h2><p><em>不支持在集群节点中使用 <code>NetworkManager</code>。如果您已经在集群节点中安装了 <code>NetworkManager</code>，您应该删除或者禁用该程序。</em></p>
<p>直接删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove -y NetworkManager  <span class="comment"># 移除包</span></span><br></pre></td></tr></table></figure>
<p>或者不删除,考虑禁用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service NetworkManager stop <span class="comment">#关闭服务</span></span><br><span class="line">chkconfig NetworkManager off <span class="comment"># 取消开机启动</span></span><br></pre></td></tr></table></figure>
<h2 id="关闭SELinux"><a href="#关闭SELinux" class="headerlink" title="关闭SELinux"></a>关闭SELinux</h2><p>如果熟悉的话可以配置，不熟悉的话，就直接关闭吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i s/SELINUX=enforcing/SELINUX=disabled/g  /etc/selinux/config     </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p><strong>彻底关闭SELinux需要重启，如果暂时不方便重启，可以先执行<code>setenforce 0</code>,等方便的时候重启服务器。</strong></p>
<h2 id="配置本地Yum源"><a href="#配置本地Yum源" class="headerlink" title="配置本地Yum源"></a>配置本地Yum源</h2><p>在<code>/etc/yum.repos.d</code>目录下创建新的本地<code>yumrepo</code>文件，本示例的<code>repo</code>文件名为<code>redhat-base.repo</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sr0 /mnt</span><br><span class="line">vi  /etc/yum.repos.d/redhat-base.repo</span><br></pre></td></tr></table></figure>
<p>以下是文件内容，<em>(假设ISO文件挂载至<code>/mnt</code>下)</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=base</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[HighAvailability]</span><br><span class="line">name=HighAvailablity</span><br><span class="line">baseurl=file:///mnt/HighAvailability</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[ResilientStorage]</span><br><span class="line">name=ResilientStorage</span><br><span class="line">baseurl=file:///mnt/ResilientStorage</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[LoadBalancer]</span><br><span class="line">name=LoadBalancer</span><br><span class="line">baseurl=file:///mnt/LoadBalancer</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>
<p>配置保存完成后，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all </span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
<h2 id="添加存储"><a href="#添加存储" class="headerlink" title="添加存储"></a>添加存储</h2><ol>
<li><p>安装<code>iscsi-initiator-utils</code>与<code>device-mapper-multipath</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y iscsi-initiator-utils device-mapper-multipath</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现<code>iscsi</code>target</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m discovery -t sendtargets -p &lt;targetIP1:PORT&gt;	<span class="comment"># 发现target</span></span><br><span class="line">iscsiadm -m discovery -t sendtargets -p &lt;targetIP2:PORT&gt; 	<span class="comment"># 发现target</span></span><br><span class="line">chkconfig iscsi on   <span class="comment"># 开机启动iscsi服务</span></span><br><span class="line">iscsiadm -m node -T &lt;IQN1&gt; -p &lt;IP1:PORT&gt; --login				<span class="comment"># 登录</span></span><br><span class="line">iscsiadm -m node -T &lt;IQN2&gt; -p &lt;IP2:PORT&gt; --login				<span class="comment"># 登录</span></span><br><span class="line">iscsiadm -m node -T &lt;IQN1&gt; -p &lt;IP1:PORT&gt; --op update -n node.startup -v automatic	<span class="comment"># 自动登录</span></span><br><span class="line">iscsiadm -m node -T &lt;IQN2&gt; -p &lt;IP2:PORT&gt; --op update -n node.startup -v automatic	<span class="comment"># 自动登录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成<code>/etc/multipath.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">enable</span> --with_multipathd y</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>multipathd</code>服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig multipathd on  			<span class="comment"># 开机启动</span></span><br><span class="line">chkconfig --list multipathd 		<span class="comment"># 检查</span></span><br><span class="line">service multipathd restart			<span class="comment"># 重启服务</span></span><br><span class="line">service multipathd status 			<span class="comment"># 检查</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看多路径设</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -ll  <span class="comment"># 查看路径</span></span><br><span class="line">lsblk 				  <span class="comment"># 查看设备</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><p>ntp配置略</p>
<h1 id="安装luci"><a href="#安装luci" class="headerlink" title="安装luci"></a>安装luci</h1><ol>
<li>在节点1上安装<code>luci</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install luci</span><br></pre></td></tr></table></figure>
<h1 id="安装ricci-cman和rgmanager"><a href="#安装ricci-cman和rgmanager" class="headerlink" title="安装ricci,cman和rgmanager"></a>安装ricci,cman和rgmanager</h1><ol>
<li><p>在两个RHCS节点上安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install ricci cman rgmanager</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置<code>ricci</code>密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd ricci</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="启动luci"><a href="#启动luci" class="headerlink" title="启动luci"></a>启动luci</h1><p>使用<code>luci</code>配置集群要求在集群中安装并运行<code>ricci</code> </p>
<ol>
<li><p>启动<code>ricci</code>服务：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ricci start  <span class="comment"># 启动服务</span></span><br><span class="line">chkconfig ricci on <span class="comment"># 开机启动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>luci</code>服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service luci start <span class="comment"># 启动服务</span></span><br><span class="line">chkconfig luci on <span class="comment"># 开机启动</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过浏览器访问<code>https://LUCI-IP:8084</code>来访问luci，当启动luci服务时，登录<code>url</code>会回显到标准输出。</p>
</li>
</ol>
<p><strong>注意</strong></p>
<p>初始情况下，只能通过root的身份验证信息访问；</p>
<p>如果 15 分钟后没有互动，则 <strong>luci</strong> 会处于闲置超时而让您退出。</p>
<h1 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h1><p>使用 <strong>luci</strong> 创建集群包括命名集群、在集群中添加集群节点、为每个节点输入 <strong>ricci</strong> 密码并提交创建集群请求。如果节点信息和密码正确，则 <strong>Conga</strong> 会自动在集群节点中安装软件（如果当前没有安装适当的软件包）并启动集群。按如下步骤创建集群：</p>
<ol>
<li><p>在 <strong>luci</strong> <strong>「Homebase」</strong>页面左侧菜单中点击<strong>「管理集群」</strong>。此时会出现<strong>「集群」</strong>页面。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/luci-01.png" alt=""></p>
</li>
</ol>
<ol>
<li><p>点击<strong>「创建」</strong>后出现<strong>「创建集群页面」</strong>。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/luci-03.png" alt=""></p>
<p><strong>图 3.3. 创建 luci 集群对话框</strong></p>
</li>
<li><p>请根据需要在<strong>「创建新集群」</strong>页面中输入以下参数：</p>
<ul>
<li><p>在<strong>「集群名称」</strong>文本框中输入集群名称。集群名称不能超过 15 个字符。</p>
</li>
<li><p>如果集群中的每个节点都有同样的 <strong>ricci</strong> 密码，您可以选择<strong>「在所有节点中使用相同的密码」</strong>，这样就可在您添加的节点中自动填写<strong>「密码」</strong>字段。</p>
</li>
<li><p>在<strong>「节点名称」</strong>栏中输入集群中节点的名称，并在<strong>「密码」</strong>栏中为该节点输入 <strong>ricci</strong>密码。</p>
</li>
<li><p>如果为您的系统配置了专门用于集群流量的专门的私有网络，则最好将 <strong>luci</strong> 配置为使用与集群节点名称解析拨通的地址与 <strong>ricci</strong> 进行沟通。您可以在<strong>「Ricci 主机名」</strong>中输入该地址达到此目的。</p>
</li>
<li><p>如果您要在 <strong>ricci</strong> 代理中使用不同的端口，而不是默认的 11111 端口，您可以更改那个参数。</p>
</li>
<li><p>点击<strong>「添加另一个节点」</strong>并输入节点名称，同时为集群的每个附加节点输入 <strong>ricci</strong> 密码。</p>
</li>
<li><p>如果您不想要在创建集群时升级已经在节点中安装的集群软件软件包，请选择<strong>「使用本地安装的软件包」</strong>选项。如果您要升级所有集群软件软件包，请选择<strong>「下载软件包」</strong>选项。</p>
<p><strong>注意</strong></p>
<p>如果缺少任意基本集群组件（<code>cman</code>、<code>rgmanager</code>、<code>modcluster</code> 及其所有相依性软件包），无论是选择<strong>「使用本地安装的软件包」</strong>，还是<strong>「下载软件包」</strong>选项，都会安装它们。如果没有安装它们，则创建节点会失败。</p>
</li>
<li><p>需要时选择<strong>「加入集群前重启节点」</strong>。</p>
</li>
<li><p>如果需要集群的存储，则请选择<strong>「启动共享存储支持」</strong>。这样做将下载支持集群存储的软件包，并启用集群的 LVM。您应该只能在可访问弹性存储附加组件或者可扩展文件系统附加组件时选择这个选项。</p>
</li>
</ul>
</li>
<li><p>点击 <strong>创建集群</strong>。点击 <strong>创建集群</strong> 后会有以下动作：</p>
<ol>
<li>如果您选择<strong>「下载软件包」</strong>，则会在节点中下载集群软件包。</li>
<li>在节点中安装集群软件（或者确认安装了正确的软件包）。</li>
<li>在集群的每个节点中更新并传推广群配置文件。</li>
<li>加入该集群的添加的节点</li>
</ol>
<p>显示的信息表示正在创建该集群。当集群准备好后，该显示会演示新创建集群的状态，请注意：如果没有在任何节点中运行 <strong>ricci</strong>，则该集群创建会失败。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/luci-04.png" alt=""></p>
</li>
<li><p>点击 <strong>创建集群</strong> 按钮创建集群后，您仍可以通过点击集群节点显示页面上部菜单中的<strong>「添加」</strong>或者<strong>「删除」</strong>功能从集群中添加或者删除节点。除非您要删除整个集群，否则必须在删除节点前停止它们。</p>
<p><strong>注意</strong></p>
<p>从集群中删除集群节点是一个破坏性操作，不能撤销。</p>
</li>
</ol>
<h1 id="配置Fence设备"><a href="#配置Fence设备" class="headerlink" title="配置Fence设备"></a>配置Fence设备</h1><h2 id="创建-Fence-设备"><a href="#创建-Fence-设备" class="headerlink" title="创建 Fence 设备"></a>创建 Fence 设备</h2><p>要创建 fence 设备请按照以下步骤执行：</p>
<ol>
<li>在<strong>「Fence 设备」</strong>配置页面中，点击<strong>「添加」</strong>。点击<strong>「添加」</strong>显示<strong>「添加 Fence 设备（事务）」</strong>对话框。在这个对话框中选择要配置的 fence 设备类型。</li>
<li>在<strong>「添加 Fence 设备（事务）」</strong>对话框中根据 fence 设备类型指定信息。</li>
<li>点击 <strong>提交</strong>。</li>
</ol>
<p>添加 fence 设备后，它会出现在<strong>「Fence 设备」</strong>配置页面中。</p>
<h1 id="为集群成员配置-FENCING"><a href="#为集群成员配置-FENCING" class="headerlink" title="为集群成员配置 FENCING"></a>为集群成员配置 FENCING</h1><p>完成创建集群和创建集群 fence 设备的初始步骤后，需要为集群节点配置 fencing。要在创建新集群后为节点配置 fencing 并为其配置 fence 设备，请按照本小节中的步骤执行。请注意：您必须为集群中的每个节点配置 fencing。</p>
<p>以下小节中提供了为节点配置单一 fence 设备、使用备份 fence 设备配置节点以及使用冗余电源配置节点的步骤：</p>
<h2 id="为节点配置单一-Fence-设备"><a href="#为节点配置单一-Fence-设备" class="headerlink" title="为节点配置单一 Fence 设备"></a>为节点配置单一 Fence 设备</h2><p>使用以下步骤配置有单一 fence 设备的节点。</p>
<ol>
<li><p>在具体集群页面中，您可以点击集群显示顶部的<strong>「节点」</strong>，为集群中的节点配置 fencing。这样做会显示组成集群的节点。当您点击 luci <strong>「Homebase」</strong>页面左侧菜单中的<strong>「管理集群」</strong>项下的集群名称时会出现这个默认页面。</p>
</li>
<li><p>点击节点名称。点击节点链接会出现一个演示如何配置该节点的页面。</p>
<p>在具体节点页面中显示所有目前在该节点中运行的服务，同时还显示该节点所在故障切换域。您可以点击其名称修改现有故障切换域。</p>
</li>
<li><p>请在具体节点页面的<strong>「Fence 设备」</strong>项下点击 <strong>添加 Fence 方法</strong>。此时会显示 <strong>在节点中添加 Fence 方法</strong> 对话框。</p>
</li>
<li><p>请输入为这个节点配置的 fencing 方法的<strong>「方法名」</strong>。这可以是红帽高可用性附加组件使用的任意名称。这与该设备的 DNS 名称不同。</p>
</li>
<li><p>点击 <strong>提交</strong>。此时会显示具体节点页面，该页面中显示您刚刚在<strong>「Fence 设备」</strong>中添加的方法。</p>
</li>
<li><p>点击 fence 事务下的 <strong>添加 Fence 事务</strong> 标签为这个方法配置 fence 事务。此时会出现<strong>「添加 Fence 设备（事务）」</strong>下拉菜单，可从中选择您之前配置的 fence 设备。</p>
</li>
<li><p>为这个方法选择 fence 设备。如果这个 fence 设备需要您配置具体节点参数，则会显示要配置的参数。</p>
<p><strong>注意</strong></p>
<p>对于非电源 fence 方法（即 SAN/存储 fencing），会在具体节点参数显示中默认选择<strong>「取消 fencing（Unfencing）」</strong>。这可保证在重启该节点前不会重新启用被 fence 的节点对存储的访问。有关 unfencing 节点的详情请参考 <code>fence_node</code>(8) man page。</p>
</li>
<li><p>点击 <strong>提交</strong>。此时会返回显示 fence 方法和 fence 事务的具体节点页面。</p>
</li>
</ol>
<h1 id="配置故障切换域"><a href="#配置故障切换域" class="headerlink" title="配置故障切换域"></a>配置故障切换域</h1><p>故障切换域是一个命名的集群节点子集，它可在节点失败事件中运行集群服务。故障切换域有以下特征：</p>
<ul>
<li><p>无限制 — 允许您为在子集指定首选成员子集，但分配给这个域名的集群服务可在任意可用成员中运行。</p>
</li>
<li><p>限制 — 允许您限制可运行具体集群服务的成员。如果在限制故障切换域中没有可用成员，则无法启动集群服务（手动或者使用集群软件均不可行）。</p>
</li>
<li><p>无序 — 当将一个集群服务分配给一个无序故障切换域时，则可从可用故障切换域成员中随机选择运行集群服务的成员，没有优先顺序。</p>
</li>
<li><p>有序的 — 可让您在故障切换域的成员间指定顺序。该列表顶端的成员是首选成员，接下来是列表中的第二个成员，依此类推。</p>
</li>
<li><p>故障恢复 — 允许您指定在故障切换域中的服务是否应该恢复到节点失败前最初运行的节点。配置这个特性在作为有序故障切换域一部分节点重复失败的环境中很有帮助。在那种情况下，如果某个节点是故障切换域中的首选节点，在可能在首选节点和其它节点间重复切换和恢复某个服务，从而不会对性能产生严重影响。</p>
<p><strong>注意</strong></p>
<p>故障恢复特性只适用于配置了有序故障切换的集群。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>更改故障切换域配置对目前运行中的服务无效。</p>
<p><strong>注意</strong></p>
<p>操作<em>不需要</em>的故障切换域。</p>
<p>默认情况下故障切换域为无限制和无序的。</p>
<p>在由几个成员组成的集群中，使用限制故障切换域可最大程度降低设置集群以便运行集群服务的工作（比如 <code>httpd</code>），它要求您在运行该集群服务的所有成员中进行完全一致的配置。您不需要将整个集群设置为运行该集群服务，只要设置与该集群服务关联的限制故障切换域中的成员即可。</p>
<p><strong>注意</strong></p>
<p>要配置首选成员，您可以创建只有一个集群成员的无限制故障切换域。这样做就让集群服务主要在那个集群成员（首选成员）中运行，但允许将该集群服务故障切换到任意其它成员中。</p>
<h2 id="添加故障切换域"><a href="#添加故障切换域" class="headerlink" title="添加故障切换域"></a>添加故障切换域</h2><p>要添加故障切换域，请按照本小节中的步骤执行。</p>
<ol>
<li><p>在具体集群页面中，您可以点击集群显示顶部的<strong>「故障切换域」</strong>为那个集群配置故障切换域。此时会显示为这个集群配置的故障切换域。</p>
</li>
<li><p>点击<strong>「添加」</strong>。点击<strong>「添加」</strong>时会显示<strong>「在集群中添加故障切换域」</strong>。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/failover-01.png" alt=""></p>
</li>
</ol>
<ol>
<li><p>在<strong>「在集群中添加故障切换域」</strong>对话框的<strong>「名称」</strong>文本框中指定故障切换域名称。</p>
<p><strong>注意</strong></p>
<p>该名称应该可以与集群中其它名称所显示的目的区别。</p>
</li>
<li><p>要启用在故障切换域成员间设置故障切换优先权，请点击<strong>「优先的」</strong>复选框。选择<strong>「优先的」</strong>复选框后，您可以为选择作为故障切换域成员的每个节点设置优先值，<strong>「优先权」</strong>。</p>
</li>
<li><p>要限制这个故障切换域成员的故障切换，请点击<strong>「有限」</strong>复选框。选择<strong>「有限」</strong>复选框后，分配给这个故障切换域的服务只能切换到这个故障切换域中的节点。</p>
</li>
<li><p>要将那个节点指定为不在这个故障切换域中恢复，请点击<strong>「无故障恢复」</strong>复选框。选择<strong>「无故障恢复」</strong>后，如果从首选节点中恢复某个服务，则该服务不会切换到恢复它的节点中。</p>
</li>
<li><p>配置这个故障切换域的成员。为每个要成为故障切换域成员的节点点击<strong>「成员」</strong>复选框。如果选择<strong>「优先的」</strong>复选框，则请为故障切换域每个成员在<strong>「优先权」</strong>文本框中设置优先权。</p>
</li>
<li><p>点击 <strong>创建</strong> 按钮。此时会显示新创建故障切换域的<strong>「故障切换域」</strong>页面。出现一条信息显示创建了新的域。刷新该页面查看更新的状态。</p>
</li>
</ol>
<h1 id="配置全局集群资源"><a href="#配置全局集群资源" class="headerlink" title="配置全局集群资源"></a>配置全局集群资源</h1><p>您可以配置在集群中运行的任意服务所使用的全局资源，还可以配置只可用于具体服务的资源。</p>
<p>要添加全局集群资源，请按照本小节中的步骤操作。您可在配置该服务时，添加属于具体服务的本地资源</p>
<ol>
<li>在具体集群页面中，您可点击集群显示顶部的<strong>「资源」</strong>菜单在那个集群中添加资源。此时会显示已经为那个集群添加的资源。</li>
<li>点击<strong>「添加」</strong>。此时会显示<strong>「在集群中添加资源」</strong>下拉菜单。</li>
<li>点击<strong>「在集群中添加资源」</strong>中的下拉框并选择要配置的资源类型。</li>
<li>输入您要添加资源的资源参数。</li>
<li>点击 <strong>提交</strong>。点击 <strong>提交</strong> 按钮会返回显示<strong>「资源」</strong>信息的资源页面，此时该页面会显示添加的资源（和其它资源）。</li>
</ol>
<p>要修改现有资源，请执行以下步骤。</p>
<ol>
<li>在 <strong>luci</strong> <strong>「资源」</strong>页面中点击要修改的资源名称。此时会显示那个资源的参数。</li>
<li>编辑该资源的参数。</li>
<li>点击 <strong>应用</strong>。</li>
</ol>
<p>要删除现有资源，请执行以下步骤。</p>
<ol>
<li>在 <strong>luci</strong> <strong>「资源」</strong>页面中选择所有要删除资源。</li>
<li>点击<strong>「删除」</strong>。</li>
</ol>
<h1 id="在集群中添加集群服务"><a href="#在集群中添加集群服务" class="headerlink" title="在集群中添加集群服务"></a>在集群中添加集群服务</h1><ol>
<li><p>在具体集群页面中您可以点击集群显示顶部的<strong>「服务组」</strong>菜单在那个集群中添加服务。此时会显示已经为那个集群配置的服务。</p>
</li>
<li><p>点击<strong>「添加」</strong>。此时会显示<strong>「在集群中添加服务组」</strong>对话框。</p>
</li>
<li><p>在<strong>「在集群中添加服务组」</strong>对话框的<strong>「服务名称」</strong>文本框中输入该服务名称。</p>
<p><strong>注意</strong></p>
<p>请使用可明确与集群中的其它服务区别开来的描述性名称。</p>
</li>
<li><p>如果您想在启动并运行集群时自动启动该服务，请选择<strong>「自动启动这个服务」</strong>复选框。如果<em>没有</em>选择这个复选框，则您必须在集群不处于停止状态时手动启动该服务。</p>
</li>
<li><p>选择<strong>「独家运行」</strong>复选框设置策略，即该服务只在没有其它服务运行的节点中运行。</p>
</li>
<li><p>如果您已经为该集群配置了故障切换域，您可以使用<strong>「故障切换域」</strong>参数的下拉菜单为该服务选择故障切换域。</p>
</li>
<li><p>使用<strong>「恢复策略」</strong>下拉框为该服务选择恢复策略。选项包括 <strong>「重新定位」</strong>、<strong>「重启」</strong>、<strong>「重启-禁用」</strong> 或者 <strong>「禁用」</strong>该服务。</p>
<p>选择<strong>「重启」</strong>选项表示在重新定位该服务前系统应尝试重启失败的服务。选择<strong>「重新定位」</strong>选项表示系统应在不同节点中重启该服务。选择<strong>「禁用」</strong>选项表示如果任意组件失败，系统就应禁用该资源组。选择<strong>「重启-禁用」</strong>选项表示该服务失败的位置尝试重启该服务，但如果重启失败，则将禁用服务而不是移动到集群的另一台主机中。</p>
<p>如果您选择<strong>「重启」</strong>或者<strong>「重启-禁用」</strong>作为该服务的恢复策略，您可以指定重新定位或者禁用该服务前最多重启失败的次数，您还可以在多少秒后不再重启。</p>
</li>
<li><p>要在服务中添加资源，请点击 <strong>添加资源</strong>。点击 <strong>添加资源</strong> 按钮会显示一个 <strong>在服务中添加资源</strong> 下拉菜单，您可从中选择要添加的现有全局资源，或者添加一个<em>只可</em>用于这个服务的新资源。</p>
<ul>
<li><p>要添加现有全局资源，请在 <strong>在服务中添加资源</strong> 下拉框中点击现有资源名称。此时会显示在您所配置服务的<strong>「服务组」</strong>页面中的资源及其参数。</p>
</li>
<li><p>要添加只可用于这个服务的新资源，请在 <strong>在服务中添加资源</strong> 下拉框中选择要配置的资源类型并为您要添加的资源输入资源参数。</p>
</li>
<li><p>当在服务中添加资源时，无论它是现有全局资源，还是只可用于这个服务的资源，您可将该资源指定为<strong>「独立子树」</strong>或者<strong>「非关键资源」</strong>。</p>
<p>如果您将资源指定为独立子树，那么如果该资源失败，则在系统尝试常规恢复前只会重启那个资源（而不是整个服务）。您可以指定在该节点中为该服务使用恢复策略前最多尝试重启该资源的次数。您还可以指定在多少秒后系统将为该服务使用恢复策略。</p>
<p>如果您将该资源指定为非关键资源，那么如果那个资源失败，则只需要重启该资源。同时如果该资源仍失败，那么只会禁用那个资源而不是整个服务。您可以指定在该节点中禁用该资源前最多重启该资源的次数。您还可以指定在多少秒后系统将禁用该资源。</p>
</li>
</ul>
</li>
<li><p>如果您要在您定义的资源中添加子资源，请点击 <strong>添加子资源</strong>。点击 <strong>添加子资源</strong> 后会显示<strong>「在服务中添加资源」</strong>下拉框，您可从中添加现有全局资源或者添加只可用于这个服务的新资源。您可以继续为这个资源添加子资源以适应您的要求。</p>
<p><strong>注意</strong></p>
<p>如果您要添加 Samba 服务资源，请将 Samba 服务资源直接连接到该服务，而<em>不是</em>服务中的资源。</p>
</li>
<li><p>当您完成为该服务添加资源，并完成为资源添加子资源时，点击 <strong>提交</strong>。点击 <strong>提交</strong> 按钮后会返回显示添加的服务（以及其它服务）的<strong>「服务组」</strong>页面。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RHCS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装JAVA-JDK</title>
    <url>/2019/07/03/Linux/JAVA/Install-the-JDK/</url>
    <content><![CDATA[<p><strong>本教程可帮助您在系统上安装Java 8或更新Java。在从Linux命令行下载Java之前，请仔细阅读说明。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>JDK下载链接</td>
<td><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h1 id="Step-1-–-下载最新的Java"><a href="#Step-1-–-下载最新的Java" class="headerlink" title="Step 1 – 下载最新的Java"></a>Step 1 – 下载最新的Java</h1><p>Oracle团队提供Java RPM包以及编译的源代码。很多次我尝试使用rpm包安装Java，但是我遇到了一些问题。所以我决定使用已编译的源代码安装Java。从那以后，我在CentOS上安装了大量Java，基于Redhat的系统没有任何问题。要从其<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">官方下载页面</a>下载最新的Java SE Development Kit 8版本，或使用以下命令从shell下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/</span><br><span class="line">wget --no-cookies --no-check-certificate --header <span class="string">"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie"</span> <span class="string">"https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz"</span></span><br><span class="line">tar xzf jdk-8u201-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="Step-2-–-使用Alternatives安装Java-8"><a href="#Step-2-–-使用Alternatives安装Java-8" class="headerlink" title="Step 2 – 使用Alternatives安装Java 8"></a>Step 2 – 使用Alternatives安装Java 8</h1><p>alternatives命令用于维护符号链接。此命令用于创建，删除，维护和显示有关包含备选系统的符号链接的信息。让我们使用<code>alternatives</code>命令在您的系统上配置Java。<code>alternative</code>命令在<strong>chkconfig</strong>包中可用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> jdk1.8.0_201/</span><br><span class="line">alternatives --install /usr/bin/java java /opt/jdk1.8.0_201/bin/java 2</span><br><span class="line">alternatives --config java</span><br></pre></td></tr></table></figure>
<p>新安装的Java版本列在第n位，因此输入n并按Enter键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">There are 3 programs which provide &#39;java&#39;.</span><br><span class="line"></span><br><span class="line">  Selection    Command</span><br><span class="line">-----------------------------------------------</span><br><span class="line">   1           &#x2F;opt&#x2F;jdk1.8.0_45&#x2F;bin&#x2F;java</span><br><span class="line"> * 2           &#x2F;opt&#x2F;jdk1.8.0_144&#x2F;bin&#x2F;java</span><br><span class="line"> + 3           &#x2F;opt&#x2F;jdk-11&#x2F;bin&#x2F;java</span><br><span class="line">   4           &#x2F;opt&#x2F;jdk1.8.0_201&#x2F;bin&#x2F;java</span><br><span class="line"></span><br><span class="line">Enter to keep the current selection[+], or type selection number: 4</span><br></pre></td></tr></table></figure>
<p>此时，JAVA 8已成功安装在您的系统上。我们还建议使用替代方法设置javac和jar命令路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alternatives --install &#x2F;usr&#x2F;bin&#x2F;jar jar &#x2F;opt&#x2F;jdk1.8.0_201&#x2F;bin&#x2F;jar 2</span><br><span class="line">alternatives --install &#x2F;usr&#x2F;bin&#x2F;javac javac &#x2F;opt&#x2F;jdk1.8.0_201&#x2F;bin&#x2F;javac 2</span><br><span class="line">alternatives --set jar &#x2F;opt&#x2F;jdk1.8.0_201&#x2F;bin&#x2F;jar</span><br><span class="line">alternatives --set javac &#x2F;opt&#x2F;jdk1.8.0_201&#x2F;bin&#x2F;javac</span><br></pre></td></tr></table></figure>
<h1 id="Step-3-–-检查已安装的Java版本"><a href="#Step-3-–-检查已安装的Java版本" class="headerlink" title="Step 3 – 检查已安装的Java版本"></a>Step 3 – 检查已安装的Java版本</h1><p>Java和javac二进制文件在PATH环境变量下可用。您可以在系统中的任何位置使用它们。让我们通过执行以下命令检查系统上安装的Java运行时环境（JRE）版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version <span class="string">"1.8.0_201"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<h1 id="Step-4-–-设置Java环境变量"><a href="#Step-4-–-设置Java环境变量" class="headerlink" title="Step 4 – 设置Java环境变量"></a>Step 4 – 设置Java环境变量</h1><p>大多数基于Java的应用程序使用环境变量来工作。使用以下命令设置Java环境变量</p>
<p>设置<strong>JAVA_HOME</strong>，<strong>JRE_HOME</strong>和<strong>PATH</strong>环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk1.8.0_201</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/opt/jdk1.8.0_201/jre</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/jdk1.8.0_201/bin:/opt/jdk1.8.0_201/jre/bin</span><br></pre></td></tr></table></figure>
<p>还要将上述命令添加到<code>/etc/bashrc</code>或<code>/etc/profile</code>文件中以自动设置环境变量。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化模板制作-CentOS7</title>
    <url>/2019/02/03/vSphere/Virtual-template-production-CentOS7/</url>
    <content><![CDATA[<p>有关CentOS6的制作我大概思路已经做过一篇<a href="https://www.sysctl.me/2017/07/12/vmawre">文章</a>，本来是希望读者根据这篇来尝试其他release的模板，再加上之前的文章可能对小白有点不友好，<a href="https://www.sysctl.me/2017/07/14/gparted">我以为SWAP和磁盘分区的问题大家是可以解决的</a>，加上最近同事有这方面的需要，就再次整理一篇。</p>
<blockquote>
<p>还是希望大家不是简单的<kbd>Ctrl</kbd> + <kbd>C</kbd>。</p>
</blockquote>
<p>这次的需求呢，是这样：</p>
<ol>
<li>网卡配置</li>
<li>IP地址分发</li>
<li>强制修改密码（有点简陋）</li>
<li>磁盘分区问题</li>
</ol>
<p>涉及到什么？<br><a id="more"></a></p>
<ol>
<li><code>ifcfg</code></li>
<li>跟<code>udev</code>没什么关系的<code>udev</code></li>
<li><code>profile</code></li>
<li><code>sed</code></li>
<li>自定义规范</li>
<li>清理工作</li>
</ol>
<p>希望读者读完这篇Step By Step一样的文档后可以理解：</p>
<ul>
<li>模板制作根本就不是模板，而是基于虚拟磁盘文件（<code>vmdk</code>）的复制及虚拟机配置文件（<code>vmx</code>）重建的过程</li>
<li>您做模板的目的是为了什么？</li>
<li>能否理解每个操作都是在做什么</li>
<li>为什么要通过这些操作，修改或删除一些内容</li>
<li>如果我的文章没能满足你的需求，您需要如何改进？</li>
</ul>
<h1 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h1><p><em>略去安装系统的步骤，（我想如果装不上系统，模板的需求也不强烈，那你就多装几次，23333）。</em></p>
<p>文字描述下过程：</p>
<ul>
<li><p>下载ISO，上传到数据存储</p>
</li>
<li><p>一个满足通用需求磁盘大小的虚拟机</p>
</li>
<li><p>安装CentOS7</p>
</li>
<li><p>巴拉巴拉</p>
</li>
</ul>
<h1 id="转换为模板之前的准备工作"><a href="#转换为模板之前的准备工作" class="headerlink" title="转换为模板之前的准备工作"></a>转换为模板之前的准备工作</h1><ul>
<li><p>更新系统（如果有内网源，最好封装到模板）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>vmtools</code>:</p>
<p>安装vmtools（这里有点问题，你到底是选open-vm-tools，还是vmware自带的iso）</p>
<p>这里vmware官方建议的是7版本以后使用<code>open-vm-tools</code>原因是通过rpm包分发的方式，且宿主机管理vmtools。</p>
<p>安装<code>open-vm-tools</code>(两者选一)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install open-vm-tools -y </span><br><span class="line">systemctl restart vmtoolsd</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查网络配置文件</p>
<p>这里就是把网卡配置的<code>UUID</code>和<code>HWADDR</code>删掉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'/^(HWADDR|UUID)=/d'</span> /etc/sysconfig/network-scripts/ifcfg-xxx  (xxx为网卡配置文件名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除udev：</p>
<p>这里其实是不用删除的，如果担心可以看下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /etc/udev/rules.d/</span><br><span class="line">rm -rf /etc/udev/rules.d/70-*  <span class="comment"># 如果存在则删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置ntp：</p>
<p>这里可选，如需要则可以安装<code>chrony</code>然后配置平时常用的ntp服务器地址</p>
</li>
<li><p>配置第一次登陆修改密码:</p>
<p>在<code>/etc/profile</code>末尾追加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd ; nmtui ; <span class="built_in">history</span> -c ; sed -i <span class="string">'$d'</span> /etc/profile <span class="comment"># 这里根据自己的需要调整。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>别写错了，修改前要清除自己的操作是在干什么 有什么风险。</p>
</blockquote>
</li>
<li><p>删除<code>machine-id</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">chmod 777 machine-id</span><br><span class="line">vi machine-id <span class="comment"># 删除machine id 删完保存</span></span><br><span class="line">chmod 444 machine-id   <span class="comment"># 还原权限。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>清空日志及其临时文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm –rf /tmp/*</span><br><span class="line">rm –rf /var/tmp/*</span><br><span class="line">systemctl stop rsyslog</span><br><span class="line">systemctl stop auditd</span><br><span class="line">rm –f /var/<span class="built_in">log</span>/*-???????? /var/<span class="built_in">log</span>/*.gz   <span class="comment"># 注意这步，选择进行。</span></span><br><span class="line">rm -f /var/<span class="built_in">log</span>/dmesg.old</span><br><span class="line">rm -rf /var/<span class="built_in">log</span>/anaconda</span><br><span class="line">rm -rf /etc/ssh/ssh_host_*</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/<span class="built_in">log</span>/btmp</span><br><span class="line"><span class="built_in">history</span> -c</span><br><span class="line"><span class="built_in">echo</span> &gt; ~/.bash_history</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行如下命令完成系统封装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sys-unconfig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接下来，系统会自动关机。然后右键此虚拟机，转换为模板。</p>
<h1 id="自定义虚拟机规范文件"><a href="#自定义虚拟机规范文件" class="headerlink" title="自定义虚拟机规范文件"></a>自定义虚拟机规范文件</h1><blockquote>
<p>自定义规范的步骤参照<a href="https://www.sysctl.me/2019/02/03/vSphere/虚拟化模板制作-Win">win模板制作</a>。</p>
</blockquote>
<p>配置完自定义规范文件，部署虚拟机时选择需要的规范文件就可以根据向导并且配置ip了。</p>
]]></content>
      <categories>
        <category>Vmware</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化模板制作-Windows</title>
    <url>/2019/02/03/vSphere/Virtual-template-production-Win/</url>
    <content><![CDATA[<blockquote>
<p>关于Win的虚拟化模板，vSphere上其实没什么难度，这里介绍的制作方式也不是唯一的，仅仅是提供一个制作的思路，如果有特殊需求，根据现有方案拓展即可。</p>
</blockquote>
<h1 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h1><ul>
<li>这次的需求有一下这几点<ol>
<li>重新封装</li>
<li>重新设置密码（有点歧义）</li>
<li>IP地址需要定义</li>
<li>SID唯一</li>
<li>优雅（尽量优雅）</li>
<li>尽量减少二次重复操作</li>
<li>vmtools安装</li>
</ol>
</li>
<li>涉及到的组件<ol>
<li>Windows</li>
<li>vmtools</li>
<li>自定义规范</li>
</ol>
</li>
</ul>
<a id="more"></a>
<p>==有关模板的制作其实就是克隆<code>vmdk</code>且重建虚拟机文件<code>vmx</code>，不信我真没办法。==</p>
<h1 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h1><ul>
<li><p>首先创建虚拟机</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-1.jpg" alt="安装系统1"></p>
<p>这里就随便拉，最好移除软盘驱动器。</p>
</li>
<li><p>打开虚拟机</p>
<p>根据需求选择语言和keyboard，选择对应版本。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-2.jpg" alt="安装系统2"></p>
</li>
<li><p>创建系统分区</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-3.jpg" alt="安装系统2"></p>
</li>
<li><p>等待安装完成</p>
</li>
</ul>
<h1 id="转换为模板之前的准备工作"><a href="#转换为模板之前的准备工作" class="headerlink" title="转换为模板之前的准备工作"></a>转换为模板之前的准备工作</h1><h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><p>因为是用于vSphere，所以第一步最好先安装对应系统的<code>vmtools</code>，要不鼠标卡的一逼。</p>
<ul>
<li><p>挂载VMware Tools</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-4.jpg" alt="安装vmtools1"></p>
</li>
<li><p>安装Tools</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-5.jpg" alt="安装vmtools2"></p>
<p>运行。</p>
<p> <img src="https://blog-image.nos-eastchina1.126.net/win-temp-6.jpg" alt="安装vmtools3"></p>
<p>选择完整安装，下一步。</p>
<blockquote>
<p>这里说下为什么不选典型；其实典型是可以的，But！！！很多第三方，比如杀毒一类的产品会需要一些驱动，典型安装时没有勾选的。（NSX也会）</p>
</blockquote>
</li>
<li><p>重启</p>
</li>
</ul>
<h2 id="操作系统配置"><a href="#操作系统配置" class="headerlink" title="操作系统配置"></a>操作系统配置</h2><p>在这之前，你要明确你模板里需要集成哪些配置，这里我举例我的环境下需要配置的东西（根据自身环境修改）：</p>
<ol>
<li>远程桌面总得开吧</li>
<li>防火墙可以先关闭掉</li>
<li>WSUS（自己百度）</li>
<li>你可能还需要更新补丁</li>
<li>KMS</li>
<li>VM Tools</li>
<li>可能需要配置NTP</li>
</ol>
<p>因为我这是一个相对干净的需求，所以都是基础配置。</p>
<p>接下来我将这些内容封装在我的模板中（基本配置不截图了）。</p>
<ul>
<li>vmtools（已完成）</li>
<li>配置IP地址</li>
<li>指定KMS服务器</li>
<li>时间同步</li>
<li>指定WSUS</li>
<li>安装所需补丁（重启继续）</li>
<li>你可能还需要移除软盘驱动器，或者还有DVD驱动器</li>
<li>一些简单的系统配置例如<ul>
<li>允许远程桌面</li>
<li>性能选项调整为最佳性能</li>
<li>虚拟内存这东西没必要的话可以干掉</li>
<li>调整你的防火墙策略（或者干掉）</li>
<li>我想IE ESC应该也不是你需要的吧，关掉</li>
<li>启动和故障恢复中的操作系统列表时间调整为5s左右</li>
<li>一些常用的组策略</li>
<li>IE主页（如果你需要的话）</li>
<li>可能你还需要禁用C盘的索引</li>
<li>碎片整理巴拉巴拉</li>
<li>也可以选择禁用优化选项</li>
<li>账户控制设置可能需要根据你的偏好修改</li>
<li>清理事件日志</li>
<li>等等</li>
</ul>
</li>
<li>你还需要安装一些通用的软件<ul>
<li>Telnet客户端</li>
<li><code>.NET Framework</code></li>
<li>可能还需要解压缩</li>
<li>说不准你要安装一个浏览器</li>
<li>如果你的环境里需要部署某些<code>agent</code>例如备份或监控</li>
</ul>
</li>
</ul>
<p>上述所有操作都是可选的，根据自己需求。接下来咱们来看下当前系统的SID</p>
<p>打开命令行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure>
<p>记住这个。</p>
<p>现在清空你的网络配置（IP地址）</p>
<p>然后打开sysprep：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-7.jpg" alt="sysprep"></p>
<p>点击确认。系统会关机。</p>
<blockquote>
<p>Windows的准备工作基本完成。</p>
<p>这里要注意，如果使用了<code>sysprep</code>，请不要重复使用使用自定义规范，两者选一个，如果你有更改主机名和ip地址的需求，转换前请勿使用<code>sysprep</code>实用程序进行封装。</p>
</blockquote>
<h1 id="自定义规范"><a href="#自定义规范" class="headerlink" title="自定义规范"></a>自定义规范</h1><p>主角来了。</p>
<ul>
<li><p>策略和配置文件</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-8.jpg" alt="自定义规范1"></p>
</li>
<li><p>新建虚拟机客户机自定义规范</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-9.jpg" alt="vm规范"></p>
</li>
<li><p>根据需要选择，我这里只选择系统版本和sid，如果你有特定的<code>sysprep</code>文件，可以指定</p>
</li>
<li><p>组织名称随便填</p>
</li>
<li><p>计算机名称选择<code>在部署向导中输入名称</code></p>
</li>
<li><p>产品秘钥没有</p>
</li>
<li><p>密码这块根据需要选择吧。我一般不选择，因为已经设置了重新封装。</p>
</li>
<li><p>选择时区</p>
</li>
<li><p>命令可选</p>
</li>
<li><p>网络选择<code>手动选择自定义设置</code>，编辑网络，选择<code>使用规范时,提示用户输入Ipv4</code>，v6地址根据你需求来吧</p>
</li>
<li><p>选择工作组</p>
</li>
</ul>
<h1 id="转换为模板"><a href="#转换为模板" class="headerlink" title="转换为模板"></a>转换为模板</h1><p>首选咱们找到刚才准备的模板虚拟机。</p>
<p>为了方便调整母模板，建议这里选择克隆为模板，当然你也可以直接转换为模板（这样不保留原虚拟机）。</p>
<h1 id="从模板部署虚拟机"><a href="#从模板部署虚拟机" class="headerlink" title="从模板部署虚拟机"></a>从模板部署虚拟机</h1><ul>
<li><p>从模板新建虚拟机</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-11.jpg" alt="从模板新建虚拟机"></p>
</li>
<li><p>选择资源池和存储就不截图了</p>
</li>
<li><p>克隆选项了解一下</p>
<p>根据自己的喜好选</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-12.jpg" alt="从模板新建虚拟机"></p>
</li>
<li><p>选择之前准备好的自定义规范</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-13.jpg" alt="选择规范"></p>
</li>
<li><p>指定主机名和ip地址</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/win-temp-14.jpg" alt="指定ip地址"></p>
</li>
<li><p>虚拟机硬件配置根据自己的需要适当修改</p>
</li>
<li><p>部署完打开电源</p>
</li>
</ul>
<blockquote>
<p>这里希望你能明白，自定义规范是如何实现的。当你通过自定义规范部署win时，部署完的虚拟机会再次重启。完成配置。所以要注意，不要在此期间（虽然很短）做重要配置。</p>
</blockquote>
<h1 id="检查通过模板部署的虚拟机"><a href="#检查通过模板部署的虚拟机" class="headerlink" title="检查通过模板部署的虚拟机"></a>检查通过模板部署的虚拟机</h1><p><strong>可以检查以下几项：</strong></p>
<ul>
<li>主机名</li>
<li>IP地址是否下发</li>
<li>SID是否重置</li>
</ul>
<p>理想状态就是通过模板部署的虚拟机几乎不需要配置就可以提供给需要的工作人员。</p>
<p>模板不是一个一劳永逸的东西，它需要根据你业务环境的变化持续改进，变得越来越顺手，维护模板会涉及这几个内容：</p>
<ol>
<li>更新</li>
<li>预配置的修改</li>
<li>预部署软件的增删改</li>
</ol>
<p>模板的积累会成为最后的模板库。</p>
<p><em>因为模板用在你自己的环境中，慢慢你就会发现，模板里面既然能装chrome，telnet，那么我为什么不能装MSSQL呢，封装进去，再生成新的模板，直接提供SQL Server，直接提供IIS，或者巴拉巴拉的服务。</em></p>
<p><em>这不就是服务目录么?但，服务目录需要一个标准。没有人来定义这个标准是没办法做服务目录的。所以基于容器的PaaS才是趋势。</em></p>
]]></content>
      <categories>
        <category>Vmware</category>
      </categories>
      <tags>
        <tag>Vmware</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>影响存储和文件系统性能的因素</title>
    <url>/2019/01/07/Linux/Performance-tuning/Storage%20and%20Filesystem/Factors-Affecting-Storage-and-File-System-Performance/</url>
    <content><![CDATA[<p>存储和文件系统性能适当设置在很大程度上取决于存储的目的，I/O和文件系统性能会受下列因素的影响：</p>
<ul>
<li>数据的写入或读取模式</li>
<li>数据重新排列与底层对齐</li>
<li>块大小</li>
<li>日志大小和位置</li>
<li>记录访问时间</li>
<li>确保数据可靠性</li>
<li>预取数据</li>
<li>预分配磁盘空间</li>
<li>文件碎片</li>
<li>资源争用<a id="more"></a>
<h1 id="I-O调度器"><a href="#I-O调度器" class="headerlink" title="I/O调度器"></a>I/O调度器</h1></li>
</ul>
<p>I/O调度程序确定I/O操作在存储设备上运行的时间和持续时间。也被称为I/O elevator。</p>
<p>linux体用了三个I/O调度程序：</p>
<ul>
<li><p><strong>deadline</strong></p>
<p>除了SATA磁盘为所有块设备的默认I/O调度器。<code>deadline</code>尝试为指向到达I/O调度器的请求提供有保障的延迟。该调度器适合大多数用例，尤其适用于读取操作比写入操作更频繁的请求。</p>
<p>将排队的I/O请求分配为读或者写批处理，按照LBA递增顺序执行。默认设置下，读取批处理优先于写批处理，这是要因为应用程序可能组织读取I/O。批处理后，<code>deadline</code>检查写入操作因等待处理器世间而处于多久的饥饿状态，并且适当地调度下一个读批处理或写批处理。</p>
</li>
<li><p><strong>cfq</strong></p>
<p>默认调度器只适用于标识为SATA硬盘的设备。完全公平队列调度器，<code>cfq</code>，将进程分成第三个独立类型：实时，尽其所能和空闲。实时类别的进程总是先于尽其所能类别进程执行，而尽其所能类别进程总是在空闲类别进程之间执行。这意味着实时类别的进程可以使尽其所能和空闲进程等待处理器时间而忍受饥饿。默认设置下，分配进程到尽其所能类别。</p>
<p><code>cfq</code>使用历史数据来预测应用是否会在不久之后发出更多I/O请求。如果将有更多I/O请求，<code>cfq</code>空闲则会等待新的I/O，即使有来自其他进程的I/O在等待处理。</p>
<p>因为有空闲的趋势，<code>cfq</code>调度器不应用与连接不会引起大量搜寻penalty（惩罚）的硬件，除非它为此目的的而被调整。<code>cfq</code>调度器也不应用于连接其他断续工作型调度器，例如基于主机的硬件<code>RAID</code>控制器，因为这些调度器的堆叠有造成大量延迟的趋势。</p>
</li>
<li><p><strong>noop</strong></p>
<p><code>noop</code>I/O调度器实现了简单的FIFO（先入先出）调度算法。请求通过简单的最后命中缓存在通用块层合并。对于使用快速存储的CPU绑定系统，这可能是最佳调度器。</p>
</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h2><p>XFS是一个强大且高度可拓展的64位文件系统。他是CentOS7的默认文件系统。XFS使用基于区段的分配，并具有多种分配方案，包括预先分诶和延迟的分配，这两种都会减少碎片和提高性能。它还支持故障恢复的元数据日志。当挂载并激活时，能够对XFS进行碎片整理。</p>
<p>XFS支持最大容量可达500TB的文件系统，以及最大容量为8EB的文件偏移量（稀疏文件）。</p>
<h2 id="EXT4"><a href="#EXT4" class="headerlink" title="EXT4"></a>EXT4</h2><p>ext4是ext3文件系统的可缩放扩展。它的默认行为对大部分工作负载是最佳的。然而，它只支持最大容量为50TB的文件系统以及最大容量为16TB的文件。</p>
<h2 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h2><p>Btrfs（B-tree文件系统）是一种相对较新的写时复制（COW）文件系统，作为技术预览发布。一些独特的Btrfs功能包括：</p>
<ul>
<li>特定文件，卷或子卷而不是整个文件系统的快照；</li>
<li>支持多种廉价磁盘冗余阵列（RAID）；</li>
<li>返回将映射I/O错误引用到文件系统对象；</li>
<li>透明压缩（分区上的所有文件都自动压缩）;</li>
<li>数据和元数据的校验和。</li>
</ul>
<p>虽然Btrfs被认为是一个稳定的文件系统，但它还在不断发展，因此与更成熟的文件系统相比，某些功能（修复工具）是最基本的。</p>
<p>目前当需要高级功能（例如快照没压缩和文件数据校验和）时，选择Btrfs是合适的，但性能相对不重要。如果不需要高级功能，则失败和风险相对较弱的性能会使其他文件系统更受欢迎。与其他文件系统相比，另一个缺点是支持的最大文件系统大小为50TB。</p>
<h2 id="GFS2"><a href="#GFS2" class="headerlink" title="GFS2"></a>GFS2</h2><p>全局文件系统2（GFS2）是一个高可用行附加组件的一部分，提供集群文件系统支持。GFS2在集群中的所有服务器上提供一致的文件系统影响，允许服务器通中读取和写入单个共享文件系统。</p>
<p>支持GFS2，最大文件系统大小为100TB。</p>
<h1 id="文件系统的调整注意事项"><a href="#文件系统的调整注意事项" class="headerlink" title="文件系统的调整注意事项"></a>文件系统的调整注意事项</h1><h2 id="格式化时的注意事项"><a href="#格式化时的注意事项" class="headerlink" title="格式化时的注意事项"></a>格式化时的注意事项</h2><p>格式化设备后，无法更改某些文件系统部分的配置，格式化存储设备前要做的决定和可用选项。</p>
<ul>
<li><p><strong>Size</strong></p>
<p>按照工作负载创建合理大小的文件系统。较小的文件系统具有相应较短的备份时间，并且需要较少的时间和内存来进行文件系统检查。但是如果你的文件系统太小，其性能将受到高度碎片的影响。</p>
</li>
<li><p><strong>Block size</strong></p>
<p>块是文件系统的工作单元。块大小决定了单个块中可以存储多少数据，因此可以确定一次写入或读取的最小数据量。</p>
<p>默认块大小适用于大多数用例。但是如果块大小（或多个块的大小）与通常一次读取或写入的数据量相同或稍大，则文件系统将更好地执行并有效低存储数据。一个小文件仍将使用整个块。文件可以分布在多个块上，但这回产生额外的运行时开销。此外，某些文件系统仅限于一定数量的块，这反过来限制了文件系统的最大大小。</p>
<p>使用<code>mkfs</code>命令格式化设备时，块大小被指定为文件系统选项的一部分。指定块大小的参数因文件系统而异。</p>
</li>
<li><p><strong>Geometry</strong></p>
<p>文件系统几何涉及跨文件系统的数据分布。如果系统使用条带存储（如RAID），则可以在格式化设备时通过将数据和元数据与基础数据集合对齐来提高性能。</p>
<p>很多数据导出的推荐集合在使用特定文件系统格式化设备时会被自动设置。如果设备没有导出这些推荐几何，或想要变更推荐设置，使用<code>mkfs</code>格式化设备时，需要手动指定几何。</p>
</li>
<li><p><strong>External journals</strong></p>
<p>日志文件系统记录在执行操作之前在日志文件中执行写操作期间所做的更改。这降低了存储设备在系统崩溃或电源故障时损坏的可能性，并加快了恢复过程。</p>
<p>元数据密集型工作负载射击队日志频繁的更新。交大的日志使用更多内存，但会降低写入操作的频率。此外，通过将日志放在与主存储一样快或更快的专用存储上，可以改善具有元数据密集型工作负载的设备的查找时间。</p>
</li>
</ul>
<h2 id="挂载时的注意事项"><a href="#挂载时的注意事项" class="headerlink" title="挂载时的注意事项"></a>挂载时的注意事项</h2><blockquote>
<p>适用于大部分文件系统的调整决定，且可在挂载设备时指定。</p>
</blockquote>
<ul>
<li><p><strong>Barriers</strong></p>
<p>文件系统屏障确保文件系统元数据在持久存储上正确编写和排序，并且<code>fsync</code>在断电时传输的数据仍然存在。</p>
</li>
<li><p><strong>Access Time</strong></p>
<p>每次读取文件时，其元数据都会根据访问发生的时间（atime）进行更新。这涉及额外的写入I/O。在大多数情况下，这种开销很小，因为默认情况下，<code>atime</code>只有当上一次访问时间早于上次修改（mtime）或状态更改（ctime）时，才会更新字段。</p>
<p>但是，如果更新此元数据非常耗时，并且如果不需要准确的访问时间数据，则可以使用<code>noatime</code>mount选项挂载文件系统。这回在读取文件时禁用元数据更新。它还启用了<code>nodiratime</code>行为，在读取目录时禁用元数据更新。</p>
</li>
<li><p><strong>Read-ahead</strong></p>
<p>预读行为我通过预先获取可能很快需要的数据并将其加载到页面缓存中来加速文件访问，在页面缓存中可以比磁盘上更快地检索它。预读值越高，系统预取数据越早。</p>
<p>Linux尝试根据检测到的文件系统设置适当的预读值。但是并不总是能够进行准确的检测。例如，如果存储阵列将自身作为单个LUN呈现给系统，则系统会检测单个LUN，并不会为阵列设置适当的预读值。</p>
<p>设计大量顺序I/O流的工作负载通常受益于搞预读值。与使用LVM条带化一样，Linux提供的于存储相关的调优配置文件提高了预读值，但这些调整对于所有工作负载并不总是足够。</p>
</li>
</ul>
<h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><blockquote>
<p>对于固态磁盘和精简配置存储，建议定期丢弃文件系统未使用的块。丢弃未使用块有两种方法：批量丢弃和在线丢弃。</p>
</blockquote>
<ul>
<li><p><strong>Batch discard（批量丢弃）</strong></p>
<p>这种丢弃是<code>fstrim</code>指令的一部分。它丢弃文件系统中与管理员指定的标准相匹配的所有不使用的块。</p>
<blockquote>
<p>CentOS支持XFS和ext4格式化设备上的batch discard，这些设备实际丢弃操作即<code>/sys/block/devname/queue/discard_max_bytes</code>值不为0的HDD设备和<code>/sys/block/sda/queue/discard_granularity</code>不为0的SSD。</p>
</blockquote>
</li>
<li><p><strong>online discard（在线丢弃）</strong></p>
<p>这种凡是的丢弃操作在挂载期间使用<code>discard</code>选项配置，实时运行不受用户干扰。然后。online discard只丢弃从使用转换到空闲的块。</p>
<blockquote>
<p>推荐使用batch discard 除非要求用 online discard 维持，或batch discard  不可用于系统工作负载。</p>
</blockquote>
</li>
<li><p><strong>Pre-allocation（预分配）</strong></p>
<p>预分配将磁盘空间标记为已经将磁盘空间分配给一个文件，而未将数据写入该空间。这可用于限制数据碎片和交叉的读取性能。CentOS支持XFS、ext4、GFS2设备预分配空间。应用程序也可以通过<code>fallocate</code>、<code>glibc</code>调用预先分配空间。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Storage and Filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>配置系统内存容量</title>
    <url>/2019/01/06/Linux/Performance-tuning/MEMORY/Configure-system-memory-capacity/</url>
    <content><![CDATA[<p>这些内核参数有可能有助于提高系统的内存利用率。通过更改<code>/proc</code>文件系统中相应的文件的值来临时设置这些参数以用于测试目的。确定用例生成最佳性能的值后，可以使用<code>sysctl</code>命令永久设置它们。</p>
<p>通常通过设置一个或多个内核参数的值来配置内存使用情况。可以通过更改<code>/proc</code>文件系统中文件的内容来临时设置这些参数，也可以使用<code>procps-ng</code>软件包提供的<code>sysctl</code>工具永久设置这些参数。</p>
<p>例如，要将<code>overcommit_memory</code>参数临时设置为1：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure></p>
<p>要永久设置这个值，在<code>/etc/sysctl.conf</code>文件中添加<code>vm.overcommit_memory=1</code>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>临时设置参数对于确定参数对系统的影响很有用。然后，当确定参数的值有所需效果时，可以永久设置参数。</p>
<h1 id="虚拟内存参数"><a href="#虚拟内存参数" class="headerlink" title="虚拟内存参数"></a>虚拟内存参数</h1><blockquote>
<p>除非另有说明，否者列出的参数都位于<code>/proc/sys/vm</code>中。</p>
</blockquote>
<ul>
<li><p><strong>dirty_ratio</strong></p>
<p>百分比值，修改总系统内存的百分比时，系统开始使用<code>pdflush</code>操作将修改写入磁盘。默认为<code>20%</code>。</p>
</li>
<li><p><strong>dirty_background_ratio</strong></p>
<p>百分比值，修改系统总内存百分比时，系统开始后台将修改写入磁盘。默认值为<code>20%</code>。</p>
</li>
<li><p><strong>overcommit_memory</strong></p>
<p>定义是接受还是拒接大内存请求的条件。</p>
<p>默认值为<code>0</code>，默认情况下，内核通过估计可用内存量和过大的请求失败来执行启发式内存过量使用处理。但是由于使用启发式而非精准算法分配内存，因此使用此设置可以重载内存。</p>
<p>当此参数设置为1时，内核不执行内存过量使用处理。增加了内存过载的可能性，但提高了内存密集型任务的性能。</p>
<p>当此参数设置为<code>2</code>时，内核拒绝内存请求等于或大于总可用<code>SWAP</code>空间和<code>overcommit_ratio</code>中指定的物理RAM的百分比之和。这样可以降低过度使用内存的风险，但建议仅适用于交换区域大于物理内存的系统。</p>
</li>
<li><p><strong>overcommit_ratio</strong></p>
<p>指定当<code>overcommit_memory</code>设置为2时考虑的物理RAM的百分比。默认是<code>50%</code>。</p>
</li>
<li><p><strong>max_map_conut</strong></p>
<p>定义进程可以使用的最大内存映射区域数。默认为<code>65545</code>，适用于大多数情况。如果程序需要映射超过此数量的文件，增加此值。</p>
</li>
<li><p><strong>min_free_kbytes</strong></p>
<p>指定在系统中保持空闲的最小千字节数。这用于确定每个低内存区域的适当值，每个低内存区域都按照其大小按比例分配了多个保留的内存空闲页面。</p>
</li>
</ul>
<blockquote>
<p>极端值可能会损坏系统。将<code>min_free_kbytes</code>设置为极低值可防止系统回收内存，但这可能导致系统挂起和OOM终止进程。但是，将<code>min_free_kbytes</code>设置太高（例如，占用系统总内存的5%-10%）会导致系统立即进入内存不足的状态，从而导致系统话费太多时间回收内存。</p>
</blockquote>
<ul>
<li><p><strong>oom_adj</strong></p>
<p>如果系统内存不足并且<code>panic_on_oom</code>参数设置为<code>0</code>，则<code>oom_killer</code>函数会终止进程，知道系统可以从具有最高<code>oom_score</code>的进程开始恢复。</p>
<p><code>oom_adj</code>参数有助于确定进程的<code>oom_score</code>，此参数是根据进程标识符设置的。设置为<code>17</code>表示禁用进程<code>oom_killer</code>。其他有效值为<code>-16</code>到<code>15</code>。</p>
<blockquote>
<p>由调整后的进程生成的进程会集成进程的<code>oom_score</code>。</p>
</blockquote>
</li>
<li><p><strong>swappiness</strong></p>
<p><code>swappiness</code>值（0-100）控制系统支持的匿名内存或页面缓存程度。较高的值可提高文件系统性能，同时积极地将较少活动的进程从RAM中交换出来。较低的值可避免将进程交换到内存中，这通常或降低延迟，但代价是<code>I/O</code>性能。默认为<code>60</code>。</p>
<blockquote>
<p>设置<code>swappiness==0</code>将非常积极的避免交换。这增加了强内存和I/O压力下OOM被杀死的风险。</p>
</blockquote>
</li>
</ul>
<p>​    </p>
<h1 id="文件系统参数"><a href="#文件系统参数" class="headerlink" title="文件系统参数"></a>文件系统参数</h1><p>所列出的参数位于<code>/proc/sys/fs</code>.</p>
<ul>
<li><p><strong>aio-max-nr</strong></p>
<p>定义所有活动异步输入/输出上下文中允许的最大事件数。默认值为<code>65535</code>。修改此值不会预先分配或调整任何内核数据结构的大小。</p>
</li>
<li><p><strong>file-max</strong></p>
<p>确定整个系统的最大文件句柄数。默认值最大值是<code>8192</code>或者可用内存页面的十分之一。</p>
<p>提高此值可以解决由于缺少可用文件句柄而导致的错误。</p>
</li>
</ul>
<h1 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h1><p>以下参数的默认位于<code>/oroc/sys/kernel</code>中，可由内核在引导时根据可用的系统资源计算。</p>
<ul>
<li><p><strong>msgmax</strong></p>
<p>定义消息队列中任何单个消息的最大允许大小（以字节为单位）。该值不得超过队列的大小（msgmnb）。要确定系统上的当前<code>msgmax</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.msgmax</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msgmnb</strong></p>
<p>定义单个消息队列的最大值（字节为单位），要确定系统上的当前<code>msgmnb</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.msgmnb</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msgmni</strong></p>
<p>定义消息队列标识符的最大数量（以及队列的最大数量），要确定系统上的当前<code>msgmin</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.msgmni</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>shmall</strong></p>
<p>定义一次可在系统上使用的共享内存页面的总数，例如，x86_64架构上的页面为4096字节。</p>
<p>要确定系统当前<code>shmall</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.shmall</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>shmmax</strong></p>
<p>定义内核允许的单个共享内存段的最大大小（字节为单位）。要确定系统上的当前<code>shmmax</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.shmmax</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>shmmni</strong></p>
<p>定义系统范围的最大共享内存段数，所有系统上的默认值均为<code>4096</code>。</p>
</li>
<li><p><strong>threads-max</strong></p>
<p>定义一次可用于内核的系统阀内最大线程数。要确定系统上当前的 <code>threads-max</code>值，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl kernel.threads-max</span><br></pre></td></tr></table></figure>
<p>默认结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mempages/(8*THREAD_SIZE/PAGESIZE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>配置大内存页</title>
    <url>/2019/01/03/Linux/Performance-tuning/MEMORY/Configure-large-memory-pages/</url>
    <content><![CDATA[<p>有个两种方法可以保留大内存页：</p>
<ol>
<li>at <strong>boot time</strong>（启动时修改）</li>
<li>at <strong>run time</strong>（运行时修改）</li>
</ol>
<p>在 启动时保留会增加成功的可能性，因为内存尚未明显碎片化。但是在NUMA架构上，页面数量会自动在NUMA节点之间分配。运行时修改允许为每个NUMA节点保留大内存页。如果在引导过程中今早完成运行时预留，则内存碎片的可能性会降低。</p>
<h1 id="引导时配置大内存页"><a href="#引导时配置大内存页" class="headerlink" title="引导时配置大内存页"></a>引导时配置大内存页</h1><p>要在引导时配置大内存页，请将以下参数添加到内核引导命令行：</p>
<a id="more"></a>
<ul>
<li><p><code>hugepages</code></p>
<p>定义引导时在内核中配置的持久性大内存页的数量。默认值为0，如果系统中有足够的连续物理空闲页面，则只能分配大内存页。此参数保留的页不能用于其他目的。</p>
<p>通过修改<code>proc/sys/vm/nr_hugepages</code>文件的值在引导后使用。</p>
<p>在NUMA系统中，使用此参数分配的大内存页在节点之间平均分配。可以通过更改节点的值在运行时将大内存页分配给特定节点的<code>/sys/devices/system/node/NODE_ID/hugepages/hugepages-1048576kB/nr_hugepages</code>文件。</p>
</li>
<li><p><code>hugepagesz</code></p>
<p>定义引导时在内核中配置的持久页面大小。有效值为2MB和1GB。默认为2MB。</p>
<p><strong>例如，保留1GB页面</strong></p>
<p>HugeTLB子系统支持的页面大小取决于体系结构。在x86_64架构上，支持2MB大内存也和1GB大内存页。</p>
<ol>
<li><p>通过将以下行附加到内核命令 ，为1GB页面创建HugeTLB池：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default_hugepagesz=1G hugepagesz=1G</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个名为<code>/usr/lib/systemd/system/hugetlb-gigantic-pages.service</code>，具体内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=HugeTLB Gigantic Pages Reservation</span><br><span class="line">DefaultDependencies=no</span><br><span class="line">Before=dev-hugepages.mount</span><br><span class="line">ConditionPathExists=/sys/devices/system/node</span><br><span class="line">ConditionKernelCommandLine=hugepagesz=1G</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">ExecStart=/usr/lib/systemd/hugetlb-reserve-pages.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sysinit.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个名为<code>/usr/lib/systemd/hugetlb-reserve-pages.sh</code>具体内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">nodes_path=/sys/devices/system/node/</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$nodes_path</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$nodes_path</span> does not exist"</span></span><br><span class="line">	<span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">reserve_pages()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">echo</span> <span class="variable">$1</span> &gt; <span class="variable">$nodes_path</span>/<span class="variable">$2</span>/hugepages/hugepages-1048576kB/nr_hugepages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reserve_pages NUMBER_OF_PAGES node</span><br></pre></td></tr></table></figure>
<p>将最后一行的<code>NUMBER_OF_PAGES</code>替换为要爆了的1GB页数，并将节点替换为要保留这些页的节点名称。</p>
</li>
<li><p>要在node0上保留两个1GB页面，在node1上保留一个1GB页，用以下代码替换最后一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reserve_pages 2 node0</span><br><span class="line">reserve_pages 1 node1</span><br></pre></td></tr></table></figure>
<p>可以根据需要对其进行修改，也可以添加更多行以在其他节点中保留。</p>
</li>
<li><p>使脚本执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x /usr/lib/systemd/hugetlb-reserve-pages.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> hugetlb-gigantic-pages</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>可以随时通过写入nr_hugepages尝试在运行时保留更多1GB页面。但是，由于内存碎片，此类预留可能会失败。保留1GB页面的最可靠方法是使用此脚本，该脚本在早期启动时运行。</p>
</blockquote>
<h1 id="运行时配置大内存页"><a href="#运行时配置大内存页" class="headerlink" title="运行时配置大内存页"></a>运行时配置大内存页</h1><p>使用以下参数可以在运行时影响大型页：</p>
<p><code>/sys/devices/system/node/NODE_ID/hugepages/HUGEPAGES-SIZE/nr_hugepages</code>定义分配给指定NUMA节点的指定大内存页数，以下示例是将20个2048KB的大页移动到node2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numastat -cm | egrep <span class="string">'Node|Huge'</span></span><br><span class="line">                 Node 0 Node 1 Node 2 Node 3  Total add </span><br><span class="line">AnonHugePages         0      2      0      8     10</span><br><span class="line">HugePages_Total       0      0      0      0      0</span><br><span class="line">HugePages_Free        0      0      0      0      0</span><br><span class="line">HugePages_Surp        0      0      0      0      0</span><br><span class="line"><span class="built_in">echo</span> 20 &gt; /sys/devices/system/node/node2/hugepages/hugepages-2048kB/nr_hugepages </span><br><span class="line">numastat -cm | egrep <span class="string">'Node|Huge'</span></span><br><span class="line">                 Node 0 Node 1 Node 2 Node 3  Total</span><br><span class="line">AnonHugePages         0      2      0      8     10 </span><br><span class="line">HugePages_Total       0      0     40      0     40</span><br><span class="line">HugePages_Free        0      0     40      0     40</span><br><span class="line">HugePages_Surp        0      0      0      0      0</span><br></pre></td></tr></table></figure>
<p><code>/proc/sys/vm/nr_overcommit_hugepages</code>定义系统通过过度使用内存而异创建和使用的其他大内存页的最大数。将任何非零值写入此文件表示如果持久性大页池耗尽，系统将从内核的正常内存页池中湖区大量页面。当这些剩余的大内存页空闲时，他们将被释放会内核的正常页面池。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>转换检测缓冲区大小</title>
    <url>/2019/01/03/Linux/Performance-tuning/MEMORY/Conversion-detection-buffer-size/</url>
    <content><![CDATA[<p>从页表中读取地址映射很耗时且资源宝贵，因此Linux操作系统提供最近使用地址的缓存：转换检测缓冲区（TLB）。但默认的TLB只能缓存一定量的的地址映射。如果需要的地址映射不存在TLB中（TLB miss），系统仍然需要读取页表以决定物理到虚拟的内存地址映射。</p>
<p>由于应用程序内存需求与用来缓存地址映射的页大小之间的关系，对于内存需求小的应用程序来说，对内存需求大的程序更容易受到TLB miss造成的性能下降。因此无论何时，避免TLB miss很重要。</p>
<p>部分Linux提供大型转换检测缓冲区（大型TLB），可以将内存分为大片段进行管理。这使大量的地址映射能同时进行缓存，降低TLB miss的可能性，提高需要大内存的应用程序的性能。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Tuned</title>
    <url>/2019/01/03/Linux/Performance-tuning/Tuned/</url>
    <content><![CDATA[<p>Tuned是一个守护进程，用于<code>udev</code>监视连接的设备，并根据所选的配置文件静态和动态地调整系统设置。Tuned分布有许多预定义的配置文件，适用于高吞吐量，低延迟或<code>powersave</code>等常见用例。可以修改为每个配置文件定义的规则，并自定义如何调整特定设备。要还原特定配置文件对系统设置所做的所有更改，可以切换到另一个配置文件或停止<code>tuned</code>服务。</p>
<blockquote>
<p>Tuned 支持 <strong>Tuned in on-deamon mode</strong>，此模式下，<code>tuned</code>会应用设置并退出。要启用这种模式，在<code>/etc/tuned/tuned-main.conf</code>文件中设置<code>deamon = 0</code> 。</p>
</blockquote>
<p>静态调优主要包括预定义的<code>sysctl</code>和<code>sysfs</code>设置以及一些配置工具的一次性激活。<code>tuned</code>还根据监控信息动态监控系统组件的使用并调整系统设置。</p>
<p>动态调整考虑了在任何给定系统的整个正常运行时间内各种系统组件的使用方式不同。例如，阴干驱动器在启动和登录期间大量使用，但稍后再用户可能主要使用web浏览器或电子邮件客户端几乎不适用，类似地，CPU和网络设备在不同时间使用特点也不同。<code>tuned</code>监控这些组件的活动并对其使用的变化做出反应。</p>
<p>典型的，办公室工作站。大多数情况下，以太网网络接口不是很活跃。每隔一段时间只有少量的电子邮件进出，或者可能会加载一些网页。对于那些类型的负载，网络接口不必全速运行，就像默认情况下那样。<code>tuned</code>有一个用于网络设备的监控和调整插件，可以检测到这活动，然后自动降低网络速率，通常为了降低功耗。如果界面上的活动增减了很长一段时间。例如正在下载,<code>tuned</code>检测到这一点并将接口速率设置为最大，以便活动级别如此之高时提供最佳性能。此原则也用于CPU和硬盘的其他插件。</p>
<p>动态<code>tuned</code>默认是禁用的，可以更改<code>/etc/tuned/tuned-main.conf</code>文件中的<code>dynamic_tuning</code>为<code>1</code>来启用。<br><a id="more"></a></p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p><code>tuned</code>使用两种类型的插件：<em>tuning plugins</em>和,<em>monitoring plugins</em>,目前有一下monitoring plugins：</p>
<ul>
<li><p>disk</p>
<p>获取每个设备的磁盘负载（IO操作数）和测量间隔。</p>
</li>
<li><p>net</p>
<p>获取每个网卡的网络负载（传输的数据包数）和测量间隔。</p>
</li>
<li><p>load</p>
<p>获取每个CPU的CPU负载和测量间隔。</p>
</li>
</ul>
<p>可能通<em>tuning plugins</em>进行动态调整来使用<em>monitoring plugins</em>的输出。当前实现的动态调整算法尝试平衡性能和<code>powersave</code>,因此在性能配置文件中被禁用（可以在<code>tuned</code>配置文件中启用或禁用各个插件的动态调整）。只要任何启用的调优插件需要其指标，<em>monitoring plugins</em>就会自动实例化，如果两个<em>tuning plugins</em>需要相同的数据，则只创建一个<em>monitoring plugins</em>实例并共享数据。</p>
<p>每个<em>tuning plugins</em>都会调整单个子系统，并从<strong>调整后的</strong>配置文件中获取几个参数。每个子系统可以具有多个设备（例如，多个CPU或网卡），这些设备由<em>tuning plugins</em>的各个实例处理。还支持各个设备的特定设置。提供的配置文件使用通配符来匹配各个子系统的所有设备，这允许插件根据所需膜表调整这些子系统（选定的配置文件）并且用户唯一需要做的就是选择正确的<code>tuned</code>配置文件。</p>
<p>目前，实现了以下<em>tuning plugins</em>：</p>
<p><strong>cpu</strong></p>
<p>​    将CPU调度器设置为<code>governor</code>参数指定的值，并根据CPU负载动态更改PM Qos CPU DMA延迟。如果CPU负载低于<em>load_threshold</em>参数指定的值，则将latency设置为<em>latency_high</em>参数指定的值，否则将其设置为<em>latency_low</em>指定的值。侧歪，可以将延迟强制为特定值，而无需进一步动态更改。这可以通过将<em>force_latency</em>参数设置为所需的延迟值来实现。</p>
<p><strong>eeepc_she</strong></p>
<p>​    根据CPU负载情况动态设置FSB速度；一般不需要配置，如果CPU负载低于或等于<code>load_threshold_powersave</code>参数指定的值，则插件将FSB速度设置为参数指定的值。</p>
<p><strong>net</strong></p>
<p>​    将<code>wake-on-lan</code>配置为<code>wake_on_lan</code>参数指定的值。还根据接口利用率动态改变接口速率。</p>
<p><strong>sysctl</strong></p>
<p>​    设置<code>sysctl</code>插件参数指定的各种设置。语法为<code>name = value</code>，其中<code>name</code>与<code>sysctl</code>工具提供的名称相同。如果需要更改其他插件未涵盖的设置，请使用此插件。</p>
<p><strong>usb</strong></p>
<p>​    将USB设备的自动暂停超时设置为<code>autosuspend</code>参数指定的值。0表示禁用自动挂起。</p>
<p><strong>audio</strong></p>
<p>​    将音频解码器的自动暂停超时设置为<code>timeout</code>参数指定的值。目前<code>snd_hda_intel</code>和<code>snd_ac97_aodec</code>得到支持。该值为0表示禁用自动暂停。</p>
<p><strong>disk</strong></p>
<p>将电梯设置为<em>elevator</em>参数指定的值。它还将ALPM设置为参数指定的值<em>alpm</em>，ASPM为参数指定的值<em>aspm</em>，scheduler quantum为<em>scheduler_quantum</em>参数指定的值，disk spindown timeout为<em>spindown</em>参数指定的值，disk readahead为指定的值<em>readahead</em>参数，可以将当前磁盘预读值乘以<em>readahead_multiply</em>参数指定的常量。此外，此插件根据当前驱动器利用率动态更改驱动器的高级电源管理和spindown超时设置。动态调整可以通过布尔参数控制<em>dynamic</em>，默认情况下启用。</p>
<p><strong>mounts</strong></p>
<p>根据<em>disable_barriers</em>参数的布尔值启用或禁用装载障碍。</p>
<p><strong>script</strong></p>
<p>此插件可用于执行在加载或卸载配置文件时运行的外部脚本。该脚本由一个参数调用，该参数可以是<code>start</code>或<code>stop</code>（它取决于在配置文件加载或卸载期间是否调用脚本）。脚本文件名可以由<em>script</em>参数指定。请注意，您需要在脚本中正确实现停止操作并恢复在启动操作期间更改的所有设置，否则回滚将不起作用。为了您的方便，<code>functions</code>默认情况下安装Bash帮助程序脚本，允许您导入和使用其中定义的各种函数。请注意，此功能主要是为了向后兼容性而提供的，建议您将其用作最后的手段，如果它们涵盖了所需的设置，则更喜欢其他插件。</p>
<p><strong>sysfs</strong></p>
<p>设置<code>sysfs</code>插件参数指定的各种设置。语法是<code>name</code>= <code>value</code>，其中<code>name</code>是<code>sysfs</code>要使用的路径。如果您需要更改其他插件未涵盖的某些设置，请使用此插件（如果它们涵盖了所需的设置，请选择特定的插件）。</p>
<p><strong>video</strong></p>
<p>在视频卡上设置各种powersave级别（目前仅支持Radeon卡）。可以使用<em>radeon_powersave</em>参数指定powersave级别。支持的值是：<code>default</code>，<code>auto</code>，<code>low</code>，<code>mid</code>，<code>high</code>，和<code>dynpm</code>。</p>
<p>bootloader</p>
<p>将参数添加到内核引导命令行。此插件支持旧版GRUB 1，GRUB 2以及带可扩展固件接口（EFI）的GRUB。可以通过<em>grub2_cfg_file</em>选项指定grub2配置文件的自定义非标准位置。参数将添加到当前grub配置及其模板中。需要重新启动计算机才能使内核参数生效。</p>
<p>可以通过以下语法指定参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmdline= arg 1 arg 2 ... arg n。</span><br></pre></td></tr></table></figure>
<h1 id="安装及其使用"><a href="#安装及其使用" class="headerlink" title="安装及其使用"></a>安装及其使用</h1><p>要安装tuned， 运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install tuned</span><br></pre></td></tr></table></figure>
<p><code>tuned</code>包还预设了最合适系统的配置文件。目前根据以下可自定义规则选择默认配置文件：</p>
<p><code>throughput-performance</code></p>
<p>​    这是在充当计算节点操作系统上预先选择的。此类型目标是最佳吞吐量性能。</p>
<p><code>virtual-guest</code></p>
<p>​    这是在虚拟机上预先选择的。目标是最佳表现。如果对性能不感兴趣，可以希望将其修改为<code>balanced</code>或<code>powersave</code>配置文件。</p>
<p><code>balanced</code></p>
<p>​    这是在所有其他情况下预先选择的。目标是平衡性能和功耗。</p>
<p>要启动<code>tuned</code>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start tuned</span><br></pre></td></tr></table></figure>
<p>开机启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> tuned</span><br></pre></td></tr></table></figure>
<p><code>tuned</code>控制。例如选择配置文件和其他：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm</span><br></pre></td></tr></table></figure>
<p>此命令要求<code>tuned</code>服务在运行。</p>
<p>要查看可用的已安装配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm list</span><br></pre></td></tr></table></figure>
<p>要查看当前激活的配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm active</span><br></pre></td></tr></table></figure>
<p>要选择或激活配置文件,运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm profile profile</span><br></pre></td></tr></table></figure>
<p>可以一次选择多个配置文件。应用程序将尝试在装载过程中合并他们，如果存在冲突，则最后指定的配置文件中的设置优先。这是自动完成的，下面示例优化系统以便在虚拟机中获得最佳性能，并同事针对低功耗进行调整，低功耗作为优先级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm prfile virtual-guest powersave</span><br></pre></td></tr></table></figure>
<p>要让<code>tuned</code>建议您为系统选择最合适的配置文件，而不更改任何现有配置文件并使用安装期间使用的相同逻辑，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm recommend</span><br></pre></td></tr></table></figure>
<h1 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h1><p>特定于分发的配置文件存储在<code>/usr/lib/tuned/</code>目录中。每个配置文件都有自己的目录。该配置文件由调用的主配置文件<code>tuned.conf</code>和可选的其他文件组成，例如帮助程序脚本。</p>
<p>如果需要自定义配置文件，请将配置文件目录复制到<code>/etc/tuned/</code>用于自定义配置文件的目录中。如果有两个相同名称的配置文件，则使用包含在<code>/etc/tuned/</code>其中的配置文件。</p>
<p>还可以在<code>/etc/tuned/</code>目录中创建的配置文件，已使用<code>/usr/lib/tuned/</code>中包含的配置文件，仅调整或覆盖某些参数。</p>
<p><code>tuned.conf</code>文件包含几个部分。有一个<code>[mian]</code>部分。其他部分是插件实例的配置。所有部分都是可选的，包括<code>[mian]</code>部分。以<code>#</code>开头是行的注释。</p>
<p><code>[main]</code>部分 有以下选项：</p>
<p><code>include-profile</code></p>
<p>​    将包括指定的配置文件，例如<code>include=powersave</code>将包括<code>powersave</code>配置文件。</p>
<blockquote>
<p>藐视插件实例的部分按以下方法格式化：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[NAME]</span><br><span class="line"><span class="built_in">type</span>=TYPE</span><br><span class="line">decices=DEVICES</span><br></pre></td></tr></table></figure>
<p><code>NAME</code>是日志中使用的插件实例名称。它可以是任意字符串。<code>TYPE</code>是插件类型。<code>DEVICES</code>是此插件实例将处理的设备列表。<code>devices</code>行可以包含列表，通配符和否定。您还可以组织规则。如果没有<code>decices</code>行，则系统中存在或稍后附加的所有设备<code>TYPE</code>将由插件实例处理。如果未配置插件的实例，则不会启用插件，如果插件支持更多选项，可以在插件部分指定它们。如果未指定该选项，则将使用默认值。</p>
<p><strong>描述实例</strong></p>
<p>以下示例将匹配<code>sd</code>开头的内容，例如<code>sda</code>或<code>sdb</code>,并且不会禁它们的障碍：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[data_disk]</span><br><span class="line"><span class="built_in">type</span>=disk</span><br><span class="line">devices=sd*</span><br><span class="line">disable_barriers=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>以下示例将匹配除<code>sda1</code>和<code>sda2</code>之外的所有内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[data_disk]</span><br><span class="line"><span class="built_in">type</span>=disk</span><br><span class="line">devices=!sda1. !sda2</span><br><span class="line">disable_barriers=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不需要插件实例的自定义命名，并且配置文件中只有一个实例定义，Tuned支持以下简短语法：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[TYPE]</span><br><span class="line">devices=DEVICES</span><br></pre></td></tr></table></figure>
<p>在这种情况下，可以省略<code>TYPE</code>行，然后将使用与类型相同的名称引用该实例。之前的示例可以重写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[disk]</span><br><span class="line">devices=sdb*</span><br><span class="line">disable_barriers=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>如果使用<code>include</code>选项多次指定相同的部分，则合并设置。如果由于冲突中的先前设置。有时，不知道之前定义的是什么，在这种情况下，可以设置<code>replace</code>为<code>true</code>.这将导致所有以前具有相同名称的定义被覆盖，而且不会发生合并。</p>
<p>您还可以通过指定<code>enabled=false</code>选项来禁用插件。这与从未定义实例的效果相同。如果要从<code>include</code>选项重新定义先前的定义并且不希望插件在自定义配置文件中处于活动状态，则禁用该插件会很有用。</p>
<p>以下是基于balance配置文件的自定义配置文件示例，并将其拓展为将所有设备的ALPM设置为最大省电方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">include=balanced</span><br><span class="line"></span><br><span class="line">[disk]</span><br><span class="line">alpm=min_power</span><br></pre></td></tr></table></figure>
<p>以下是将<code>isolcpus=2</code>添加到内核引导命令行的自定义配置文件的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[bootloader]</span><br><span class="line">cmdline=isolcpus=2</span><br></pre></td></tr></table></figure>
<p>应用配置文件后，需要重新启动计算机才能使更改生效。</p>
<h1 id="Tuned-adm"><a href="#Tuned-adm" class="headerlink" title="Tuned-adm"></a>Tuned-adm</h1><p>对系统的详细分析可能非常耗时，默认包含许多典型用例的预定义的配置文件，可以使用<code>tuned-adm</code>程序轻松激活这些配置文件，还可以创建，修改和删除配置文件。</p>
<p>要列出所有可用的配置文件并标识当前活动配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm list</span><br></pre></td></tr></table></figure>
<p>要仅显示当前活动的配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm active</span><br></pre></td></tr></table></figure>
<p>要切换到其中一个可用的配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm profile PROFILE_NAME</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm profile latency-performance</span><br></pre></td></tr></table></figure>
<p>要禁用所有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm off</span><br></pre></td></tr></table></figure>
<p>以下是默认的预置的配置文件列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置文件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>balanced</code></td>
<td>默认节能配置文件。旨在成为性能和功耗之间的折衷。尽可能尝试使用自动缩放和自动调整。对大多数负载都有很好的效果。唯一的缺点是延迟增加。</td>
</tr>
<tr>
<td><code>powersave</code></td>
<td>最佳节能配置文件。可以牺牲性能以最小化实际功耗。在当前的<code>tuned</code>版本中，它可以在<code>SATA</code>主机适配实现USB自动挂起等省电方式。</td>
</tr>
<tr>
<td><code>throughput-performance</code></td>
<td>针对高吞吐量优化的服务器配置文件它禁用节能机制并启用<code>sysctl</code>设置，提高磁盘，网络I/O的吞吐量性能并切换到<code>deadline</code>调度程序。CPU调控器为<code>performance</code>。</td>
</tr>
<tr>
<td><code>latency-performance</code></td>
<td>针对低延迟优化服务器配置文件。它禁用省电机制并启用<code>sysctl</code>设置以改善延迟。CPU调控器设置为<code>performance</code>并且CPU锁定到低C状态。</td>
</tr>
<tr>
<td><code>network-latency</code></td>
<td>用于低延迟网络的配置文件。基于<code>latency-performance</code>设置，禁用透明大页面，NUMA平衡和调整其他几个网络相关的<code>sysctl</code>参数。</td>
</tr>
<tr>
<td><code>network-throughput</code></td>
<td>吞吐量网络的配置文件，基于<code>throughput-performance</code>，增加了内核网络缓冲区。</td>
</tr>
<tr>
<td><code>virtual-guest</code></td>
<td>基于<code>enterprise-storage</code>配置文件，除其他任务外，还可减少虚拟内存并增加磁盘预读值。不会禁用磁盘障碍。</td>
</tr>
<tr>
<td><code>virtual-host</code></td>
<td>基于<code>enterprise-storage</code>配置文件，减少虚拟内存吞吐量，增加磁盘预读值并启用更强大的脏页值。</td>
</tr>
<tr>
<td><code>oracle</code></td>
<td>基于<code>throughput-performance</code>配置文件，针对oracle数据库优化，禁用透明的大页面并修改其他一些与性能相关的内核参数。</td>
</tr>
<tr>
<td><code>desktop</code></td>
<td>基于<code>balanced</code>配置文件。还支持调度程序自动组，以便更高的相应交互式程序。</td>
</tr>
<tr>
<td><code>default</code></td>
<td>只启动CPU和磁盘插件。</td>
</tr>
<tr>
<td><code>desktop-powesave</code></td>
<td>针对桌面系统的节能配置文件。</td>
</tr>
<tr>
<td><code>lapto-ac-powersave</code></td>
<td>针对运行AC的笔记本电脑节能配置文件。</td>
</tr>
<tr>
<td><code>lapto-battery-powersave</code></td>
<td>针对笔记本节能配置文件。</td>
</tr>
<tr>
<td><code>spindown-disk</code></td>
<td>经典HDD的机器的节能配置文件，最大限度地延长spindown时间。禁用省电机制，禁用USB自动挂起，禁用蓝牙，启用WiFi省电，禁用日志同步，增加磁盘回写时间，降低磁盘刷新，使用<code>noatime</code>选项重新挂载所有分区。</td>
</tr>
<tr>
<td><code>enterprise-storage</code></td>
<td>针对企业级存储的服务器配置文件，最大化I/O吞吐量，禁用非root和非引导分区上的障碍。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="powertop2tuned"><a href="#powertop2tuned" class="headerlink" title="powertop2tuned"></a>powertop2tuned</h1><p><code>powertop2tuned</code>是一个实用程序，允许从<code>PowerTOP</code>建议创建自定义<code>tuned</code>配置文件。</p>
<p>要安装请运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install tuned-utils</span><br></pre></td></tr></table></figure>
<p>创建一个自定义配置文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">powertop2tuned NEW_PROFILE_NAME</span><br></pre></td></tr></table></figure>
<p>默认情况下，它会在<code>/etc/tuned</code>目录中创建配置文件，并将其基于当前选定的配置文件。出于安全原因，最初在新配置文件中禁用所有<code>PowerTOP</code>调整，要使他们能够在<code>/etc/tuned/profile/tuned.conf</code>中取消对您感兴趣的调整。可以使用<code>--enable</code> 或者<code>-e</code>选项生成新的配置文件，其中包含启用<code>PowerTOP</code>建议的大多数调整。一些危险和调整，如USB自动暂停仍将被禁用。如果确实需要它们，必须手动取消注释。默认情况下，不会激活新的配置文件，要激活请运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuned-adm profile NEW_PROFILE_NAME</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>内存页大小</title>
    <url>/2019/01/02/Linux/Performance-tuning/MEMORY/Memory-page-size/</url>
    <content><![CDATA[<p>物理内存管理区块称为页，每个页的物理位置都映射到一个虚拟位置以便处理器能够访问内存。这种映射存储于一个叫做页表的数据结构中。</p>
<p>默认情况下，一个页4KB，由于页的默认大小非常小，因此需要很多页来管理大量的内存。但是，页表只能存储有限的地址映射，增加其存储地址映射的数量既昂贵又困难，因为要考虑到将性能保护顶级保持在内存需求的范围内。</p>
<p>Linux通过静态大型页来给每个页管理大内存的能力。静态大型分页可以配置到1GB大小。但是很难对其进行手动管理，必须在启动时就分配好。</p>
<p>透明大分页很大程度上使之余静态大页面的一个自动选择。透明大型页大小为2MB且默认启动。它们有时会干扰对延迟敏感的应用，因此常常在延迟严重时被禁用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>监控和诊断性能问题</title>
    <url>/2019/01/01/Linux/Performance-tuning/MEMORY/Monitor-and-diagnose-memory-performance-issues/</url>
    <content><![CDATA[<h1 id="使用vmstat监控内存使用量"><a href="#使用vmstat监控内存使用量" class="headerlink" title="使用vmstat监控内存使用量"></a>使用vmstat监控内存使用量</h1><p><code>vmstat</code>由procps-ng包提供。</p>
<p>以下命令显示各种事件计数器和内存统计的表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmstat -s</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="使用Valgrind分析应用程序的内存使用情况"><a href="#使用Valgrind分析应用程序的内存使用情况" class="headerlink" title="使用Valgrind分析应用程序的内存使用情况"></a>使用Valgrind分析应用程序的内存使用情况</h1><p><code>valgrind</code>是一个为用户空间二进制文件提供检测的框架。附带了许多工具，用于分析程序的性能：</p>
<p>要使用<code>valgrind</code>请安装<code>balgrind</code>软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install valgrind</span><br></pre></td></tr></table></figure>
<h2 id="使用memcheck分析内存使用情况"><a href="#使用memcheck分析内存使用情况" class="headerlink" title="使用memcheck分析内存使用情况"></a>使用memcheck分析内存使用情况</h2><p><code>memcheck</code>是默认的<code>valgrind</code>工具。可以检测并报告许多难以检测和诊断的内存错误，例如：</p>
<ul>
<li>不应发生的内存访问</li>
<li>未定义或未初始化的值使用</li>
<li>错误地释放堆内存</li>
<li>指针重置</li>
<li>内存泄露</li>
</ul>
<p>由于<code>memcheck</code>使用检测，因此使用<code>memcheck</code>执行的应用程序比平时慢十倍到三十倍。</p>
<p>要在应用程序运行<code>memcheck</code>，执行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=mecheck APPLICATION</span><br></pre></td></tr></table></figure>
<p>还可以使用以下选项将<code>memcheck</code>输出集中在特定类型的问题上。</p>
<ul>
<li><p><code>--leak-check</code></p>
<p>应用程序完成启动后，<code>memcheck</code>会搜索内存泄露。默认值为<code>--leak-check=summary</code>.它打印出发现的内存泄露次数，可以指定<code>--leak-check=yes</code>或<code>--leak-check=full</code>来输出每个泄露的详细信息。要禁用，请指定<code>--leak-check=no</code>。</p>
</li>
<li><p><code>--undef-value-errors</code></p>
<p>默认值为<code>--undef-value-errors=yes</code>,当未使用自定义的值时报告错误，还可以指定<code>--undef-value-error=no</code>，这将禁用此报告，加快<code>memcheck</code>。</p>
</li>
<li><p><code>--ignore-ranges</code></p>
<p>指定<code>memcheck</code>在检查内存寻址能力时忽略一个或多个范围，例如，<code>--ignore-ranges=0xPP-0xQQ,0xRR-0xSS</code>。</p>
</li>
</ul>
<h2 id="使用chchegrind分析缓存使用情况"><a href="#使用chchegrind分析缓存使用情况" class="headerlink" title="使用chchegrind分析缓存使用情况"></a>使用chchegrind分析缓存使用情况</h2><p><code>cachegrind</code>模拟应用程序与系统缓存层次结构和分支预测期器的交互。它跟踪模拟的第一级指令和数据告诉缓存的使用，以检测与此级别告诉缓存的不良代码交互，它还跟踪最后一级缓存（二级或三级）以跟踪内存访问。因此，使用<code>cachegrind</code>应用程序比平时慢了20到100倍。</p>
<p><code>cachegrind</code>手机应用程序执行期间的统计信息，并将摘要输出到控制台。要在程序上运行<code>cachegrid</code>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vaglrind --tool = cachegrind  APPLICATION</span><br></pre></td></tr></table></figure>
<p>还可以使用以下选项将<code>cachegrind</code>输出聚焦到特定问题。</p>
<ul>
<li><p><code>--I1</code></p>
<p>指定第一级指令高速缓存的大小，关联性和行大小，就像这样：<code>--I1=SIZE,ASSOCIATIVITY,LINE_SIZE</code>。</p>
</li>
<li><p><code>--D1</code> </p>
<p>指定第一级数据高速缓存的大小，关联性和行大小，就像这样：<code>--D1=SIZE,ASSOCIATIVITY,LINE_SIZE</code>。</p>
</li>
<li><p><code>--LL</code></p>
<p>指定最后一级缓存的大小，关联性和行大小，就像这样：<code>--LL=SIZE,ASSOCIATIVITY,LINE_SIZE</code>。</p>
</li>
<li><p><code>--cache-sim</code></p>
<p>启用或禁用缓存访问和未命中计数。默认情况下是启用（<code>–cache-sim=yes</code>）。禁用会使<code>cachegrind</code>无法收集信息。</p>
</li>
<li><p><code>--branch-sim</code></p>
<p>启用或禁用分支指令的集合和不正确的预测计数。默认情况启用此选项。禁用会使<code>cachegrind</code>无法收集信息。</p>
</li>
</ul>
<p><code>cachegrind</code>将详细的分析信息写入每个进程的<code>cachegrind.out.pid</code>文件，其中<code>pid</code>是进程标识符。这个相信信息可以由配套<code>cg_annotate</code>工具进一步处理，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cg_annotate cachegrind.out.pid</span><br></pre></td></tr></table></figure>
<p><code>cachegrind</code>还提供了cg_diff工具，可以更轻松地在代码更改之前和之后绘制性能。要比较输出文件，执行以下命令，先用初始配置文件输出文件替换，然后再用后续配置文件输出文件替换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cg_diff FIRST SECOND</span><br></pre></td></tr></table></figure>
<p>使用<code>cg_annotate</code>工具可以更详细地查看输出文件。</p>
<h2 id="使用massif分析堆和堆栈空间"><a href="#使用massif分析堆和堆栈空间" class="headerlink" title="使用massif分析堆和堆栈空间"></a>使用massif分析堆和堆栈空间</h2><p><code>massif</code>测量指定应用程序使用的堆空间。可以测量有用的空间以及额外用来记录和校准的空间，<code>massif</code>有助于了解减少应用程序内存使用的方法，以便提高运行速度，减少应用程序耗尽系统交换空间的可能性。使用<code>massif</code>执行的应用程序运行起来比平时慢20倍左右。</p>
<p>要在一个应用程序中运行massif ，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=massif APPLICATION</span><br></pre></td></tr></table></figure>
<p>用户也可以使用以下选项来将<code>massif</code>的输出集中在一个特定问题上。</p>
<ul>
<li><p><code>--heap</code></p>
<p>设定<code>massif</code>是否分析堆。默认值为<code>--heap=yes</code>。要禁用堆分析设置为<code>--heap=no</code>。</p>
</li>
<li><p><code>--heap-admin</code></p>
<p>堆分析启用时要设定每个用于管理的数据块字节数。默认为8字节。</p>
</li>
<li><p><code>--stacks</code></p>
<p>设置<code>massif</code>是否分析堆。默认为<code>--stack=no</code>由于堆分析会减缓<code>massif</code>将这一选项设置为<code>--stack=yes</code>来启用。注意，<code>massif</code>会假设主要的堆始于零值，这是为了更好地显示与所分析的应用程序相关的堆尺寸的变化。</p>
</li>
<li><p><code>--time-unit</code></p>
<p>设定<code>massif</code>收集分析数据的间隔。默认为<code>i</code> （执行指令）。用户也可以指定<code>ms</code></p>
<p>(毫秒)和<code>B</code>（分配或回收的堆栈字节数）。检查分配的字节数有利于短期运行程序测试，因为对于不同硬件，它是最具重复性的。</p>
</li>
</ul>
<p><code>massif</code>将分析数据输出至<code>massif.out.pid</code>文件，该文件中的<code>pid</code>是指定应用程序的进程标识符。<code>ms_print</code>工具将此分析数据汇成图片，以此显示执行应用程序的内存消耗，也包括峰值内存分配点负责分配的站点详情。要绘制<code>massif.out.pid</code>文件的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ms_print massif.out.pid</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Tuna</title>
    <url>/2019/01/01/Linux/Performance-tuning/Tuna/</url>
    <content><![CDATA[<p>可以使用<code>tuna</code>程序调整调度程序可调参数，调整线程优先级，<code>IRQ</code>处理程序以及隔离CPU核心和套接字，<code>tuna</code>旨在降低执行调优任务的复杂性。</p>
<h1 id="用tuna查看系统"><a href="#用tuna查看系统" class="headerlink" title="用tuna查看系统"></a>用tuna查看系统</h1><p>可以使用<code>tuna</code>显示系统当前正在发生的情况。</p>
<p>查看当前的策略和优先事项，使用<code>tuna --show_threads</code>命令：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --show_threads</span><br><span class="line">                      线程       ctxt_switches</span><br><span class="line">  pid   SCHED_   rtpri affinity voluntary nonvoluntary           cmd</span><br><span class="line">  1      OTHER     0      0,1      1741         1927         systemd</span><br><span class="line">  2      OTHER     0      0,1       162            0        kthreadd</span><br><span class="line">  3      OTHER     0        0      1372            0     ksoftirqd/0</span><br><span class="line">  5      OTHER     0        0         8            0    kworker/0:0H</span><br><span class="line">  6      OTHER     0      0,1       136            0  kworker/u256:0</span><br><span class="line">  7       FIFO    99        0       329            0     migration/0</span><br><span class="line">  8      OTHER     0      0,1         2            0          rcu_bh</span><br><span class="line">  9      OTHER     0      0,1     21314            0       rcu_sched</span><br><span class="line">  10      FIFO    99        0      2132            0      watchdog/0</span><br><span class="line">  11      FIFO    99        1      2132            0      watchdog/1</span><br><span class="line">  12      FIFO    99        1       279            0     migration/1</span><br><span class="line">  13     OTHER     0        1       786            0     ksoftirqd/1</span><br><span class="line">  15     OTHER     0        1        11            0    kworker/1:0H</span><br><span class="line">  17     OTHER     0      0,1       162            0       kdevtmpfs</span><br><span class="line">  18     OTHER     0      0,1         2            0           netns</span><br><span class="line">  19     OTHER     0      0,1        72            0      khungtaskd</span><br><span class="line">  20     OTHER     0      0,1         2            0       writeback</span><br></pre></td></tr></table></figure></p>
<p>想要仅显示与PID对应的特定线程或匹配命令名称，在<code>--show_threads</code>之前添加<code>--threads</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --threads=PID_OR_CMD_LIST --show_threads</span><br></pre></td></tr></table></figure>
<p>查看当前中断请求（IRQ）及其相关性，使用<code>tuna --show_irqs</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --show_irqs</span><br></pre></td></tr></table></figure>
<p>仅显示与IRQ编号对应的特定中断请求或匹配IRQ用户名，在<code>--show_irqs</code>之前添加<code>--irqs</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs=NUMBER_OR_USER_LIST --show_irqs</span><br></pre></td></tr></table></figure>
<h1 id="使用tuna调整CPU"><a href="#使用tuna调整CPU" class="headerlink" title="使用tuna调整CPU"></a>使用tuna调整CPU</h1><p><code>tuna</code>命令可以针对单个CPU，要列出系统上的CPU，<code>/proc/cpuinfo</code>文件可以获取详细信息。</p>
<p>要指定受命令影响的CPU列表，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpus=CPU_LIST --COMMAND</span><br></pre></td></tr></table></figure>
<p>隔离CPU会导致当前该CPU上运行的所有任务移动到下一个可用的CPU。要隔离CPU，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpus=CPU_LIST --isolate</span><br></pre></td></tr></table></figure>
<p>包含CPU允许线程在指定的CPU上运行。要包含CPU，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpu=CPU_LIST --include</span><br></pre></td></tr></table></figure>
<p><code>CPU_LIST</code>参数是逗号分隔的CPU编号列表。例如，<code>--cpus=0,2</code>。</p>
<h1 id="使用tuna调整IRQS"><a href="#使用tuna调整IRQS" class="headerlink" title="使用tuna调整IRQS"></a>使用tuna调整IRQS</h1><p>要查看系统上当前运行的IRQ列表，查看<code>/proc/interrpupts</code>文件。也可以使用<code>tuna --show_irqs</code>命令。</p>
<p>要指定受命令影响的IRQ列表，使用<code>–irqs</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs=IRQ_LIST --COMMAND</span><br></pre></td></tr></table></figure>
<p>要将终端移动到指定的CPU，请使用<code>--move</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs=IRQ_LIST --cpus=CPU_LIST --move</span><br></pre></td></tr></table></figure>
<p><code>IRQ_LIST</code>参数是逗号分隔的<code>IRQ</code>编号或用户名模式的列表。</p>
<p><code>CPU_LIST</code>参数是逗号分隔的CPU编号列表。例如，<code>--cpus=0,2</code>。</p>
<p>例如，要定位名称以<code>sfc1</code>开头的所有的中断，并将他们分布在两个CPU：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs=sfc1\* --cpus=7,8 --move --spread</span><br></pre></td></tr></table></figure>
<p>要验证设置，使用<code>--move</code>参数修改<code>IRQ</code>之前和之后使用<code>-show_irqs</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs=128 --show_irqs</span><br><span class="line">tuna --irqs=128 --cpus=3 --move</span><br><span class="line">tuna --irqs=128 --show_irqs</span><br></pre></td></tr></table></figure>
<p>可以比较出更改前后<code>IRQ</code>的状态。</p>
<h1 id="使用tuna调整任务"><a href="#使用tuna调整任务" class="headerlink" title="使用tuna调整任务"></a>使用tuna调整任务</h1><p>要更改线程的策略和优先级信息，使用<code>--priority</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --rhreads=PID_OR_CMD_LIST --priority=[POLICY:]RT_PRIORITY</span><br></pre></td></tr></table></figure>
<ul>
<li><em>PID_OR_CMD_LIST</em>是逗号分隔的PID或命令名模式的列表。</li>
<li>对于默认策略，将策略设置为<strong>RR</strong>（roind-robin），<strong>FIFO</strong>（first in ， first out）或者<strong>OTHER</strong>。</li>
<li>将RT_PRIORITY设置为范围1-99。1是最低优先级，99是最高优先级。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --threads=7861 --priority=RR:40</span><br></pre></td></tr></table></figure>
<p>要验证设置的更改，请在修改<code>--proprity</code>之前和之后使用<code>--show_threads</code>参数查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --rhreads=sshd --show_threads --priority=RR:40 --show_threads</span><br></pre></td></tr></table></figure>
<p>这允许比较更改之前和之后所选线程的状态。</p>
<h1 id="tuna配置示例"><a href="#tuna配置示例" class="headerlink" title="tuna配置示例"></a>tuna配置示例</h1><p><strong>将任务分配给特定CPU</strong></p>
<p>以下示例使用具有四个或更多处理器的系统，并显示如何使所有<code>ssh</code>线程在CPU 0和1以及<code>http</code>CPU 2和3上的所有线程上运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpus=0,1 --threads=ssh\* --move --cpus=2,3 --threads=http\* --move</span><br></pre></td></tr></table></figure>
<p>上面的示例命令按顺序执行以下操作：</p>
<ol>
<li>Select CPUs 0 and 1.</li>
<li>Select all threads that begin with <code>ssh</code>.</li>
<li>Move the selected threads to the selected CPUs. Tuna sets the affinity mask of threads starting with <code>ssh</code> to the appropriate CPUs. The CPUs can be expressed numerically as 0 and 1, in hex mask as <code>0x3</code>, or in binary as <code>11</code>.</li>
<li>Reset the CPU list to 2 and 3.</li>
<li>Select all threads that begin with <code>http</code>.</li>
<li>Move the selected threads to the selected CPUs. Tuna sets the affinity mask of threads starting with <code>http</code> to the appropriate CPUs. The CPUs can be expressed numerically as 2 and 3, in hex mask as <code>0xC</code>, or in binary as <code>1100</code>.</li>
</ol>
<p><strong>查看当前配置</strong></p>
<p>以下示例使用<code>--show_threads</code>（<code>-P</code>）参数显示当前配置，然后测试所请求的更改是否按预期进行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --threads=gnome-sc\* \</span><br><span class="line">        --show_threads \</span><br><span class="line">        --cpus=0 \</span><br><span class="line">        --move \</span><br><span class="line">        --show_threads \</span><br><span class="line">        --cpus=1 \</span><br><span class="line">        --move \</span><br><span class="line">        --show_threads \</span><br><span class="line">        --cpus=+0 \</span><br><span class="line">        --move \</span><br><span class="line">        --show_threads</span><br><span class="line"></span><br><span class="line">                       thread       ctxt_switches</span><br><span class="line">     pid SCHED_ rtpri affinity voluntary nonvoluntary             cmd</span><br><span class="line">   3861   OTHER     0      0,1     33997           58 gnome-screensav</span><br><span class="line">                       thread       ctxt_switches</span><br><span class="line">     pid SCHED_ rtpri affinity voluntary nonvoluntary             cmd</span><br><span class="line">   3861   OTHER     0        0     33997           58 gnome-screensav</span><br><span class="line">                       thread       ctxt_switches</span><br><span class="line">     pid SCHED_ rtpri affinity voluntary nonvoluntary             cmd</span><br><span class="line">   3861   OTHER     0        1     33997           58 gnome-screensav</span><br><span class="line">                       thread       ctxt_switches</span><br><span class="line">     pid SCHED_ rtpri affinity voluntary nonvoluntary             cmd</span><br><span class="line">   3861   OTHER     0      0,1     33997           58 gnome-screensav</span><br></pre></td></tr></table></figure>
<p>The above example command performs the following operations sequentially:</p>
<ol>
<li>Select all threads that begin with <code>gnome-sc</code>.</li>
<li>Show the selected threads to enable the user to verify their affinity mask and RT priority.</li>
<li>Select CPU 0.</li>
<li>Move the <code>gnome-sc</code> threads to the selected CPU (CPU 0).</li>
<li>Show the result of the move.</li>
<li>Reset the CPU list to CPU 1.</li>
<li>Move the <code>gnome-sc</code> threads to the selected CPU (CPU 1).</li>
<li>Show the result of the move.</li>
<li>Add CPU 0 to the CPU list.</li>
<li>Move the <code>gnome-sc</code> threads to the selected CPUs (CPUs 0 and 1).</li>
<li>Show the result of the move.</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>配置透明的大内存页</title>
    <url>/2019/01/01/Linux/Performance-tuning/MEMORY/Configure-transparent-large-memory-pages/</url>
    <content><![CDATA[<p>透明大内存页（THP）是HugeTLB的替代解决方案。使用THP，内核会自动为进程分配大内存页，因此不需要手动预留大内存页。</p>
<p>THP功能有两种操作模式：系统范围和每个进程。当在系统范围内启用THP时，内核会尝试在可能分配大页面时，内核会尝试在可能分配大页面时为任何进程分配大页面，并且该进程使用大的连续虚拟内存区域。如果每个进程启用THP，则内核仅将大页面分配给<code>madvise()</code>系统调用指定的各个进程的内存区域。</p>
<p>注意，THP功能仅支持2MB页面。默认情况下启用透明大页面，要检查状态，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<p>要启用透明的大页面，请运行：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> always &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure></p>
<p>为了防止应用程序分配超出必要的内存资源，可以在系统范围内禁用大页面，并且只能通过以下命令在<code>MADV_HUGEPAGE madvise</code>区域启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<p>要禁用透明大内存页，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>
<p>有时，为了短期分配提供低延迟比使用长期分配立即获得最佳性能具有更高的优先级，这种情况下，可以在启用THP的同事禁用<code>direct compaction</code>。</p>
<p>直接压缩巨大页面分配期间的同步内存压缩。禁用直接压缩不能保证节省内存。  但可以减低频繁页面错误期间更高延迟的风险，主要如果工作负载从THP中获益很大，则性能会降低，要禁用直接压缩，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> madvise &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU配置建议</title>
    <url>/2018/12/23/Linux/Performance-tuning/CPU/CPU-configuration-recommendations/</url>
    <content><![CDATA[<p>红帽企业版 Linux 提供了大量工具来协助管理员配置系统。本章概述了可用的工具并提供了使用它们在红帽企业版 Linux 7 中解决与处理器相关的性能问题的实例。</p>
<h1 id="配置内核滴答记号时间"><a href="#配置内核滴答记号时间" class="headerlink" title="配置内核滴答记号时间"></a>配置内核滴答记号时间</h1><p>默认情况下，红帽企业版 Linux 7 使用无时钟内核，它不会中断空闲 CPU 来减少用电量，并允许较新的处理器利用深睡眠状态。</p>
<p>红帽企业版 Linux 7 同样提供一种动态的无时钟设置（默认禁用），这对于延迟敏感型的工作负载来说是很有帮助的，例如高性能计算或实时计算。</p>
<p>要启用特定内核中的动态无时钟性能，在内核命令行中用 <em>nohz_full</em> 参数进行设定。在 16 核的系统中，设定 <code>nohz_full=1-15</code> 可以在 1 到 15 内核中启用动态无时钟内核性能，并将所有的计时移动至唯一未设定的内核中（0 内核）。这种性能可以在启动时暂时启用，也可以在 <code>/etc/default/grub</code> 文件中永久启用。要持续此性能，请运行 <code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 指令来保存配置。<br><a id="more"></a><br>启用动态无时钟性能需要一些手动管理。</p>
<ul>
<li><p>当系统启动时，必须手动将 rcu 线程移动至对延迟不敏感的内核，这种情况下为 0 内核。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `pgrep rcu` ; <span class="keyword">do</span> taskset -pc 0 <span class="variable">$i</span> ; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在内核命令行上使用 <em>isolcpus</em> 参数来将特定的内核与用户空间任务隔离开。</p>
</li>
<li><p>可以选择性地为辅助性内核设置内核回写式 bdi-flush 线程的 CPU 关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/bus/workqueue/devices/writeback/cpumask</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>验证动态无时钟配置是否正常运行，执行以下命令，其中 <em>stress</em> 是在 CPU 中运行 1 秒的程序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf <span class="built_in">stat</span> -C 1 -e irq_vectors:local_timer_entry taskset -c 1 stress -t 1 -c 1</span><br></pre></td></tr></table></figure>
<p>可替代 <em>stress</em> 的是一个脚本，该脚本的运行类似 <code>while :; do d=1; done</code> 。以下链接中的程序是另一个合适的替代程序： </p>
<p>默认的内核计时器配置在繁忙 CPU 中显示 1000 次滴答记号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf <span class="built_in">stat</span> -C 1 -e irq_vectors:local_timer_entry taskset -c 1 stress -t 1 -c 1</span><br><span class="line">1000 irq_vectors:local_timer_entry</span><br></pre></td></tr></table></figure>
<p>动态无时钟内核配置下，用户只会看到一次滴答记号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf <span class="built_in">stat</span> -C 1 -e irq_vectors:local_timer_entry taskset -c 1 stress -t 1 -c 1</span><br><span class="line">1 irq_vectors:local_timer_entry</span><br></pre></td></tr></table></figure>
<h1 id="设置硬件性能策略"><a href="#设置硬件性能策略" class="headerlink" title="设置硬件性能策略"></a>设置硬件性能策略</h1><p><strong>x86_energy_perf_policy</strong> 工具允许管理员定义性能与能效的相对重要性。当处理器在性能与能效间权衡选择时，此信息可用来改变支持这一特征的处理器。</p>
<p>默认情况下适用于所有在 <code>performance</code> 模式下的处理器，它要求处理器的支持，由 <code>CPUID.06H.ECX.bit3</code> 显示，且必须在有 root 特权的情况下运行。</p>
<h1 id="使用-taskset-设置处理器关联"><a href="#使用-taskset-设置处理器关联" class="headerlink" title="使用 taskset 设置处理器关联"></a>使用 taskset 设置处理器关联</h1><p><strong>taskset</strong> 工具由 util-linux 数据包提供。<strong>Taskset</strong> 允许管理员恢复和设置进程中的处理器关联，或通过特定的处理器关联来启动一个进程。</p>
<p><strong>重要</strong></p>
<p><strong>taskset</strong> 不能保证本地的内存配置。若需要本地内存配置的额外性能收益，推荐使用 <strong>numactl</strong> 来替代 <strong>taskset</strong>。</p>
<h1 id="使用-numaactl-管理-NUMA-关联"><a href="#使用-numaactl-管理-NUMA-关联" class="headerlink" title="使用 numaactl 管理 NUMA 关联"></a>使用 numaactl 管理 NUMA 关联</h1><p>管理员可以通过特定的调度或内存安置策略来使用 <strong>numactl</strong> 运行进程。<strong>Numactl</strong> 也可以为共享内存片段或文件设置永久性策略，并设置处理器关联和进程的内存关联。</p>
<p>在 NUMA 拓扑系统中，处理器访问内存的速度会由于处理器和存储体之间距离的增加而减慢。因此，重要的是要对性能敏感的应用程序进行配置，以便它们能够从最近的且可能的存储体分配内存。最好是使用在同一 NUMA 节点的内存和 CPU。</p>
<p>对性能敏感的多线程应用程序经配置后在特定的 NUMA 节点上运行会比在特定的处理器上运行好处更多。这是否适合则取决于用户系统及应用程序的需求。如果多个应用程序线程访问同一缓存数据，那么对那些线程进行配置，使其在同一处理器上运行可能是合适的。但是，如果在同一处理器上运行的多线程访问及缓存的是不同数据，那么每个线程可能会收回之前线程访问的缓存数据。这就意味着每个线程会“缺失”缓存，会浪费运行时间来从磁盘中获取数据并在缓存中替代它。可以使用 <strong>perf</strong> 工具，用它来查看大量的缓存缺失。</p>
<p><strong>Numactl</strong> 提供大量的选择来协助管理处理器及内存关联。</p>
<p><strong>注意</strong></p>
<p><strong>numactl</strong> 数据包包括 <code>libnuma</code> 库。这个库提供了一个简单的编程接口至内核支持的 NUMA 策略，比起 <strong>numactl</strong> 应用程序，它可以用来进行更细致的调节。</p>
<h1 id="使用-numad-进行自动化-NUMA-关联管理"><a href="#使用-numad-进行自动化-NUMA-关联管理" class="headerlink" title="使用 numad 进行自动化 NUMA 关联管理"></a>使用 numad 进行自动化 NUMA 关联管理</h1><p><code>numad</code> 是一种自动化的 NUMA 关联管理后台程序。它对系统中的 NUMA 拓扑及资源用量进行监控，以便动态地改善 NUMA 资源配置及管理。</p>
<p><strong>numad</strong> 也同样提供预先安置咨询服务，这一服务可以通过不同的作业管理系统来查询，并为处理器 CPU 的初始绑定及内存资源提供帮助。无论 numad 是以可执行程序或服务在运行，这一预先安置咨询都可用。</p>
<h1 id="调节调度策略"><a href="#调节调度策略" class="headerlink" title="调节调度策略"></a>调节调度策略</h1><p>Linux 调度器执行大量的调度原则，以此决定线程运行的位置和时长。调度原则主要有两类：普通原则和实时原则。普通线程用于普通优先级任务，实时原则用于具有时效性且必须无中断完成的任务。</p>
<p>实时线程不受时间间隔的控制，这意味着它们将一直运行直至它们阻拦、退出、主动让步或是被更高优先权的线程预先安置。最低优先权的实时线程会先于其他普通原则的线程进行调度。</p>
<h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><h3 id="SCHED-FIFO-静态优先级调度"><a href="#SCHED-FIFO-静态优先级调度" class="headerlink" title="SCHED_FIFO 静态优先级调度"></a>SCHED_FIFO 静态优先级调度</h3><p><code>SCHED_FIFO</code> （也叫做静态优先级调度）是一项实时策略，定义了每个线程的固定优先级。这一策略让管理员能改进事件响应的时间并减少延迟，这一策略建议无法运行较长时间且具有时效性的任务使用。</p>
<p>在使用 <code>SCHED_FIFO</code> 时，调度器会按优先级顺序扫描所有的 <code>SCHED_FIFO</code> 线程，并对准备运行的最高优先级线程进行调度。一个 <code>SCHED_FIFO</code> 线程的优先级级别可以是 1 至 99 之间的任何整数，99 是最高优先级。红帽建议一开始使用较小的数字，在确定了延迟问题后再增加优先级。</p>
<p><strong>警告</strong></p>
<p>由于实时线程不受时间间隔的控制，红帽不推荐设置 99 优先级。这会使同优先级的进程成为迁移线程或监控线程，如果线程进入一个计算机回路且这些线程被阻拦，它们将无法运行。这种情况下，单处理器系统最终会暂停。</p>
<p>管理员可以限制 <code>SCHED_FIFO</code> 的带宽以防止实时应用程序的程序员启用独占处理器的实时任务。</p>
<ul>
<li><p>/proc/sys/kernel/sched_rt_period_us</p>
<p>该参数以微秒为单位来定义时间，是百分之百的处理器带宽。默认值为 <code>1000000</code> μs, 或1秒。</p>
</li>
<li><p>/proc/sys/kernel/sched_rt_runtime_us</p>
<p>该参数以微秒为单位来定义时间，用来运行实时线程。默认值为 <code>950000</code> μs, 或0.95秒。</p>
</li>
</ul>
<h4 id="SCHED-RR-轮循优先级调度"><a href="#SCHED-RR-轮循优先级调度" class="headerlink" title="SCHED_RR 轮循优先级调度"></a>SCHED_RR 轮循优先级调度</h4><p><code>SCHED_RR</code> 是 <code>SCHED_FIFO</code> 的一个轮循变形。这一策略在同优先级的多线程需要运行时很有用。</p>
<p>正如 <code>SCHED_FIFO</code>，<code>SCHED_RR</code> 是一项实时策略，定义了每个线程的固定优先级。调度器会按优先级顺序扫描所有的 <code>SCHED_RR</code> 线程，并对准备运行的最高优先级线程进行调度。但是，和 <code>SCHED_FIFO</code> 不同，同优先级的线程在一定的时间间隔内是以循环的方式进行调度的。</p>
<p>用户可以使用 <em>sched_rr_timeslice_ms</em> 内核参数，并毫秒为单位设定这一时间间隔 (<code>/proc/sys/kernel/sched_rr_timeslice_ms</code>) 。最小值为1毫秒。</p>
<h3 id="SCHED-OTHER-普通调度"><a href="#SCHED-OTHER-普通调度" class="headerlink" title="SCHED_OTHER 普通调度"></a>SCHED_OTHER 普通调度</h3><p><code>SCHED_OTHER</code> 是红帽企业版 Linux 7 中默认的调度策略。这一策略使用 CFS （完全公平排程器）让处理器能够平等地访问用此策略调度的所有线程。这一策略在有大量线程或数据吞吐量优先时最为有用，因为它能够随着时间而更为有效地调度线程。</p>
<p>在使用这一策略时，调度器会创建一个动态优先级列表，此列表一部分是基于每个进程线程的进程优先级。管理员可以改变一个进程的进程优先级，但是不能直接改变调度器的动态优先级列表。</p>
<h2 id="隔离-CPU"><a href="#隔离-CPU" class="headerlink" title="隔离 CPU"></a>隔离 CPU</h2><p>用户可以使用 <em>isolcpus</em> 开机参数来从调度器隔离一个或多个 CPU，以此防止调度器在此 CPU 上调度任何用户空间的线程。</p>
<p>一旦 CPU 被隔离，用户须手动分配进程至被隔离的 CPU，或使用 CPU 关联系统呼叫或 numactl 命令。</p>
<p>将系统中第三和第六 CPU 隔离至第八 CPU，添加如下至内核命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isolcpus=2,5-7</span><br></pre></td></tr></table></figure>
<p>用户也可使用 <strong>Tuna</strong> 工具来隔离CPU。<strong>Tuna</strong> 可以随时隔离 CPU，不仅仅局限于启动时。但这种隔离方法与 <em>isolcpus</em> 参数略有不同，并且目前尚未实现与 <em>isolcpus</em>相关的性能收益。</p>
<h1 id="设置中断关联"><a href="#设置中断关联" class="headerlink" title="设置中断关联"></a>设置中断关联</h1><p>中断请求有一个相关的关联属性<em>smp_affinity</em>， 它能确定处理中断请求的处理器。若要提高应用程序的性能，就将中断关联和进程关联分配至同一处理器或分配至同一内核的处理器。这可以使特定的中断和应用程序线程共享高速缓存线路。</p>
<p>特定中断请求的中断关联值存储在相关的 <code>/proc/irq/*irq_number*/smp_affinity</code> 文件下。<em>smp_affinity</em> 是存储为十六进制的位掩码来代表系统中所有的处理器。默认值为 <code>f</code>，这意味着一个中断请求可以在系统中任何处理器中处理。如果将这个值设为 <code>1</code> 则意味着只有 0 位处理器可以处理这一中断。</p>
<p>在超过 32 个处理器的系统中，用户须将 <em>smp_affinity</em>的值限定为分散的 32 位组。例如，如果一开始只想使用 64 位处理器系统中的 32 位处理器来处理一个中断请求，可以运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0xffffffff,00000000 &gt; /proc/irq/IRQ_NUMBER/smp_affinity</span><br></pre></td></tr></table></figure>
<p>此外，如果 BIOS 导出其 NUMA 拓扑，<strong>irqbalance</strong> 服务可以使用此信息来处理节点上的中断请求，对请求服务的硬件来说此节点是本地节点。</p>
<p><strong>注意</strong></p>
<p>如果在支持中断驱动且可以修改一个中断请求的 <em>smp_affinity</em> 系统中设置硬件，那么特定的处理器处理一个中断请求的决策就是硬件级别，它不会受内核的干扰。</p>
<h1 id="使用-Tuna-配置-CPU、线程和中断关联"><a href="#使用-Tuna-配置-CPU、线程和中断关联" class="headerlink" title="使用 Tuna 配置 CPU、线程和中断关联"></a>使用 Tuna 配置 CPU、线程和中断关联</h1><p><strong>Tuna</strong> 能够控制 CPU、线程及中断关联，并能给其所能控制的每类实体提供大量操作。</p>
<p>要从一个或多个特定的 CPU 中移除所有线程，请运行如下命令，使用想要隔离的 CPU 数量来替换 <em>CPUs</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpus CPUs --isolate</span><br></pre></td></tr></table></figure>
<p>要在可运行特定线程的 CPU 列表中加入一个 CPU，请运行如下命令，使用想要加入的 CPU 数量来替换 <em>CPUs</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --cpus CPUs --include</span><br></pre></td></tr></table></figure>
<p>要将一个中断请求移动至特定的 CPU，请运行如下命令，用 CPU 数量替换 <em>CPU</em>，用想要移动且使用逗号分隔的中断请求列表替换 <em>IRQs</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --irqs IRQs --cpus CPU --move</span><br></pre></td></tr></table></figure>
<p>此外，用户可以使用如下命令来找到所有 <code>sfc1*</code> 模式的中断请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna -q sfc1* -c7 -m -x</span><br></pre></td></tr></table></figure>
<p>要改变一个线程的策略和优先级，请运行如下命令，使用想要改变的线程替换 <em>thread</em>，使用需要的线程运行策略名称替换 <em>policy</em>，用从 0（最低优先级）至 99（最高优先级）间的一个整数替换 <em>level</em>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tuna --threads thread --priority policy:level</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>监控和诊断性能问题（CPU）</title>
    <url>/2018/12/22/Linux/Performance-tuning/CPU/Monitor-and-diagnose-performance-issues/</url>
    <content><![CDATA[<p>以下工具对于处理器机器配置相关的系统性能和监控性能问题诊断有很大帮助。</p>
<a id="more"></a>
<h1 id="turbostat"><a href="#turbostat" class="headerlink" title="turbostat"></a>turbostat</h1><p><code>turbostat</code>在规定的间隔中给出计时器的结果以协助识别服务器异常，例如过度耗电，无法进入睡眠状态或是创建了不必要的系统管理中断（SMIs）。</p>
<h1 id="numastat"><a href="#numastat" class="headerlink" title="numastat"></a>numastat</h1><p><code>numastat</code>工具会列举出每个NUMA节点内存数据给所有的进程和操作系统，并会告知进程内存是散布于系统还是集中于某个节点。</p>
<p>通过处理器的<code>top</code>输出进行交互参照<code>numastat</code>输出，已确认进程线程是在同一个节点运行，此节点是进程内存分配节点。</p>
<h1 id="proc-interrupts"><a href="#proc-interrupts" class="headerlink" title="/proc/interrupts"></a>/proc/interrupts</h1><p><code>/proc/interrupts</code>文件列举了从一个特殊的I/O设备发送至各处理器的中断数量，显示了中断请求(IRQ)数量、系统中个处理器该类型中断请求的数量，发送的中断类型以及都好分隔开的回应所列出中断请求的设备列表。</p>
<p>如果一个特定的应用程序或是设备生成大量的中断请求给远程处理器，其性能就会收到影响。这种情况下，当应用程序或设备在处理中断请求时，可以在同一节点设置一个处理器，缓解性能不佳的情况。</p>
<h1 id="使用pqos监控缓存和内存带宽"><a href="#使用pqos监控缓存和内存带宽" class="headerlink" title="使用pqos监控缓存和内存带宽"></a>使用pqos监控缓存和内存带宽</h1><p><code>pqos</code>实用程序，可从<code>intel-cmt-cat</code>包获得，使您可以监控CPU缓存和内存带宽最近Intel处理器。</p>
<p><code>pqos</code>工具提供了类似于高速缓存和内存监测工具<code>top</code>工具。它监测：</p>
<ul>
<li>每个周期的指令（IPC）。</li>
<li>最后一级缓存MISSES的计数。</li>
<li>在给定CPU中执行的程序在LLC中占用的大小（以KB为单位）。</li>
<li>本地内存的带宽（MBL）。</li>
<li>远程内存的带宽（MBR）。</li>
</ul>
<p>使用以下命令启动监视工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pqos --mon-top</span><br></pre></td></tr></table></figure>
<p>输出中的项目按最高LLC占用率排序。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU系统拓扑，调度与中断请求管理</title>
    <url>/2018/12/21/Linux/Performance-tuning/CPU/CPU-scheduling-and-interrupt-request-management/</url>
    <content><![CDATA[<h1 id="系统拓扑"><a href="#系统拓扑" class="headerlink" title="系统拓扑"></a>系统拓扑</h1><p>现代计算机技术，一个“<em>中央</em>”处理单元的观念是误导性的。因为大部分现代化的系统都有多个处理器。这些处理器是如何相互连接的，并且如何连接至其他系统资源——“系统拓扑“会对系统和应用的性能以及系统调节选项产生影响。</p>
<p>现代计算机技术主要运用两种主要拓扑类型</p>
<p><strong>SMP拓扑</strong></p>
<p>​    SMP（对称多处理器）拓扑允许所有的处理器同时访问内存。然而，由于内存访问权限的共享性和平等性，固然会迫使所有CPU及SMP系统序列化的内存访问权限的局限性增加，目前这种情况不被接受，几乎所有服务器系统都是NUMA（非一致性内存访问）。</p>
<p><strong>NUMA拓扑</strong></p>
<p>​    相比SMP，NUMA（非一致性内存访问）拓扑是近来开发的。在NUMA系统中，多个处理器分组至一个socket。每个socket都有一个专用内存区，对该内存进行本地访问的服务器统称为一个节点。</p>
<p>同一个节点上的服务器能告诉访问该节点的存储体，但访问其他节点上的存储体就比较慢，因此，访问非本地存储体会造成性能的损失。</p>
<p>考虑性能损失，服务器执行应用程序时，NMUA拓扑结构系统中对性能明爱的应用程序应访问同一个节点的内存，并且尽可能地避免访问任何远程内存。</p>
<p>因此，调节NUMA拓扑结构系统中的应用程序性能时，重要的是要考虑这一应用程序的执行点以及最靠近此执行点的存储体。</p>
<p>在NUMA拓扑结构系统中，<code>/sys</code>文件系统包含处理器、内存及外围设备连接信息。<code>/sys/devices/system/cpu</code>目录包含处理器在系统中相互连接的详情。<code>/sys/devices/system/node</code>目录包含系统中NUMA的节点信息以及节点间的相对距离。<br><a id="more"></a></p>
<h2 id="确定系统拓扑结构"><a href="#确定系统拓扑结构" class="headerlink" title="确定系统拓扑结构"></a>确定系统拓扑结构</h2><p>很多指令可以了解系统的 拓扑结构。<code>numactl --hardware</code>指令概述了系统的拓扑结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure>
<p><code>lscpu</code>指令由<code>util-linux</code>包提供。包括CPU体系结构信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>
<p><code>lstopo</code> 指令由<code>hwloc</code>包提供，创建了用户的系统示意图。<code>lstopo-no-graphics</code>指令提供了详尽的文本输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lstopo-no-graphics</span><br></pre></td></tr></table></figure>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><p>执行进程的最小单元是<em>线程</em>。系统调度器决定运行线程的处理器和运行的时间。但由于调度器主要关注的是保持系统繁忙，因此可能不会为应用程序的性能而对线程进行最佳调度。</p>
<p>例如，在NUMA系统中，一个处理器在节点B可用，一个应用程序在节点A运行，要是在节点B的处理器保持忙碌，调度器会把应用程序的一个线程转移到节点B。但是线程上的应用程序仍需要访问节点A的内存。由于该线程目前在B节点运行，并且对于此线程来说节点A的内存已不是本地内存，访问起来就要花更长的时间。较于在节点A等待可用的处理器，并且在能够进行本地内存访问的源节点上执行线程，此线程在节点B结束运行可就更加费时。</p>
<p>设计器或管理员确定线程的运行位置能使性能敏感的应用程序从中受益。</p>
<h2 id="Kernel-Ticks"><a href="#Kernel-Ticks" class="headerlink" title="Kernel Ticks"></a>Kernel Ticks</h2><p>早期Linux版本中，Linux内核会定期中断每个CPU以查看需完成的任务。查看的结果用来决定进程调度及负载均衡均衡。这种常规性的中断叫做一个Kernel Ticks。</p>
<p>此标记的出现不考虑内核是否有任务要执行。这意味着为了回应这些中断，即使是空闲的内核也会被迫定期进入高能状态（高达每秒1000次）。这阻止了系统有效地利用x86处理器的深睡眠状态。</p>
<p>新版本中，默认情况下内核不再中断趋于低功率状态的空闲CPU，叫做无时钟内核。当一个或多个任务在运行时，按需中断取代了定时中断，使CPU可以更久地处于空闲状态或低功率状态，较少电量消耗。</p>
<p>7版本中提供了一种动态无时钟设置（<code>nohz_full</code>），通过用户空间的任务来减少内核干扰以进一步改善确定性。这一设置可以在指定的内核中通过<code>nohz_full</code>内核参数来启用。当这一设置在一个内核中启用时，所有的计时活动将会被移动至无延迟敏感性的内核。这对于高性能计算和实时计算工作负载来说都很有用，因为用户空间任务对于内核计时器Ticks信号造成微秒级的延迟尤为敏感。</p>
<h1 id="中断请求管理"><a href="#中断请求管理" class="headerlink" title="中断请求管理"></a>中断请求管理</h1><p>中断请求或IRQ是请求及时关注的信号，是从硬件发送至处理器的。系统中的每个设备都分配到一个或多个IRQ号，以便能发送独一无二的中断信号。当启动中断时，收到中断请求的处理器会立即暂停执行当前应用程序线程，这是为了处理该中断请求。</p>
<p>因为中断了正常的运行。搞中断率会严重降系统性能，但减少中断的时间是可能，可以设置中断关联或发送一批低优先级的中断（组合中断）。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>性能监控工具</title>
    <url>/2018/12/20/Linux/Performance-tuning/Performance-monitoring-tools/Performance-monitoring-tools/</url>
    <content><![CDATA[<blockquote>
<p>关于性能调优可能你需要使用到的性能监控工具（也可以说是监控性能的手段）。这里不详细说明工具的具体使用方法和参数，这些最后会单独整理一份。</p>
</blockquote>
<h1 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h1><p><code>/proc</code>文件系统是包含代表Linux内核当前状态文件的层次结构的目录，它允许用户和应用程序查看内核的系统试图。</p>
<p><code>/proc</code>目录还包含有关系统硬件和任何当前正在运行的进程信息。<code>/proc</code>文件系统中的大多数文件都是只读的，但是<code>/proc/sys/</code>中的文件，可以由用户和应用程序操纵，以便将配置更改传递给内核。<br><a id="more"></a></p>
<h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p><code>procps-ng</code>包提供的<code>top</code>工具提供正在运行系统中进程的动态试图。他可以显示各种信息，包括系统摘要和当前由系统内核管理的任务列表。还具有操作流程的能力，并且在系统重启期间使配置更改保持不变。</p>
<p>默认情况下，显示的进程根据CPU使用的百分比排序，以便可以轻松查看小号最多资源的进程。信息顶部的显示和操作都是可以配置的。</p>
<h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>虚拟内存统计工具<code>vmstat</code>提供有关系统进程，内存，分页，块输入/输出，中断和CPU活动的即时报告。<code>vmstat</code>允许设置采样间隔，以便近实时的观察系统活动。</p>
<h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>系统活动报告器，<code>sar</code>，收集并报告当天到目前为止发生的系统的活动信息。默认输出显示当天的CPU使用情况，从当天开始的十分钟00::00:00）。</p>
<p>使用<code>-i</code>选项以秒为单位设置间隔时间，例如<code>sar -i 60</code>告诉<code>sar</code>每分钟检查一次CPU使用情况。</p>
<p><code>sar</code>是<code>top</code>手动创建系统活动定期报告的替代方法。它由<code>sysstat</code>包提供。</p>
<h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p><code>perf</code>工具通过硬件性能计数器和内核跟踪点来跟踪其他命令和应用程序对系统的影响。<code>perf</code>的子命令可以显示和记录常见性能事件和统计信息，并分析和报告记录的数据。</p>
<h1 id="turbostat"><a href="#turbostat" class="headerlink" title="turbostat"></a>turbostat</h1><p><code>turbostat</code>由<code>kernel-tools</code>包提供。它在处理器拓扑结构，频率，空闲功率状态统计，温度和功率。</p>
<p><code>turbostat</code>可用于识别在功率使用或空闲时间方面效率低下的服务器。它还有助于识别系统上发生的系统管理中断（SMI）的速率。还可以用于验证电源管理调整的效果。</p>
<p><code>turbostat</code>需要root权限。还需要处理器支持：</p>
<ul>
<li>不变的时间戳计数器</li>
<li>APERF模型专用寄存器</li>
<li>MPERF模型专用寄存器</li>
</ul>
<h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><p><code>iostat</code>由<code>sysstat</code>包提供，可以监控并报告系统I/O设备负载，帮助决定平衡物理磁盘之间的I/O负载。</p>
<h1 id="irqbalance"><a href="#irqbalance" class="headerlink" title="irqbalance"></a>irqbalance</h1><p><code>irqbalance</code>可在处理器之间分配硬件终端，提高系统性能。</p>
<h1 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h1><p><code>ss</code>用于输出有关套接字的统计信息，允许随时评估设备性能。默认情况下，<code>ss</code>列出已建立连接的打开的非监听TCP套接字，虽然<code>ss</code>提供了很多选项以过滤有关套接字的统计信息（一种常见用法是<code>ss -tmpie</code>显示有关套接字内存使用情况和套接字的进程详细信息）。但建议使用<code>netstat</code>，<code>netstat</code>由<code>net-tools</code>包提供。</p>
<h1 id="numastat"><a href="#numastat" class="headerlink" title="numastat"></a>numastat</h1><p><code>numastat</code>工具以每个NUMA节点为基础显示进程和操作系统的内存统计信息。</p>
<p>默认情况下，<code>numastat</code>显示每个节点的NUMA从内核内存分配器中查找未命中系统统计信息。高的<code>numa_hit</code>值和低的<code>numa_miss</code>值表示最佳性能。<code>numastat</code>还提供了许多命令行选项。可以显示系统和进程内存如何在系统中的NUMA节点之间的分布。P@ssw0rd否在分配了内存的同一节点运行。</p>
<h1 id="numad"><a href="#numad" class="headerlink" title="numad"></a>numad</h1><p><code>numad</code>时一个自动NUMA亲和力管理守护进程。他监控系统内的NUMA拓扑和资源使用情况，以便动态地改进NUMA资源分配和管理（以及系统性能）。根据系统工作负载，<code>numad</code>可以在性能基准测试中提供高达50%的提升。它还提供了一个可以由各种作业管理系统查询的预置位建议，以便为其进程初始绑定CPU和内存资源提供帮助。</p>
<p><code>numad</code>通过定期访问<code>/proc</code>文件系统中的信息，基于每个节点监控可用的系统资源。它尝试维护指定的资源使用级别，并在必要的时候通过在NUMA节点之间移动进程来重新平衡资源分配。<code>numad</code>尝试通过在系统的NUMA节点的子集上本地化和隔离重要的进程来实现最佳NUMA性能。</p>
<p><code>numad</code>主要使具有长时间运行流程的系统受益，这些流程消耗大量资源，并且包含在整个系统资源的子集中。还可能有益于消耗多个NUMA节点的资源的应用程序；但是，随着系统资源消耗百分比的增加，<code>numad</code>提供的好处就会减少。</p>
<p>当进程只运行几分钟或者不消耗很多资源时，<code>numad</code>不太可能提高性能。具有连续，不可预测的内存访问模式的系统（如大型内存数据库）也不太可能从使用<code>numad</code>中受益。</p>
<h1 id="SystemTap"><a href="#SystemTap" class="headerlink" title="SystemTap"></a>SystemTap</h1><p>SystemTap是一种跟踪和探测工具，可以详细监控和分析操作系统活动，尤其是内核活动。它提供类似于<code>top</code>，<code>ps</code>，<code>netstat</code>和<code>iostat</code>等工具输出的信息，但包括用于过滤和分析收集的数据的其他选项。</p>
<p><code>SystemTap</code>提供了更深入，更精确的系统活动和应用程序分析。</p>
<h1 id="OProfile"><a href="#OProfile" class="headerlink" title="OProfile"></a>OProfile</h1><p><code>OProfile</code>是一个系统范围的性能监控工具。它使用处理器的专用性能监控硬件来检索有关内核和系统可执行文件的信息，以确定某些事件的频率，例如何时引用内存，二级缓存请求的数量以及接收的硬件请求的数量。<code>OProfile</code>还可用于确定处理器使用情况，并确定最常使用的应用程序和服务。</p>
<p>但是<code>OProfile</code>有一些限制：</p>
<ul>
<li>性能监控样本可能不准确。因为处理器可能无序地执行指令，所以可以从附近的指令，而不是记录触发中断的指令。</li>
<li><code>OProile</code>希望程序多次启动和停止。这样的话多次运行得到的样本就可以累积，用户可能需要清除上一次运行的样本数据。</li>
<li><code>OProfile</code>集中识别CPU访问限制和进程问题。因此，对于等待锁定其他事件来识别睡眠状态的进程无帮助。</li>
</ul>
<h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h1><p>Valgrind提供大量检测分析工具帮助提高应用程序性能。这些工具能检测内存和与线程相关的错误，同样能检测堆、栈和数组的超限运行，使用户能够轻松定位和修改应用程序代码错误。也可以配置缓存、堆和分支预测来确定能增加应用程序速度并最小化内存使用率的因素。</p>
<p>通过在CPU运行应用程序来进程分析，并在执行时对现有的应用程序代码进行测试。之后显示的评论会更清楚的标识出每个参与应用程序执行的进程至用户指定文件、文件描述符或网络socket。</p>
<h1 id="PQOS"><a href="#PQOS" class="headerlink" title="PQOS"></a>PQOS</h1><p><code>pqos</code>程序可从<code>intel-cmt-cat</code>包获取，可以监控和控制CPU高速缓存和内存带宽。</p>
<p>它公开了Resource Director Technology（RDT）功能集的以下处理器功能：</p>
<ul>
<li>监控<ul>
<li>使用缓存监控技术（CMT）进行最后一级缓存（LLC）使用和争用监控。</li>
<li>使用内存带宽监控（MBM）技术监控线程内存带宽。</li>
</ul>
</li>
<li>分配<ul>
<li>使用高速缓存分配技术（CAT）控制可用于特定线程的LLC空间。</li>
<li>使用代码和数据优先级（CDP）技术控制LLC中的代码和数据放置。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>RPM包</title>
    <url>/2018/12/17/Linux/RPM/RPM-package/</url>
    <content><![CDATA[<h1 id="什么是RPM？"><a href="#什么是RPM？" class="headerlink" title="什么是RPM？"></a>什么是RPM？</h1><p>RPM包只是一个包含系统所需的其他文件和信息的文件。具体来说，RPM包由包含文件的<code>cpio</code>存档和包含有关包的元数据的RPM标头组成。<code>rpm</code>软件包管理器使用这种元数据来确定的依赖。在那安装文件和其他信息。</p>
<p>有两种类型的RPM包：</p>
<ul>
<li>源RPM（SRPM）</li>
<li>二进制RPM</li>
</ul>
<p>SRPM和二进制RPM弓箭文件格式和工具，但具有不同的内容并用于不同的目的。SRPM包含源代码，可选的补丁和SPEC文件，它描述了如何将源代码构建为二进制文件。<br><a id="more"></a></p>
<h2 id="RPM打包工具"><a href="#RPM打包工具" class="headerlink" title="RPM打包工具"></a>RPM打包工具</h2><p>查看安装位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install rpmdevtools</span><br><span class="line">rpm -ql rpmdevtools</span><br></pre></td></tr></table></figure>
<h2 id="RPM打包工作区"><a href="#RPM打包工作区" class="headerlink" title="RPM打包工作区"></a>RPM打包工作区</h2><p>要设置作为RPM打包工作区的目录布局，请使用<code>rpmdev-setuptree</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmdev-setuptree</span><br><span class="line">tree ~/rpmbuild/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rpmbuild/</span><br><span class="line">├── BUILD</span><br><span class="line">├── RPMS</span><br><span class="line">├── SOURCES</span><br><span class="line">├── SPECS</span><br><span class="line">└── SRPMS</span><br><span class="line"></span><br><span class="line">5 directories, 0 files</span><br></pre></td></tr></table></figure>
<p>创建的目录用于以下目的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>BUILD</td>
<td>构建包时，会在此处创建<code>%buildroots</code>目录，如果日志输出未提供足够的信息，这对于查找失败原因有帮助。</td>
</tr>
<tr>
<td>RPMS</td>
<td>二进制RPM在此处创建，位于不同体系结构的子目录中，例如在<code>x86_64</code>和<code>noarch</code>中</td>
</tr>
<tr>
<td>SOURCES</td>
<td>打包器放置压缩的源代码存档和补丁。<code>rpmbuild</code>在这里查找他们。</td>
</tr>
<tr>
<td>SPECS</td>
<td>打包器将SPEC文件放在此处。</td>
</tr>
<tr>
<td>SRPMS</td>
<td>当<code>rpmbuild</code>用于构建SRPM而不是二进制RPM时，将在此处创建生成SRPM。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="什么是SPEC文件"><a href="#什么是SPEC文件" class="headerlink" title="什么是SPEC文件"></a>什么是SPEC文件</h2><p>SPEC文件可以被任务是<code>rpmbuild</code>程序用于构建RPM的方法。通过定义指令来告诉构建系统要做什么，这些部分在<code>Preamble</code>和<code>Body</code>中定义。<code>Preamble</code>包含<code>Body</code>中使用的一系列元数据项。<code>Body</code>包含说明的主要部分。</p>
<h2 id="Preamble-项"><a href="#Preamble-项" class="headerlink" title="Preamble 项"></a>Preamble 项</h2><p>列出RPM SPEC文件中的Preamble部分的选项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SPEC指令</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Name</code></td>
<td>包的基本名称，应与SPEC文件名匹配</td>
</tr>
<tr>
<td><code>Version</code></td>
<td>软件的上游版本号</td>
</tr>
<tr>
<td><code>Release</code></td>
<td>此版本软件发布的次数。通常，将初始值设为<code>1%{?dist}</code>，并在每个新版本的包中增加它。在构建新版本时重置为1。</td>
</tr>
<tr>
<td><code>Summary</code></td>
<td>包的简短摘要。</td>
</tr>
<tr>
<td><code>license</code></td>
<td>正在打包的软件的许可证</td>
</tr>
<tr>
<td><code>URL</code></td>
<td>有关该程序的更多信息的完整URL，通常这是打包软件上游项目的网站。</td>
</tr>
<tr>
<td><code>Source0</code></td>
<td>上游源代码的压缩归档的路径或URL。这应该指向存档的可访问且可靠的存储，例如上游页面而不是打包器的本地存储。如果需要，可以添加更多的SourceX,数字递增。例如：Source1。</td>
</tr>
<tr>
<td><code>Patch0</code></td>
<td>必要时应用于源代码的第一个补丁的名称。如果需要，可以添加更多PatchX指令，每次递增数字，例如：Patch1，Patch2，Patch3等。</td>
</tr>
<tr>
<td><code>BuildArch</code></td>
<td>如果包不依赖于体系结构，例如，如果完全使用解释型编程语言编写，请将其设置为<code>BuildArch: noarch</code>。如果未设置，则程序包会自动继承构建它的计算机的体系结构<code>x86_64</code>。</td>
</tr>
<tr>
<td><code>BuildRequires</code></td>
<td>以逗号或空格分隔的包列表，用于构建使用编译语言编写的程序。可以有多个<code>BuildRequires</code>条目。每个条目在SPEC文件中都有自己的行。</td>
</tr>
<tr>
<td><code>Requires</code></td>
<td>软件包在安装后运行所需的软件包列表，可以有多条<code>Requires</code>条目，每个条目在SPEC文件中都有自己的行。</td>
</tr>
<tr>
<td><code>ExcludeArch</code></td>
<td>如果某个软件无法在特定的处理器体系上运行，则可以在此处排除该体系结构。</td>
</tr>
</tbody>
</table>
</div>
<p><code>Name</code>,<code>Version</code>和<code>Release</code>指令包含RPM包的文件名。RPM包维护者和系统管理员经常将这三个指令称为<code>NVR</code>或<code>N-V-R</code>，因为RPM包文件名具有<code>NAME-VERSION-RELEASE</code>格式。</p>
<p>可以通过使用<code>rpm</code>查询特定的包来获取<code>NAME-VERSION-RELEASE</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -q python</span><br><span class="line">python-2.7.5-76.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>这里<code>python</code>是Package Name，<code>2.7.5</code>是Version，<code>76.el7</code>是Release，<code>x86_64</code>是体系结构，与<strong>NVR</strong>不同，体系结构标记不受RPM包装程序的直接控制，而是由<code>rpmbuild</code>构建环境定义。例外是与架构无关的<code>noarch</code>包。</p>
<h2 id="Body-项"><a href="#Body-项" class="headerlink" title="Body 项"></a>Body 项</h2><p>此表列出了RPM SPEC文件的Body部分中使用的项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>SPEC指令</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%descriptipn</code></td>
<td>RPM中打包的软件的完整描述。该描述可以跨越多行并且可以分成段落。</td>
</tr>
<tr>
<td><code>%prep</code></td>
<td>用于准备要构建的软件的命令或一系列命令，例如，解压缩存档<code>Source0</code>、该指令可以包含shell脚本。</td>
</tr>
<tr>
<td><code>%build</code></td>
<td>用于将软件实际构建为机器码或字节码的命令或一系列命令。</td>
</tr>
<tr>
<td><code>%install</code></td>
<td>用于将所需构建组件从<code>%builffit</code>（构建发生的位置）复制到<code>%buildroot</code>目录（包含要打包的文件的目录结构）的命令。通常意味着将文件从<code>~/rpmbuild/BUILD</code>复制到<code>~/rpmbuild/BUILDROOT</code>。这尽在创建包时运行，而不是在安装时运行。</td>
</tr>
<tr>
<td><code>%check</code></td>
<td>用于测试软件的命令。通常包括单元测试等内容。</td>
</tr>
<tr>
<td><code>%files</code></td>
<td>将在最终用户的系统中安装的文件列表。</td>
</tr>
<tr>
<td><code>changelog</code></td>
<td>不同<code>Version</code>或<code>Release</code>之间发生的更改记录。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="BuildRoots"><a href="#BuildRoots" class="headerlink" title="BuildRoots"></a>BuildRoots</h2><p>在RPM打包的北京下，<code>buildroot</code>是一个chroot环境。这意味着使用与最终用户系统中相同的文件系统层次结构将构建组件放置在此处，其中<code>buildroot</code>充当根目录，构建组件的防止应符合最终用户系统文件层次结构标准。</p>
<p><code>buildroot</code>中的文件稍后会被放入<code>cpio</code>存档中，后者将成为RPM的主要部分，在最终用户的系统上安装RPM时，会在根目录中提取这些文件，从而保留正确的层次结构。</p>
<h2 id="RPM宏"><a href="#RPM宏" class="headerlink" title="RPM宏"></a>RPM宏</h2><p>RPM宏是直接文本替换，可以在使用某些内置功能时根据语句的可选评估有条件的分配。这意味着您可以让RPM为您执行文本替换。</p>
<p>例如，在SPEC文件中多次引用打包软件版本时，这很有用。您只能在<code>%{version}</code>宏中定义一次版本。然后再整个SPEC文件中使用<code>%{version}</code>。每次出现都会自动替换之前定义的版本。</p>
<blockquote>
<p>如果看到一个不熟悉的宏，可以使用一下方法对其进行评估：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> %&#123;_MACRO&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> %&#123;_bindir&#125;</span><br><span class="line">rpm --<span class="built_in">eval</span> %&#123;_libexecdir&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>%{?dist}</code>一个常见的宏，表示“分发标签”。表示用于构建的分布。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --<span class="built_in">eval</span> %&#123;?dist&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用SPEC文件"><a href="#使用SPEC文件" class="headerlink" title="使用SPEC文件"></a>使用SPEC文件</h2><p>将软件打包成RPM的很多一部分工作时编辑SPEC文件。</p>
<p>要打包新软件，需要创建一个新的SPEC文件，不要从头开始手动编写，使用<code>rpmdev-new-spec</code>命令。它会创建一个未填充的SPEC文件，并填写必要的指令和字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmdev-newspec bello</span><br></pre></td></tr></table></figure>
<p>生成的<code>bello.spec</code>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:           bello</span><br><span class="line">Version:</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:</span><br><span class="line"></span><br><span class="line">License:</span><br><span class="line">URL:</span><br><span class="line">Source0:</span><br><span class="line"></span><br><span class="line">BuildRequires:</span><br><span class="line">Requires:</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">%configure</span><br><span class="line">make %&#123;?_smp_mflags&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">rm -rf <span class="variable">$RPM_BUILD_ROOT</span></span><br><span class="line">%make_install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%doc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure>
<p>完善<code>bello.spec</code>内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:           bello</span><br><span class="line">Version:        0.1</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        Hello World example implemented <span class="keyword">in</span> bash script</span><br><span class="line"></span><br><span class="line">License:        GPLv3+</span><br><span class="line">URL:            https://www.example.com/%&#123;name&#125;</span><br><span class="line">Source0:        https://www.example.com/%&#123;name&#125;/releases/%&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">Requires:       bash</span><br><span class="line"></span><br><span class="line">BuildArch:      noarch</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">The long-tail description <span class="keyword">for</span> our Hello World Example implemented <span class="keyword">in</span></span><br><span class="line">bash script.</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line"></span><br><span class="line">mkdir -p %&#123;buildroot&#125;/%&#123;_bindir&#125;</span><br><span class="line"></span><br><span class="line">install -m 0755 %&#123;name&#125; %&#123;buildroot&#125;/%&#123;_bindir&#125;/%&#123;name&#125;</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%license LICENSE</span><br><span class="line">%&#123;_bindir&#125;/%&#123;name&#125;</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line">* Tue May 31 2016 Adam Miller &lt;maxamillion@fedoraproject.org&gt; - 0.1-1</span><br><span class="line">- First bello package</span><br><span class="line">- Example second item <span class="keyword">in</span> the changelog <span class="keyword">for</span> version-release 0.1-1</span><br></pre></td></tr></table></figure>
<p>完善<code>pello.spec</code>内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:           pello</span><br><span class="line">Version:        0.1.1</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        Hello World example implemented <span class="keyword">in</span> python</span><br><span class="line"></span><br><span class="line">License:        GPLv3+</span><br><span class="line">URL:            https://www.example.com/%&#123;name&#125;</span><br><span class="line">Source0:        https://www.example.com/%&#123;name&#125;/releases/%&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">BuildRequires:  python</span><br><span class="line">Requires:       python</span><br><span class="line">Requires:       bash</span><br><span class="line"></span><br><span class="line">BuildArch:      noarch</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">The long-tail description <span class="keyword">for</span> our Hello World Example implemented <span class="keyword">in</span></span><br><span class="line">Python.</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line"></span><br><span class="line">python -m compileall %&#123;name&#125;.py</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line"></span><br><span class="line">mkdir -p %&#123;buildroot&#125;/%&#123;_bindir&#125;</span><br><span class="line">mkdir -p %&#123;buildroot&#125;/usr/lib/%&#123;name&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; %&#123;buildroot&#125;/%&#123;_bindir&#125;/%&#123;name&#125; &lt;&lt;-EOF</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/usr/bin/python /usr/lib/%&#123;name&#125;/%&#123;name&#125;.pyc</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 0755 %&#123;buildroot&#125;/%&#123;_bindir&#125;/%&#123;name&#125;</span><br><span class="line"></span><br><span class="line">install -m 0644 %&#123;name&#125;.py* %&#123;buildroot&#125;/usr/lib/%&#123;name&#125;/</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%license LICENSE</span><br><span class="line">%dir /usr/lib/%&#123;name&#125;/</span><br><span class="line">%&#123;_bindir&#125;/%&#123;name&#125;</span><br><span class="line">/usr/lib/%&#123;name&#125;/%&#123;name&#125;.py*</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line">* Tue May 31 2016 Adam Miller &lt;maxamillion@fedoraproject.org&gt; - 0.1.1-1</span><br><span class="line">  - First pello package</span><br></pre></td></tr></table></figure>
<p>完善<code>cello.spec</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Name:           cello</span><br><span class="line">Version:        1.0</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        Hello World example implemented <span class="keyword">in</span> C</span><br><span class="line"></span><br><span class="line">License:        GPLv3+</span><br><span class="line">URL:            https://www.example.com/%&#123;name&#125;</span><br><span class="line">Source0:        https://www.example.com/%&#123;name&#125;/releases/%&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">Patch0:         cello-output-first-patch.patch</span><br><span class="line"></span><br><span class="line">BuildRequires:  gcc</span><br><span class="line">BuildRequires:  make</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">The long-tail description <span class="keyword">for</span> our Hello World Example implemented <span class="keyword">in</span></span><br><span class="line">C.</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%patch0</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">make %&#123;?_smp_mflags&#125;</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">%make_install</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%license LICENSE</span><br><span class="line">%&#123;_bindir&#125;/%&#123;name&#125;</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line">* Tue May 31 2016 Adam Miller &lt;maxamillion@fedoraproject.org&gt; - 1.0-1</span><br><span class="line">- First cello package</span><br></pre></td></tr></table></figure>
<p> <code>/etc/rpmdevtools/</code>目录中有几种流行语言SPEC文件模板。</p>
<h2 id="构建RPMS"><a href="#构建RPMS" class="headerlink" title="构建RPMS"></a>构建RPMS</h2><p>RPM是使用<code>rpmbuild</code>构建的。</p>
<p>方案：</p>
<ol>
<li>构建源RPM</li>
<li>构建二进制RPM</li>
</ol>
<p><code>rpmbuild</code>需要某个目录和文件结构。这与<code>rpmdev-setuptree</code>程序设置的结构相同。</p>
<h2 id="源RPMS"><a href="#源RPMS" class="headerlink" title="源RPMS"></a>源RPMS</h2><p>为什么要构建源RPM（SRPM）?</p>
<ol>
<li>保留不是道环境的RPM的某个Name-Version-Release的确切来源。这包括确切的SPEC文件，源代码和所有相关补丁。这对于回顾历史记录和调试很有用。</li>
<li>能够在不同硬件平台或体系架构上构建二进制RPM。</li>
</ol>
<h2 id="创建SRPM"><a href="#创建SRPM" class="headerlink" title="创建SRPM"></a>创建SRPM</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmbuild -bs SPECFILE</span><br></pre></td></tr></table></figure>
<p>这里，我们建立<code>bello</code>、<code>pello</code>、<code>cello</code>的SRPM。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/rpmbuild/SPECS/</span><br><span class="line">rpmbuild -bs bello.spec</span><br><span class="line">写道:/root/rpmbuild/SRPMS/bello-0.1-1.el7.centos.src.rpm</span><br><span class="line">rpmbuild -bs cello.spec</span><br><span class="line">写道:/root/rpmbuild/SRPMS/cello-1.0-1.el7.centos.src.rpm</span><br><span class="line">rpmbuild -bs pello.spec</span><br><span class="line">写道:/root/rpmbuild/SRPMS/pello-0.1.1-1.el7.centos.src.rpm</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，SRPM被防止在<code>rpmbuild/SRPMS</code>目录中，</p>
</blockquote>
<h2 id="二进制RPMS"><a href="#二进制RPMS" class="headerlink" title="二进制RPMS"></a>二进制RPMS</h2><p>构建二进制RPM有两种方法：</p>
<ol>
<li>使用<code>rpmbuild --rebuild</code>命令重建。</li>
<li>使用<code>rpmbuild -bb</code>命令从SPEC文件构建，<code>-bb</code>选项代表构建二进制。</li>
</ol>
<h3 id="从源RPM重建"><a href="#从源RPM重建" class="headerlink" title="从源RPM重建"></a>从源RPM重建</h3><p>要从源RPM重<code>bello</code>、<code>cello</code>以及<code>pello</code>，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmbuild --rebuild ~/rpmbuild/SRPMS/bello-0.1-1.el7.centos.src.rpm</span><br><span class="line">rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el7.centos.src.rpm</span><br><span class="line">rpmbuild --rebuild ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.centos.src.rpm</span><br></pre></td></tr></table></figure>
<ul>
<li>创建二进制RPM时生成的输出是详细的，有助于调试</li>
<li>调用<code>rpmbuild --rebuild</code>：<ul>
<li>将SRPM内容安装到<code>~/rpmbuild/</code>。</li>
<li>使用已安装的内容构建。</li>
<li>删除SPEC和源码。</li>
</ul>
</li>
</ul>
<p>如果想要保留SPEC和源码，有两个办法：</p>
<ol>
<li><p>构建时使用<code>--recompile</code>而不是<code>--rebuild</code>。</p>
</li>
<li><p>使用一下命令安装SRPM：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="从SPEC构建二进制文件"><a href="#从SPEC构建二进制文件" class="headerlink" title="从SPEC构建二进制文件"></a>从SPEC构建二进制文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmbuild --bb ~/rpmbuild/SPEC/bello.spec</span><br><span class="line">rpmbuild --bb ~/rpmbuild/SPEC/cello.spec</span><br><span class="line">rpmbuild --bb ~/rpmbuild/SPEC/pello.spec</span><br></pre></td></tr></table></figure>
<h2 id="检查RPM"><a href="#检查RPM" class="headerlink" title="检查RPM"></a>检查RPM</h2><p>使用<code>rpmlint</code>检查RPM包:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmlint ~/build/RPMS/x86_64/cello-1.0-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>使用<code>rpmlint</code>检查SPEC文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmlint ~/rpmbuild/SPECS/cello.spec</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个RPM包</title>
    <url>/2018/12/12/Linux/RPM/Create-an-RPM-package/</url>
    <content><![CDATA[<p>创建RPM包可能很复杂。下面是一个简化的示例:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name:       hello-world</span><br><span class="line">Version:    1</span><br><span class="line">Release:    1</span><br><span class="line">Summary:    Most simple RPM package</span><br><span class="line">License:    FIXME</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">This is my first RPM package, which does nothing.</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line"># we have no source, so nothing here</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line">cat &gt; hello-world.sh &lt;&lt;EOF</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">echo Hello world</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">mkdir -p %&#123;buildroot&#125;&#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">install -m 755 hello-world.sh %&#123;buildroot&#125;&#x2F;usr&#x2F;bin&#x2F;hello-world.sh</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;hello-world.sh</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line"># let skip this for now</span><br></pre></td></tr></table></figure></p>
<p>将文件另存为<code>hello-world.spec</code>。</p>
<p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutils patch rpmdevtools</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmdev-setuptree</span><br><span class="line">rpmbuild -ba hello-world.spec</span><br></pre></td></tr></table></figure>
<p><code>rpm-setuptree</code>命令创建了几个工作目录。由于这些目录永久存储在<code>$HOME</code>中，因此不需要再次输入命令。</p>
<p>执行<code>rpm-build</code>命令的输出类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">执行(%prep): /bin/sh -e /var/tmp/rpm-tmp.mwA7kE</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span> /root/rpmbuild/BUILD</span><br><span class="line">+ <span class="built_in">exit</span> 0</span><br><span class="line">执行(%build): /bin/sh -e /var/tmp/rpm-tmp.WRcFAO</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span> /root/rpmbuild/BUILD</span><br><span class="line">+ cat</span><br><span class="line">+ <span class="built_in">exit</span> 0</span><br><span class="line">执行(%install): /bin/sh -e /var/tmp/rpm-tmp.UQtmSY</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span> /root/rpmbuild/BUILD</span><br><span class="line">+ <span class="string">'['</span> /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64 <span class="string">'!='</span> / <span class="string">']'</span></span><br><span class="line">+ rm -rf /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64</span><br><span class="line">++ dirname /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64</span><br><span class="line">+ mkdir -p /root/rpmbuild/BUILDROOT</span><br><span class="line">+ mkdir /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64</span><br><span class="line">+ mkdir -p /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64/usr/bin/</span><br><span class="line">+ install -m 755 hello-world.sh /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64/usr/bin/hello-world.sh</span><br><span class="line">+ <span class="string">'['</span> <span class="string">'%&#123;buildarch&#125;'</span> = noarch <span class="string">']'</span></span><br><span class="line">+ QA_CHECK_RPATHS=1</span><br><span class="line">+ <span class="keyword">case</span> <span class="string">"<span class="variable">$&#123;QA_CHECK_RPATHS:-&#125;</span>"</span> <span class="keyword">in</span></span><br><span class="line">+ /usr/lib/rpm/check-rpaths</span><br><span class="line">+ /usr/lib/rpm/check-buildroot</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-compress</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-strip /usr/bin/strip</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-strip-comment-note /usr/bin/strip /usr/bin/objdump</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-strip-static-archive /usr/bin/strip</span><br><span class="line">+ /usr/lib/rpm/brp-python-bytecompile /usr/bin/python 1</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-python-hardlink</span><br><span class="line">+ /usr/lib/rpm/redhat/brp-java-repack-jars</span><br><span class="line">处理文件：hello-world-1-1.x86_64</span><br><span class="line">Provides: hello-world = 1-1 hello-world(x86-64) = 1-1</span><br><span class="line">Requires(rpmlib): rpmlib(CompressedFileNames) &lt;= 3.0.4-1 rpmlib(FileDigests) &lt;= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</span><br><span class="line">Requires: /usr/bin/bash</span><br><span class="line">检查未打包文件：/usr/lib/rpm/check-files /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64</span><br><span class="line">写道:/root/rpmbuild/SRPMS/hello-world-1-1.src.rpm</span><br><span class="line">写道:/root/rpmbuild/RPMS/x86_64/hello-world-1-1.x86_64.rpm</span><br><span class="line">执行(%clean): /bin/sh -e /var/tmp/rpm-tmp.1fjrRw</span><br><span class="line">+ <span class="built_in">umask</span> 022</span><br><span class="line">+ <span class="built_in">cd</span> /root/rpmbuild/BUILD</span><br><span class="line">+ /usr/bin/rm -rf /root/rpmbuild/BUILDROOT/hello-world-1-1.x86_64</span><br><span class="line">+ <span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p><code>$HOME/rpmbuild/RPMS/x86-64/hello-world-1-1.x86_64.rpm</code>是生成的RPM包。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>准备打包软件</title>
    <url>/2018/12/11/Linux/RPM/Ready-to-package-software/</url>
    <content><![CDATA[<h1 id="什么是源代码？"><a href="#什么是源代码？" class="headerlink" title="什么是源代码？"></a>什么是源代码？</h1><p><strong>源代码</strong>是计算机的人类可读指令，描述了如何执行计算。源代码使用编程语言表示。</p>
<p>下面，使用三种不同编程语言编写<code>Hello World</code>，用着三种不同语言编写的程序以不同的方式打包。</p>
<a id="more"></a>
<p>用<code>bash</code>编写<code>Hello World</code>：</p>
<p>filename:<code>bello</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Hello World\n"</span></span><br></pre></td></tr></table></figure>
<p>用<code>Python</code>编写<code>Hello World</code>：</p>
<p>filename:<code>pello.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">print(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>
<p>用<code>C</code>编写<code>Hello World</code>：</p>
<p>filename：<code>cello.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>） &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的结果都是在命令行上输出<code>Hello World</code>。</p>
<h1 id="程序如何制作"><a href="#程序如何制作" class="headerlink" title="程序如何制作"></a>程序如何制作</h1><p>人类可读的源代码有许多方法可以成为机器代码-计算机遵循实际执行程序的指令。但是，所有方法都可以简化为以下三种：</p>
<ol>
<li>程序是本地编译的。</li>
<li>程序由原始解释来解释的。</li>
<li>程序由字节编译解释。</li>
</ol>
<h2 id="本机编译代码"><a href="#本机编译代码" class="headerlink" title="本机编译代码"></a>本机编译代码</h2><p><strong>本机编译的</strong>软件是用编程语言<strong>编写的</strong>软件，编译成机器代码，生成二进制可执行文件。这种软件可以独立运行。</p>
<p>以这种方式构建的RPM包是特定于体系结构的。这意味着如果在64位（x86_64）处理器的计算机上编译此类软件，则无法在32位（x86）处理器上执行。生成的包将在其名称中指定体系结构。</p>
<h2 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h2><p>某些编程语言（<code>bash</code>或<code>Python</code>）无法编译为机器代码。相反，他们的程序的源代码是由语言解释器或语言虚拟机逐步执行的，无需事先转换。</p>
<p>完全用解释型编程语言编写的软件不是特定于体系结构的，因此，生成的RPM包将包含<code>noarch</code>字符串。</p>
<p>解释型语言或者是字节编译或原始解释。这两种类型在程序构建过程和包装过程中有所不同。</p>
<h3 id="原始解释程序"><a href="#原始解释程序" class="headerlink" title="原始解释程序"></a>原始解释程序</h3><p>原始解释程序语言根本不需要编译，它们由解释器直接执行。</p>
<h3 id="字节编译程序"><a href="#字节编译程序" class="headerlink" title="字节编译程序"></a>字节编译程序</h3><p>字节编译语言需要编译成字节代码，然后由语言虚拟机执行。</p>
<h1 id="从源码构建软件"><a href="#从源码构建软件" class="headerlink" title="从源码构建软件"></a>从源码构建软件</h1><ul>
<li>对于编译语言编写的软件，源代码通过<strong>构建</strong>（<strong>Build</strong>）过程生成机器代码。这个过程通常称为<strong>编译</strong> （<strong>compiling</strong>），因不同的语言而异。生成的软件可以<strong>运行</strong>（<strong>run</strong>）或<strong>执行</strong>（<strong>executed</strong>），这使计算机可以执行程序员指定的任务。</li>
<li>对于原始解释语言编写的软件，源代码不是构建的，而是直接执行。</li>
<li>对于用字节编译的解释语言编写的软件，源代码被编译成字节代码，然后由语言虚拟机执行。</li>
</ul>
<h2 id="本机编译代码-1"><a href="#本机编译代码-1" class="headerlink" title="本机编译代码"></a>本机编译代码</h2><p>使用C语言编写的<code>cello.c</code>程序构建为可执行文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h3><p>从GNU编译器集合（<code>GCC</code>）调用C编译器将源代码编译为二进制文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g -o cello cello.c</span><br></pre></td></tr></table></figure>
<p>执行二进制文件<code>cello</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cello</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>这样，已经从源代码构建并运行本机编译的软件。</p>
<h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><p>可以自动化构建，而不是手动构建源代码。这是大型软件常用的做法。通过创建<code>Makefile</code>软件运行<code>GNU</code> <code>make</code>程序来自动完成构建。</p>
<p>要设置自动构建，需要创建一个名为<code>Makefile</code>和相同的<code>cello.c</code>：</p>
<p>Makefile:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">cello:</span></span><br><span class="line">        gcc -g -o cello cello.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm cello</span><br></pre></td></tr></table></figure>
<p>现在构建软件，只需要运行<code>make</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make: <span class="string">'cello'</span> is up to date.</span><br></pre></td></tr></table></figure>
<p>由于已经有一个构建存在，可以执行<code>make clean</code>后再次运行<code>make</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean </span><br><span class="line">rm cello </span><br><span class="line">make </span><br><span class="line">gcc -g -o cello cello.c</span><br></pre></td></tr></table></figure>
<h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><h3 id="字节编译代码"><a href="#字节编译代码" class="headerlink" title="字节编译代码"></a>字节编译代码</h3><p><code>peool.py</code>用Python编写的程序编译为字节代码，然后由Python语言虚拟机执行。Pyhton源代码也可以是原始解释的，但字节编译版本更快。因此，RPM Packagers更喜欢将字节编译版本打包以分发给最终用户。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">print(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>
<p>对于不同的语言，字节编译程序的过程是不同的。取决于语言，语言的虚拟机以及与该语言一起使用的工具和过程。</p>
<p>字节编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m compileall pello.py</span><br><span class="line">file pello.pyc</span><br></pre></td></tr></table></figure>
<p>执行以下字节代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python pello.pyc</span><br></pre></td></tr></table></figure>
<h3 id="解释代码-1"><a href="#解释代码-1" class="headerlink" title="解释代码"></a>解释代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"Hello World\n"</span></span><br></pre></td></tr></table></figure>
<p>用shell脚本语言编写的程序，例如<code>bash</code>是解释的。因此，只需要使源代码可执行文件运行它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x bello</span><br><span class="line">./bello</span><br></pre></td></tr></table></figure>
<h1 id="修补软件"><a href="#修补软件" class="headerlink" title="修补软件"></a>修补软件</h1><p>补丁是源代码，更新其他源代码。被格式化为<code>diff</code>因为它表示两个版本的文本之间的不同。</p>
<blockquote>
<p>开发人员经常使用版本控制系统，例如<code>git</code>来管理源代码仓库，这些工具提供了自己创建差异或修补软件的方法。</p>
</blockquote>
<p>在示例中，我们使用<code>diff</code>从原始源代码创建补丁，然后使用<code>patch</code>应用它。在创建RPM时，将在后面的部分中使用修补。</p>
<p>修补如何与RPM包装相关？在打包时，我们保留它，而不是简答地修改源代码，并在其上使用补丁。</p>
<p>在为<code>cello.c</code>内容创建补丁：</p>
<ol>
<li><p>保留原始源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp cello.c cello.c.orig</span><br></pre></td></tr></table></figure>
<p>这是保留原始源代码文件的常用方法。</p>
</li>
<li><p>更改<code>cello.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World from my very first patch!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>diff</code>生成补丁：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff -Naur cello.c.orig cello.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>将补丁程序保存到文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diff -Naur cello.c.orig cello.c &gt; cello-output-first-patch.patch</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复原始<code>cello.c</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp cello.c.orig cello.c</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>我们保留原始文件<code>cello.c</code>，因为在构建RPM时，会使用原始文件，而不是修改过的文件。</p>
</blockquote>
<p><code>cello.c</code>要使用补丁<code>cello.output-first-patch.patch</code>,请将补丁文件重定向到<code>patch</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patch &lt; cello-output-first-patch.patch</span><br></pre></td></tr></table></figure>
<p>构建并运行修补程序<code>cello.c</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br><span class="line">./cello</span><br></pre></td></tr></table></figure>
<p>您已经创建了一个补丁，修补了一个程序，构建了修补程序并运行它。</p>
<h1 id="安装任意工具"><a href="#安装任意工具" class="headerlink" title="安装任意工具"></a>安装任意工具</h1><p>Linux和其他类Unix系统相比的一大优势是文件系统层次标准（FHS）。它指定应在哪个目录中找到哪些文件。从RPM软件包安装的文件应根据FHS要求进行存放。例如，可执行文件应该放入系统<code>PATH</code>变量中的目录。</p>
<p>我们将探索在系统中放置任意文件的两种流行方法：使用<code>install</code>，<code>make install</code>命令。</p>
<h2 id="使用install命令"><a href="#使用install命令" class="headerlink" title="使用install命令"></a>使用install命令</h2><p>有时使用构建自动化工具并不是最佳的，例如，如果打包的程序很简答并且不需要额外的开销。在这些情况下，打包器通常使用<code>install</code>命令，该命令将放置到具有指定权限集的文件系统中的指定目录中。</p>
<blockquote>
<p><code>install</code>将<code>bello</code>文件放入包含可执行脚本通用权限的<code>usr/bin</code>：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">install -m 0755 bello /usr/bin/bello</span><br></pre></td></tr></table></figure>
<p>现在<code>bello</code>位于<code>$PATH</code>变量中列出的目录。因此可以从任何位置执行<code>bello</code>。</p>
<h2 id="使用make-install命令"><a href="#使用make-install命令" class="headerlink" title="使用make install命令"></a>使用make install命令</h2><p>将以构建的软件安装到系统的自动方式是使用<code>make install</code>命令。它要求<code>Makefile</code>指定如何在系统中将任意文件安装到系统中。</p>
<p>将<code>install</code>部分添加到Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">cello:</span></span><br><span class="line">	gcc -g -o cello cello.c</span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm cello</span><br><span class="line">	</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	mkdir -p <span class="variable">$(DESTDIR)</span>/usr/bin</span><br><span class="line">	install -m 0755 cello <span class="variable">$(DESTDIR)</span>/usr/bin/cello</span><br></pre></td></tr></table></figure>
<p><code>$(DESTDIR)</code>变量是<code>GNU</code>内置的，通常用于指定安装到不是根目录不同的目录。</p>
<p>现在，不仅可以使用<code>Makefile</code>构建软件，还可以将其安装到目标系统。</p>
<p>要构建和安装程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>现在<code>cello</code>位于$PATH变量列出的目录中。</p>
<h1 id="准备打包的源代码"><a href="#准备打包的源代码" class="headerlink" title="准备打包的源代码"></a>准备打包的源代码</h1><blockquote>
<p>创建源代码存档通常不是由RPM Packager完成的，而是由开发人员完成的。打包器使用现成的源代码存档。</p>
</blockquote>
<p>软件应与软件许可证一起分发。例如，使用<a href="https://www.gnu.org/licenses/quick-guide-gplv3.html" target="_blank" rel="noopener">GPLv3</a>许可证。许可证文本将进入每个文件中。RPM打包程序在打包时需要处理许可证文件。</p>
<p><code>LICENSE</code>实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This program is free software: you can redistribute it and/or modify</span><br><span class="line">it under the terms of the GNU General Public License as published by</span><br><span class="line">the Free Software Foundation, either version 3 of the License, or</span><br><span class="line">(at your option) any later version.</span><br><span class="line"></span><br><span class="line">This program is distributed <span class="keyword">in</span> the hope that it will be useful,</span><br><span class="line">but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line">GNU General Public License <span class="keyword">for</span> more details.</span><br><span class="line"></span><br><span class="line">You should have received a copy of the GNU General Public License</span><br><span class="line">along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span><br></pre></td></tr></table></figure>
<h1 id="将源代码放入Tarball"><a href="#将源代码放入Tarball" class="headerlink" title="将源代码放入Tarball"></a>将源代码放入Tarball</h1><p>我们将三个<code>Hello World</code>程序中的每一个都放入一个gzip压缩的tarball中。软件通常以这种方式发布。</p>
<h2 id="bello"><a href="#bello" class="headerlink" title="bello"></a>bello</h2><p>假设这是<code>0.1</code>版本的程序。</p>
<p>准备bello项目进行分发：</p>
<ol>
<li><p>将文件放在一个目录中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/bello-0.1</span><br><span class="line">mv ~/bello /tmp/bello-0.1/</span><br><span class="line">cp /tmp/LICENSE /tmp/bello-0.1/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用于分发的存档并将其移至<code>~/rpmbuild/SOURCES/</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">tar -cvzf pello-0.1.1.tar.gz pello-0.1.1</span><br><span class="line">mv /tmp/pello-0.1.1.tar.gz /rpmbuild/SOURCES/</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="cello"><a href="#cello" class="headerlink" title="cello"></a>cello</h2><p>项目包含 <code>cello.c</code> 和 <code>Makefile</code> 文件, </p>
<ol>
<li><p>将文件放在一个目录中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/cello-1.0</span><br><span class="line">mv ~/cello.c /tmp/cello-1.0/</span><br><span class="line">mv ~/Makefile /tmp/cello-1.0/</span><br><span class="line">cp /tmp/LICENSE /tmp/cello-1.0/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用于分发的存档并移至 <code>~/rpmbuild/SOURCES/</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">tar -cvzf cello-1.0.tar.gz cello-1.0</span><br><span class="line">mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加补丁:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么使用RPM打包软件</title>
    <url>/2018/12/10/Linux/RPM/Why-use-RPM-to-package-software/</url>
    <content><![CDATA[<p>RPM Package Manager（RPM）是在RedHat，CentOS和Fedora上运行的包管理系统。RPM使您可以轻松分发、管理和更新为RedHat、CentOS和Fedora创建的软件。许多软件供应商通过传统的归档文件（例如tarball）来分发他们的软件。但，将软件打包到RPM有以下优点：</p>
<p><strong>安装，重新安装，删除，升级和验证包</strong></p>
<p>​    用户可以使用标准软件包管理工具（例如<code>Yum</code>、<code>PackageKit</code>）来安装，重新安装，删除，升级和验证RPM软件包。</p>
<p><strong>使用已安装的软件包的数据库来查询和验证软件包</strong></p>
<p>​    由于RPM维护已安装软件包及其文件的数据库，因此用户可以轻松查询和验证系统上的软件包。</p>
<p><strong>使用元数据来描述包，安装说明等</strong></p>
<p>​    每个RPM软件包都包含描述软件包的组件，版本，发行版，大小，项目URL，安装说明等元数据。</p>
<p><strong>将原始软件源打包为源包和二进制包</strong></p>
<p>​    RPM</p>
<p><strong>将原始软件源打包为源包和二进制包</strong></p>
<p>RPM允许您获取原始软件源并将其打包为用户的源和二进制包。在源包中，您拥有原始源以及所使用的任何修补程序以及完整的构建说明。随着软件的新版本发布，此设计可以简化软件包的维护。</p>
<p><strong>将包添加到Yum存储库</strong></p>
<p>您可以将软件包添加到Yum存储库，使客户端可以轻松查找和部署软件。</p>
<p><strong>对您的包裹进行数字签名</strong></p>
<p>使用GPG签名密钥，您可以对软件包进行数字签名，以便用户能够验证软件包的真实性。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>使用HAPROXY和KEEPALIVED负载均衡简单示例</title>
    <url>/2018/12/09/LB/Simple-example-using-HAPROXY-and-KEEPALIVED-load-balancing/</url>
    <content><![CDATA[<h1 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>指定自己需要开放的端口来替换80/tcp</p>
<h1 id="安装配置Keepalived"><a href="#安装配置Keepalived" class="headerlink" title="安装配置Keepalived"></a>安装配置Keepalived</h1><a id="more"></a>
<ol>
<li><p>两个节点安装Keepalived</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install keepalived</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑Keepalived配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/keepalive/keepalived.conf</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">  script <span class="string">"killall -0 haproxy"</span> <span class="comment"># check the haproxy process</span></span><br><span class="line">  interval 2 <span class="comment"># every 2 seconds</span></span><br><span class="line">  weight 2 <span class="comment"># add 2 points if OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">  interface eth0 <span class="comment"># interface to monitor</span></span><br><span class="line">  state MASTER <span class="comment"># MASTER on haproxy, BACKUP on haproxy2</span></span><br><span class="line">  virtual_router_id 51</span><br><span class="line">  priority 101 <span class="comment"># 101 on haproxy, 100 on haproxy2</span></span><br><span class="line">  virtual_ipaddress &#123;</span><br><span class="line">    192.168.0.100 <span class="comment"># virtual ip address</span></span><br><span class="line">  &#125;</span><br><span class="line">  track_script &#123;</span><br><span class="line">    chk_haproxy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> keepalived ; systemctl start keepalived</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="安装配置HAProxy"><a href="#安装配置HAProxy" class="headerlink" title="安装配置HAProxy"></a>安装配置HAProxy</h1><ol>
<li><p>安装HAProxy。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install haproxy</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置HAProxy。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frontend http_web *:80</span><br><span class="line">    mode http</span><br><span class="line">    default_backend rgw</span><br><span class="line"></span><br><span class="line">backend rgw</span><br><span class="line">    balance roundrobin</span><br><span class="line">    mode http</span><br><span class="line">    server  rgw1 10.0.0.71:80 check</span><br><span class="line">    server  rgw2 10.0.0.80:80 check</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> haproxy ; systemctl start haproxy</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>HAProxy</tag>
        <tag>KEEPALIVED</tag>
      </tags>
  </entry>
  <entry>
    <title>路由方法</title>
    <url>/2018/12/08/LB/Routing-method/</url>
    <content><![CDATA[<h1 id="NAT路由"><a href="#NAT路由" class="headerlink" title="NAT路由"></a>NAT路由</h1><p>下图说明了利用NAT路由在Internet和专用网络之间移动请求的负载均衡。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/lvs-nat-routing.png" alt=""></p>
<p>活动的LVS路由器有连个NIC。Internet的NIC在eth0上具有<em>真实IP地址</em>和浮动IP地址。专用网络接口的NIC在eth1上具有真实IP地址和浮动IP地址。专用网络接口的NIC在eth1上具有真实IP地址和浮动IP地址。在故障转移的情况下，面向Internet的虚拟接口和面向私有的虚拟接口同时由备用LVS路由器接管。位于专用网络上的所有真实服务器都是用NAT路由的浮动IP作为与活动LVS路由器通信的默认路由，以便他们响应来自Internet的请求的能力不受损害。</p>
<p>LVS路由器的公共浮动IP地址和专用NAT浮动IP地址被分配给物理NIC。虽然可以将每个浮动IP地址与LVS路由器节点上的自己的物理设备相关联，不要求具有两个以上NIC。</p>
<p>活动LVS路由器接收请求并将其路由到适当的服务器。然后，真是服务器处理该请求并将数据包返回到LVS路由器，该路由器使用网络地址转换来用LVS路由器的公共VIP地址替换数据包中的真实服务器的地址。此过程称为IP伪装，因为真实服务器的实际IP地址对请求客户端是隐藏的。</p>
<p>使用此NAT路由，真实服务器可以是运行各种操作系统的任何类型的机器。主要缺点是LVS路由器可能成为大型集群的瓶颈，因为它必须处理传入和传出请求。</p>
<p>这些<code>ipvs</code>模块使用自己的内部NAT例程，这些例程独立于<code>iptables</code>和<code>ip6tables</code>NAT。当真实服务器配置为NAT而不是<code>/etc/keepalived/keepalived.conf</code>文件中的DR时。浙江有助于IPv4和IPv6NAT。<br><a id="more"></a></p>
<h1 id="直接路由"><a href="#直接路由" class="headerlink" title="直接路由"></a>直接路由</h1><p>与其他Load Balancer网络相比，构建使用直接路由的负载均衡器设置可提供；那个更高的性能优势。直接路由允许真实服务器直接处理和路由数据包到请求用户，而不是通过LVS路由器传递所有的数据包。直接通过路由器将LVS路由器的作业降级为仅处理传入的数据包来减低网络性能问题的可能性。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/lvs-direct-routing.png" alt=""></p>
<p>典型的直接路由负载均衡设置中，LVS路由器通过虚拟IP接收传入服务器请求，并使用调度算法将请求路由到真实服务器。真实服务器处理请求并将相应直接发送到客户端，绕过LVS路由器。这种路由方法允许可扩展。因为可以添加真实服务器而不会增加LVS路由器的负担，以将输出数据包从真实服务器路由到客户端，这可能成为网络负载过重的瓶颈。</p>
<h2 id="直接路由的ARP限制"><a href="#直接路由的ARP限制" class="headerlink" title="直接路由的ARP限制"></a>直接路由的ARP限制</h2><p>似然子啊Load Balancer中使用直接路由有许多优点，但也存在限制，Load Balancer通过直接路由的最常见问题是ARP。</p>
<p>典型情况下，Internet上的客户端向IP地址发送请求。网络路由器通常通过使用ARP将IP地址与机器的MAC地址相关联来向其目的地发送请求。ARP请求被广播到网络上的所有连接的机器，具有正确的IP/MAC地址组合的机器接受该数据包。IP/MAC关联存储在ARP缓存中，该缓存会定期清除并重新填充IP/MAC关联。</p>
<p>直接路由Load Balancer设置中的ARP请求问题是，因为客户端对IP地址的请求必须与要处理的请求的MAC地址相关联，所以LoadBalancer系统的虚拟IP地址也必须与MAC也是如此。但是，由于LVS路由器的真实服务器都具有相同的VIP，因此ARP请求将被广播到与 VIP相关联的所有机器。这将导致一些问题，例如VIP直接与其中一个真实服务器关联并处理请求，完全绕过LVS路由并且无法实现LoadBalancer的目的。</p>
<p>要解决此问题。请确保始终将传入请求发送到LVS路由器而不是其中的一个真实服务器。这可以通过过滤ARP请求或过滤IP数据包来完成。可以使用<code>arptables</code>完成ARP过滤，并且可以使用<code>iptables</code>或<code>firewalld</code>实现IP数据包的过滤。</p>
<p>这两种方法不同之处在于：</p>
<ul>
<li>ARP过滤方法阻止到达真实服务器的请求。这可以防止ARP将VIP与真实服务器关联，从而使活动虚拟服务器以MAC地址进行相应。</li>
<li>IP包过滤方法允许将包路由到具有其他IP地址的真实服务器上。这完全避免了ARP问题。</li>
</ul>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>Route</tag>
      </tags>
  </entry>
  <entry>
    <title>直接使用路由的负载均衡</title>
    <url>/2018/12/07/LB/Load-balancing-using-routing-directly/</url>
    <content><![CDATA[<p>直接路由允许真实的服务器直接处理和路由数据包到请求用户，而不是通过LVS路由器传递传出数据包。直接路由器要求真实服务器通过LVS路由器物理连接到网段，并且能够处理和定向传输数据包。</p>
<p><strong>网络布局</strong></p>
<p>​    在直接路由器负载均衡配置中，LVS路由器需要接收传入请求并将它们路由到适当的真实服务器以进行处理。然后真正的服务器需要直接将相应路由到客户端。因此，例如，如果客户端在Internet上，并通过LVS路由将数据包发送到真实服务器，则真实服务器必须能够通过Internet直接连接到客户端。这可以通过为真实服务器配置网关以将数据包传递到Internet来完成。服务器池中的每个真实服务器都可以拥有自己独立的网关（并且每个网关都是有自己的Internet），对与典型的LoadBalancer设置，真实服务器可以通过一个网关进行通信。</p>
<a id="more"></a>
<h1 id="使用arptables进行直接路由"><a href="#使用arptables进行直接路由" class="headerlink" title="使用arptables进行直接路由"></a>使用arptables进行直接路由</h1><p>为了使用<code>arptables</code>配置直接路由，每个真实服务器必须配置其虚拟ip地址，以便他们可以直接路由数据包。真实服务器完全忽略对VIP的ARP请求，并且可能以其他方式发送包含VIP的任何ARP数据包破坏以包含真实服务器的IP而不是VIP。</p>
<p>使用<code>arptables</code>，应用程序可以绑定到真实服务器正在服务的每个单独的VIP端口。例如<code>arptables</code>允许多个HTTP Server实例运行并明确绑定到系统上的不同VIP。</p>
<p>要配置每个真实服务器可以忽略每个虚拟IP地址的ARP请求，执行以下步骤：</p>
<ol>
<li><p>为每个真实服务器上的每个虚拟IP地址创建ARP表条目（real_ip是导向器用来与真实服务器通信的IP；通常这是绑定到<code>eth0</code>的IP）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arptables -A IN -d &lt;virtual_ip&gt; -j DROP</span><br><span class="line">arptables -A OUT -s &lt;virtual_ip&gt; -j mangle --mangle-ip -s &lt;real_ip&gt;</span><br></pre></td></tr></table></figure>
<p>这将导致真实服务器忽略对虚拟IP地址的所有ARP请求，并更改可能包含虚拟IP的任何传出ARP响应，以便他们包含服务器的真实IP。应响应任何VIP的ARP请求的唯一节点是当前活动的LVS节点。</p>
</li>
<li><p>在每个真实服务器上完成此操作后，通过在每个真实服务器上键入以下命令来保存ARP表条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arptables-save &gt; /etc/sysconfig/arptables</span><br><span class="line">systemctl <span class="built_in">enable</span> arptables.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>ip addr</code>创建IP别名在所有真实服务器上配置虚拟IP地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr add 192.168.76.24 dev eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Keepalived以进行直接路由。通过配置<code>keepalived.conf</code>；来完成。</p>
</li>
</ol>
<h1 id="使用firewalld直接路由"><a href="#使用firewalld直接路由" class="headerlink" title="使用firewalld直接路由"></a>使用firewalld直接路由</h1><p>可以使用<code>firewalld</code>创建防火墙规则来避免ARP问题。要配置直接路由，请添加创建透明代理的规则，以便真实服务器将为发送到VIP地址的数据包提供服务，即使系统上不存在VIP也是如此。</p>
<p>这种方法比<code>arptables</code>更简单。此方法还完全绕过LVS ARP问题，因为虚拟IP地址仅存在于活动LVS控制器上。</p>
<p>但是，相比<code>arptables</code>，使用直接路由方法存在性能问题，因为在转发中存在开销，比如IP伪装，每个返回数据包。</p>
<p>也无法直接路重用端口。例如，无法运行绑定到80端口的两个单独HTTP Server服务。因为两者必须绑定到<code>INADDR_ANY</code>而不是虚拟IP地址。</p>
<p>要使用<code>firewalld</code>配置直接路由，执行以下步骤：</p>
<ol>
<li><p>为从LVS接收数据包的网络接口区域启用IP伪装。例如，对于<code>external</code>区域：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=external --add-masquerade --permanent</span><br></pre></td></tr></table></figure>
<p>如果省略<code>zone</code>，则使用默认区域。<code>--permanent</code>选项使设置保持不变，但该命令在下次启动时生效。立即生效，请加<code>--permanent</code>参数。</p>
</li>
<li><p>对于要由真实服务器提供服务的每个VIP，端口和协议（TCP或UDP）组合，请按照以下格式输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=zone --add-forward-port=port=port_number:proto=protocol:toport=port_number:toaddr=virtual_IP_address</span><br></pre></td></tr></table></figure>
<p>例如，要将<code>TCP</code>端口80上的流量配置为重定向到端口3753，请执行以下操作<code>192.168.10.10</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=external --add-forward-port=port=80:proto=tcp:toport=3753:toaddr=192.168.10.10 --permanent</span><br></pre></td></tr></table></figure>
<p>此命令将真实服务器处理发往他们的VIP端口的数据包。</p>
</li>
<li><p>确保firewald运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld &amp;&amp; systemctl start firewalld</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用iptables直接路由"><a href="#使用iptables直接路由" class="headerlink" title="使用iptables直接路由"></a>使用iptables直接路由</h1><p>也可以通过创建<code>iptables</code>规则解决ARP问题。要使用<code>iptables</code>配置直接路由，必须添加创建透明代理的规则，以便真实服务器将服务发送到VIP地址的数据包，即使系统上不存在VIP地址。</p>
<p>要使用该<code>iptables</code>方法配置直接路由，请执行以下步骤：</p>
<ol>
<li><p>在每个真实服务器上，要为真实服务器提供服务的每个VIP，端口和协议组合输入一下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTE -p &lt;tcp|udp&gt; -d &lt;vip&gt; --dport &lt;port&gt; -j REDIRECT</span><br></pre></td></tr></table></figure>
<p>此命令将使真实服务器处理发往它们的VIP和端口的数据包。</p>
</li>
<li><p>在每个真实服务器上保存配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/syconfig/iptables</span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="使用sysctl直接路由"><a href="#使用sysctl直接路由" class="headerlink" title="使用sysctl直接路由"></a>使用sysctl直接路由</h1><p>采用直接路由时处理ARP限制的另一种方法是使用<code>sysctl</code>。可以配置两个<code>sysctl</code>设置，使真实服务器不会再ARP请求中宣布VIP，也不会回复VIP请求的VIP地址。要启用此功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/conf/eth0/arp_ignore</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/conf/eth0/arp_announce</span><br></pre></td></tr></table></figure>
<p>或者，将下面内容添加到<code>/etc/sysctl.d/arp.conf</code>文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.conf.eth0.arp_ignore = 1</span><br><span class="line">net.ipv4.conf.eth0.arp_announce = 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>Route</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Keepalived进行初始负载均衡器配置</title>
    <url>/2018/12/07/LB/Use-Keepalived-for-initial-load-balancer-configuration/</url>
    <content><![CDATA[<p>安装LoadBalancer软件包后，必须采取一些基本步骤来设置LVS路由器和用于Keepalived的真实服务器。<br><a id="more"></a></p>
<h1 id="基本Keepalived配置"><a href="#基本Keepalived配置" class="headerlink" title="基本Keepalived配置"></a>基本Keepalived配置</h1><p>在基本配置示例中，两个系统配置负载均衡。LB1（活动）和LB2（备份）将路由请求四个Web服务器池，这些HTTP服务器使用真实的IP地址运行，IP为<code>192.168.1.20-192.168.1.24</code>，共享虚拟Ip地址<code>10.0.0.1</code>。每个负载均衡都有两个接口（<code>eth0和eth1</code>）一个用于处理外部流量，另一个用于将请求路由到真实服务器。使用的负载均衡算法是Round Robin，路由方法是Network Address Translation。</p>
<h2 id="创建Keepalived-conf文件"><a href="#创建Keepalived-conf文件" class="headerlink" title="创建Keepalived.conf文件"></a>创建Keepalived.conf文件</h2><p>Keepalived通过配置<code>keepalived.conf</code>为负载均衡器进行配置。要创建负载均衡，请在活动和备份负载均衡LB1和LB2中编辑<code>Keepalived.conf</code>文件。</p>
<h3 id="全局定义"><a href="#全局定义" class="headerlink" title="全局定义"></a>全局定义</h3><p>全局定义部分允许管理员在发生负载均衡器更改时指定通知详细信息。全局配置定义是可选的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">        admin@example.com</span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from noreplay@example.com</span><br><span class="line">    smtp_server 127.0.0.1</span><br><span class="line">    smtp_connect_timeout 60</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notification_email</code>是负载均衡器的管理员、<code>notification_email_from</code>是发送负载均衡器状态更改的地址、<code>SMTP</code>指邮件服务器。</p>
<h3 id="VRRP实例"><a href="#VRRP实例" class="headerlink" title="VRRP实例"></a>VRRP实例</h3><p>以下是LB1（主）中在<code>keepalived.conf</code>中<code>vrrp_sync_group</code>段的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_sync_group VG1 &#123;</span><br><span class="line">    group &#123;</span><br><span class="line">        RH_EXT</span><br><span class="line">        RH_INT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance RH_EXT &#123;</span><br><span class="line">    state MASTET</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_route_id 50</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PAAS</span><br><span class="line">        auth_pass passw123</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.0.0.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance RH_INT &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth1</span><br><span class="line">    virtual_route_id 2</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PAAS</span><br><span class="line">        auth_pass passw123</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LB2（备份路由）<code>keepalived.conf</code>中<code>vrrp_sync_group</code>段配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vrrp_sync_group VG1 &#123;</span><br><span class="line">    group &#123;</span><br><span class="line">        RH_EXT</span><br><span class="line">        RH_INT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance RH_EXT &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 50</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PAAS</span><br><span class="line">        auth_pass passw123</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些示例中，<code>vrrp_sync_group</code>定义了通过任何状态更改（例如故障转移）保持在一起的VRRP组。为外部接口定义了一个与Internet通信（RH_EXT），以及用于内部接口（RH_INT）的实例。</p>
<p><code>vrrp_instance</code>详细说明了VRRP服务守护进程的虚拟接口配置，守护进程创建虚拟IP实例。<code>state MASTER</code>指定活动服务器，<code>state BACKUP</code>指定备份服务器。</p>
<p><code>interface</code>参数将物理接口名称分配给此特定虚拟IP实例。</p>
<p><code>virtual_route_id</code>是虚拟路由器实例的数字标识符。在参与此虚拟路由器的所有LVS路由器系统上必须相同。它用于区分<code>keepalived</code>在同一网络接口上运行的多个实例。</p>
<p><code>priority</code>所述分配分配界面接管在故障转移的顺序；数字越大，优先级越高。此优先级值在0到255的范围内，并且<code>state</code>配置为<code>MASTER</code>的优先级应设置为高于<code>state</code>配置为<code>BACKUP</code>的服务器 。</p>
<p><code>authentication</code>指定于对服务器进行身份验证以进行故障转移同步身份验证类型（<code>auth_type</code>）和密码(<code>auth_pass</code>)。<code>PAAS</code>指定密码认证；Keepalived还支持<code>AH</code>或验证标头以及实现连接完整性。</p>
<p>最后，该<code>virtual_ipaddress</code>选项指定接口虚拟IP地址。</p>
<h3 id="虚拟服务器定义"><a href="#虚拟服务器定义" class="headerlink" title="虚拟服务器定义"></a>虚拟服务器定义</h3><p>LB1和LB2上的<code>keepalived.conf</code>中文件的虚拟服务器定义部分相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtual_server 10.0.0.1 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.1.20 80 &#123;</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">                connect_timeout 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.1.21 80 &#123;</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">                connect_timeout 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.1.22 80 &#123;</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">                connect_timeout 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.1.23 80 &#123;</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">                connect_timeout 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此块中，<code>virtual_server</code>首先使用IP地址配置。然后<code>delay_loop</code>配置运行状况检查之间的时间量（以秒为单位）。<code>lb_algo</code>选项指定用于可用性的算法类型（在本例中，<code>rr</code>对于Round-Robin。<code>lb_kind</code>选项确定路由方法，在这种情况下使用网络地址转换（或<code>nat</code>）。</p>
<p>配置虚拟服务器详细信息后<code>real_server</code>，再次通过首先指定IP地址来配置选项。该<code>TCP_CHECK</code>节使用TCP检查真实服务器的可用性。<code>connect_timeout</code>配置发生超时之前的秒数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算法名称</th>
<th><code>lv_algo</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>轮循</td>
<td><code>rr</code></td>
</tr>
<tr>
<td>加权循环法</td>
<td><code>wrr</code></td>
</tr>
<tr>
<td>最小连接</td>
<td><code>lc</code></td>
</tr>
<tr>
<td>加权最小连接</td>
<td><code>wlc</code></td>
</tr>
<tr>
<td>基于位置的最小连接</td>
<td><code>lblc</code></td>
</tr>
<tr>
<td>具有复制的基于位置的最小连接调度</td>
<td><code>lblcr</code></td>
</tr>
<tr>
<td>目的地哈希</td>
<td><code>dh</code></td>
</tr>
<tr>
<td>来源哈希</td>
<td><code>sh</code></td>
</tr>
<tr>
<td>来源预期延迟</td>
<td><code>sed</code></td>
</tr>
<tr>
<td>从不排队</td>
<td><code>nq</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>KEEPALIVED</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived调度</title>
    <url>/2018/12/05/LB/Keepalived-scheduling/</url>
    <content><![CDATA[<p>使用Keepalived为在真实服务器之间分配流量提供了灵活性，原因在于支持的各种调度算法。负载平衡优于不太灵活的方法，例如Round-Round DNS，其中DNS的分层特性和客户端机器高速缓存可能导致负载不平衡。另外LVS路由器采用的地基过滤具有优于应用级请求转发的优点，因为在网络分组级平衡负载导致最小的计算开销并且允许更大的可拓展性。</p>
<p>使用分配的权重为各个机器提供任意优先级。使用这种形式的调度，可以使用各种硬件和软件组合创建一组真实服务器，并且活动路由器可以均匀地分配的每个真实服务器。</p>
<p>Keepalived的调度机制由<code>IPVS</code>内核模块和一些补丁集合提供，这些模块支持L4传输层交换，旨在与单一IP地址上的多个服务器配合使用。</p>
<p>为了有效的跟踪和路由数据包到真实服务器，IPVS在内核汇总构建了一个IPVS表。主LVS路由使用此表将请求从虚拟服务器地址重定向到真实服务器并返回。<br><a id="more"></a></p>
<h1 id="Keepalived调度算法"><a href="#Keepalived调度算法" class="headerlink" title="Keepalived调度算法"></a>Keepalived调度算法</h1><p>IPVS表采用的结构取决于管理员为任何给定虚拟服务器选择的调度算法。为了使您集群的扶额类型以及如何调度这些服务具有最大的灵活性，Keepalived支持下面列出的调度算法。</p>
<p><em>循环调度</em></p>
<p>按顺序在真实服务器池周围分配每个请求。使用此算法，所有的真实服务器都被视为平等，而不考虑负载。此调度算法类似循环dns，但由于是基于网络连接而不是基于主机，因此更加精细。负载均衡循环调度也不会遭受缓存的DNS查询导致的不平衡。</p>
<p><em>加权循环调度</em></p>
<p>按顺序在真实服务器周围分配每个请求，但为容量更大的服务器提供更多作业。容量由用户指定的权重银子指示，然后通过动态负载信息向上或向下调整。</p>
<p>如果池中真实服务器的容量存在显著差异，则加权循环调度是首选的。但是，如果请求负载变换很大，则加权较多的服务器可能会回答超过请求的份额。</p>
<p><em>最小连接</em></p>
<p>将更多请求分发给具有较少活动连接的真实服务器。因为它通过IPVS表跟踪到真实服务器的实时连接，所以最少连接时一种动态调度算法，如果请求负载存在高度变化，则它使最好的选择。它最适合于每个成员节点具有大致相同容量的真实服务器池。如果一组服务器具有不同的功能，则加权最小连接调度是更好的选择。</p>
<p><em>加权最小连接</em></p>
<p>将更多请求分发给相对其容量具有较少活动连接的服务器。容量由用户指定的权重指示，然后通过动态负载信息向上或向下调整。当真是服务器池包含不同容量服务器的硬件时，加权使得该算法成为理想选择。</p>
<p><em>基于位置的最小连接调度</em></p>
<p>将更多请求分发给相对于其目标IP具有较少活动连接的服务器。此算法旨在用于代理缓存服务器集群。它将IP地址的数据包路由到该地址的服务器吗，除非该服务器高于其容量且服务器处于半负载状态，在这种情况下，它将IP地址分配给负载最小的真实服务器。</p>
<p><em>基于位置的最小连接调度与复制调度</em></p>
<p>将更多请求分发给相对于其目标IP具有叫较少活动连接的服务器。此算法还设计用于代理缓存服务器集群。它通过将目标IP地址映射到真实服务器节点的子集而与基于位置的最小连接调度不同。然后将请求路由到此子集中具有最少连接数的服务器。如果目标IP的所有节点都高于容量，则通过将来自整个真实服务器池的连接最少的真实服务器添加到该目标IP的真实服务器子集，来复制该目标IP地址的新服务器。然后从真实服务器子集中删除负载最多的节点以防止过度复制。</p>
<p><em>目标哈希调度</em></p>
<p>通过在静态哈希表中查找目标IP，将请求分发到真实服务器池。次算法旨在用于代理缓存服务器集群。</p>
<p><em>源哈希调度</em></p>
<p>通过在静态哈希表中查找源IP，将请求分发到真实服务器池。该算法适用于具有多个防火墙的LVS路由器。</p>
<p><em>最短预期延迟</em></p>
<p>根据给定服务器上的连接数除以其分配的权重，将连接请求分配给服务器，该服务器具有预期的最短延迟。</p>
<p><em>从不排队</em></p>
<p>双管齐下的调度程序，首选查找并向空闲或无连接的服务器发送连接请求。如果没有空闲度武器，则调度程序默认使用与<em>最短预期延迟</em>相同的延迟最少的服务器。</p>
<h2 id="服务器权重和调度"><a href="#服务器权重和调度" class="headerlink" title="服务器权重和调度"></a>服务器权重和调度</h2><p>LoadBalancer的管理员可以为实际服务器池中的每个节点分配<em>权重</em>。权重是一个整数值，它被考虑到任何<em>权重感知</em>调度算法（例如加权最小连接）中，并帮助LVS路由器更均匀地加载具有不同功能的硬件。</p>
<p>权重相对于彼此的比率作用。例如，如果一个真实服务器的权重为1而另一个服务器的权重为5，那么权重为5的服务器将获得另一份服务器连接的五倍。</p>
<p>实际服务器权重的默认值为1。</p>
<p>虽然增加实际服务器池中的不同硬件配置的权重可以更有效地对集群进行负载平衡，但是当真实服务器引入真实服务器池并且使用加权最小连接调度虚拟服务器时，它可能导致临时不平衡。 </p>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>KEEPALIVED</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived直接路由配置</title>
    <url>/2018/12/04/LB/Keepalived-direct-routing/</url>
    <content><![CDATA[<p>Keepalived的直接路由配置与NAT配置类似。在以下示例中，Keepalived配置为在80端口上为一组运行HTTP的真实服务器提供负载均衡。要配置直接路由，将<code>lb_kind</code>参数更改为<code>DR</code>。</p>
<p>以下示例显示使用直接路由的Keepalived配置活动服务器的<code>keepalived.conf</code>配置文件。<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    notification_email &#123;</span><br><span class="line">      admin@example.com</span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from noreply_admin@example.com</span><br><span class="line">    smtp_server 127.0.0.1</span><br><span class="line">    smtp_connect_timeout 60   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance RH_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 50</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PAAS</span><br><span class="line">        auth_paas paasw123</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.32.0.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 172.31.0.1 80</span><br><span class="line">	delay_loop 10</span><br><span class="line">	lb_algo rr</span><br><span class="line">	lb_kind DR</span><br><span class="line">	persistence_timeout 9600</span><br><span class="line">	protocol TCP</span><br><span class="line">	</span><br><span class="line">	real_srrver 192.168.0.1 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port	80</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	real_server 192.168.0.2 80 &#123;</span><br><span class="line">        werght 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port	80</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	real_server 192,168.0.3 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port	80</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下示例显示直接路由的Keepalived配置中备份服务器的<code>keepalived.conf</code>文件。状态和优先级值与活动服务器不同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     admin@example.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from noreply_admin@example.com</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance RH_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 50</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass passw123</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.31.0.1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 172.31.0.1 80</span><br><span class="line">    delay_loop 10</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 9600</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.0.1 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port    80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.0.2 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port    80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    real_server 192.168.0.3 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">          connect_timeout 10</span><br><span class="line">          connect_port    80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>KEEPALIVED</tag>
      </tags>
  </entry>
  <entry>
    <title>KEEPALIVED概述</title>
    <url>/2018/12/03/LB/Keepalived-introduction/</url>
    <content><![CDATA[<p>Keepalived在活动的LVS路由以及一个或多个可选的备用LVS路由上运行。主动LVS路由上有两个作用：</p>
<ul>
<li>平衡真是服务器上的负载。</li>
<li>检查每个真是服务的完整性。</li>
</ul>
<p>活动（主）路由器使用<em>虚拟路由冗余协议（VRRP）</em>通知备用路由器其活动状态，协议要求主动路由器定期发送advertisements报文。如果活动路由器停止发送advertisements报文，则选择新的主节点。</p>
<a id="more"></a>
<h1 id="基本的Keepalived负载均衡器配置"><a href="#基本的Keepalived负载均衡器配置" class="headerlink" title="基本的Keepalived负载均衡器配置"></a>基本的Keepalived负载均衡器配置</h1><p>下图显示了一个由两层组成的简单的Keepalived负载均衡器配置，在第一层是一个活动和几个备用LVS路由器。每个LVS路由器都有两个网络接口，一个在Internet上，一个在专用网络上，使他们能够调节两个网络之间的流量。对于此示例，活动路由器正在使用网络地址转换（NAT）将来自互联网的流量引导到第二层上的可变数量的真实服务器。这反过来又提供了必要的服务。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/lvs-two-tier-1.png" alt=""></p>
<p> 到达LVS路由器的服务请求被发送到虚拟IP地址（VIP）。这是一个可公开路由的地址，与FQDN关联，并分配给一个或多个虚拟服务器。虚拟服务器时配置为监听特定虚拟IP。在故障转移期间，VIP地址从一个LVS路由器迁移到另一个路由器，从而保持VIP地址存在。也称为浮动IP。</p>
<p>可以将VIP地址分配给LVS路由器连接到Internet的同一设备。例如，如果<code>eth0</code>连接到Internet，则可以分配给多个虚拟服务器的<code>eth0</code>。或者，每个虚拟服务器可以与每个服务的单独设备相关联。例如，HTTP流量可以在<code>eth0</code>的192.168.1.111处理，而FTP流量可以在<code>eth0</code>的192.168.1.222 处理。</p>
<p>在设计一个主路由器和一个被动路由器的部署方案中，活动路由器的角色是将服务请求从虚拟IP地址重定向到真实服务器。</p>
<p>活动路由器还通过三个内置运行状况检查动态监测真是服务器上的特定服务的整体运行状况：简单的TCP连接，HTTP和HTTPS。对于TCP连接，活动路由器将定期检查它是否可以连接到某个真实服务器上的端口。对于HTTP和HTTPS，活动路由器将定期获取真实服务器上的URL并验证内容。</p>
<p>备路由器执行备用系统的角色。路由器故障转移由VRRP处理。启动时，所有路由器都加入组播组。用于发送和接受VRRP通告。由于VRRP是基于优先级的协议，因此具有最高优先级的路由器被选为主设备。一旦路由器被选为主设备，他就负责定期向组播组发送VRRP通告。</p>
<p>如果备路由器未能在特定时间内接收通告，则将选择新的主节点。新的主服务器将接管VIP并发送地址解析协议（ARP）消息，当路由器返回活动服务时，他可能称为备服务器或主服务器。行为由路由器的优先级决定。</p>
<p>使用简单的双层配置基本最适合提供不经常跟；更改的数据-例如静态网页-因为各个真实服务器不会再每个节点之间同步数据。</p>
<h1 id="三层KEEPALIVED负载均衡器配置"><a href="#三层KEEPALIVED负载均衡器配置" class="headerlink" title="三层KEEPALIVED负载均衡器配置"></a>三层KEEPALIVED负载均衡器配置</h1><p>下图显示了典型的三层Keepalived负载均衡器拓扑。此示例中，活动LVS路由器将来自Internet的请求路由到真实服务器池。然后，每个真实服务器通过网络访问共享数据源。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/lvs-three-tier.png" alt=""></p>
<p>此配置非常适用于 繁忙的FTP服务器，其中可访问的数据存储在中央的高可用服务器上，并由每个真实服务器通过导出的NFS或Samba进行访问。对访问高度可用的事物数据库的网站，也建议此拓扑，此外如果使用LoadBalancer的主动主动配置，管理员可以配置一个高可用集群，以同时为这两个角色提供服务。</p>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>KEEPALIVED</tag>
      </tags>
  </entry>
  <entry>
    <title>HAProxy配置</title>
    <url>/2018/12/02/LB/HAProxy-configuration/</url>
    <content><![CDATA[<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><p><code>global</code>设置配置适用于运行HAProxy的所有服务器的参数。<code>global</code>部分可能如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">	<span class="built_in">log</span> 127.0.0.1 local2</span><br><span class="line">	maxconn 4000</span><br><span class="line">	user haproxy</span><br><span class="line">	group haproxy</span><br><span class="line">	daemon</span><br></pre></td></tr></table></figure>
<p>在上面的配置中，管理员已将服务配置<code>log</code>为本地<code>syslog</code>服务器的所有条目。默认情况下，这可能是<code>/var/log/syslog</code>或某些指定的位置。</p>
<p><code>maxconn</code>参数指定服务器的最大并发连接数。默认情况下，最大值为2000。</p>
<p><code>user</code>和<code>group</code>参数指定<code>haproxy</code>进程所属的用户名和租名。</p>
<p>最后<code>daemon</code>参数指定<code>haproxy</code>作为后台进程运行。<br><a id="more"></a></p>
<h1 id="默认设置"><a href="#默认设置" class="headerlink" title="默认设置"></a>默认设置</h1><p><code>default</code>设置配置适用于所有代理子节的配置参数（<code>frontend</code>,<code>backend</code>,<code>listen</code>）。配置如下所示：</p>
<blockquote>
<p>proxy 子节（<em>frontend</em>，<em>backend</em>，<em>listen</em>）中配置任何参数都优先于<code>default</code>中的参数值。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults</span><br><span class="line">	mode					http</span><br><span class="line">	<span class="built_in">log</span>						global</span><br><span class="line">	option					httplog</span><br><span class="line">	option					dontlognull</span><br><span class="line">	retries					3</span><br><span class="line">	timeout http-request	10s</span><br><span class="line">	timeout queue			1m</span><br><span class="line">	timeout connect			10s</span><br><span class="line">	timeout client			1m</span><br><span class="line">	timeout server			1m</span><br></pre></td></tr></table></figure>
<p><code>mode</code>指定HAProxy实例的协议。使用<code>http</code>模式将源请求连接到基于HTTP的真实服务器，非常适合Web服务器负载均衡。对于其他程序，请使用<code>tcp</code>模式。</p>
<p><code>log</code>指定日志条目的日志地址和<code>syslog</code>工具。HAProxy将全局配置中的log参数引用。</p>
<p><code>option httplog</code>允许记录HTTP会话，包括HTTP请求，会话状态，连接号，原地址和连接计数器以及其他值。</p>
<p><code>option httplognull</code>禁用空连接的记录，这意味着HAProxy不会记录没有传输数据的连接。建议不要讲此类环境用于Internet上的web应用程序，其中空连接可能表示恶意活动，例如漏洞的开放端口扫描。<code>retries</code>指定真实服务器在第一次尝试连接失败后重试连接情趣的次数。</p>
<p><code>timeout</code>指定请求连接或相应的不活动时间长度。这些值通常以毫秒为单位，但可以通过以任何单位表示，支持的单位是<code>us</code>（微秒），<code>ms</code>（毫秒），<code>s</code>（秒），<code>m</code>（分钟），<code>h</code>（小时），<code>d</code>（天）。</p>
<p><code>http-request 10s</code>等待来自客户端的完整HTTP请求10秒。<code>quue 1m</code>将一分钟设置为连接断开之前等待的时间，并且客户端收到<code>503</code>错误。<code>connect 10s</code>指定等待成功连接到服务器的秒数。<code>client 1m</code>指定客户单可以保持非活动状态的时间量。<code>server 1m</code>指定服务器在超时发生之前接受或发送数据的时间。</p>
<h1 id="前端设置"><a href="#前端设置" class="headerlink" title="前端设置"></a>前端设置</h1><p>这些<code>frontend</code>设置为服务器的监听套接字配置客户端连接请求。HAProxy配置<code>frontend</code>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frontend main</span><br><span class="line">  <span class="built_in">bind</span> 192.168.0.10:80</span><br><span class="line">  default_backend app</span><br></pre></td></tr></table></figure>
<p>在<code>frontend</code>的<code>main</code>配置为<code>192.168.0.10</code>的IP地址，并使用<code>bind</code>参数指定监听80端口。连接后，使用<code>backend</code>指定所有会话连接到<code>app</code>后端。</p>
<h1 id="后端设置"><a href="#后端设置" class="headerlink" title="后端设置"></a>后端设置</h1><p>在<code>backend</code>设置中指定真实服务器的IP地址以及负载均衡调度算法。<code>backend</code>部分如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backend app</span><br><span class="line">	balance		roundrobin</span><br><span class="line">	server	app1	192.168.1.1:80 check</span><br><span class="line">	server  app2	192.168.1.2:80 check</span><br><span class="line">	server  app3    192.168.1.3:80 check inter 2s rise 4 fall 3</span><br><span class="line">	server 	app4	192.168.1.4:80 backup</span><br></pre></td></tr></table></figure>
<p>后端服务器已命名<em>app</em>。在<em>balance</em>指定要使用的负载均衡的调度算法，在这种情况下是循环（<em>roundrobin</em>），但也可以是通过HAProxy的支持的任何调度。</p>
<p>这些<em>server</em>行指定后端可用的服务器。<em>app1</em>to <em>app4</em>是每个真实服务器内部分配的名称。日志文件将按名称指定服务器消息。地址是分配的IP地址。IP地址中冒号后面的值是特定服务器上连接发生的端口号。该<em>check</em>选项标记服务器以进行定期运行状况检查，以确保它可用并能够接收和发送数据并获取会话请求。服务器app3还将运行状况检查间隔配置为两秒（<em>inter 2s</em>），app3必须通过的检查量以确定服务器是否被视为正常（<em>rise 4</em>），以及服务器在被视为失败之前连续未通过检查的次数（<em>fall 3</em>） 。</p>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>HAProxy</tag>
      </tags>
  </entry>
  <entry>
    <title>鄙视链</title>
    <url>/2018/12/01/Despise-chain-finishing/</url>
    <content><![CDATA[<h1 id="必须要这么分："><a href="#必须要这么分：" class="headerlink" title="必须要这么分："></a><strong>必须要这么分：</strong></h1><p>每类人群，一般是后者瞧不起前者。</p>
<h1 id="首先，你得按照学历来分"><a href="#首先，你得按照学历来分" class="headerlink" title="首先，你得按照学历来分"></a>首先，你得按照学历来分</h1><ul>
<li>- 胎教程序员</li>
<li>- 学前班程序员</li>
<li>- 大班程序员</li>
<li>- 小学程序员</li>
<li>- 普通初中程序员</li>
<li>- 重点初中程序员</li>
<li>- 普通高中程序员</li>
<li>- 重点高中程序员</li>
<li>- 专科程序员</li>
<li>- 普通本科程序员</li>
<li>- 重点本科程序员</li>
</ul>
<h1 id="当然，你最好加上专业来区分"><a href="#当然，你最好加上专业来区分" class="headerlink" title="当然，你最好加上专业来区分"></a>当然，你最好加上专业来区分</h1><a id="more"></a>
<ul>
<li>- 艺术转过来的程序员</li>
<li>- 文科转过来的程序员</li>
<li>- 社科转过来的程序员</li>
<li>- 理科转过来的程序员</li>
<li>- 非科班的工科转过来的程序员</li>
<li>- 法学转过来的程序员</li>
<li>- 商科转过来的程序员</li>
<li>- 科班程序员</li>
</ul>
<h1 id="其次，你得按照家庭情况来分"><a href="#其次，你得按照家庭情况来分" class="headerlink" title="其次，你得按照家庭情况来分"></a>其次，你得按照家庭情况来分</h1><ul>
<li>- 农村背景</li>
<li>- 四线城市背景</li>
<li>- 三线城市背景</li>
<li>- 二线城市背景</li>
<li>- 一线城市背景</li>
</ul>
<h1 id="然后，你得按照方向来分，"><a href="#然后，你得按照方向来分，" class="headerlink" title="然后，你得按照方向来分，"></a>然后，你得按照方向来分，</h1><ul>
<li>- PC 端工程师</li>
<li>- 安卓工程师</li>
<li>- IOS 工程师</li>
<li>- 运维工程师</li>
<li>- 网络工程师</li>
<li>- 前端工程师</li>
<li>- 后端工程师</li>
<li>- 系统工程师</li>
</ul>
<h1 id="接着，你得按照开发语言来分"><a href="#接着，你得按照开发语言来分" class="headerlink" title="接着，你得按照开发语言来分"></a>接着，你得按照开发语言来分</h1><ul>
<li>- Java 程序员</li>
<li>- C# 程序员</li>
<li>- Python 程序员</li>
<li>- Rust 程序员</li>
<li>- Go 程序员</li>
<li>- Markdown 程序员</li>
<li>- PHP 程序员</li>
<li>- PPT 架构师</li>
</ul>
<h1 id="最后，你得按照有没有对象来分"><a href="#最后，你得按照有没有对象来分" class="headerlink" title="最后，你得按照有没有对象来分"></a>最后，你得按照有没有对象来分</h1><ul>
<li>- 没有对象强行面向对象开发工程师</li>
<li>- 没有对象强行过程式开发工程师</li>
<li>- 没有对象强行函数式开发工程师</li>
<li>- 有对象并且面向对象开发工程师</li>
</ul>
<p>好，大家现在可以开始互相鄙视了，我去写会 Python 。</p>
<blockquote>
<p>那么问题来了, <strong>为什么PHP瞧不起其他语言?</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>鄙视链</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算网络</title>
    <url>/2018/12/01/Networking/Cloud-computing-network/</url>
    <content><![CDATA[<h1 id="物理机-gt-虚拟机"><a href="#物理机-gt-虚拟机" class="headerlink" title="物理机 -&gt; 虚拟机"></a>物理机 -&gt; 虚拟机</h1><p>所谓云计算，其实就是基于虚拟化产生的一种消费方式，可以这样一句话概括：</p>
<blockquote>
<p>N个物理区域中，分别运行着M * N个节点的虚拟化节点，由这些节点组成了一个或多个虚拟化集群，在这个集群上运行着N多个虚拟机实例，向互联网上的消费者提供虚拟机实例以供计算，这就是公有云；自建自用，就是私有云；自建了还额花钱买了其他运营商提供的计算虚拟机实例，就是混合云（这里仅仅说的是计算资源，其他存储或网络资源同理）。</p>
</blockquote>
<p>当然，如果你可以编排物理机，也是可以成为云计算的。（物理机好比拿地盖房子，虚拟机好比购买公寓）</p>
<p>如果你不知道虚拟化是什么，这样你下一个<code>virtualbox</code>安装体验一下，虚拟化软件就像你去电脑城买笔记本，你可以跟虚拟化软件说，我要几颗CPU，多大内存，多大硬盘，什么网卡（前提你有）。用的时候你一创建，不玩了你点删除，就没了。</p>
<p>生产环境，主流的虚拟化主要是这几种：VMware、Xen、KVM等。</p>
<p>这里说qemu-kvm，从名字上来看，<code>emu</code>就是<code>Emulator</code>(模拟器)，主要模拟CPU、RAM（内存）、网络、硬盘，使得虚拟机感觉自己在使用独立的硬件资源，但真正使用的时候，肯定是要用物理设备的。</p>
<p>例如，多个虚拟机轮流使用物理CPU（这个具体可以google一下），内存是使用虚拟内存映射的方式，最终映射到物理内存上。硬盘简单一些，你笔记本有500GB，新建一个20GB空文件（当然，要根据要求的格式创建），这就是你虚拟机的磁盘。</p>
<p>虚拟化软件是什么？骗子，向上骗虚拟机里面的应用，让他们感觉自己是在用真实的硬件资源，其实自己啥也没有，全部向下从物理机里面取。<br><a id="more"></a></p>
<h1 id="虚拟网卡原理"><a href="#虚拟网卡原理" class="headerlink" title="虚拟网卡原理"></a>虚拟网卡原理</h1><p>如何将虚拟机网络和物理网络连接呢?</p>
<p>首先，虚拟机要有网卡，对于qemu-kvm来说，是通过TUN/TAP实现的。</p>
<p>虚拟机时物理机上跑的一个软件或进程，这个进程可以像其他程序打开文件一样，打开一个称为TUN/TAP的<code>Char Dev</code>(字符设备文件)。打开了这个字符设备文件之后，在物理机就能看到一张TAP网卡。</p>
<p>虚拟化既然是骗子，会将打开的这个文件，虚拟化成网卡，拿给虚拟机，虚拟机就将网络流量发往这个“网卡”。</p>
<p>虚拟机的网络流量会到骗子这里，骗子将网络包转换成文件流，写入字符设备，就像写文件一样，内核中的TUN/TAP字符设备会收到这个写入的文件流，交给TUN/TAP的虚拟网卡驱动，这个驱动将文件流转换成网络包，交给TCP/IP协议栈，最终从虚拟TAP网卡发出来，变成标准的网络包。</p>
<p>骗来骗去，转来转去，数据从虚拟机发到了虚拟机外面。</p>
<h1 id="虚拟网卡怎么连接呢"><a href="#虚拟网卡怎么连接呢" class="headerlink" title="虚拟网卡怎么连接呢"></a>虚拟网卡怎么连接呢</h1><p>有了虚拟TAP网卡。如何接入真实网络呢，这种网络需要注意哪些：</p>
<ul>
<li><strong>共享</strong>： 尽管每个虚拟机都会有一个或多个虚拟网卡，但是物理机上可能只有有限的网卡。多个虚拟网卡设备如何共享一个出口呢？</li>
<li><strong>隔离</strong>： 一个是安全隔离，两个虚拟机可能属于两个用户，怎么保证用户A的数据不被用户B接收到呢；另一个隔离是流量隔离：两个虚拟机，如果一直迅雷下载，会不会影响到邻居虚拟机。</li>
<li><strong>互通</strong>：互通也是两个方面，同一宿主机上的两个虚拟机，属于同一个用户的话，如何通信；如果是不同宿主机呢？</li>
<li><strong>灵活</strong>：虚拟机和物理机不同，会经常创建、删除、迁移，互通或不同，需要能够灵活的配置。</li>
</ul>
<h2 id="共享与互通"><a href="#共享与互通" class="headerlink" title="共享与互通"></a>共享与互通</h2><p>一台物理机上有多个虚拟机，有多个虚拟网卡，这些虚拟网卡如何连接在一起，互相访问，并且连接外网？</p>
<p>在物理机上，应该有个虚拟交换机，Linux有<code>brctl</code>命令，可以创建虚拟的网桥，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brctl addbr br0</span><br></pre></td></tr></table></figure>
<p>创建网桥后，将两个虚拟机的虚拟网卡连接到网桥上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">btctl addif br0 tap0</span><br></pre></td></tr></table></figure>
<p>两台虚拟机配置为相同网段就可以互通了。</p>
<p>如何访问外网呢？有两种方式：</p>
<p>一种是桥接，桥接模式下，物理网卡也连接到这个虚拟交换机上。</p>
<p>在数据中心中，采取也是类似的隶属，只不过是Linux，每台机器都创建网桥br0，虚拟机的网卡都连接到br0,物理网卡也连接到br0上，所有的br0都通过物理网卡出来连接到物理交换机上。</p>
<p>这种方式下，不但解决了同一台机器的互通问题，也解决了跨主机通信的问题，因为都是一个二层网络，彼此用相同网段访问就可以了。不过只适合小规模。</p>
<p>二层网络最大的问题是广播，一个数据中心的物理机已经很多了，需要VLAN来解决广播风暴问题，那么就要使用另外一种方式，NAT。在这种方式下，你登录到虚拟机查看ip地址，会发现虚拟机的网络是虚拟机的，物理机的网络是物理机的，虚拟机访问物理机是需要将地址NAT为物理机的地址。</p>
<h2 id="隔离问题"><a href="#隔离问题" class="headerlink" title="隔离问题"></a>隔离问题</h2><p>互通问题解决了，如果一台机器上的两个虚拟机不属于同一个用户，当然是选择VLAN，可以设置两个虚拟机的tag。</p>
<p>但是如何跨主机通信并且实现VLAN隔离呢？（brctl的tag是无法在网桥之外起作用的）</p>
<p><code>vconfig</code>可以基于物理网卡来创建带VLAN的虚拟网卡，</p>
<p>首先为每个用户分配不同的VLAN，基于物理网卡，为每个用户创建带VLAN的网卡，不同的用户使用不同的网桥，带VLAN的虚拟网卡也连接到虚拟网桥上。</p>
<p>当然，网桥的功能相对简单，VLAN数目也是限制，不够灵活，真实生产环境几乎不会用这种方案。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>HAProxy 调度算法</title>
    <url>/2018/12/01/LB/HAProxy-scheduling-algorithm/</url>
    <content><![CDATA[<p>可以在<code>/etc/haproxy/haproxy.cfg</code>配置文件的<code>backend</code>部分的<code>balance</code>参数中编辑用于负载均衡的HAProxy调度算法。注意，HAProxy支持具有多个后端的配置，并且每个后端都可以配置调度算法。</p>
<p><strong>Round-Robin(roundrobin)</strong></p>
<p>按顺序在真实服务器池分配每个请求。使用此算法，所有真实服务器都被视为同等，而不考虑容量或负载。此调度模型类似于循环DNS，但由于它是基于网络连接而不是主机，因此更加精细。负载均衡循环调度也不会遭受DNS缓存查询导致的不平衡。但是在HAProxy中，由于服务器的权重配置可以使用此调度程序即时完成，因此活动服务器的数量限制为每个后端。<br><a id="more"></a><br><strong>静态循环（static-rr）</strong></p>
<p>像Round-Robin一样，围绕真实服务器池顺序分配每个请求，但不允许动态配置权重。但是，由于服务器权重的静态特性，后端的活动服务器数量没有限制。</p>
<p><strong>最少连接（leastconn）</strong></p>
<p>将更多请求分发给具有较少活动连接的真实服务器。具有不同会话或连接长度的动态环境的管理员可能会发现此调度程序更适合其环境。它也是一组服务器具有不同容量的环境的理想选择，因为管理员可以使用此调度程序即时调整权重。</p>
<p><strong>来源(source)</strong></p>
<p>通过散列请求源IP地址并除以所有正在运行的服务器的权重来分配对服务器的请求，以确定那个服务器将获得请求。在所有服务器都在运行的情况下，源ip请求将始终由同一个真实服务器提供服务。如果正在运行的服务器的数量或容量发生变化，则会话可能移动到另一个服务器，因为散列/权重结果已更改。</p>
<p><strong>URI（uri）</strong></p>
<p>通过散列整个URI（或URI的可配置部分）将请求分发给服务器，并除以所有正在运行的服务器的权重，以确定请求的服务器。在所有活动服务器都在运行的情况下，目标IP请求将始终由统一真实服务器提供服务。可以通过URI的目录部分的开头处的字符长度来进一步配置该调度器，以计算散列结果和URI中的目录深度（由URI中的正斜杠指定）以计算散列结果。</p>
<p><strong>网址参数（url_param）</strong></p>
<p>通过在源URL请求中查找特定参数字符串并执行哈希计算除以所有正在运行的服务器的权重，将请求分发到服务器。如果URL中缺少该参数，则调度程序默认为循环调度。可以基于POST参数以及基于管理员在计算散列结果之前为特定参数的权重分配的最大八位字节的数量来使用修饰符。</p>
<p><strong>标题名称（hdr）</strong></p>
<p>通过检查每个源HTTP请求中的特定标头名称并执行散列计算除以所有正在运行的服务器的权重，将请求分发到服务器。如果标头不存在，则调度程序默认为循环调度。</p>
<p><strong>RDP Cookie (rdp-cookie)</strong></p>
<p>通过查找每个TCP请求的RDP cookie并执行哈希计算除以所有正在运行的服务器的权重，将请求分发给服务器。如果标头不存在，则调度程序默认为循环调度。此方法非常适合持久性，因为可以保持会话完整性。</p>
]]></content>
      <categories>
        <category>LB</category>
      </categories>
      <tags>
        <tag>HAProxy</tag>
      </tags>
  </entry>
  <entry>
    <title>配置OPENSSH</title>
    <url>/2018/11/17/Linux/OPENSSH/Configure-OPENSSH/</url>
    <content><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>有两套不同的配置文件：客户端程序（ssh，scp和sftp），以及SSH服务器（sshd守护进程）。</p>
<p>系统范围的SSH配置信息存储在<code>/etc/ssh/</code>目录中，用户特定的ssh配置信息存储在<code>~/.ssh/</code>目录中。<br><a id="more"></a></p>
<blockquote>
<p>系统范围的配置文件</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/etc/ssh/moduli</code></td>
<td>包含用于Diffie-Hellman密钥交换的Diffie-Hellman组，这对用于构建安全传输层至关重要。在SSH会话开始时交换密钥时，会创建一个共享的秘密值，这个值无法由任何一方单独确定，此值用于提供主机身份验证。</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_config</code></td>
<td>默认的SSH客户端配置文件。请注意，如果<code>~/.ssh/config</code>存在，它将被覆盖。</td>
</tr>
<tr>
<td><code>/etc/ssh/sshd_config</code></td>
<td>ssd守护进程的配置文件。</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_ecdsa_key</code></td>
<td>sshd守护进程使用的ECDSA私钥。</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_ho;st_ecdsa_key.pub</code></td>
<td>sshd守护进程使用的ECDSA公钥</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_rsa_key</code></td>
<td>sshd守护进程用于使用SSH V2的RSA私钥。</td>
</tr>
<tr>
<td><code>/etc/ssh/ssh_host_rsa_key.pub</code></td>
<td>sshd守护进程用于使用SSH V2的RSA公钥。</td>
</tr>
<tr>
<td><code>/etc/pam.d/sshd</code></td>
<td>sshd守护进程的PAM配置文件。</td>
</tr>
<tr>
<td><code>/etc/sysconfig/sshd</code></td>
<td>sshd服务的配置文件。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>用户特定的配置文件</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~/.ssh/authorized_keys</code></td>
<td>保存服务器的授权公钥列表。当客户端连接到服务器时，服务器通过检查存储在此文件的以签名公钥来验证客户端。</td>
</tr>
<tr>
<td><code>~/.ssh/id_ecdsa</code></td>
<td>包含用户的ECDSA私钥。</td>
</tr>
<tr>
<td><code>~/.ssh/id_ecdsa.pub</code></td>
<td>用户的ECDSA公钥。</td>
</tr>
<tr>
<td><code>~/.ssh/id.rsa</code></td>
<td>ssh 使用的SSH V2 RSA私钥。</td>
</tr>
<tr>
<td><code>~/.ssh/id.rsa.pub</code></td>
<td>ssh 使用的SSH V2 RSA公钥。</td>
</tr>
<tr>
<td><code>~/.ssh/known_hosts</code></td>
<td>包含用户访问的SSH服务器的主机密钥。此文件对于确保ssh客户端连接到正确的SSH服务器非常重要。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="启动OpenSSH服务器"><a href="#启动OpenSSH服务器" class="headerlink" title="启动OpenSSH服务器"></a>启动OpenSSH服务器</h1><p>要运行OpenSSH服务器，必须安装<code>openssh-server</code>软件包。</p>
<p>要在当前会话中启动sshd守护进程，请在shell提示符输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service</span><br></pre></td></tr></table></figure>
<p>要在当前会话中停止正在运行的sshd守护进程，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop sshd.service</span><br></pre></td></tr></table></figure>
<p>如果希望守护进程在引导是启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sshd.service</span><br></pre></td></tr></table></figure>
<p>sshd守护进程取决于<code>network.target</code>目标单位，这是足够的静态配置的网络接口，并为默认<code>ListenAddress 0.0.0.0</code> 选项。要在<code>ListenAddress</code> 指令中指定不同的地址并使用较慢的动态网络配置，请将<code>network-online.target</code>目标单元的依赖性添加到<code>sshd.service</code>单元文件中。实现此目的，请在<code>/etc/systemd/system/sshd.service.d/local.conf</code>键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br></pre></td></tr></table></figure>
<p>之后，使用以下命令重新加载<code>systemd</code>管理器配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl deamon-reload</span><br></pre></td></tr></table></figure>
<p>请注意，如果重新安装系统，将创建一组新的标识。因此，在重新安装之前使用任何OpenSSH工具连接到系统的客户端将看到以下消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br></pre></td></tr></table></figure>
<p>为了防止这种情况，可以从；那个<code>/etc/ssh</code>目录中备份相关文件。并在重新安装系统时还原文件。</p>
<h1 id="需要SSH进行远程连接"><a href="#需要SSH进行远程连接" class="headerlink" title="需要SSH进行远程连接"></a>需要SSH进行远程连接</h1><p>要是SSH真正有效，应禁止使用不安全的连接协议，否则，用户的密码可能会在一个会话中使用SSH进行保护，只能在以后使用Telnet登录时截获。需要禁用的服务包括<code>telnet</code>,<code>rsh</code>,<code>rlogin</code>和<code>vsftpd</code>。</p>
<h1 id="使用基于密钥的身份验证"><a href="#使用基于密钥的身份验证" class="headerlink" title="使用基于密钥的身份验证"></a>使用基于密钥的身份验证</h1><p>要进一步提高系统安全性，请生成SSH密钥对，然后通过禁用密码身份验证来强制执行基于密钥的身份验证。为此，请编辑<code>/etc/ssh/sshd_config</code>然后更改<code>PaswordAuthentication</code>选项值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<p>如果你不是一个新的默认安装其他的系统上工作，检查<code>PubkeyAuthentication no</code> 是否设置，如果远程连接，不使用控制台访问，建议在禁用密码验证之间测试基于密钥的登录。</p>
<p>为了能够使用<code>ssh</code>，<code>scp</code>或<code>sftp</code>从客户端计算机连接到服务器，请按照以下步骤生成授权密钥对，请注意，必须分别为每个用户生成密钥。</p>
<p>要对安装NFS的主目录使用基于密钥的身份验证，首先设置SELinux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsebool -P use_nfs_home_dirs 1</span><br></pre></td></tr></table></figure>
<h1 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="　生成密钥对"></a>　生成密钥对</h1><p>要为SSH V2生成RSA密钥对，请按照下列步骤操作：</p>
<ol>
<li><p>通过在shell提示符下键入一下内容来生成RSA密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入<code>Enter</code>确认创建密钥的默认位置（~/.ssh/id_rsa）。</p>
</li>
<li><p>输入密码（可选），在此之后，将看到类似以下消息。、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /home/USER/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/USER/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:UNIgIT4wfhdQH/K7yqmjsbZnnyGDKiDviv492U5z78Y USER@penguin.example.com</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|o ..==o+.        |</span></span><br><span class="line"><span class="string">|.+ . .=oo        |</span></span><br><span class="line"><span class="string">| .o. ..o         |</span></span><br><span class="line"><span class="string">|  ...  ..        |</span></span><br><span class="line"><span class="string">|       .S        |</span></span><br><span class="line"><span class="string">|o .     .        |</span></span><br><span class="line"><span class="string">|o+ o .o+ ..      |</span></span><br><span class="line"><span class="string">|+.++=o*.o .E     |</span></span><br><span class="line"><span class="string">|BBBo+Bo.  oo     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，<code>~/.ssh/</code>目录的权限设置为<code>rwx------</code>或700八进制表示法表示。这是为了确保只有<em>USER</em>才能查看内容。如果需要，可以使用一下命令确认：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -ld ~/.ssh</span><br><span class="line">drwx------. 2 USER USER 54 Nov 25 16:56 /home/USER/.ssh/</span><br></pre></td></tr></table></figure>
</li>
<li><p>要将公钥复制到远程计算机，请按一下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id user@hostname</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>~/.ssh/id*.pub</code>如果尚未安装，则会复制最近修改过的公钥，或者指定公钥的文件名，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id.rsa.pub user@hostname</span><br></pre></td></tr></table></figure>
<p>这将复制 <code>~/.ssh/id_rsa.pub</code>到<code>~/.ssh/authorized_keys</code>文件到您要连接的机器上。如果文件已存在，则将键附加到其末尾。</p>
<p>要为SSH V2生成ECDSA密钥对，请按照下列步骤操作：</p>
<ol>
<li><p>通过在shell提示符下键入以下内容来生成ECDSA密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ecdsa</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="配置ssh-agent"><a href="#配置ssh-agent" class="headerlink" title="配置ssh-agent"></a>配置ssh-agent</h1><p>要存储密码，以便每次启动与远程计算机的连接时都不需要密码，这可以使用<code>ssh-agent</code>身份验证代理。</p>
<p>确保安装<code>openssh-askpass</code></p>
<p>要保存某个shell提示符的密码，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-add</span><br></pre></td></tr></table></figure>
<p>注意，注销时，密码将被遗忘，每次登陆虚拟控制台或终端窗口时都必须执行该命令。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH协议</title>
    <url>/2018/11/17/Linux/OPENSSH/SSH-protocol/</url>
    <content><![CDATA[<h1 id="为什么使用SSH"><a href="#为什么使用SSH" class="headerlink" title="为什么使用SSH"></a>为什么使用SSH</h1><p>潜在的入侵者可以使用各种工具，是他么能够中断、拦截和重新路由网络流量，从而获得对计算机系统的访问权限。一般来说，威胁可以分为以下几类：</p>
<p><strong>拦截两个系统之间的通信</strong></p>
<p>​    攻击者可以在通信方面的网络上的某个地方，复制他们之间传递的任何信息。他可以拦截并保留信息，或者更改信息并将其发送给预期的收件人。</p>
<p>​    此流量通常使用数据包嗅探器执行，数据包嗅探器是一种相当常见的网络实用程序，可捕获流经网络的每个数据包，并分析其内容。</p>
<p><strong>假冒特定主机</strong></p>
<p>​    攻击者的系统被配置被构成传输的预期接收者。如果此策略有效，则用户的系统仍然不知道它正在与错误的主机通信。</p>
<p>​    可以使用称为<em>DNS poisoning</em>的技术或通过所谓的IP欺骗来执行此攻击。在第一种情况下，入侵者使用破解的DNS服务器将客户端系统指向恶意复制的主机，在第二种情况下，入侵者发送看似来自可信主机的伪造网络数据包。</p>
<p>这两种技术都可以拦截潜在的敏感信息，如果拦截是出于敌意的原因，结果可能是灾难性的。如果使用SSH进行远程shell登录和文件复制，则可以大大减少这些安全威胁。这是因为SSH客户端和服务器使用数字签名来验证其身份。此外，客户端和服务器系统之间的所有通信都是加密的。欺骗通信双方的身份是行不通的，因为每个数据包都使用仅由本地和远程系统知道的秘钥加密。</p>
<a id="more"></a>
<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="　主要特点"></a>　主要特点</h1><p>SSH协议支持以下安全措施：</p>
<p><strong>没有人可以冒充目标服务器</strong></p>
<p>​    初始连接后，客户端可以验证它是否可以连接到之前连接的同一服务器。</p>
<p><strong>没有人可以捕获身份验证信息</strong></p>
<p>​    客户端使用强大的128位加密将其身份验证信息传输到服务器。</p>
<p><strong>没有人可以拦截通信</strong></p>
<p>​    在会话期间发送和接受的所有数据都使用128位加密进行传输，使得截获的传输极难解密和读取。</p>
<p>此外，它还提供一下选项：</p>
<p><strong>它提供了通过网络使用图形应用程序的安全方法</strong></p>
<p>​    使用称为X11转发的技术，客户端可以从服务器转发。</p>
<p><strong>它提供一种保护其他不安全协议的方法</strong></p>
<p>​    SSH协议加密它发送和接受的所有内容。使用称为端口转发的技术，SSH服务器可以成为保护其他不安全协议（如POP）以及提高整体系统和数据安全性的渠道。</p>
<p><strong>它可用于创建安全通道</strong></p>
<p>​    可以将OpenSSH服务器和客户端配置配置为为服务器和客户端计算机之间的流量创建类似于虚拟专用网络的隧道。</p>
<p><strong>它支持Kerberos身份验证</strong><br>​    可以将OpenSSH服务器和客户端配置为使用Kerberos网络身份验证协议的GSSAPI（通用安全应用程序接口）实现进行身份验证。</p>
<h1 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h1><p>目前存在两种SSH： version 1和新的 version 2，其具有增强的秘钥交换算法，不易受版本的已知漏洞攻击。</p>
<h1 id="SSH连接的事件序列"><a href="#SSH连接的事件序列" class="headerlink" title="SSH连接的事件序列"></a>SSH连接的事件序列</h1><p>以下系列事件有助于保护两台主机之间SSH通信的完整性。</p>
<ol>
<li>进行加密握手，以便客户端可以验证它是否在与正确的服务器通信。</li>
<li>使用对称加密对客户端和远程主机之间的连接的传输层进行加密。</li>
<li>客户端向服务器验证自身。</li>
<li>客户端通过加密连接与远程主机交互。</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层的主要作用是在认证时和后续通信期间促进两个主机之间的安全通信。传输层通过处理数据的加密和解密，以及在发送和接收数据分组时提供分组的完整性保护来实现这一点，传输层还提供压缩，加速信息传输。</p>
<p>SSH客户端与服务器联系后，将交换秘钥信息，以便两个系统可以正确构建传输层。在此交换期间发生以下步骤：</p>
<ul>
<li>秘钥交换</li>
<li>确定公钥加密算法</li>
<li>确定对称加密算法</li>
<li>确定消息验证算法</li>
<li>确定哈希算法</li>
</ul>
<p>在密钥交换期间，服务器使用唯一的<em>host key</em>向客户端标识自己，如果客户端之前从未与此特定服务器通信，则服务器的主机密钥对客户端是未知的，并且它不会连接。OpenSSH通过接受服务器的主机密钥来解决这个问题。这是在通知并且已接受并验证新主机密钥之后完成的。在后续连接中，将根据客户端上保存的版本检查服务器的主机密钥，从而确保客户端确实与目标服务器进行通信。如果将来主机秘钥不在匹配，则用户必须在连接之前删除客户端保存的版本。</p>
<p>SSH旨在用于几乎任何类型的公钥算法或编码格式。在初始密钥交换创建用于交换的哈希值和共享密钥值之后，两个系统立即开始计算新密钥和算法以保护通过连接发送的认证和未来数据。</p>
<p>在使用给定密钥和算法传输了一定量的传输之后（确切的数量取决ssh实现），发生另一个密钥交换，生成另一组散列值和新的共享秘密值。即使攻击者能够确定哈希值和共享密钥值，此信息仅在有限的时间段内有效。</p>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>一旦传输层构建了一个安全隧道以在两个系统之间传递信息，服务器就会告诉客户端支持不同的身份验证方法，例如使用私钥编码签名或输入密码。然后，客户端尝试使用这些支持的方法之一向服务器验证自身。</p>
<p>可以将SSH服务器和客户端配置为允许不同类型的身份验证，从而为每一方提供最佳控制量，服务器可以根据其安全模型决定它支持哪些加密方法，客户端可以出从可用选项中选择验证方法的顺序。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>在通过SSH传输层成功进行身份验证之后，通过<em>multiplexing</em>技术打开多个通道，这些通道中的每一个都处理不同终端会话和转发X11会话的通信。</p>
<p>客户端和服务器都可以创建新通道。然后在连接的每一端为每个通道分配不同的编号。当客户端尝试打开新通道时，客户端会发送通道号以及请求。该信息由服务器存储，因此当给定会话结束时，可以关闭其通道而不会中断主SSH连接。</p>
<p>通道还支持流量控制，允许他们已有序的方式发送和接收数据。这样，在客户端收到通道打开的消息之前，不会通过通道发送数据。</p>
<p>客户端和服务器自动协商每个通道的特征，具体取决于客户端请求的服务类型以及用户连接到网络的方式。这使得处理不同的远程连接具有很大的灵活性，而无需更改协议的基本基础结构。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSH客户端</title>
    <url>/2018/11/16/Linux/OPENSSH/OpenSSH-client/</url>
    <content><![CDATA[<p>要从客户端连接到OpenSSH服务器，必须安装<code>openssh-clients</code>软件包。<br><a id="more"></a></p>
<h1 id="使用ssh"><a href="#使用ssh" class="headerlink" title="使用ssh"></a>使用ssh</h1><p>ssh允许您登陆到远程计算机并在那里执行命令，替代<code>rlogin</code> ,<code>telnet</code>程序。</p>
<p>与<code>telnet</code>命令类似，使用一下命令登陆到远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh hostname</span><br></pre></td></tr></table></figure>
<p>例如，要登陆主机名为<code>ssh.example.com</code>，请在shell提示符下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh ssh.example.com</span><br></pre></td></tr></table></figure>
<p>这将使用您在本地计算机上使用的相同用户名登陆。如果要指定其他用户名，请使用一下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ssh.example.com</span><br></pre></td></tr></table></figure>
<p>第一次启动连接时，将显示类似于以下内容的消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">'ssh.example.com'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:vuGKK9dsW34zrZzwjl5g+vOE6EZQvHRQ8zObKYO2mW4.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:7e:15:c3:03:4d:e1:dd:ee:99:dc:3e:f4:b9:67:6b:62.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure>
<p>在回答此对话框中的问题之前，用户应始终检查指纹是否正确。用户可以要求服务器的管理员确认密钥是否正确。这应该以安全且事先商定的方式进行，如果用户可以访问服务器的主机密钥，则可以使用<code>ssh-kengen</code>命令检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-kengen -l -f /etc/ssh/ssh_host_ecdsa_key.pub</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要获取MD5密钥指纹，请使用 -E md5选项</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub -EM md5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果SSH服务器的主机密钥更改，则客户端会通知用户连接无法继续，直到从<code>~/.ssh/known_hosts</code>文件中删除服务器的主机密钥。但是，在执行此操作之前，请与SSH服务器的系统管理员联系以验证服务器是佛收到损害。</p>
<p>要从<code>~/.ssh/known_hosts</code>文件中删除密钥，请发出如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R ssh.example.com</span><br></pre></td></tr></table></figure>
</blockquote>
<p>ssh验证完成后， 将为您提供远程计算机的shell提示符。</p>
<p>或者，该ssh程序可用于在远程计算机上执行命令，而无需到shell提示符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@hostname <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ssh.example cat /etc/redhat-release</span><br></pre></td></tr></table></figure>
<h1 id="使用scp"><a href="#使用scp" class="headerlink" title="使用scp"></a>使用scp</h1><p><code>scp</code> 可用于通过安全的加密连接在计算机之间传输文件。在它的设计中，非常类似<code>rcp</code>要将本地文件传输到远程系统，使用一下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp localfile username@hostname:remotefile</span><br></pre></td></tr></table></figure>
<p>例如，如果要复制<code>taglist.vim</code>到远程计算机ssh.example.com:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp taglist.vim  USER@ssh.example.com:.vim/plugin/taglist.vim</span><br></pre></td></tr></table></figure>
<p>要将远程文件传输到本地系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@hostname:remotefile localfile</span><br></pre></td></tr></table></figure>
<p>例如将远程主机的<code>.vimrc</code>复制到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp USER@ssh.example.com:.vimrc .vimrc</span><br></pre></td></tr></table></figure>
<h1 id="使用sftp"><a href="#使用sftp" class="headerlink" title="使用sftp"></a>使用sftp</h1><p><code>sftp</code>可用于打开安全的交互式FTP会话。在其设计中，它类似于<code>ftp</code>使用安全的加密连接。</p>
<p>要连接到远程系统，请使用以下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sftp username@hostname</span><br></pre></td></tr></table></figure>
<p>例如，登录到名为远程机器<code>ssh.example.com</code>与<code>USER</code>作为用户名，类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sftp USER@ssh.example.com</span><br></pre></td></tr></table></figure>
<p><strong>可用的sftp命令</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls</code>[ <em>目录</em> ]</td>
<td>列出远程<em>目录</em>的内容。如果未提供，则默认使用当前工作目录。</td>
</tr>
<tr>
<td><code>cd</code> <em>目录</em></td>
<td>将远程工作目录更改为<em>目录</em>。</td>
</tr>
<tr>
<td><code>mkdir</code> <em>目录</em></td>
<td>创建一个远程<em>目录</em>。</td>
</tr>
<tr>
<td><code>rmdir</code> <em>路径</em></td>
<td>删除远程<em>目录</em>。</td>
</tr>
<tr>
<td><code>put</code> <em>localfile</em> [ <em>remotefile</em> ]</td>
<td>将<em>本地文件</em>传输到远程计算机。</td>
</tr>
<tr>
<td><code>get</code> <em>remotefile</em> [ <em>localfile</em> ]</td>
<td>传输<em>参数】remotefile</em>从远程机器。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化程序设计方法</title>
    <url>/2018/10/26/Program-design/Structured-programming/</url>
    <content><![CDATA[<p><strong>结构化程序设计方法出现的背景</strong></p>
<ul>
<li>goto语句是有害的</li>
<li>可以从高级语言中消除goto语句，主张在高级语言中应保留goto语句，在功能方面不加限制，但限制其使用范围，切不必对一般用户开放</li>
<li>争论的焦点不应该放在是否取消goto语句上， 应该放在程序的质量上</li>
</ul>
<p><em>计算机发展的初期，评价软件质量主要看占内存容量的大小和运行速度的快慢</em></p>
<p><strong>程序设计的目标</strong></p>
<ul>
<li>不只是编写一个能够得到正确运行结果的程序</li>
<li>关注程序结构的好坏，好的结构比高的效率更为重要</li>
</ul>
<a id="more"></a>
<p><strong>结构化程序设计的一个比较流行的定义是</strong></p>
<ul>
<li>结构化程序设计（Srructured Programming）是一种程序设计的原则和方法</li>
<li>限制和避免使用goto语句,采用”自顶向下,逐步求精”方法进行程序设计</li>
<li>按照这种原则和方法设计出的程序的特点为:<ul>
<li>结构清晰</li>
<li>容易阅读</li>
<li>容易修改</li>
<li>容易验证</li>
</ul>
</li>
</ul>
<p><strong>结构化程序设计的目标</strong></p>
<ul>
<li>为了得到一个好结构的程序</li>
<li>有无goto语句,并不是程序结构好坏的标志</li>
</ul>
<p><em>采用顺序、选择和循环三种基本控制作为程序设计的基本单元</em></p>
<p><strong>坚持单入口单出口原则</strong></p>
<ul>
<li>程序的静态结构和动态执行可以保持一致</li>
<li>差异很大会给程序的流向分析带来困难，可读性差，易出错，不易查错</li>
</ul>
<p><strong>正规程序需满足下面两个条件</strong></p>
<ul>
<li>具有一个入口线，一个出口线</li>
<li>对每一个节点，都有一条从入口线到出口县的通路通过该节点</li>
</ul>
<p><strong>正规程序的某些部分仍是正规程序——正规子程序</strong></p>
<p><strong>基本程序</strong></p>
<ul>
<li>不存在多余一个函数节点的正规真子程序（不可再分解的正规程序，不能抽象为多于一个的函数节点）</li>
<li>封闭结构（若存在的话）都是正规程序</li>
<li>任何一个结构化程序都是可以用这些基本程序来构成</li>
<li>怼构造一个结构化程序来说并不都是必须的 </li>
</ul>
<p><strong>复合程序</strong></p>
<p>一个基本程序的函数节点用另外一个基本程序替换，所产生的正规程序称之为复合程序</p>
<p><em>复合程序的替换形式：堆叠，嵌套</em></p>
<p><strong>基集合</strong></p>
<p><em>用于构造程序的基本程序集合</em></p>
<p><strong>结构化程序</strong></p>
<p><em>由基本程序的一个固定的基集合构造出来的复合程序</em></p>
<ul>
<li>按照结构化程序设计的要求设计出的语言——结构化程序设计语言</li>
<li>按照结构化程序设计语言（或结构化程序设计思想）设计的程序——结构化程序</li>
</ul>
<p><strong>结构化程序的特点：</strong></p>
<p><em>无论从总体上还是从每一个组成部分来看， 都遵循“单入口单出口”的原则</em></p>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程概述（Python）</title>
    <url>/2018/10/18/Program-design/Python/System-Programming-Overview/</url>
    <content><![CDATA[<h1 id="系统编程概述"><a href="#系统编程概述" class="headerlink" title="系统编程概述"></a>系统编程概述</h1><h2 id="字符串方法基础知识"><a href="#字符串方法基础知识" class="headerlink" title="字符串方法基础知识"></a>字符串方法基础知识</h2><p>Python的字符串方法本身并非系统相关工具, 但他们频繁现身于绝大多数Python程序,字符串方法保罗用于查找和替换的调用:<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'xxxSPAMxxx'</span></span><br><span class="line">mystr.find(<span class="string">'SPAM'</span>)				<span class="comment"># 返回首个匹配的位置偏移量</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'xxaaxxaa'</span></span><br><span class="line">mystr.replace(<span class="string">'aa'</span>, <span class="string">'SPAM'</span>) 	<span class="comment"># 全局替换</span></span><br><span class="line"><span class="string">'xxSPAMxxSPAM'</span></span><br></pre></td></tr></table></figure>
<p><code>find</code>函数返回子字符串第一个匹配所在的便宜位置,<code>replace</code>函数则完成全局搜索与替换,和所有字符串操作一样,<code>replace</code>函数返回的是新字符串,而不是改变原有字符串(<strong>字符串是不可变的</strong>).有了这些方法,子字符串可以还原成字符串来处理.</p>
<p>在最新的Python版本中, 如果我们只需要得到”是/否”的回答,那么通常可以用成员判断运算符<code>in</code>(用于测试子字符串是否存在)来替代<code>find</code>函数.去除字符串结尾的空格有多种方法,这在从文件读取文本行时特别有用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'xxxSPAMxxx'</span></span><br><span class="line"><span class="string">'SPAM'</span> <span class="keyword">in</span> mystr 		<span class="comment"># 子字符串搜索/测试</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">'Ni'</span> <span class="keyword">in</span> mystr 			<span class="comment"># 没找到时</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">mystr.find(<span class="string">'Ni'</span>)</span><br><span class="line"><span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mystr = <span class="string">'\t Ni \n'</span></span><br><span class="line">mystr.strip()			<span class="comment"># 去除空白分隔符</span></span><br><span class="line"><span class="string">'Ni'</span></span><br><span class="line">mystr.rstrip()			<span class="comment"># 去除空白分隔符(在右侧进行)</span></span><br><span class="line"><span class="string">'\t Ni'</span></span><br></pre></td></tr></table></figure>
<p>字符串方法为大小写转换等提供了有用的函数,另外还有一个名为<code>string</code> 的标准库模块,里面定义了一些有用的预设变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'SHRUBBERY'</span></span><br><span class="line">mystr.lower()			<span class="comment"># 大小写转换器</span></span><br><span class="line"><span class="string">'shrubbery'</span></span><br><span class="line"></span><br><span class="line">mystr.isalpha()			<span class="comment"># 内容测试</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">mystr.isdigit()			</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string			<span class="comment"># 环境预设: 可在'in'等语句中使用</span></span><br><span class="line">string.ascii_lowercase</span><br><span class="line"><span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">string.whitespace		<span class="comment"># 空白分隔符</span></span><br><span class="line"><span class="string">' \t\n\r\x0b\x0c'</span></span><br></pre></td></tr></table></figure>
<p>还有一些方法,可以用字符串作为分隔符来分割原始字符串,也可以用子字符串将它们连接起来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'aaa,bbb,ccc'</span>		<span class="comment"># 分割为子字符串组成的列表</span></span><br><span class="line">mystr.split(<span class="string">','</span>)</span><br><span class="line">[<span class="string">'aaa'</span>,<span class="string">'bbb'</span>,<span class="string">'ccc'</span>]</span><br><span class="line"></span><br><span class="line">mystr = <span class="string">'a b\nc\nd'</span></span><br><span class="line">mystr.split()				<span class="comment"># 默认分隔符: 泛空格符</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">delim = <span class="string">'NI'</span></span><br><span class="line">delim.join([<span class="string">'aaa'</span>, <span class="string">'bbb'</span>, <span class="string">'ccc'</span>])	<span class="comment"># 连接子字符串列表</span></span><br><span class="line"><span class="string">'aaaNIbbbNIccc'</span></span><br><span class="line"></span><br><span class="line"><span class="string">' '</span>.join([<span class="string">'A'</span>, <span class="string">'dead'</span>, <span class="string">'parrot'</span>]) 	<span class="comment"># 在其中添加空格符</span></span><br><span class="line">chars</span><br><span class="line"><span class="string">'A dead parrot'</span></span><br><span class="line"></span><br><span class="line">chars = list(<span class="string">'Lorreta'</span>)				<span class="comment"># 转换为字符组成的列表</span></span><br><span class="line">chars</span><br><span class="line">[<span class="string">'L'</span> , <span class="string">'o'</span>,  <span class="string">'r'</span>,  <span class="string">'r'</span>,  <span class="string">'e'</span>,  <span class="string">'t'</span>,  <span class="string">'a'</span>]</span><br><span class="line">chars.append(<span class="string">'!'</span>)</span><br><span class="line"><span class="string">''</span>.join(chars)						<span class="comment"># 生成字符串: 分隔符为空</span></span><br><span class="line"><span class="string">'Lorreta!'</span></span><br></pre></td></tr></table></figure>
<p>浙西额调用其实格外有用,例如,对于一行以制表符分隔的多列数据,我们用一次<code>split</code>调用即可将其解析为多个列,实际上,我们可以组成<code>split</code>和<code>join</code>来模拟前面介绍的<code>replace</code>函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mystr = <span class="string">'xxaaxxaa'</span></span><br><span class="line"><span class="string">'SPAM'</span>.join(mystr.split(<span class="string">'aa'</span>))			<span class="comment"># str.replace </span></span><br><span class="line"><span class="string">'xxSPAMxxSPAM'</span></span><br></pre></td></tr></table></figure>
<p>Python不会自动将字符串转换为数字,反之亦然,如果要实现两种转换的任意一种,需要手动完成:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int(<span class="string">"42"</span>), eval(<span class="string">"42"</span>)			<span class="comment"># 字符串转换为整型</span></span><br><span class="line">(<span class="number">42</span>, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">str(<span class="number">42</span>) , repr(<span class="number">42</span>)				<span class="comment"># 整型转换为字符串</span></span><br><span class="line">(<span class="string">'42'</span>, <span class="string">'42'</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">"%d"</span> % <span class="number">42</span>), <span class="string">'&#123;:d&#125;.format(42)'</span>		<span class="comment"># 分别借助格式化表达式和方法</span></span><br><span class="line">(<span class="string">'42'</span>, <span class="string">'42'</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"42"</span> + str(<span class="number">1</span>), int(<span class="string">"42"</span>) + <span class="number">1</span>		<span class="comment"># 分别为连接和加法</span></span><br><span class="line">(<span class="string">'421'</span>, <span class="number">43</span>)</span><br></pre></td></tr></table></figure>
<p>上面最后一行命令中, 第一个表达式出发字符串连接(因为两边都是字符串) , 而第二个表达式触发加法运算(因为两个对象都是数字).Python并不会嘉定你需要数字还是字符串,然后自行完成转换.Python的第一条指导原则使尽可能避免不必要的神器操作,以及猜测用户行为的诱惑.</p>
<h2 id="Python-3-X中的其他字符串概念-Unicode和字节"><a href="#Python-3-X中的其他字符串概念-Unicode和字节" class="headerlink" title="Python 3.X中的其他字符串概念: Unicode和字节"></a>Python 3.X中的其他字符串概念: Unicode和字节</h2><p>Python3.X的字符串功能很丰富,<strong>str</strong>对象类型, 具有一定序列的字符(从术语来讲就是作为<strong>Unicode</strong>的”代码单元”出现的Unicode”代码点”),它既代表<strong>ASCII码</strong>,又代表了更广泛的Unicode文本,并且可以根据需求手动或自动地处理文件传输时的编码与解码.字符串常出现在引号中(如’abc’),而对于<strong>非ASCII</strong>文本,有多种特殊语法来进行编码(如‘\xc4\xe8’,‘\u00c4\u00e8’)。</p>
<p>Python3.x中添加了两个字符串类型，他们足以支持绝大多数str字符串操作：<strong>bytes</strong>，用来表示8位二进制数据的短整型序列：<strong>bytearray</strong>，字节的一个可更改的变异形式。一般来说，你会因为字符串左侧引号前面的字符<strong>“b”</strong> 而明白自己处理的是字节。3.X中的文件也采取了类似的区分，在文本模式下使用<strong>str</strong>类型（它也处理Unicode的编码和换行符转换），在二进制模式下使用<strong>bytes</strong>（在字节序列和文件之间转移时不会改变字节）。</p>
<p><strong>Unicode</strong>文本多用于国际化的应用程序中，此外许多针对二进制的Python工具现在也可以处理字节字符串。比如<code>open</code>函数，还有<code>os.listdir</code>和<code>os.walk</code>工具。即使是处理简单的目录工具，有时也必须小心文件内容和名称中的<strong>Unicode</strong>。此外，对象<code>pickle</code>和二进制数据解析等现在都已经成为面向字节的工具。</p>
<h2 id="文件操作基础知识"><a href="#文件操作基础知识" class="headerlink" title="文件操作基础知识"></a>文件操作基础知识</h2><p>除了处理字符串，文件对象属于Python语言的核心部分，下面这些调用分别实现了：</p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>实现</th>
<th style="text-align:left">调用</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件内容加载为字符串</td>
<td style="text-align:left">open(‘file’).read()</td>
<td style="text-align:left"><em>将整个文件读取为字符串</em></td>
</tr>
<tr>
<td>固定大小的字节集合加载为字符串</td>
<td style="text-align:left">open(‘file’).read(N)</td>
<td style="text-align:left"><em>将后面N个字节读取为字符串</em></td>
</tr>
<tr>
<td>文件的内容加载为单行字符串组成的列表</td>
<td style="text-align:left">open(‘file’).readlines()</td>
<td style="text-align:left"><em>将文件读取为单行字符串组成的列表</em></td>
</tr>
<tr>
<td>文件的下一行加载为字符串</td>
<td style="text-align:left">open(‘file’).readline()</td>
<td style="text-align:left"><em>跨过‘\n’读取下一行</em></td>
</tr>
</tbody>
</table>
</div>
<p>也可以在<strong>Python</strong>里对<strong>shell</strong>命令使用这些调用来读取其输出。文件对象还有用于发送字符串到相关文件的<code>write</code>方法。在Python中，生成输出文件再将它读取回来一如反正。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = open(<span class="string">'spam.txt'</span>, <span class="string">'w'</span>) 			<span class="comment"># 创建文件 spam.txt</span></span><br><span class="line">file.write((<span class="string">'spam'</span> * <span class="number">5</span>) + <span class="string">'\n'</span>)			<span class="comment"># 写入文本：返回所写入的#个字符</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">'spam.txt'</span>)					<span class="comment"># 或者用open('spam.txt).read</span></span><br><span class="line">text = file.read()					    <span class="comment"># 读取为字符串</span></span><br><span class="line">text</span><br><span class="line"><span class="string">'spamspamspamspamspam\n'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用程序的两种方式"><a href="#使用程序的两种方式" class="headerlink" title="使用程序的两种方式"></a>使用程序的两种方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys	<span class="comment">#    do something</span></span><br></pre></td></tr></table></figure>
<p>Python每个模块都有一个内置的变量<code>__name__</code>变量，当且仅当文件作为程序运行时，而不是作为库导入时，Python会将这个变量设备<code>__main__</code>字符串。因此，当这个脚本代码作为顶层程序运行时，文件最后几行会自动执行，单在其他地方导入时则不会执行，这个技巧提醒我们要编写可重用的脚本代码：用函数的形式来编写程序，而不是作为顶层代码，这样可以方便以后的导入和重用。</p>
<p>这里的要点是既可以独立运行，也可以在别处导入并调用其中定义的某个函数。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Sys</tag>
      </tags>
  </entry>
  <entry>
    <title>递推</title>
    <url>/2018/10/11/Program-design/Recursion/</url>
    <content><![CDATA[<h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><h2 id="递推的基本思想"><a href="#递推的基本思想" class="headerlink" title="递推的基本思想"></a>递推的基本思想</h2><ul>
<li>递推法<ul>
<li>利用问题本身所具有的一种递推关系来求解问题的一种方法</li>
</ul>
</li>
<li>递推<ul>
<li>是指从已知的初始条件出发，依据某种递推关系，逐次推出所要计算的中间结果和最终结果<ul>
<li>初始条件要么在问题本身中已经给定</li>
<li>要么需要通过对问题的分析和化简来确定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="递推的本质和特点"><a href="#递推的本质和特点" class="headerlink" title="递推的本质和特点"></a>递推的本质和特点</h2><ul>
<li>递推的本质<ul>
<li>把一个复杂的计算过程转化为一个简单过程的多次重复计算</li>
</ul>
</li>
<li>可递推求解的问题的特点<ul>
<li>问题可以划分成多个状态</li>
<li>除初始状态外，其他各状态都可用固定的递推关系来表示</li>
</ul>
</li>
<li>递推的应用<ul>
<li>常用于按照一定的规律来计算序列中的指定项</li>
<li>递推关系式通常不会直接给出</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="递推的方法"><a href="#递推的方法" class="headerlink" title="递推的方法"></a>递推的方法</h2><p><strong>正向顺推</strong></p>
<p><em>从已知条件出发，向着所求问题前进，最后与所求问题联系起来</em></p>
<p><strong>方向逆推</strong></p>
<ul>
<li>从所求问题出发，向着已知条件靠拢，最后与已知条件联系起来</li>
<li>从问题的结果出发，一步一步还原出答案</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计方法</title>
    <url>/2018/10/05/Program-design/Bottom-up-and-top-down-programming-methods/</url>
    <content><![CDATA[<h1 id="自底向上-Down-top-的程序设计方法"><a href="#自底向上-Down-top-的程序设计方法" class="headerlink" title="自底向上(Down-top)的程序设计方法"></a>自底向上(Down-top)的程序设计方法</h1><ul>
<li>先编写出基础程序段</li>
<li>然后再逐步扩大规、补充和升级某些功能</li>
<li>实际上是一种自底向上构造程序的过程</li>
</ul>
<p><em>功能简单、规模较小 ==&gt; 功能增加、规模增大</em></p>
<h1 id="自顶向下-Down-top-的程序设计方法"><a href="#自顶向下-Down-top-的程序设计方法" class="headerlink" title="自顶向下(Down-top)的程序设计方法"></a>自顶向下(Down-top)的程序设计方法</h1><ul>
<li>先写出结构简单、清晰的主程序来表达整个问题<ul>
<li>在此问题包含的复杂子问题用子程序或函数来实现</li>
</ul>
</li>
<li>若子问题中还包含负载的子问题,再用子程序或函数实现</li>
<li>知道每个细节都可以用高级语言表达为止</li>
</ul>
<p><em>上:比较抽象的层面 ==&gt;下:更具体的层面,接近程序设计语言</em></p>
<a id="more"></a>
<h1 id="逐步求精-Stepwise-Refinement-方法"><a href="#逐步求精-Stepwise-Refinement-方法" class="headerlink" title="逐步求精(Stepwise Refinement)方法"></a>逐步求精(Stepwise Refinement)方法</h1><ul>
<li>对问题的全局作出决策,设计出怼问题本身较为自然的、很可能是用自然语言表达的==抽象算法==<ul>
<li>由一些抽象数据及其上的操作(即抽象语句)组成，仅仅表示解决问题的一般策略和问题的一般结构</li>
</ul>
</li>
<li>怼抽象算法进一步求精，就进入下一层抽象<ul>
<li>每求精一步，抽象语句和抽象数据都将进一步分解和精细化</li>
</ul>
</li>
<li>如此继续下去，直到最后的算法能为计算机所“理解”为止<ul>
<li>易于用某种高级语言表达</li>
</ul>
</li>
</ul>
<p><em>简而言之：先全局后局部、先整体后细节、先抽象后具体的自顶向下的方法</em></p>
<p><strong>实际程序开发过程不是纯粹的自顶向下和自底向上</strong></p>
<ul>
<li>自顶向下的分解和自底向上的构造两个过程混合交织进行、</li>
<li>由不断的自底向上修正所补充的自顶向下的程序设计方法</li>
</ul>
<p><strong>优点是</strong></p>
<ul>
<li><p>得到的程序是有良好结构的程序</p>
</li>
<li><p>可简化程序的正确性验证</p>
<ul>
<li>结合逐步求精的过程，采取边设计边逐级验证的方法</li>
<li>与写完整个程序后再验证相比，可大大减少程序调试的时间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代</title>
    <url>/2018/10/04/Program-design/Iteration/</url>
    <content><![CDATA[<h1 id="迭代法的基本思想"><a href="#迭代法的基本思想" class="headerlink" title="迭代法的基本思想"></a>迭代法的基本思想</h1><p><strong>迭代法（Iterative Method），也称辗转法</strong></p>
<ul>
<li>通过迭代函数（迭代关系式、迭代公式）</li>
<li>由迭代变量旧值（前一个值）推出新值（下一个值），在不断用新值取代旧值</li>
<li>反复校正迭代变量的值</li>
<li>通过反复迭代，缠身一个数列： <script type="math/tex">x_0,x_1,x_2,x_n</script>,直到逐步逼近问题的解</li>
</ul>
<script type="math/tex; mode=display">x_{n+1} = g(x_n)</script><h1 id="迭代法的基本步骤"><a href="#迭代法的基本步骤" class="headerlink" title="迭代法的基本步骤"></a>迭代法的基本步骤</h1><ol>
<li><p>确定迭代变量</p>
<p>在可用迭代法求解的问题中，应至少存在一个可直接或间接地不断由旧值推出新值的变量——迭代变量</p>
</li>
<li><p>建立迭代函数</p>
<p>解决迭代问题的关键</p>
</li>
<li><p>确定迭代结束条件（收敛判据）</p>
<ol>
<li>所需的迭代次数是已知的确定的值——计数控制循环</li>
<li>所需的迭代次数无法确定——条件控制的循环</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h1 id="精确迭代"><a href="#精确迭代" class="headerlink" title="精确迭代"></a>精确迭代</h1><p><strong>通过迭代能过得到精确解</strong></p>
<ul>
<li>计算两个正整数的商和余数<ul>
<li>商和余数的关系： <script type="math/tex">x = q * y + r</script></li>
<li>迭代变量：r</li>
<li>迭代关系式：<script type="math/tex">r = r - y</script></li>
<li>迭代结束条件：<script type="math/tex">r < y</script></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st1&#x3D;&gt;start: 开始</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入x和y</span><br><span class="line">op1&#x3D;&gt;operation: q &#x3D; 0, r &#x3D; x</span><br><span class="line">cond1&#x3D;&gt;condition: r &gt;&#x3D; y </span><br><span class="line">op2&#x3D;&gt;operation: r &#x3D; r - y</span><br><span class="line">op3&#x3D;&gt;operation: q &#x3D; q + 1</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出q和r</span><br><span class="line">en&#x3D;&gt;end: 结束</span><br><span class="line">st1-&gt;in-&gt;op1-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;op2-&gt;op3(left)-&gt;cond1</span><br><span class="line">cond1(no)-&gt;out-&gt;en</span><br></pre></td></tr></table></figure>
<h1 id="近似迭代"><a href="#近似迭代" class="headerlink" title="近似迭代"></a>近似迭代</h1><p><strong>近似迭代</strong></p>
<ul>
<li>从一个初始估值出发迭代产生一些列离解越来越近的近似解<ul>
<li><script type="math/tex; mode=display">x_{n+1} = g(x_n) $$ $$x_0,x_1,x_2...,x_n</script></li>
</ul>
</li>
<li>近似求解非线性方程的根<ul>
<li>利用求根公式——直接求解方程的精确解</li>
<li>但非线性方程很难直接求解得到精确的数值解，往往只要求得到满足一定精度要求的近似解</li>
</ul>
</li>
<li>直接迭代法就是最简单的迭代法——简单迭代法</li>
</ul>
<h1 id="直接迭代法"><a href="#直接迭代法" class="headerlink" title="直接迭代法"></a>直接迭代法</h1><p><strong>直接迭代法求方程<script type="math/tex">f(x) = 0</script>的根的基本思路</strong></p>
<ul>
<li>确定迭代变量：x</li>
<li>建立迭代函数：<script type="math/tex">x = g(x)</script><ul>
<li><script type="math/tex; mode=display">f(x) = 0 $$ －＞ $$x = g(x)</script></li>
<li>求<script type="math/tex">f(x)</script> 的根－＞求<script type="math/tex">x = g(x)</script>的根</li>
</ul>
</li>
</ul>
<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p><strong>直接迭代法</strong></p>
<ul>
<li>迭代函数可从方程直接导出,迭代函数的构造有多种方法</li>
<li>并非所有的都能使迭代收敛</li>
</ul>
<p><strong>牛顿迭代法</strong></p>
<ul>
<li><p>牛顿在17世纪提出的一种在实数域和复数域上近似求解非线性方程的方法</p>
</li>
<li><p>实质:以直代曲</p>
</li>
<li><p>优点:</p>
<ul>
<li>收敛很快,在单根附近二阶收敛,在重根附近线性收敛</li>
<li>可求复根</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>对重根收敛较慢</li>
<li>要求函数的一阶导数存在,并且不能为0</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>iteration</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2018/10/03/Program-design/Recursive/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p><em>如果一个对象部分地由它自己组成或按它自己定义,则称它是递归的(Recursive)</em></p>
<p><strong>递归</strong></p>
<p>函数/过程/子程序在运行过程中直接或间接调用自身而产生的重用现象</p>
<p><strong>递归——阶乘</strong></p>
<script type="math/tex; mode=display">N! = 1 * 2 * 3 *...* N</script><script type="math/tex; mode=display">N! = 1 * 2 * 3 *...*(N-1) * N</script><script type="math/tex; mode=display">N! = (N - 1)! * N</script><script type="math/tex; mode=display">(N - 1)! = (N - 2)! * (N - 1)</script><p><strong>递归算法必须包含如下两个部分</strong></p>
<ul>
<li>有其自身定义的与原始问题类似的更小规模的子问题，它使递归过程持续进行，称为==一般条件（General case）==<ul>
<li>计算n！问题的一般条件可以用递归公式表示为： <script type="math/tex">n! = n * (n-1)!</script> 当 n&gt;1时</li>
</ul>
</li>
<li>所藐视问题的最简单的情况，他是一个能控制递归过程结束的条件，称为==基本条件（Base case）==<ul>
<li>计算n！问题的基本条件可以表示为：<script type="math/tex">n! = 1</script> n=1时</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p><strong>优势</strong></p>
<ul>
<li>逻辑清楚，结构清晰，可读性好，更逼近数学公式的表示，符合人的思维习惯，能使一个蕴含递归关系且结构复杂的程序简洁精炼</li>
<li>特别是在难于找到从边界到解的全过程的情况下，如果把问题推进一步，其结果仍维持原问题的关系</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>嵌套层次深，函数调用开销大</li>
<li>重复计算</li>
</ul>
<p><strong>特别适用于使用递归算法的三种情况</strong></p>
<ul>
<li>数学定义递归的，如计算阶乘、最大公约数和Fibonacci数列等</li>
<li>数据结构是递归的，如队列、链表、树和图等</li>
<li>问题的解法是递归的，如Hanoi塔，骑士游历、八皇后问题等</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile参考</title>
    <url>/2018/09/16/Linux/container/docker/Dockerfile/</url>
    <content><![CDATA[<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><code>docker build</code>命令<code>Dockerfile</code>根据<em>上下文</em>构建image。构建的上下文是指定位置<code>PATH</code>或的文件<code>URL</code>。这<code>PATH</code>是本地文件系统上的目录。<code>URL</code>是一个Git存储库位置。</p>
<p>递归处理上下文。因此，a <code>PATH</code>包括所有子目录，<code>URL</code>包括存储库及其子模块。此示例显示了使用当前目录作为上下文的构建命令：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>构建由Docker守护程序运行，而不是由CLI运行。构建过程的第一件事是将整个上下文（递归地）发送到守护进程。在大多数情况下，最好从空目录开始作为上下文，并将Dockerfile保存在该目录中。仅添加构建Dockerfile所需的文件。</p>
<blockquote>
<p><strong>警告</strong>：不要用你的根目录下，<code>/</code>作为<code>PATH</code>因为它会导致生成到您的硬盘驱动器的全部内容传输到docker守护进程。</p>
</blockquote>
<p>要在构建上下文中使用文件，请<code>Dockerfile</code>引用指令中指定的文件，例如<code>COPY</code>指令。要提高构建的性能，请通过向<code>.dockerignore</code>上下文目录添加文件来排除文件和目录。</p>
<p>它<code>Dockerfile</code>被调用<code>Dockerfile</code>并位于上下文的根中。您可以使用<code>-f</code>标志<code>docker build</code>指向文件系统中任何位置的Dockerfile。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<p>如果构建成功，您可以指定存储库和标记以保存新image：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure>
<p>要在构建后将映像标记为多个存储库，请在<code>-t</code>运行<code>build</code>命令时添加多个参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure>
<p>在Docker守护程序运行其中的指令之前<code>Dockerfile</code>，它会执行初步验证<code>Dockerfile</code>并在语法不正确时返回错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t <span class="built_in">test</span>/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<p>Docker守护程序<code>Dockerfile</code>逐个运行指令，在必要时将每条指令的结果提交给新image，最后输出新image的ID。Docker守护程序将自动清理您发送的上下文。</p>
<p>请注意，每条指令都是独立运行的，会导致创建新image - 因此<code>RUN cd /tmp</code>不会对下一条指令产生任何影响。</p>
<p>只要有可能，Docker将重新使用中间image（缓存），以<code>docker build</code>显着加速该过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER xxx@xxx.xx</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed <span class="string">'s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/'</span> &amp;&amp; <span class="built_in">echo</span> <span class="built_in">wait</span>) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>
<p>构建缓存仅用于具有本地父链的。这意味着这些image是由以前的版本创建的，或者加载了整个image链<code>docker load</code>。如果您希望使用特定image的构建缓存，可以使用<code>--cache-from</code>选项指定它。指定的image <code>--cache-from</code>不需要具有父链，可以从其他注册表中提取。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>这是以下格式<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>
<p><em>该指令不区分大小写。但是，惯例是让它们成为大写的，以便更容易地将它们与参数区分开来。</em></p>
<p>Docker <code>Dockerfile</code>按顺序运行指令。一个<code>Dockerfile</code> <strong>必须用<code>FROM</code>指令启动</strong>。该<code>FROM</code>指令指定您正在构建的<em>Baseimage</em>。<code>FROM</code>可以仅由一个或多个前面<code>ARG</code>的指令，其声明了在使用的参数<code>FROM</code>中的行<code>Dockerfile</code>。</p>
<p>Docker 将以条目<em>开头的</em>行<code>#</code>视为注释，除非该行是有效的<code>parser-directives</code>。<code>#</code>行中任何其他位置的标记都被视为参数。这允许这样的陈述：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'we are running some # of cool things'</span></span></span><br></pre></td></tr></table></figure>
<p>注释中不支持行继续符。</p>
<h1 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h1><p>解析器指令是可选的，并且影响<code>Dockerfile</code>处理a 中后续行的方式。解析器指令不会向构建添加图层，也不会显示为构建步骤。解析器指令在表单中被写为特殊类型的注释<code># directive=value</code>。单个指令只能使用一次。</p>
<p>一旦处理了注释，空行或构建器指令，Docker就不再查找解析器指令。相反，它将格式化为解析器指令的任何内容视为注释，并且不会尝试验证它是否可能是解析器指令。因此，所有解析器指令必须位于a的顶部<code>Dockerfile</code>。</p>
<p>解析器器指令不区分大小写。但是，惯例是它们是小写的。约定还包括任何解析器指令后面的空行。解析器指令不支持行继续符。</p>
<p>由于这些规则，以下示例均无效：</p>
<p>由于行继续而无效：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># direc \</span></span><br><span class="line">tive=value</span><br></pre></td></tr></table></figure>
<p>由于出现两次无效：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># directive=value1</span></span><br><span class="line"><span class="comment"># directive=value2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>由于在构建器指令后出现而被视为注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ImageName</span><br><span class="line"><span class="comment"># directive=value</span></span><br></pre></td></tr></table></figure>
<p>由于在不是解析器指令的注释之后出现而被视为注释：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># About my dockerfile</span></span><br><span class="line"><span class="comment"># directive=value</span></span><br><span class="line"><span class="keyword">FROM</span> ImageName</span><br></pre></td></tr></table></figure>
<p>由于未被识别，未知指令被视为注释。此外，由于出现在不是解析器指令的注释之后，已知指令被视为注释。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unknowndirective=value</span></span><br><span class="line"><span class="comment"># knowndirective=value</span></span><br></pre></td></tr></table></figure>
<p>解析器指令中允许使用非换行空格。因此，以下几行都是相同的：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#directive=value</span></span><br><span class="line"><span class="comment"># directive =value</span></span><br><span class="line"><span class="comment">#	directive= value</span></span><br><span class="line"><span class="comment"># directive = value</span></span><br><span class="line"><span class="comment">#	  dIrEcTiVe=value</span></span><br></pre></td></tr></table></figure>
<p>支持以下解析器指令：</p>
<ul>
<li><code>escape</code></li>
</ul>
<h1 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=\ (backslash)</span></span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=` (backtick)</span></span><br></pre></td></tr></table></figure>
<p><code>escape</code>指令设置用于转义字符的字符 <code>Dockerfile</code>。如果未指定，则默认转义字符为<code>\</code>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> testfile.txt c:\\</span></span><br><span class="line"><span class="bash">RUN dir c:\</span></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t cmd .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;2 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;2 : COPY testfile.txt c:\RUN dir c:</span><br><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>
<p>上面的一个解决方案是<code>/</code>用作<code>COPY</code> 指令的目标，和<code>dir</code>。但是，这种语法充其量是令人困惑的，因为对于路径来说并不自然<code>Windows</code>，并且最坏的情况是容易出错，因为并非所有命令都 作为路径分隔符<code>Windows</code>支持<code>/</code>。</p>
<p>通过添加<code>escape</code>解析器指令，以下<code>Dockerfile</code>成功使用文件路径的自然平台语义<code>Windows</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> testfile.txt c:\</span></span><br><span class="line"><span class="bash">RUN dir c:\</span></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache&#x3D;true .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1&#x2F;3 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;3 : COPY testfile.txt c:\</span><br><span class="line"> ---&gt; 96655de338de</span><br><span class="line">Removing intermediate container 4db9acbb1682</span><br><span class="line">Step 3&#x2F;3 : RUN dir c:\</span><br><span class="line"> ---&gt; Running in a2c157f842f5</span><br><span class="line"> Volume in drive C has no label.</span><br><span class="line"> Volume Serial Number is 7E6D-E0F7</span><br><span class="line"></span><br><span class="line"> Directory of c:\</span><br><span class="line"></span><br><span class="line">10&#x2F;05&#x2F;2016  05:04 PM             1,894 License.txt</span><br><span class="line">10&#x2F;05&#x2F;2016  02:22 PM    &lt;DIR&gt;          Program Files</span><br><span class="line">10&#x2F;05&#x2F;2016  02:14 PM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">10&#x2F;28&#x2F;2016  11:18 AM                62 testfile.txt</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Users</span><br><span class="line">10&#x2F;28&#x2F;2016  11:20 AM    &lt;DIR&gt;          Windows</span><br><span class="line">           2 File(s)          1,956 bytes</span><br><span class="line">           4 Dir(s)  21,259,096,064 bytes free</span><br><span class="line"> ---&gt; 01c7f3bef04f</span><br><span class="line">Removing intermediate container a2c157f842f5</span><br><span class="line">Successfully built 01c7f3bef04f</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Environment-replacement"><a href="#Environment-replacement" class="headerlink" title="Environment replacement"></a>Environment replacement</h1><p>环境变量（声明的<code>ENV</code>），也可以在特定指令作为变量用来被解释 <code>Dockerfile</code>。还会处理转义，以便将类似变量的语法包含在字面上。</p>
<p>环境变量<code>Dockerfile</code>用 <code>$variable_name</code>or表示<code>${variable_name}</code>。它们被等效地处理，并且括号语法通常用于解决具有没有空格的变量名称的问题，例如<code>${foo}_bar</code>。</p>
<p>该<code>${variable_name}</code>语法还支持一些标准的<code>bash</code> 修饰如下规定：</p>
<ul>
<li><code>${variable:-word}</code>表示如果<code>variable</code>设置后，结果将是该值。如果<code>variable</code>未设置则结果将是<code>word</code>。</li>
<li><code>${variable:+word}</code>表示如果<code>variable</code>设置，那么<code>word</code>将是结果，否则结果是空字符串。</li>
</ul>
<p>在所有情况下，<code>word</code>可以是任何字符串，包括其他环境变量。</p>
<p>通过<code>\</code>在变量之前添加来实现转义：<code>\$foo</code>或者<code>\${foo}</code>，例如，将分别转换为<code>$foo</code>和<code>${foo}</code>文本。</p>
<p>示例（解析后的表示显示在<code>#</code>）之后：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENV</span> foo /bar</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$&#123;foo&#125;</span>   <span class="comment"># WORKDIR /bar</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . <span class="variable">$foo</span>       <span class="comment"># ADD . /bar</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> \<span class="variable">$foo</span> /quux <span class="comment"># COPY $foo /quux</span></span></span><br></pre></td></tr></table></figure>
<p>以下指令列表支持环境变量<code>Dockerfile</code>：</p>
<ul>
<li><code>ADD</code></li>
<li><code>COPY</code></li>
<li><code>ENV</code></li>
<li><code>EXPOSE</code></li>
<li><code>FROM</code></li>
<li><code>LABEL</code></li>
<li><code>STOPSIGNAL</code></li>
<li><code>USER</code></li>
<li><code>VOLUME</code></li>
<li><code>WORKDIR</code></li>
</ul>
<p>以及：</p>
<ul>
<li><code>ONBUILD</code> （当与上面支持的指令之一结合使用时）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：在1.4之前，<code>ONBUILD</code>指令<strong>不</strong>支持环境变量，即使与上面列出的任何指令结合使用也是如此。</p>
</blockquote>
<p>环境变量替换将在整个指令中对每个变量使用相同的值。换句话说，在这个例子中：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc</span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc</span><br></pre></td></tr></table></figure>
<p>将导致<code>def</code>具有值<code>hello</code>，而不是<code>bye</code>。但是， <code>ghi</code>将具有值，<code>bye</code>因为它不是设置<code>abc</code>为的相同指令的一部分<code>bye</code>。</p>
<h1 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h1><p>在docker CLI将上下文发送到docker守护程序之前，它会查找<code>.dockerignore</code>在上下文的根目录中指定的文件。如果此文件存在，CLI将修改上下文以排除与其中的模式匹配的文件和目录。这有助于避免不必要地将大型或敏感文件和目录发送到守护程序，并可能使用<code>ADD</code>或将它们添加到映像中<code>COPY</code>。</p>
<p>CLI将<code>.dockerignore</code>文件解释为新行分隔的模式列表，类似于Unix shell的文件globs。出于匹配的目的，上下文的根被认为是工作目录和根目录。例如，模式 <code>/foo/bar</code>和<code>foo/bar</code>两者都排除<code>bar</code> 在位于的git存储库的<code>foo</code>子目录<code>PATH</code>或根目录中命名的文件或目录<code>URL</code>。两者都不包括任何其他内容。</p>
<p>如果<code>.dockerignore</code>文件中的行以第<code>#</code>1列开头，则此行被视为注释，并在CLI解释之前被忽略。</p>
<p>这是一个示例<code>.dockerignore</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># comment</span></span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>
<p>此文件导致以下构建行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>规则</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code># comment</code></td>
<td>忽略。</td>
</tr>
<tr>
<td><code>*/temp*</code></td>
<td>排除名称以<code>temp</code>根目录的任何直接子目录开头的文件和目录。例如，<code>/somedir/temporary.txt</code>排除普通文件，目录也是如此<code>/somedir/temp</code>。</td>
</tr>
<tr>
<td><code>*/*/temp*</code></td>
<td>排除<code>temp</code>从根目录下两级开始的任何子目录开始的文件和目录。例如，<code>/somedir/subdir/temporary.txt</code>被排除在外。</td>
</tr>
<tr>
<td><code>temp?</code></td>
<td>排除根目录中的文件和目录，其名称是单字符扩展名<code>temp</code>。例如，<code>/tempa</code>与<code>/tempb</code>被排除在外。</td>
</tr>
</tbody>
</table>
</div>
<p>匹配是使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成的。预处理步骤去除了开头和结尾的空白，并消除<code>.</code>与<code>..</code>使用Go的元素 <a href="http://golang.org/pkg/path/filepath/#Clean" target="_blank" rel="noopener">filepath.Clean</a>。预处理后为空的行将被忽略。</p>
<p>除了Go的filepath.Match规则，Docker还支持一个<code>**</code>匹配任意数量目录（包括零）的特殊通配符字符串。例如，<code>**/*.go</code>将排除<code>.go</code> 在所有目录中找到的以该结尾的所有文件，包括构建上下文的根。</p>
<p>以<code>!</code>（感叹号）开头的行可用于对排除项进行例外处理。以下是<code>.dockerignore</code>使用此机制的示例文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure>
<p><em>除</em> <code>README.md</code>上下文<em>外</em>，所有降价文件<em>除外</em>。</p>
<p><code>!</code>异常规则的放置会影响行为：<code>.dockerignore</code>匹配特定文件的最后一行确定是包含还是排除。请考虑以下示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README*.md</span><br><span class="line">README-secret.md</span><br></pre></td></tr></table></figure>
<p>除了以外的README文件，上下文中不包含markdown文件 <code>README-secret.md</code>。</p>
<p>现在考虑这个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.md</span><br><span class="line">README-secret.md</span><br><span class="line">!README*.md</span><br></pre></td></tr></table></figure>
<p>包含所有README文件。中间线没有效果，因为 <code>!README*.md</code>匹配<code>README-secret.md</code>并且最后。</p>
<p>您甚至可以使用<code>.dockerignore</code>文件来排除<code>Dockerfile</code> 和<code>.dockerignore</code>文件。这些文件仍然发送到守护程序，因为它需要它们来完成它的工作。但是<code>ADD</code>和<code>COPY</code>指令不会将它们复制到image中。</p>
<p>最后，您可能希望指定要包含在上下文中的文件，而不是要排除的文件。要实现此目的，请指定<code>*</code>第一个模式，然后指定一个或多个<code>!</code>异常模式。</p>
<p><strong>注意</strong>：由于历史原因，将<code>.</code>忽略该模式。</p>
<h1 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt; [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>
<p>该<code>FROM</code>指令初始化新的构建阶段并为后续指令设置<em>Baseimage</em>。因此，有效<code>Dockerfile</code>必须以<code>FROM</code>指令开始。image可以是任何有效image - 通过从<em>dockerrepos</em>提取<em>image</em>来启动它尤其容易。</p>
<ul>
<li><code>ARG</code>是先于仅指示<code>FROM</code>在<code>Dockerfile</code>。</li>
<li><code>FROM</code>可以在单个内容中多次出现<code>Dockerfile</code>以创建多个image，或者使用一个构建阶段作为另一个构建阶段的依赖项。只需在每条新<code>FROM</code>指令之前记下提交输出的最后一个imageID 。每条<code>FROM</code>指令都清除先前指令创建的任何状态。</li>
<li>可选地，可以通过添加<code>AS name</code>到<code>FROM</code>指令来将 名称赋予新的构建阶段。该名称可用于后续<code>FROM</code>和 <code>COPY --from=&lt;name|index&gt;</code>指令，以引用此阶段构建的image。</li>
<li>该<code>tag</code>或<code>digest</code>值是可选的。如果省略其中任何一个，则构建器默认采用<code>latest</code>标记。如果找不到<code>tag</code>值，构建器将返回错误。</li>
</ul>
<h2 id="了解ARG和FROM如何交互"><a href="#了解ARG和FROM如何交互" class="headerlink" title="了解ARG和FROM如何交互"></a>了解ARG和FROM如何交互</h2><p><code>FROM</code>说明支持由<code>ARG</code> 第一个之前发生的任何指令声明的变量<code>FROM</code>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>
<p>在<code>ARG</code>生命之前，<code>FROM</code>是一个构建阶段之外，因此它不能在之后的任何指令使用<code>FROM</code>。要<code>ARG</code>在第一次<code>FROM</code>使用之前使用声明的默认值，请在<code>ARG</code>构建阶段内使用没有值的指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>
<h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p>RUN有两种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code>（<em>shell</em>表单，该命令在shell中运行，默认情况下<code>/bin/sh -c</code>在Linux或<code>cmd /S /C</code>Windows 上运行）</li>
<li><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>（<em>执行</em>形式）</li>
</ul>
<p>该<code>RUN</code>指令将在当前image之上的新层中执行任何命令并提交结果。生成的提交image将用于下一步<code>Dockerfile</code>。</p>
<p>分层<code>RUN</code>指令和生成提交符合Docker的核心概念，可以从image历史中的任何点创建容器，就像源代码控制一样。</p>
<p>在<em>EXEC</em>形式使得能够避免壳串改写（munging），<code>RUN</code> 使用不包含指定壳可执行基本image命令。</p>
<p>可以使用 <code>SHELL</code>命令更改<em>shell</em>表单的默认shell。</p>
<p>在<em>shell</em>形式中，您可以使用<code>\</code>（反斜杠）将单个RUN指令继续到下一行。例如，考虑以下两行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">'source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="bash"><span class="built_in">echo</span> <span class="variable">$HOME</span><span class="string">'</span></span></span><br></pre></td></tr></table></figure>
<p>它们一起相当于这一行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">'source $HOME/.bashrc; echo $HOME'</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：要使用除“/ bin / sh”之外的其他shell，请使用传入所需shell 的<em>exec</em>表单。例如，<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>RUN [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
<p><strong>注意</strong>：在<em>JSON</em>表单中，必须转义反斜杠。这在反斜杠是路径分隔符的Windows上尤为重要。由于不是有效的JSON，以下行将被视为<em>shell</em>表单，并以意外方式失败：<code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code> 此示例的正确语法是：<code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code></p>
</blockquote>
<p><code>RUN</code>在下一次构建期间，指令的缓存不会自动失效。类似指令的缓存<code>RUN apt-get dist-upgrade -y</code>将在下一次构建期间重用。例如，<code>RUN</code>可以通过使用<code>--no-cache</code> 标志使指令的高速缓存无效<code>docker build --no-cache</code>。</p>
<p><code>RUN</code>指令的高速缓存可以通过<code>ADD</code></p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>该<code>CMD</code>指令有三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>（<em>执行</em>形式，这是首选形式）</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code>（作为<em>ENTRYPOINT的默认参数</em>）</li>
<li><code>CMD command param1 param2</code>（<em>贝壳</em>形式）</li>
</ul>
<p>a中只能有一条<code>CMD</code>指令<code>Dockerfile</code>。如果列出多个，<code>CMD</code> 则只有最后一个<code>CMD</code>生效。</p>
<p><strong>a的主要目的CMD是为执行容器提供默认值。</strong>这些默认值可以包含可执行文件，也可以省略可执行文件，在这种情况下，您还必须指定一条<code>ENTRYPOINT</code> 指令。</p>
<blockquote>
<p><strong>注意</strong>：如果<code>CMD</code>用于为<code>ENTRYPOINT</code> 指令提供默认参数，则应使用JSON数组格式指定<code>CMD</code>和<code>ENTRYPOINT</code>指令。</p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>CMD [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
</blockquote>
<p>在shell或exec格式中使用时，该<code>CMD</code>指令设置在运行映像时要执行的命令。</p>
<p>如果你使用的是<em>shell的</em>形式<code>CMD</code>，那么<code>&lt;command&gt;</code>将执行 <code>/bin/sh -c</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"This is a test."</span> | wc -</span></span><br></pre></td></tr></table></figure>
<p>如果要在 <code>&lt;command&gt;</code> 没有 <strong>shell</strong> 的情况下运行，则必须将该命令表示为JSON数组，并提供可执行文件的完整路径。 此数组形式是首选格式CMD。任何其他参数必须在数组中单独表示为字符串：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/bin/wc"</span>,<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果您希望容器每次都运行相同的可执行文件，那么您应该考虑<code>ENTRYPOINT</code>结合使用<code>CMD</code>。</p>
<p>如果用户指定了参数，<code>docker run</code>那么它们将覆盖指定的默认值<code>CMD</code>。</p>
<blockquote>
<p><strong>注意</strong>：不要混淆<code>RUN</code>使用<code>CMD</code>。<code>RUN</code>实际上运行一个命令并提交结果; <code>CMD</code>在构建时不执行任何操作，但指定image的预期命令。</p>
</blockquote>
<h1 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>
<p><code>LABEL</code>指令将元数据添加到image。 <code>LABEL</code>是键值对。要在<code>LABEL</code>值中包含空格，请使用引号和反斜杠，就像在命令行解析中一样。一些用法示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> <span class="string">"com.example.vendor"</span>=<span class="string">"ACME Incorporated"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.label-with-value=<span class="string">"foo"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"This text illustrates \</span></span></span><br><span class="line"><span class="bash">that label-values can span multiple lines.<span class="string">"</span></span></span><br></pre></td></tr></table></figure>
<p>image可以有多个标签。您可以在一行中指定多个标签。在Docker 1.10之前，这减小了最终image的大小，但现在不再是这种情况了。您仍然可以选择在单个指令中指定多个标签，方法有以下两种：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> multi.label2=<span class="string">"value2"</span> other=<span class="string">"value3"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> \</span></span><br><span class="line"><span class="bash">      multi.label2=<span class="string">"value2"</span> \</span></span><br><span class="line"><span class="bash">      other=<span class="string">"value3"</span></span></span><br></pre></td></tr></table></figure>
<p>基本或父image中包含的标签（<code>FROM</code>线中的image）由image继承。如果标签已存在但具有不同的值，则最近应用的值将覆盖任何先前设置的值。</p>
<p>要查看image的标签，请使用该<code>docker inspect</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;com.example.vendor&quot;: &quot;ACME Incorporated&quot;</span><br><span class="line">    &quot;com.example.label-with-value&quot;: &quot;foo&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;This text illustrates that label-values can span multiple lines.&quot;,</span><br><span class="line">    &quot;multi.label1&quot;: &quot;value1&quot;,</span><br><span class="line">    &quot;multi.label2&quot;: &quot;value2&quot;,</span><br><span class="line">    &quot;other&quot;: &quot;value3&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<p><code>EXPOSE</code>指令通知Docker容器在运行时侦听指定的网络端口。您可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认为TCP。</p>
<p>该<code>EXPOSE</code>指令实际上没有发布端口。它作为构建映像的人和运行容器的人之间的一种文档，用于发布要发布的端口。要在运行容器时实际发布端口，请使用<code>-p</code>标志on <code>docker run</code> 来发布和映射一个或多个端口，或使用<code>-P</code>标志发布所有公开的端口并将它们映射到高阶端口。</p>
<p>默认情况下，<code>EXPOSE</code>假定为TCP。您还可以指定UDP：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>要在TCP和UDP上公开，请包含两行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果使用<code>docker run</code> <code>-P</code> ，端口将为TCP暴露一次，对UDP则暴露一次。请记住，<code>-P</code>在主机上使用短暂的高阶主机端口，因此TCP和UDP的端口不同。</p>
<p>无论<code>EXPOSE</code>设置如何，您都可以使用<code>-p</code>标志在运行时覆盖它们。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure>
<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<p>该<code>ENV</code>指令将环境变量<code>&lt;key&gt;</code>设置为该值 <code>&lt;value&gt;</code>。此值将在构建阶段中所有后续指令的环境中。</p>
<p><code>ENV</code>指令有两种形式。第一种形式，<code>ENV &lt;key&gt; &lt;value&gt;</code>将一个变量设置为一个值。第一个空格后的整个字符串将被视为<code>&lt;value&gt;</code>- 包括空格字符。该值将针对其他环境变量进行解释，因此如果未对其进行转义，则将删除引号字符。</p>
<p>第二种形式<code>ENV &lt;key&gt;=&lt;value&gt; ...</code>允许一次设置多个变量。请注意，第二种形式在语法中使用等号（=），而第一种形式则不然。与命令行解析一样，引号和反斜杠可用于在值内包含空格。</p>
<p>例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName=<span class="string">"John Doe"</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br></pre></td></tr></table></figure>
<p>将在最终image中产生相同的结果。</p>
<p><code>ENV</code>当从生成的image运行容器时，使用的环境变量将保持不变。您可以使用<code>docker inspect</code>，查看值，并使用它们进行更改<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>。</p>
<blockquote>
<p><strong>注意</strong>：环境持久性可能会导致意外的副作用。例如，设置<code>ENV DEBIAN_FRONTEND noninteractive</code>可能会使基于Debian的image上的apt-get用户感到困惑。要为单个命令设置值，请使用 <code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>。</p>
</blockquote>
<h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><p>ADD有两种形式：</p>
<ul>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> （包含空格的路径需要此表单）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：该<code>--chown</code>功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用<code>/etc/passwd</code>和<code>/etc/group</code>将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
</blockquote>
<p>该<code>ADD</code>指令从中复制新文件，目录或远程文件URL <code>&lt;src&gt;</code> ，并将它们添加到路径上image的文件系统中<code>&lt;dest&gt;</code>。</p>
<p><code>&lt;src&gt;</code>可以指定多个资源，但如果它们是文件或目录，则它们的路径将被解释为相对于构建上下文的源。</p>
<p>每个都<code>&lt;src&gt;</code>可能包含通配符，匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/        <span class="comment"># adds all files starting with "hom"</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/    <span class="comment"># ? is replaced with any single character, e.g., "home.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>的<code>&lt;dest&gt;</code>是一个绝对路径，或相对于一个路径<code>WORKDIR</code>，到其中的源将在目标容器内进行复制。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> relativeDir/          <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> /absoluteDir/         <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure>
<p>添加包含特殊字符（例如<code>[</code> 和<code>]</code>）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。例如，要添加名为的文件<code>arr[0].txt</code>，请使用以下命令;</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> arr[[]0].txt /mydir/    <span class="comment"># copy a file named "arr[0].txt" to /mydir/</span></span></span><br></pre></td></tr></table></figure>
<p>除非可选<code>--chown</code>标志指定给定用户名，组名或UID / GID组合以请求所添加内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。<code>--chown</code>标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。如果提供了用户名或组名，则容器的根文件系统 <code>/etc/passwd</code>和<code>/etc/group</code>文件将分别用于执行从名称到整数UID或GID的转换。以下示例显示了该<code>--chown</code>标志的有效定义：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=55:mygroup files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=bin files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=1 files* /somedir/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> --chown=10:11 files* /somedir/</span></span><br></pre></td></tr></table></figure>
<p>如果容器根文件系统不包含任何文件<code>/etc/passwd</code>或 <code>/etc/group</code>文件，并且<code>--chown</code> 标志中使用了用户名或组名，则构建将在<code>ADD</code>操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<p>在<code>&lt;src&gt;</code>远程文件URL 的情况下，目标将具有600的权限。如果正在检索的远程文件具有HTTP<code>Last-Modified</code>标头，则来自该标头的时间戳将用于设置<code>mtime</code>目标文件。但是，与在处理期间处理的任何其他文件一样<code>ADD</code>，<code>mtime</code>将不包括在确定文件是否已更改且应更新缓存中。</p>
<blockquote>
<p><strong>注意</strong>：如果通过传递<code>Dockerfile</code>STDIN（<code>docker build - &lt; somefile</code>）进行构建，则没有构建上下文，因此<code>Dockerfile</code> 只能包含基于URL的<code>ADD</code>指令。您还可以通过STDIN :( <code>docker build - &lt; archive.tar.gz</code>）传递压缩存档<code>Dockerfile</code>，该存档位于存档的根目录，其余存档将用作构建的上下文。</p>
<p><strong>注意</strong>：如果您的网址文件都使用认证保护，您将需要使用<code>RUN wget</code>，<code>RUN curl</code>或使用其它工具从容器内的<code>ADD</code>指令不支持验证。</p>
<p><strong>注意</strong>：<code>ADD</code>如果内容<code>&lt;src&gt;</code>已更改，则第一个遇到的指令将使来自Dockerfile的所有后续指令的高速缓存无效。这包括使缓存无效以获取<code>RUN</code>指令。</p>
</blockquote>
<p><code>ADD</code> 遵守以下规则：</p>
<ul>
<li>该<code>&lt;src&gt;</code>路径必须是内部<em>语境</em>的构建; 你不能<code>ADD ../something /something</code>，因为a的第一步 <code>docker build</code>是将上下文目录（和子目录）发送到docker守护程序。</li>
<li>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>不以尾部斜杠结尾，则从URL下载文件并将其复制到<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;src&gt;</code>是URL并且<code>&lt;dest&gt;</code>以尾部斜杠结尾，则从URL推断文件名并将文件下载到<code>&lt;dest&gt;/&lt;filename&gt;</code>。例如，<code>ADD http://example.com/foobar /</code>将创建该文件<code>/foobar</code>。URL必须具有非常重要的路径，以便在这种情况下可以发现适当的文件名（<code>http://example.com</code> 不起作用）。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li><p>如果<code>&lt;src&gt;</code>是以可识别的压缩格式（identity，gzip，bzip2或xz）的<em>本地</em> tar存档，则将其解压缩为目录。从资源<em>远程</em>网址<strong>不</strong>解压。复制或解压缩目录时，它具有与之相同的行为<code>tar -x</code>，结果是：</p>
<ol>
<li>无论在目的地路径上存在什么，</li>
<li>源树的内容，在逐个文件的基础上解决了有利于“2.”的冲突。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：文件是否被识别为可识别的压缩格式仅基于文件的内容而不是文件的名称来完成。例如，如果一个空文件碰巧结束，<code>.tar.gz</code>这将不会被识别为压缩文件，并且<strong>不会</strong>生成任何类型的解压缩错误消息，而是将文件简单地复制到目标。</p>
</blockquote>
</li>
<li><p>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠结尾<code>/</code>，则将其视为目录，<code>&lt;src&gt;</code>并将写入内容<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</p>
</li>
<li><p>如果<code>&lt;src&gt;</code>直接或由于使用通配符指定了多个资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</p>
</li>
<li><p>如果<code>&lt;dest&gt;</code>不以尾部斜杠结束，则将其视为常规文件，<code>&lt;src&gt;</code>并将写入其中的内容<code>&lt;dest&gt;</code>。</p>
</li>
<li><p>如果<code>&lt;dest&gt;</code>不存在，则会在其路径中创建所有缺少的目录。</p>
</li>
</ul>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>COPY有两种形式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> （包含空格的路径需要此表单）</li>
</ul>
<blockquote>
<p><strong>注意</strong>：该<code>--chown</code>功能仅在用于构建Linux容器的Dockerfiles上受支持，并且不适用于Windows容器。由于用户和组所有权概念不能在Linux和Windows之间进行转换，因此使用<code>/etc/passwd</code>和<code>/etc/group</code>将用户名和组名转换为ID会限制此功能仅适用于基于Linux OS的容器。</p>
</blockquote>
<p>该<code>COPY</code>指令从中复制新文件或目录<code>&lt;src&gt;</code> ，并将它们添加到路径中容器的文件系统中<code>&lt;dest&gt;</code>。</p>
<p><code>&lt;src&gt;</code>可以指定多个资源，但文件和目录的路径将被解释为相对于构建上下文的源。</p>
<p>每个都<code>&lt;src&gt;</code>可能包含通配符，匹配将使用Go的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener">filepath.Match</a>规则完成。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/        <span class="comment"># adds all files starting with "hom"</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hom?.txt /mydir/    <span class="comment"># ? is replaced with any single character, e.g., "home.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>的<code>&lt;dest&gt;</code>是一个绝对路径，或相对于一个路径<code>WORKDIR</code>，到其中的源将在目标容器内进行复制。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="built_in">test</span> relativeDir/   <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> <span class="built_in">test</span> /absoluteDir/  <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure>
<p>复制包含特殊字符（例如<code>[</code> 和<code>]</code>）的文件或目录时，需要按照Golang规则转义这些路径，以防止它们被视为匹配模式。例如，要复制名为的文件<code>arr[0].txt</code>，请使用以下命令;</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> arr[[]0].txt /mydir/    <span class="comment"># copy a file named "arr[0].txt" to /mydir/</span></span></span><br></pre></td></tr></table></figure>
<p>除非可选<code>--chown</code>标志指定给定用户名，组名或UID / GID组合以请求复制内容的特定所有权，否则将使用UID和GID为0创建所有新文件和目录。<code>--chown</code>标志的格式允许用户名和组名字符串或任意组合的直接整数UID和GID。提供没有组名的用户名或没有GID的UID将使用与GID相同的数字UID。如果提供了用户名或组名，则容器的根文件系统 <code>/etc/passwd</code>和<code>/etc/group</code>文件将分别用于执行从名称到整数UID或GID的转换。以下示例显示了该<code>--chown</code>标志的有效定义：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=55:mygroup files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=bin files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=1 files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /somedir/</span></span><br></pre></td></tr></table></figure>
<p>如果容器根文件系统不包含任何文件<code>/etc/passwd</code>或 <code>/etc/group</code>文件，并且<code>--chown</code> 标志中使用了用户名或组名，则构建将在<code>COPY</code>操作上失败。使用数字ID不需要查找，也不依赖于容器根文件系统内容。</p>
<blockquote>
<p><strong>注意</strong>：如果使用STDIN（<code>docker build - &lt; somefile</code>）构建，则没有构建上下文，因此<code>COPY</code>无法使用。</p>
</blockquote>
<p>（可选）<code>COPY</code>接受一个标志<code>--from=&lt;name|index&gt;</code>，该标志可用于将源位置设置为<code>FROM .. AS &lt;name&gt;</code>将用于替代用户发送的构建上下文的先前构建阶段（使用其创建）。该标志还接受为<code>FROM</code>指令启动的所有先前构建阶段分配的数字索引 。如果找不到具有指定名称的构建阶段，则尝试使用具有相同名称的image。</p>
<p><code>COPY</code> 遵守以下规则：</p>
<ul>
<li>该<code>&lt;src&gt;</code>路径必须是内部<em>语境</em>的构建; 你不能<code>COPY ../something /something</code>，因为a的第一步 <code>docker build</code>是将上下文目录（和子目录）发送到docker守护程序。</li>
<li>如果<code>&lt;src&gt;</code>是目录，则复制目录的全部内容，包括文件系统元数据。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：不复制目录本身，只复制其内容。</p>
</blockquote>
<ul>
<li>如果<code>&lt;src&gt;</code>是任何其他类型的文件，则将其与元数据一起单独复制。在这种情况下，如果<code>&lt;dest&gt;</code>以尾部斜杠结尾<code>/</code>，则将其视为目录，<code>&lt;src&gt;</code>并将写入内容<code>&lt;dest&gt;/base(&lt;src&gt;)</code>。</li>
<li>如果<code>&lt;src&gt;</code>直接或由于使用通配符指定了多个资源，则<code>&lt;dest&gt;</code>必须是目录，并且必须以斜杠结尾<code>/</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不以尾部斜杠结束，则将其视为常规文件，<code>&lt;src&gt;</code>并将写入其中的内容<code>&lt;dest&gt;</code>。</li>
<li>如果<code>&lt;dest&gt;</code>不存在，则会在其路径中创建所有缺少的目录。</li>
</ul>
<h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p>ENTRYPOINT有两种形式：</p>
<ul>
<li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> （<em>exec</em>形式，首选）</li>
<li><code>ENTRYPOINT command param1 param2</code> （<em>shell</em>形式）</li>
</ul>
<p><code>ENTRYPOINT</code>允许您配置将作为可执行文件运行的容器。</p>
<p>例如，以下将使用其默认内容启动nginx，侦听端口80：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t --rm -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>命令行参数<code>docker run &lt;image&gt;</code>将附加在<em>exec</em>表单中的所有元素之后<code>ENTRYPOINT</code>，并将覆盖使用的所有指定元素<code>CMD</code>。这允许将参数传递给入口点，<code>docker run &lt;image&gt; -d</code> 即将<code>-d</code>参数传递给入口点。您可以<code>ENTRYPOINT</code>使用<code>docker run --entrypoint</code> 标志覆盖指令。</p>
<p>所述<em>shell</em>形式防止任何<code>CMD</code>或<code>run</code>被使用命令行参数，但是具有你的缺点<code>ENTRYPOINT</code>将被开始作为一个子命令<code>/bin/sh -c</code>，其不通过信号。这意味着可执行文件将不是容器<code>PID 1</code>- 并且不会收到Unix信号 - 因此您的可执行文件将不会收到 <code>SIGTERM</code>来自<code>docker stop &lt;container&gt;</code>。</p>
<p>只有意志中的最后一条<code>ENTRYPOINT</code>指令<code>Dockerfile</code>才有效。</p>
<h2 id="exec-ENTRYPOINT示例"><a href="#exec-ENTRYPOINT示例" class="headerlink" title="exec ENTRYPOINT示例"></a>exec ENTRYPOINT示例</h2><p>您可以使用<em>exec</em>形式<code>ENTRYPOINT</code>设置相当稳定的默认命令和参数，然后使用任一形式<code>CMD</code>设置更可能更改的其他默认值。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"-c"</span>]</span></span><br></pre></td></tr></table></figure>
<p>运行容器时，您可以看到这<code>top</code>是唯一的进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name <span class="built_in">test</span>  top -H</span><br><span class="line">top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers</span><br><span class="line">KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top</span><br></pre></td></tr></table></figure>
<p>要进一步检查结果，您可以使用<code>docker exec</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  2.6  0.1  19752  2352 ?        Ss+  08:24   0:00 top -b -H</span><br><span class="line">root         7  0.0  0.1  15572  2164 ?        R+   08:25   0:00 ps aux</span><br></pre></td></tr></table></figure>
<p>并且您可以优雅地请求<code>docker stop test</code>来关闭<code>top</code>。</p>
<p>以下<code>Dockerfile</code>显示使用<code>ENTRYPOINT</code>在前台运行Apache（即as <code>PID 1</code>）：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stable</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/var/www"</span>, <span class="string">"/var/log/apache2"</span>, <span class="string">"/etc/apache2"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/sbin/apache2ctl"</span>, <span class="string">"-D"</span>, <span class="string">"FOREGROUND"</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果需要为单个可执行文件编写启动脚本，可以使用<code>exec</code>和<code>gosu</code> 命令确保最终的可执行文件接收Unix信号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>最后，如果您需要在关机时进行一些额外的清理（或与其他容器通信），或者协调多个可执行文件，您可能需要确保<code>ENTRYPOINT</code>脚本接收Unix信号，传递它们，然后执行一些更多的工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Note: I've written this using sh so it works in the busybox container too</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># USE the trap if you need to also do manual cleanup after the service is stopped,</span></span><br><span class="line"><span class="comment">#     or need to start multiple services in the one container</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo TRAPed signal"</span> HUP INT QUIT TERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># start service in background here</span></span><br><span class="line">/usr/sbin/apachectl start</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[hit enter key to exit] or run 'docker stop &lt;container&gt;'"</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop service and clean up here</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"stopping apache"</span></span><br><span class="line">/usr/sbin/apachectl stop</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exited <span class="variable">$0</span>"</span></span><br></pre></td></tr></table></figure>
<p>如果运行此映像<code>docker run -it --rm -p 80:80 --name test apache</code>，则可以使用<code>docker exec</code>，或检查容器的进程<code>docker top</code>，然后请求脚本停止Apache：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start</span><br><span class="line">root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux</span><br><span class="line">$ docker top <span class="built_in">test</span></span><br><span class="line">PID                 USER                COMMAND</span><br><span class="line">10035               root                &#123;run.sh&#125; /bin/sh /run.sh 123 cmd cmd2</span><br><span class="line">10054               root                /usr/sbin/apache2 -k start</span><br><span class="line">10055               33                  /usr/sbin/apache2 -k start</span><br><span class="line">10056               33                  /usr/sbin/apache2 -k start</span><br><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 0.27s</span><br><span class="line">user	0m 0.03s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong>您可以使用覆盖<code>ENTRYPOINT</code>设置<code>--entrypoint</code>，但这只能将二进制设置为<em>exec</em>（不会<code>sh -c</code>使用）。</p>
<p><strong>注意</strong>：<em>exec</em>表单被解析为JSON数组，这意味着您必须使用双引号（“）来围绕单词而不是单引号（’）。</p>
<p><strong>注意</strong>：与<em>shell</em>表单不同，<em>exec</em>表单不会调用命令shell。这意味着不会发生正常的shell处理。例如， <code>ENTRYPOINT [ &quot;echo&quot;, &quot;$HOME&quot; ]</code>不会对变量进行替换<code>$HOME</code>。如果你想要shell处理，那么要么使用<em>shell</em>表单，要么直接执行shell，例如：<code>ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>。当使用exec表单并直接执行shell时，就像shell表单的情况一样，它是执行环境变量扩展的shell，而不是docker。</p>
</blockquote>
<h2 id="Shell-ENTRYPOINT示例"><a href="#Shell-ENTRYPOINT示例" class="headerlink" title="Shell ENTRYPOINT示例"></a>Shell ENTRYPOINT示例</h2><p>您可以为<code>ENTRYPOINT</code>它指定一个纯字符串，它将在其中执行<code>/bin/sh -c</code>。此表单将使用shell处理来替换shell环境变量，并将忽略任何<code>CMD</code>或<code>docker run</code>命令行参数。为了确保能够正确地<code>docker stop</code>发出任何长时间运行的<code>ENTRYPOINT</code>可执行文件，您需要记住启动它<code>exec</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">exec</span> top -b</span></span><br></pre></td></tr></table></figure>
<p>运行此image时，您将看到单个<code>PID 1</code>进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name <span class="built_in">test</span> top</span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2/98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>
<p>哪个将彻底退出<code>docker stop</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 0.20s</span><br><span class="line">user	0m 0.02s</span><br><span class="line">sys	0m 0.04s</span><br></pre></td></tr></table></figure>
<p>如果您忘记添加<code>exec</code>到您的开头<code>ENTRYPOINT</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> top -b</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> --ignored-param1</span></span><br></pre></td></tr></table></figure>
<p>然后，您可以运行它（为下一步命名）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --name <span class="built_in">test</span> top --ignored-param2</span><br><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span><br><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.01 0.02 0.05 2/101 7</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7     1 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>
<p>您可以从输出中<code>top</code>看到指定<code>ENTRYPOINT</code>的不是<code>PID 1</code>。</p>
<p>如果然后运行<code>docker stop test</code>，容器将不会干净地退出 - <code>stop</code>命令将被强制<code>SIGKILL</code>在超时后发送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">PID   USER     COMMAND</span><br><span class="line">    1 root     /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7 root     top -b</span><br><span class="line">    8 root     ps aux</span><br><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real	0m 10.19s</span><br><span class="line">user	0m 0.04s</span><br><span class="line">sys	0m 0.03s</span><br></pre></td></tr></table></figure>
<h2 id="了解CMD和ENTRYPOINT如何相互作用"><a href="#了解CMD和ENTRYPOINT如何相互作用" class="headerlink" title="了解CMD和ENTRYPOINT如何相互作用"></a>了解CMD和ENTRYPOINT如何相互作用</h2><p> <code>CMD</code>和<code>ENTRYPOINT</code>指定运行容器时执行的命令。很少有规则描述他们的合作。</p>
<ol>
<li>Dockerfile应至少指定一个<code>CMD</code>或<code>ENTRYPOINT</code>命令。</li>
<li><code>ENTRYPOINT</code> 应该在将容器用作可执行文件时定义。</li>
<li><code>CMD</code>应该用作定义<code>ENTRYPOINT</code>命令的默认参数或在容器中执行ad-hoc命令的方法。</li>
<li><code>CMD</code> 在使用替代参数运行容器时将被覆盖。</li>
</ol>
<p>下表显示了针对不同<code>ENTRYPOINT</code>/ <code>CMD</code>组合执行的命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>No ENTRYPOINT</th>
<th>ENTRYPOINT exec_entry p1_entry</th>
<th>ENTRYPOINT [“exec_entry”，“p1_entry”]</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>No CMD</strong></td>
<td><em>error，not allowed</em></td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr>
<td><strong>CMD [“exec_cmd”，“p1_cmd”]</strong></td>
<td>exec_cmd p1_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr>
<td><strong>CMD [“p1_cmd”，“p2_cmd”]</strong></td>
<td>p1_cmd p2_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr>
<td><strong>CMD exec_cmd p1_cmd</strong></td>
<td>/ bin / sh -c exec_cmd p1_cmd</td>
<td>/ bin / sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry / bin / sh -c exec_cmd p1_cmd</td>
</tr>
</tbody>
</table>
</div>
<h1 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>VOLUME</code>指令创建具有指定名称的安装点，并将其标记为从本机主机或其他容器保存外部安装的卷。该值可以是JSON数组，<code>VOLUME [&quot;/var/log/&quot;]</code>或具有多个参数的普通字符串，例如<code>VOLUME /var/log</code>或<code>VOLUME /var/log /var/db</code>。</p>
<p><code>docker run</code>命令使用基础映像中指定位置存在的任何数据初始化新创建的卷。例如，请考虑以下Dockerfile片段：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /myvol</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /myvol</span></span><br></pre></td></tr></table></figure>
<p>此Dockerfile会<code>docker run</code>生成一个image，该image将导致创建新的挂载点<code>/myvol</code>并将<code>greeting</code>文件复制到新创建的卷中。</p>
<h2 id="有关指定卷的说明"><a href="#有关指定卷的说明" class="headerlink" title="有关指定卷的说明"></a>有关指定卷的说明</h2><p>关于卷中的卷，请记住以下事项<code>Dockerfile</code>。</p>
<ul>
<li><strong>基于Windows的容器上的卷</strong>：使用基于Windows的容器时，容器中卷的目标必须是以下之一：<ul>
<li>不存在或空目录</li>
<li>除了之外的驱动器 <code>C:</code></li>
</ul>
</li>
<li><strong>从Dockerfile中更改卷</strong>：如果任何构建步骤在声明后<strong>更改卷内的</strong>数据，那么这些更改将被丢弃。</li>
<li><strong>JSON格式</strong>：列表被解析为JSON数组。您必须用双引号（<code>&quot;</code>）而不是单引号（<code>&#39;</code>）括起单词。</li>
<li><strong>主机目录在容器运行时声明</strong>：主机目录（mountpoint）本质上是依赖于主机的。这是为了保持image的可移植性，因为不能保证给定的主机目录在所有主机上都可用。因此，您无法从Dockerfile中安装主机目录。该<code>VOLUME</code>指令不支持指定<code>host-dir</code> 参数。您必须在创建或运行容器时指定安装点。</li>
</ul>
<h1 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;] or</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>
<p><code>USER</code>运行的image和用于当任何指令设置的用户名（或UID）和任选的所述用户组（或GID）使用<code>RUN</code>，<code>CMD</code>和 <code>ENTRYPOINT</code>它后面的指令<code>Dockerfile</code>。</p>
<blockquote>
<p><strong>警告</strong>：当用户没有主要组时，image（或下一个说明）将与该<code>root</code>组一起运行。</p>
<p>在Windows上，如果用户不是内置帐户，则必须先创建用户。这可以通过<code>net user</code>作为Dockerfile的一部分调用的命令来完成。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"><span class="comment"># Create Windows user in the container</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> net user /add patrick</span></span><br><span class="line"><span class="comment"># Set it for subsequent commands</span></span><br><span class="line"><span class="keyword">USER</span> patrick</span><br></pre></td></tr></table></figure>
<h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>
<p><code>WORKDIR</code>指令集的工作目录对任何<code>RUN</code>，<code>CMD</code>， <code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code>它后面的说明<code>Dockerfile</code>。如果<code>WORKDIR</code>不存在，即使它未在任何后续<code>Dockerfile</code>指令中使用，也将创建它。</p>
<p><code>WORKDIR</code>指令可以在a中多次使用<code>Dockerfile</code>。如果提供了相对路径，则它将相对于前一条<code>WORKDIR</code>指令的路径 。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p>最终<code>pwd</code>命令的输出<code>Dockerfile</code>将是 <code>/a/b/c</code>。</p>
<p><code>WORKDIR</code>指令可以解析先前使用的环境变量 <code>ENV</code>。您只能使用显式设置的环境变量<code>Dockerfile</code>。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<p>最终<code>pwd</code>命令的输出<code>Dockerfile</code>将是 <code>/path/$DIRNAME</code></p>
<h1 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>
<p><code>ARG</code>指令定义了一个变量，用户可以<code>docker build</code>使用该<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 标志在构建时将该变量传递给构建器。如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure>
<p>Dockerfile可以包括一个或多个<code>ARG</code>指令。例如，以下是有效的Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1</span><br><span class="line"><span class="keyword">ARG</span> buildno</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告：</strong>建议不要使用构建时变量来传递密码，例如github密钥，用户凭据等<code>docker history</code>。使用该命令，构建时变量值对于映像的任何用户都是可见的。</p>
</blockquote>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>的<code>ARG</code>指令可以可选地包括一个默认值：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br><span class="line"><span class="keyword">ARG</span> buildno=<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果<code>ARG</code>指令具有默认值，并且在构建时没有传递值，则构建器将使用默认值。</p>
<h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>一个<code>ARG</code>变量定义进入从在其上在限定的线效果<code>Dockerfile</code>不从参数对命令行或其他地方使用。例如，考虑这个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="number">2</span> <span class="keyword">USER</span> $&#123;<span class="keyword">user</span>:-some_user&#125;</span><br><span class="line"><span class="number">3</span> <span class="keyword">ARG</span> <span class="keyword">user</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">USER</span> $<span class="keyword">user</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>用户通过调用以下内容构建此文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg user=what_user .</span><br></pre></td></tr></table></figure>
<p>第2行计算<code>USER``some_user</code>为<code>user</code>变量在后续第3行定义。第4行<code>USER</code>计算结果<code>what_user</code>为<code>user</code>定义，并<code>what_user</code>在命令行上传递值。在通过<code>ARG</code>指令定义之前 ，对变量的任何使用都会导致空字符串。</p>
<p>一个<code>ARG</code>指令超出范围在它被定义的构建阶段结束。要在多个阶段中使用arg，每个阶段都必须包含该<code>ARG</code>指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> SETTINGS</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./run/setup <span class="variable">$SETTINGS</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> SETTINGS</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ./run/other <span class="variable">$SETTINGS</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用ARG变量"><a href="#使用ARG变量" class="headerlink" title="使用ARG变量"></a>使用ARG变量</h2><p>您可以使用<code>ARG</code>或<code>ENV</code>指令指定指令可用的变量<code>RUN</code>。使用该<code>ENV</code>指令定义的环境变量 始终覆盖<code>ARG</code>同名指令。考虑这个Dockerfile和一个<code>ENV</code>和<code>ARG</code>指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER v1.<span class="number">0.0</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>然后，假设使用此命令构建此映像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg CONT_IMG_VER=v2.0.1 .</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>RUN</code>指令使用<code>v1.0.0</code>而不是<code>ARG</code>用户传递的设置：<code>v2.0.1</code>此行为类似于shell脚本，其中本地范围的变量覆盖作为参数传递的变量或从其定义的环境继承的变量。</p>
<p>使用上面的示例但不同的<code>ENV</code>规范，您可以在指令<code>ARG</code>和<code>ENV</code>指令之间创建更有用的交互：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.<span class="number">0.0</span>&#125;</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>与<code>ARG</code>指令不同，<code>ENV</code>值始终保留在构建的image中。考虑没有<code>--build-arg</code>标志的docker构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build .</span><br></pre></td></tr></table></figure>
<p>使用此Dockerfile示例<code>CONT_IMG_VER</code>仍然保留在image中，但其值将是指令<code>v1.0.0</code>中第3行的默认值<code>ENV</code>。</p>
<h2 id="预定义的ARG"><a href="#预定义的ARG" class="headerlink" title="预定义的ARG"></a>预定义的ARG</h2><p>Docker有一组预定义<code>ARG</code>变量，您可以<code>ARG</code>在Dockerfile中使用相应的指令。</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<p>要使用它们，只需使用标志在命令行上传递它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--build-arg &lt;varname&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，这些预定义变量将从输出中排除 <code>docker history</code>。排除它们可以降低在<code>HTTP_PROXY</code>变量中意外泄露敏感验证信息的风险。</p>
<p>例如，考虑使用构建以下Dockerfile<code>--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>HTTP_PROXY</code>变量的值在<code>docker history</code>和中不可用， 并且不会被缓存。如果您要更改位置，并且您的代理服务器已更改为<code>http://user:pass@proxy.sfo.example.com</code>，则后续构建不会导致缓存未命中。</p>
<p>如果需要覆盖此行为，则可以通过<code>ARG</code> 在Dockerfile中添加语句来执行此操作，如下所示：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ARG</span> HTTP_PROXY</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello World"</span></span></span><br></pre></td></tr></table></figure>
<p>构建此Dockerfile时，<code>HTTP_PROXY</code>会保留在其中 <code>docker history</code>，并且更改其值会使构建缓存无效。</p>
<h2 id="对构建缓存的影响"><a href="#对构建缓存的影响" class="headerlink" title="对构建缓存的影响"></a>对构建缓存的影响</h2><p><code>ARG</code>变量不会像<code>ENV</code>变量那样持久保存在构建的image中。但是，<code>ARG</code>变量确实以类似的方式影响构建缓存。如果Dockerfile定义了一个<code>ARG</code>值与前一个版本不同的变量，则在第一次使用时会发生“缓存未命中”，而不是其定义。特别是，<code>RUN</code>指令后面的所有指令都 隐式<code>ARG</code>使用<code>ARG</code>变量（作为环境变量），因此可能导致高速缓存未命中。<code>ARG</code>除非在中包含匹配的<code>ARG</code>语句，否则所有预定义变量都将免于缓存<code>Dockerfile</code>。</p>
<p>例如，考虑这两个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure>
<p>如果<code>--build-arg CONT_IMG_VER=&lt;value&gt;</code>在命令行中指定，则在两种情况下，第2行上的规范都不会导致高速缓存未命中; 第3行确实导致缓存未命中。<code>ARG CONT_IMG_VER</code>导致RUN行被识别为与运行<code>CONT_IMG_VER=&lt;value&gt;</code>echo hello 相同，因此如果<code>&lt;value&gt;</code> 更改，我们将获得缓存未命中。</p>
<p>考虑同一命令行下的另一个示例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER $CONT_IMG_VER</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>在此示例中，高速缓存未命中发生在第3行。发生未命中是因为<code>ENV</code>引用<code>ARG</code>变量的变量值和通过命令行更改了该变量。在此示例中，该<code>ENV</code> 命令使image包含该值。</p>
<p>如果一条<code>ENV</code>指令覆盖了一个<code>ARG</code>同名的指令，比如这个Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="number">2</span> <span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="number">3</span> <span class="keyword">ENV</span> CONT_IMG_VER hello</span><br><span class="line"><span class="number">4</span> <span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>
<p>第3行不会导致缓存未命中，因为值为<code>CONT_IMG_VER</code>常量（<code>hello</code>）。因此，<code>RUN</code>（第4行）上使用的环境变量和值在构建之间不会发生变化。</p>
<h1 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<p>当image用作另一个构建的基础时，该<code>ONBUILD</code>指令向image添加将在稍后执行的<em>触发</em>指令。触发器将在下游构建的上下文中执行，就好像它已经<code>FROM</code>在下游指令之后立即插入一样<code>Dockerfile</code>。</p>
<p>任何构建指令都可以注册为触发器。</p>
<p>如果要构建将用作构建其他映像的基础的映像（例如，可以使用特定于用户的配置自定义的应用程序构建环境或守护程序），这将非常有用。</p>
<p>例如，如果您的映像是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要<em>在</em> 此<em>之后</em>调用构建脚本。你不能只是打电话<code>ADD</code>和<code>RUN</code>现在，因为你还没有访问应用程序的源代码，这将是为每个应用程序生成不同的。您可以简单地为应用程序开发人员提供<code>Dockerfile</code>复制粘贴到他们的应用程序中的样板，但这样做效率低，容易出错且难以更新，因为它与特定于应用程序的代码混合在一起。</p>
<p>解决方案是用于<code>ONBUILD</code>在下一个构建阶段注册预先指令以便稍后运行。</p>
<p>以下是它的工作原理：</p>
<ol>
<li>当遇到<code>ONBUILD</code>指令时，构建器会向正在构建的image的元数据添加触发器。该指令不会影响当前构建。</li>
<li>在构建结束时，所有触发器的列表存储在键下的image清单中<code>OnBuild</code>。可以使用该<code>docker inspect</code>命令检查它们。</li>
<li>稍后，可以使用该<code>FROM</code>指令将image用作新构建的基础 。作为处理<code>FROM</code>指令的一部分，下游构建器查找<code>ONBUILD</code>触发器，并按照它们注册的顺序执行它们。如果任何触发器失败，<code>FROM</code>则中止指令，这反过来导致构建失败。如果所有触发器都成功，则<code>FROM</code>指令完成并且构建继续照常进行。</li>
<li>执行后，触发器将从最终image中清除。换句话说，它们不是由“大孩子”构建继承的。</li>
</ol>
<p>例如，您可以添加以下内容：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong>：不允许<code>ONBUILD</code>使用链接指令<code>ONBUILD ONBUILD</code>。</p>
<p><strong>警告</strong>：<code>ONBUILD</code>指令可能不会触发<code>FROM</code>或<code>MAINTAINER</code>指令。</p>
</blockquote>
<h1 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br></pre></td></tr></table></figure>
<p>该<code>STOPSIGNAL</code>指令设置将发送到容器的系统调用信号以退出。此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，例如9，或SIGNAME格式的信号名，例如SIGKILL。</p>
<h1 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h1><p><code>HEALTHCHECK</code>指令有两种形式：</p>
<ul>
<li><code>HEALTHCHECK [OPTIONS] CMD command</code> （通过在容器内运行命令来检查容器运行状况）</li>
<li><code>HEALTHCHECK NONE</code> （禁用从基础映像继承的任何运行状况检查）</li>
</ul>
<p>该<code>HEALTHCHECK</code>指令告诉Docker如何测试容器以检查它是否仍在工作。即使服务器进程仍在运行，这也可以检测到陷入无限循环且无法处理新连接的Web服务器等情况。</p>
<p>当容器指定了<em>运行状况检查时</em>，除了正常状态外，它还具有<em>运行</em>状况。这个状态最初是<code>starting</code>。每当健康检查通过时，它就会变成<code>healthy</code>（以前的状态）。经过一定数量的连续失败后，它就变成了<code>unhealthy</code>。</p>
<p>之前可以出现的选项<code>CMD</code>是：</p>
<ul>
<li><code>--interval=DURATION</code>（默认值：<code>30s</code>）</li>
<li><code>--timeout=DURATION</code>（默认值：<code>30s</code>）</li>
<li><code>--start-period=DURATION</code>（默认值：<code>0s</code>）</li>
<li><code>--retries=N</code>（默认值：<code>3</code>）</li>
</ul>
<p>运行状况检查将首先在容器启动后的<strong>间隔</strong>秒运行，然后在每次上一次检查完成后再<strong>间隔</strong>秒。</p>
<p>如果单次运行的检查花费的时间超过<strong>超时</strong>秒数，那么检查将被视为失败。</p>
<p>它需要<strong>重试</strong>连续的健康检查失败才能考虑容器<code>unhealthy</code>。</p>
<p><strong>start period</strong>为需要时间引导的容器提供初始化时间。在此期间探测失败将不计入最大重试次数。但是，如果在启动期间运行状况检查成功，则会将容器视为已启动，并且所有连续失败将计入最大重试次数。</p>
<p><code>HEALTHCHECK</code>Dockerfile中只能有一条指令。如果列出多个，则只有最后一个<code>HEALTHCHECK</code>生效。</p>
<p><code>CMD</code>关键字后面的命令可以是shell命令（例如<code>HEALTHCHECK CMD /bin/check-running</code>）或<em>exec</em>数组（与其他Dockerfile命令一样; <code>ENTRYPOINT</code>有关详细信息，请参阅参考资料）。</p>
<p>命令的退出状态指示容器的运行状况。可能的值是：</p>
<ul>
<li>0：成功 - 容器健康且随时可用</li>
<li>1：不健康 - 容器无法正常工作</li>
<li>2：保留 - 不要使用此退出代码</li>
</ul>
<p>例如，要检查每五分钟左右网络服务器能够在三秒钟内为网站的主页面提供服务：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5m --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）将存储在运行状况中并可以使用查询 <code>docker inspect</code>。此类输出应保持较短（目前仅存储前4096个字节）。</p>
<p>当容器的运行状况更改时，将<code>health_status</code>生成具有新状态的事件。</p>
<p>该<code>HEALTHCHECK</code>功能已添加到Docker 1.12中。</p>
<h1 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"parameters"</span>]</span></span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>指令允许覆盖用于<em>shell</em>形式的命令的默认shell 。Linux上的默认shell是<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>，而在Windows上<code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>。该<code>SHELL</code>指令<em>必须</em>以JSON格式写入Dockerfile。</p>
<p>的<code>SHELL</code>：其中有两个常用的和完全不同的原生贝壳指令是在Windows上特别有用<code>cmd</code>和<code>powershell</code>，以及提供包括候补炮弹<code>sh</code>。</p>
<p>该<code>SHELL</code>指令可以多次出现。每条<code>SHELL</code>指令都会覆盖所有先前的<code>SHELL</code>指令，并影响所有后续指令。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C powershell -command Write-Host default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> powershell -<span class="built_in">command</span> Write-Host default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as powershell -command Write-Host hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"powershell"</span>, <span class="string">"-command"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> Write-Host hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"cmd"</span>, <span class="string">"/S"</span>, <span class="string">"/C"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure>
<p>以下说明可以通过影响<code>SHELL</code>指令时， <em>壳</em>他们的形式在一个Dockerfile使用：<code>RUN</code>，<code>CMD</code>和<code>ENTRYPOINT</code>。</p>
<p>以下示例是在Windows上找到的常见模式，可以使用以下<code>SHELL</code>指令简化：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> powershell -<span class="built_in">command</span> Execute-MyCmdlet -param1 <span class="string">"c:\foo.txt"</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>docker调用的命令将是：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmd</span><span class="bash"> /S /C powershell -<span class="built_in">command</span> Execute-MyCmdlet -param1 <span class="string">"c:\foo.txt"</span></span></span><br></pre></td></tr></table></figure>
<p>由于两个原因，这是低效的。首先，调用一个不必要的cmd.exe命令处理器（也就是shell）。其次，<em>shell</em> 形式的每条<code>RUN</code>指令都需要额外的命令前缀。<code>powershell -command</code></p>
<p>为了提高效率，可以采用两种机制中的一种。一种是使用RUN命令的JSON形式，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"powershell"</span>, <span class="string">"-command"</span>, <span class="string">"Execute-MyCmdlet"</span>, <span class="string">"-param1 \"c:\\foo.txt\""</span>]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>虽然JSON表单是明确的，并且不使用不必要的cmd.exe，但它确实需要通过双引号和转义更加详细。替代机制是使用<code>SHELL</code>指令和<em>shell</em>表单，为Windows用户创建更自然的语法，尤其是与<code>escape</code>解析器指令结合使用时：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> microsoft/nanoserver</span><br><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"powershell"</span>,<span class="string">"-command"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> New-Item -ItemType Directory C:\Example</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> Execute-MyCmdlet.ps1 c:\example\</span></span><br><span class="line"><span class="bash">RUN c:\example\Execute-MyCmdlet -sample <span class="string">'hello world'</span></span></span><br></pre></td></tr></table></figure>
<p>导致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt; docker build -t shell .</span><br><span class="line">Sending build context to Docker daemon 4.096 kB</span><br><span class="line">Step 1&#x2F;5 : FROM microsoft&#x2F;nanoserver</span><br><span class="line"> ---&gt; 22738ff49c6d</span><br><span class="line">Step 2&#x2F;5 : SHELL powershell -command</span><br><span class="line"> ---&gt; Running in 6fcdb6855ae2</span><br><span class="line"> ---&gt; 6331462d4300</span><br><span class="line">Removing intermediate container 6fcdb6855ae2</span><br><span class="line">Step 3&#x2F;5 : RUN New-Item -ItemType Directory C:\Example</span><br><span class="line"> ---&gt; Running in d0eef8386e97</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: C:\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----       10&#x2F;28&#x2F;2016  11:26 AM                Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ---&gt; 3f2fbf1395d9</span><br><span class="line">Removing intermediate container d0eef8386e97</span><br><span class="line">Step 4&#x2F;5 : ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line"> ---&gt; a955b2621c31</span><br><span class="line">Removing intermediate container b825593d39fc</span><br><span class="line">Step 5&#x2F;5 : RUN c:\example\Execute-MyCmdlet &#39;hello world&#39;</span><br><span class="line"> ---&gt; Running in be6d8e63fe75</span><br><span class="line">hello world</span><br><span class="line"> ---&gt; 8e559e9bf424</span><br><span class="line">Removing intermediate container be6d8e63fe75</span><br><span class="line">Successfully built 8e559e9bf424</span><br><span class="line">PS E:\docker\build\shell&gt;</span><br></pre></td></tr></table></figure>
<p><code>SHELL</code>指令还可用于修改shell的运行方式。例如，<code>SHELL cmd /S /C /V:ON|OFF</code>在Windows上使用，可以修改延迟的环境变量扩展语义。</p>
<p>的<code>SHELL</code>，也可以在Linux上使用的指令应当替代壳需要如<code>zsh</code>，<code>csh</code>，<code>tcsh</code>和其他。</p>
<p>该<code>SHELL</code>功能已添加到Docker 1.12中。</p>
<h1 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span>      ubuntu</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> Description=<span class="string">"This image is used to start the foobar executable"</span> Vendor=<span class="string">"ACME Products"</span> Version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y inotify-tools nginx apache2 openssh-server</span></span><br><span class="line"><span class="comment"># Firefox over VNC</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install vnc, xvfb in order to create a 'fake' display and firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir ~/.vnc</span></span><br><span class="line"><span class="comment"># Setup a password</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> x11vnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class="line"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> bash -c <span class="string">'echo "firefox" &gt;&gt; /.bashrc'</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5900</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash">    [<span class="string">"x11vnc"</span>, <span class="string">"-forever"</span>, <span class="string">"-usepw"</span>, <span class="string">"-create"</span>]</span></span><br><span class="line"><span class="comment"># Multiple images example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> foo &gt; bar</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 907ad6c2736f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> moo &gt; oink</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 695d7793cbe4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You'll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span><br><span class="line"><span class="comment"># /oink.</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker构建应用</title>
    <url>/2018/09/15/Linux/container/docker/Building-applications-with-docker/</url>
    <content><![CDATA[<h1 id="如何保持图像小"><a href="#如何保持图像小" class="headerlink" title="如何保持图像小"></a>如何保持图像小</h1><p>在启动容器或服务时，小图像可以更快地通过网络，并且可以更快地加载到内存中。有一些经验法则可以保持图像尺寸小：</p>
<ul>
<li><p>从适当的基本图像开始。例如，如果您需要JDK，请考虑将您的图像基于官方<code>openjdk</code>图像，而不是从通用<code>ubuntu</code>图像开始并<code>openjdk</code>作为Dockerfile的一部分进行安装。</p>
</li>
<li><p>使用多级构建。例如，您可以使用该<code>maven</code>映像构建Java应用程序，然后重置为<code>tomcat</code>映像并将Java工件复制到正确的位置以部署您的应用程序，所有这些都在同一个Dockerfile中。这意味着您的最终图像不包含构建所引入的所有库和依赖项，而只包含运行它们所需的工件和环境。</p>
<ul>
<li><p>如果您需要使用不包含多级构建的Docker版本，请尝试通过最小化<code>RUN</code>Dockerfile 中单独命令的数量来减少图像中的图层数。您可以通过将多个命令合并为<code>RUN</code>一行并使用shell的机制将它们组合在一起来实现此目的。考虑以下两个片段。第一个在图像中创建两个图层，而第二个图层仅创建一个图层。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y python</span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get -y update &amp;&amp; apt-get install -y python</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果您有多个共同点的图像，请考虑使用共享组件创建自己的基本图像，并在其上创建独特的图像。Docker只需要加载公共层一次，然后缓存它们。这意味着您的衍生图像可以更有效地使用Docker主机上的内存并加载更快。</p>
</li>
<li><p>要使生产映像保持精简但允许调试，请考虑使用生产映像作为调试映像的基本映像。可以在生产映像之上添加其他测试或调试工具。</p>
</li>
<li><p>在构建图像时，始终使用有用的标记对其进行标记，这些标记用于编码版本信息，预期目标（<code>prod</code>或者<code>test</code>，例如），稳定性或在不同环境中部署应用程序时有用的其他信息。不要依赖自动创建的<code>latest</code>标签。</p>
<a id="more"></a>
<h1 id="在何处以及如何保留应用程序数据"><a href="#在何处以及如何保留应用程序数据" class="headerlink" title="在何处以及如何保留应用程序数据"></a>在何处以及如何保留应用程序数据</h1></li>
<li><p><strong>避免</strong>使用存储驱动程序将应用程序数据存储在容器的可写层中 。这会增加容器的大小，从I/O角度来看，与使用卷或绑定装载相比效率较低。</p>
</li>
<li>而是使用卷存储数据。</li>
<li>适合使用<code>bind mounts</code>的一种情况 是在开发期间，您可能希望将源目录或刚刚构建的二进制文件挂载到容器中。对于生产，请使用卷，将其安装到与开发期间装入绑定装置相同的位置。</li>
<li>对于生产，使用<code>secrets</code>来存储服务使用的敏感应用程序数据，并对 配置文件等非敏感数据使用<code>configs</code>。如果您当前使用独立容器，请考虑迁移以使用单一副本服务，以便您可以利用这些仅限服务的功能。</li>
</ul>
<h1 id="使用CI-CD进行测试和部署"><a href="#使用CI-CD进行测试和部署" class="headerlink" title="使用CI/CD进行测试和部署"></a>使用CI/CD进行测试和部署</h1><ul>
<li>当您检查对源代码管理的更改或创建拉取请求时，请使用CI/CD自动构建和标记Docker镜像并对其进行测试。</li>
</ul>
<h1 id="开发和生产环境的差异"><a href="#开发和生产环境的差异" class="headerlink" title="开发和生产环境的差异"></a>开发和生产环境的差异</h1><div class="table-container">
<table>
<thead>
<tr>
<th>发展</th>
<th>生产</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用<code>bind mounts</code>为您的容器提供对源代码的访问权限。</td>
<td>使用卷来存储容器数据。</td>
</tr>
<tr>
<td>使用Docker for Mac或Docker for Windows。</td>
<td>如果可能，请使用Docker EE，并使用<code>userns-remap</code>以更好地隔离Docker进程与主机进程。</td>
</tr>
<tr>
<td>不要担心时间漂移。</td>
<td>始终在Docker主机上和每个容器进程内运行NTP客户端，并将它们全部同步到同一个NTP服务器。如果使用swarm服务，还要确保每个Docker节点将其时钟与容器同步到同一时间源。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker简单介绍</title>
    <url>/2018/09/15/Linux/container/docker/Docker101/</url>
    <content><![CDATA[<p>记得第一次知道容器这个词是2016年（技术渣），那时Openstack还如日中天，我安装了一个Ubuntu，翻了翻文档， 百度看了下仅有的几个博客，用蹩脚的操作安装上Docker（那时还部分ce，ee）就那几分钟，Docker就可以实现部署好几种应用来完成我的测试，发现docker这真是个神器，到今天为止，我也没有玩明白docker（没有长期的投入实践），包括以后的Kubernetes，Openshift，Rancher等等这些PaaS平台，也仅仅是部署，这里就不说原因了；从今天起，开始复习这些略识之无的东西，今天先复习一下命令。<br><a id="more"></a></p>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p><em>这里以Centos7为例：</em></p>
<ol>
<li>卸载系统自带的docker</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove -y docker  docker-client  docker-client-latest  docker-common  docker-latest  docker-latest-logrotate  docker-logrotate  docker-selinux  docker-engine-selinux  docker-engine</span><br></pre></td></tr></table></figure>
<ol>
<li>添加Docker yum存储库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装docker-ce</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>
<ol>
<li>启动docker服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker ; systemctl start docker</span><br></pre></td></tr></table></figure>
<ol>
<li>测试</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p><em>如果需要卸载 记得卸载后删除 <code>/var/lib/docker</code>目录</em></p>
<h1 id="Docker-概念"><a href="#Docker-概念" class="headerlink" title="Docker 概念"></a>Docker 概念</h1><p>Docker是开发人员和系统管理员 使用容器开发，部署和运行应用程序的平台。使用Linux容器部署应用程序称为容器化。容器不是新的，但它们用于轻松部署应用程序。</p>
<p><strong>容器化越来越受欢迎，因为容器是：</strong></p>
<ul>
<li>灵活：即使是最复杂的应用也可以集装箱化。</li>
<li>轻量级：容器利用并共享主机内核。</li>
<li>可互换：您可以即时部署更新和升级。</li>
<li>便携式：您可以在本地构建，部署到云，并在任何地方运行。</li>
<li>可扩展：您可以增加并自动分发容器副本。</li>
<li>可堆叠：您可以垂直和即时堆叠服务。</li>
</ul>
<h2 id="images-和-containers"><a href="#images-和-containers" class="headerlink" title="images 和 containers"></a>images 和 containers</h2><p>通过运行image启动容器，一个image是一个可执行的包，其中包括运行程序所需的所有内容和代码、运行时环境、依赖库、环境变量和配置文件。</p>
<p>这里不说内部实现，从目的来看，启动一个容器的目的是为了运行一个程序，虚拟机则是安装配置一个应用程序，容器可以省去一些重复工作， 提高效率；容器运行， 在操作系统看来，就是一个独立进程，完成了沙盒应用的功能，而虚拟机则运行了一个“完整的GuestOS”，通过虚拟机管理程序（hypervisor ）对主机进行虚拟访问。</p>
<h1 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h1><h2 id="基本信息查看命令"><a href="#基本信息查看命令" class="headerlink" title="基本信息查看命令"></a>基本信息查看命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## List Docker CLI commands</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Display Docker version and info</span></span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment">## Execute Docker image</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker images</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker containers (running, all, all in quiet mode)</span></span><br><span class="line">docker container ls</span><br><span class="line">docker container ls --all</span><br><span class="line">docker container ls -aq</span><br></pre></td></tr></table></figure>
<h2 id="简单Dockerfile"><a href="#简单Dockerfile" class="headerlink" title="简单Dockerfile"></a>简单Dockerfile</h2><p><em>Dockerfile例子</em><br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make port 80 available to the world outside this container</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define environment variable</span></span><br><span class="line"><span class="keyword">ENV</span> NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run app.py when the container launches</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure></p>
<p><em>基于Dockerfile构建应用镜像</em><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t image-name .</span><br></pre></td></tr></table></figure></p>
<p>查看基于Dockerfile构建的镜像<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure></p>
<p><em>运行容器</em><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 4321:80 testimage</span><br></pre></td></tr></table></figure><br><em>待容器运行，会基于名为testimage的镜像后台运行一个容器，并且将容器内部的80端口映射到本机4321端口，如果容器80端口将可以访问，现在则可以访问宿主机<code>ip:4321</code>来访问容器内部的80端口。</em></p>
<h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p><em>可以将本地的镜像发布到dockerhub， 随处下载运行自己的镜像，</em><br>首先你需要创建一个<a href="https://hub.docker.com" target="_blank" rel="noopener">dockerhub</a>账户.</p>
<h3 id="本地登录dockerhub"><a href="#本地登录dockerhub" class="headerlink" title="本地登录dockerhub"></a>本地登录dockerhub</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>
<h3 id="标记镜像"><a href="#标记镜像" class="headerlink" title="标记镜像"></a>标记镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br></pre></td></tr></table></figure>
<p>例如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag testimage xieth/mytestimage:v1</span><br></pre></td></tr></table></figure></p>
<p>查看新标记的image<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两行命令功能相同</span></span><br><span class="line">docker image ls</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><br>现在可以从其他计算机运行刚才发布的镜像了。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 4321:80 xieth/mytestimage:v1</span><br></pre></td></tr></table></figure></p>
<h3 id="基本命令整理"><a href="#基本命令整理" class="headerlink" title="基本命令整理"></a>基本命令整理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t friendlyhello .  <span class="comment"># Create image using this directory's Dockerfile</span></span><br><span class="line">docker run -p 4000:80 friendlyhello  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></span><br><span class="line">docker run -d -p 4000:80 friendlyhello         <span class="comment"># Same thing, but in detached mode</span></span><br><span class="line">docker container ls                                <span class="comment"># List all running containers</span></span><br><span class="line">docker container ls -a             <span class="comment"># List all containers, even those not running</span></span><br><span class="line">docker container stop &lt;<span class="built_in">hash</span>&gt;           <span class="comment"># Gracefully stop the specified container</span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;         <span class="comment"># Force shutdown of the specified container</span></span><br><span class="line">docker container rm &lt;<span class="built_in">hash</span>&gt;        <span class="comment"># Remove specified container from this machine</span></span><br><span class="line">docker container rm $(docker container ls -a -q)         <span class="comment"># Remove all containers</span></span><br><span class="line">docker image ls -a                             <span class="comment"># List all images on this machine</span></span><br><span class="line">docker image rm &lt;image id&gt;            <span class="comment"># Remove specified image from this machine</span></span><br><span class="line">docker image rm $(docker image ls -a -q)   <span class="comment"># Remove all images from this machine</span></span><br><span class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></span><br><span class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>docker 的命令风格跟linux几乎一样，忘了直接<code>docker --help</code> 看下帮助，其实这些命令就现在看来几乎用不上，现在大家都在关注容器上层的集群编排，大部分不需要用手动敲命令来一个个实现， 而是通过标记语言yaml来实现容器的构建与运行。</p>
]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计</title>
    <url>/2018/09/11/Program-design/Object-oriented-programming/</url>
    <content><![CDATA[<p><strong>面向对象程序设计</strong></p>
<p><strong>对象</strong></p>
<ul>
<li>万物皆为对象</li>
<li>包含一定的数据结构和状态的实体，称为对象</li>
<li>作用于对象的行为（如访问和处理对象的状态），称为操作（operation）</li>
</ul>
<h1 id="面向对象（Objective-Orientation，OO）"><a href="#面向对象（Objective-Orientation，OO）" class="headerlink" title="面向对象（Objective Orientation，OO）"></a>面向对象（Objective Orientation，OO）</h1><ol>
<li>以==对象==为核心</li>
<li>先构造与整个系统（问题）相关的各个对象，描述他们的状态，他们的行为，然后通过消息来调动这些对象，让他们来解决这个问题</li>
<li>==程序 = 对象 + 消息==</li>
<li>面向对象将对象作为软件系统结构的基本组成单元，以主体数据为中心，将数据及其上作用的操作一起封装，以标准的接口规范对外提供服务<a id="more"></a>
<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1></li>
</ol>
<p><strong>更易理解</strong></p>
<ul>
<li>用更利于人理解的方法对复杂系统进行分析、设计与编程。</li>
</ul>
<p><strong>更高效</strong></p>
<ul>
<li>面向对象能有效提高编程的效率，通过封装技术，消息机制可以像搭积木的一样快速开发出一个全新的系统，</li>
</ul>
<p>可重用性，可维护性更好。</p>
<p><em>再面向过程的思想中，编程者更像是一个==独裁者==，一个==执行者==；</em></p>
<p><em>面向对象的思想中，编程者更像是一部==电影的导演==。他组织剧组里的成员，交代分工和工作时的互相配合，然后再启动拍摄后退居到幕后，具体工作由收下按照他早已做好的安排来完成。</em></p>
<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><ul>
<li>开车时，引擎之于司机；</li>
<li>定义对象的操作，==只提供抽象的接口，并隐藏他们的具体实现==，称为封装。</li>
<li>面向对象封装了数据和逻辑，具有==更好的信息隐藏能力==。</li>
</ul>
<h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><ul>
<li>子类（也称派生类）对象拥有与其基类（也称父类）相同的全部属性和方法，</li>
</ul>
<h2 id="多态性（Poymorphism）"><a href="#多态性（Poymorphism）" class="headerlink" title="多态性（Poymorphism）"></a>多态性（Poymorphism）</h2><ul>
<li>多态是指在基本类中定义的属性或行为被子类继承后，==可以有不同的数据类型或行为特征==，多态性使程序可以按照他们的共同特征来书写</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>分治</title>
    <url>/2018/08/24/Program-design/Divide-and-conquer%20/</url>
    <content><![CDATA[<h1 id="分治的基本思想"><a href="#分治的基本思想" class="headerlink" title="分治的基本思想"></a>分治的基本思想</h1><p><strong>分治（Divide and Conquer）</strong></p>
<ul>
<li>分而治之，是处理复杂问题的一个最基本、也最常用的策略之一</li>
</ul>
<p><strong>基本思想</strong></p>
<p>规模为N的原始问题 ==&gt; 若干规模较小的同类子问题 ==&gt;  若干规模更小的同类子问题 ==&gt; 直接求解规模更小的子问题 ==&gt; 将各个子问题的解合并为原问题的解</p>
<p><strong>分治的实例———找假币</strong></p>
<p><em>12个一模一样的硬币，已知==只有一枚是假币==，并且假币和真币的重量不一样（假设假币比真币轻），问如何用一个天平把假币从这12枚硬币中找出来，只能称3次</em></p>
<ol>
<li>最简单的办法： 直接求解的找假币问题： 2枚称1次</li>
<li>稍复杂的：3枚，需要称几次？</li>
<li>分治法 + 排除法<ol>
<li>12枚分成两等份，每份6枚；</li>
<li>假币那端的6枚再次分为两等分，每份3枚；</li>
<li>有假币的那一端的3枚硬币中任意取出2个去称重。</li>
</ol>
</li>
<li>分治法<ol>
<li>把12枚硬币分成3等份，每份4枚；</li>
<li>在有假币的那一端的4枚硬币中，任取两枚到天平两端去称重；</li>
<li>若假币在余下的那两枚中，则把这两枚硬币放到天平两端去称重。</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h1 id="典型分治的方法"><a href="#典型分治的方法" class="headerlink" title="典型分治的方法"></a>典型分治的方法</h1><ul>
<li>最常用的是二分法<ul>
<li>每次将原问题分解为两个子问题<ul>
<li>一分为二的哲学思想的应用</li>
<li>许多经典的算法，并归排序、拆半查找、二分法就方程的根等</li>
</ul>
</li>
<li>合并是算法的关键<ul>
<li>无统一的模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="分治的实例"><a href="#分治的实例" class="headerlink" title="分治的实例"></a>分治的实例</h1><ul>
<li>归并排序<ul>
<li>将相邻的两个有序数列合并成一个新的有序数列：总是取两个剩余序列中排在前面的最小数放到合并后的序列中，</li>
</ul>
</li>
</ul>
<p>分治方法给我们的哲学思考——换一个角度，一分为二地观察和思考问题，</p>
<ul>
<li>化繁为简</li>
<li>化难为易</li>
<li>化大为小</li>
<li>化未知为已知</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Yum</title>
    <url>/2018/08/24/Linux/CentOSYum/</url>
    <content><![CDATA[<p><strong>Yum</strong>是Red Hat软件包管理器，它能够查询有关可用软件包的信息，从存储库获取软件包，安装和卸载软件包，以及将整个系统更新到最新的可用版本。Yum在更新，安装或删除软件包时执行自动依赖性解析，因此能够自动确定，获取和安装所有可用的依赖软件包。</p>
<p>Yum可以配置新的，额外的存储库或<em>包源</em>，还提供许多增强和扩展其功能的插件。百胜可以执行许多与<strong>RPM</strong>相同的任务; 此外，许多命令行选项都是类似的。Yum可以在一台计算机或一组计算机上轻松简单地进行包管理。</p>
<a id="more"></a>
<h1 id="检查和更新包"><a href="#检查和更新包" class="headerlink" title="检查和更新包"></a>检查和更新包</h1><p>通过Yum，可以检查系统是否有等待应用的更新。可以列出需要更新的软件包并将其作为整体进行更新，也可以更新选定的单个软件包。</p>
<h2 id="查询更新"><a href="#查询更新" class="headerlink" title="查询更新"></a>查询更新</h2><p>要查看系统上哪些已安装的软件包具有可用更新，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum check-update</span><br></pre></td></tr></table></figure>
<p><em>yum check-update 的输出类似这样：</em></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/yum1.jpg" alt="yum check-update output"></p>
<h2 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h2><p>您可以选择一次更新单个包，多个包或所有包。如果您更新的软件包或软件包的任何依赖项本身都有可用的更新，那么它们也会更新。</p>
<h3 id="更新单个包"><a href="#更新单个包" class="headerlink" title="更新单个包"></a>更新单个包</h3><p>要更新单个程序包，请运行以下命令<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update 包名</span><br></pre></td></tr></table></figure>
<p>yum 提供更新信息，然后提示您确认更新; yum默认以交互方式运行。如果您已经知道<code>yum</code>命令计划执行哪些事务，则可以使用该<code>-y</code>选项自动回答<code>yes</code> yum请求的任何问题（在这种情况下，它以非交互方式运行）。但是，您应该始终检查yum计划对系统进行哪些更改，以便您可以轻松解决可能出现的任何问题。您也可以选择下载软件包而无需安装它。为此，请<code>d</code>在下载提示中选择该选项。这将启动所选包的后台下载。</p>
<p>如果事务失败，您可以使用<code>yum history</code>所述的命令查看yum事务历史。</p>
<p>无论您是否使用<code>yum update</code>或<code>yum install</code>命令，Yum始终<em>会安装</em>新内核。</p>
<p>当使用<strong>RPM</strong>，而另一方面，它使用是很重要的<code>rpm -i kernel</code>，其安装一个新的内核，而不是命令<code>rpm -u kernel</code>其<em>替换</em>当前内核。</p>
<p>同样，可以更新包组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group update 组名</span><br></pre></td></tr></table></figure>
<h4 id="更新所有包及其依赖项"><a href="#更新所有包及其依赖项" class="headerlink" title="更新所有包及其依赖项"></a>更新所有包及其依赖项</h4><p>要更新所有包及其依赖项，请使用<code>yum update</code>不带任何参数的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>
<h3 id="更新与安全相关的包"><a href="#更新与安全相关的包" class="headerlink" title="更新与安全相关的包"></a>更新与安全相关的包</h3><p>如果程序包具有可用的安全更新，则只能将这些程序包更新为其最新版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update --security</span><br></pre></td></tr></table></figure>
<p>您还可以仅将包更新到包含最新安全更新的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update-minimal --security</span><br></pre></td></tr></table></figure>
<p>例如，假设：</p>
<ul>
<li><p>该内核3.10.0-1软件包安装在系统上;</p>
</li>
<li><p>该内核3.10.0-2包发布的安全更新;</p>
</li>
<li><p>该内核3.10.0-3包被发布了作为一个bug修复更新。</p>
</li>
</ul>
<p>然后<code>yum update-minimal --security</code>将软件包更新到kernel-3.10.0-2，并将<code>yum update --security</code>软件包更新到kernel-3.10.0-3。</p>
<h3 id="自动化包更新"><a href="#自动化包更新" class="headerlink" title="自动化包更新"></a>自动化包更新</h3><p>要刷新包数据库并自动下载更新，您可以使用该<code>yum-cron</code>服务。</p>
<h2 id="使用ISO和Yum离线升级系统"><a href="#使用ISO和Yum离线升级系统" class="headerlink" title="使用ISO和Yum离线升级系统"></a>使用ISO和Yum离线升级系统</h2><p>对于与Internet或Red Hat Network断开连接的系统，使用<code>yum update</code>带有Red Hat Enterprise Linux安装的命令，ISO映像是将系统升级到最新次要版本的简便快捷方式。以下步骤说明了升级过程：</p>
<ol>
<li><p>创建目标目录以装入ISO映像。安装时不会自动创建此目录，因此请在继续下一步之前创建该目录。作为<code>root</code>，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mount_dir</span><br></pre></td></tr></table></figure>
<p>将<em>mount_dir</em>替换为mount目录的路径。通常，用户将其创建为目录中的<code>/media</code>子目录。</p>
</li>
<li><p>将Red Hat Enterprise Linux 7安装ISO映像挂载到先前创建的目标目录。作为<code>root</code>，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o loop iso_name  mount_dir</span><br></pre></td></tr></table></figure>
<p>更换<em>ISO_NAME</em>与路径，以您的ISO映像，并<em>mount_dir</em>与到目标目录的路径。此处，<code>-o``loop</code>需要该选项将文件作为块设备安装。</p>
</li>
<li><p>将<code>media.repo</code>文件从mount目录复制到该<code>/etc/yum.repos.d/</code>目录。请注意，此目录中的配置文件必须具有<em>.repo</em>扩展名才能正常运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp mount_dir/media.repo /etc/yum.repos.d/new.repo</span><br></pre></td></tr></table></figure>
<p>这将为yum存储库创建配置文件。将<em>new.repo</em>替换为文件名，例如<em>rhel7.repo</em>。</p>
</li>
<li><p>编辑新配置文件，使其指向Red Hat Enterprise Linux安装ISO。将以下行添加到文件中： <code>/etc/yum.repos.d/*new.repo*</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">baseurl = file：/// mount_dir</span><br></pre></td></tr></table></figure>
<p>将<em>mount_dir</em>替换为安装点的路径。</p>
</li>
<li><p>更新所有yum存储库，包括在先前步骤中创建的。作为，键入：<code>/etc/yum.repos.d/*new.repo*``root</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure>
<p>这会将您的系统升级到安装的ISO映像提供的版本。</p>
</li>
<li><p>成功升级后，您可以卸载ISO映像。作为<code>root</code>，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount mount_dir</span><br></pre></td></tr></table></figure>
<p>其中<em>mount_dir</em>是mount目录的路径。此外，您可以删除在第一步中创建的安装目录。作为<code>root</code>，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rmdir mount_dir</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您不将先前创建的配置文件用于其他安装或更新，则可以将其删除。作为<code>root</code>，键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /etc/yum.repos.d/new.repo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>例：从CentOS7.0升级到7.5</strong></p>
<p>如果需要使用具有较新版本系统的ISO映像升级系统而无法访问Internet，例如<code>CentOS-7-x86_64-Everything-1804.iso</code>，请创建用于安装的目标目录，例如<code>/media/centos7/</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ mount -o loop CentOS-7-x86_64-Everything-1804.iso /media/centos7/</span><br></pre></td></tr></table></figure>
<p>要使yum将挂载点识别为存储库，请将以下行添加到<code>/etc/yum.repos.d/centos.repo</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">baseurl=file:///media/centos7/</span><br></pre></td></tr></table></figure>
<p>现在，更新yum存储库会将您的系统升级到由<code>CentOS-7-x86_64-Everything-1804.iso</code>。提供的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ yum update</span><br></pre></td></tr></table></figure>
<p>系统升级成功后，可以卸载映像，删除目标目录和配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ umount /media/centos7/</span><br><span class="line">〜]＃ rmdir /media/centos7/</span><br><span class="line">〜]＃ rm /etc/yum.repos.d/centos.repo</span><br></pre></td></tr></table></figure>
<h1 id="使用包"><a href="#使用包" class="headerlink" title="使用包"></a>使用包</h1><p>Yum使您能够使用软件包执行一整套操作，包括搜索包，查看有关包，安装和删除的信息。</p>
<h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><p>您可以使用以下命令搜索所有RPM包名称，描述和摘要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search   xxx</span><br></pre></td></tr></table></figure>
<p>获得更全更详尽的慢搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search all xxx</span><br></pre></td></tr></table></figure>
<h2 id="清单包"><a href="#清单包" class="headerlink" title="清单包"></a>清单包</h2><p>要列出有关所有已安装<em>和</em>可用软件包的信息<em>，</em>请在shell提示符下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list all</span><br></pre></td></tr></table></figure>
<p>要列出与插入的glob表达式匹配的已安装<em>和</em>可用的包，请使用以下命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list glob_expression…</span><br></pre></td></tr></table></figure>
<p>要列出系统上安装的所有软件包，请使用<code>installed</code>关键字。输出中最右边的列列出了从中检索包的存储库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed glob_expression ...</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list available gstreamer\*plugin\*</span><br></pre></td></tr></table></figure>
<h3 id="列出存储库"><a href="#列出存储库" class="headerlink" title="列出存储库"></a>列出存储库</h3><p>要列出系统上每个已<em>启用</em>存储库的存储库ID，名称和程序包数，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure>
<p>要列出有关这些存储库的更多信息，请添加该<code>-v</code>选项。启用此选项后，将为每个列出的存储库显示包括文件名，总大小，上次更新日期和基本URL的信息。或者，您可以使用<code>repoinfo</code>生成相同输出的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repoinfo</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist -v</span><br></pre></td></tr></table></figure>
<p>要列出启用和禁用的存储库，请使用以下命令。状态列将添加到输出列表中，以显示启用了哪些存储库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist all</span><br></pre></td></tr></table></figure>
<p>通过<code>disabled</code>作为第一个参数传递，可以将命令输出减少到禁用的存储库。为了进一步说明，您可以将存储库的ID或名称或相关的glob_expressions作为参数传递。请注意，如果存储库ID或名称与插入的参数之间存在完全匹配，则即使未通过<em>启用</em>或<em>禁用的</em>过滤器，也会列出此存储库。</p>
<h2 id="显示包信息"><a href="#显示包信息" class="headerlink" title="显示包信息"></a>显示包信息</h2><p>要显示有关一个或多个包的信息，请使用以下命令（glob表达式在此处也有效）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum info package_name ...</span><br></pre></td></tr></table></figure>
<p>例如显示nginx的包信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum info nginx</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * epel: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : nginx</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Epoch       : 1</span><br><span class="line">Version     : 1.12.2</span><br><span class="line">Release     : 2.el7</span><br><span class="line">Size        : 1.5 M</span><br><span class="line">Repo        : installed</span><br><span class="line">From repo   : epel</span><br><span class="line">Summary     : A high performance web server and reverse proxy server</span><br><span class="line">URL         : http://nginx.org/</span><br><span class="line">License     : BSD</span><br><span class="line">Description : Nginx is a web server and a reverse proxy server <span class="keyword">for</span> HTTP, SMTP, POP3 and</span><br><span class="line">            : IMAP protocols, with a strong focus on high concurrency, performance and low</span><br><span class="line">            : memory usage.</span><br></pre></td></tr></table></figure>
<p><code>rpm -q --info package_name</code>同样可以查看包信息</p>
<h3 id="使用yumdb"><a href="#使用yumdb" class="headerlink" title="使用yumdb"></a>使用yumdb</h3><p>还可以使用以下命令在yum数据库中查询有关包的替代和有用信息：</p>
<p>此命令提供有关包的其他信息，包括包的校验和（以及用于生成它的算法，如SHA-256），在命令行上给出的用于安装包的命令（如果有）以及在系统上安装软件包的原因（<code>user</code>表示它是由用户安装的，并且<code>dep</code>表示它是作为依赖项引入的）。</p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>要安装单个程序包及其所有未安装的依赖项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install package_name</span><br></pre></td></tr></table></figure>
<p>还可以通过将其名称作为参数附加来同时安装多个软件包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install package_name  package_name ...</span><br></pre></td></tr></table></figure>
<p>模糊匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install audacious-plugins-\*</span><br></pre></td></tr></table></figure>
<p><code>yum install</code> 还可以提供文件名。如果您知道要安装的二进制文件的名称，而不知道其软件包名称，则可以指定<code>yum install</code>路径名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install /usr/sbin/named</span><br></pre></td></tr></table></figure>
<p>正如您在上面的示例中所看到的，<code>yum install</code>命令不需要严格定义的参数。它可以处理各种格式的包名称和glob表达式，这使得用户的安装更加容易。另一方面，<strong>yum</strong>需要一些时间才能正确解析输入，特别是如果指定了大量的包。要优化程序包搜索，可以使用以下命令显式定义如何解析参数：</p>
<p>使用<code>install-n</code>，<strong>yum</strong>将<em>name</em>解释为包的确切名称。<code>install-na</code>命令告诉<strong>yum</strong>后续参数包含包名称和体系结构除以点字符。有了<code>install-nevra</code>，<strong>yum</strong>会期望以<em>name-epoch：version-release.architecture</em>的形式<em>出现</em>一个参数。同样，您可以在搜索要删除的包时使用<code>yum remove-n</code>，<code>yum remove-na</code>和<code>yum remove-nevra</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install-n package_name</span><br><span class="line">yum install-na name.architecture</span><br><span class="line">yum install-nevra name-epoch:version-release.architecture</span><br></pre></td></tr></table></figure>
<p>如果您知道要安装包含<code>named</code>二进制文件的软件包，但您不知道文件安装在哪个目录<code>bin/</code>或<code>sbin/</code>目录中，请使用<code>yum provides</code>带有glob表达式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># yum provides "*bin/mysql"</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.nwsuaf.edu.cn</span><br><span class="line"> * epel: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.163.com</span><br><span class="line">1:mariadb-5.5.56-2.el7.x86_64 : A community developed branch of MySQL</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1:mariadb-5.5.60-1.el7_5.x86_64 : A community developed branch of MySQL</span><br><span class="line">Repo        : updates</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1:mariadb-5.5.56-2.el7.x86_64 : A community developed branch of MySQL</span><br><span class="line">Repo        : @base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/bin/mysql</span><br></pre></td></tr></table></figure>
<p><strong>安装过程</strong></p>
<p>以下示例提供了使用<strong>yum</strong>进行安装的概述。要下载并安装最新版本的httpd软件包，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum install httpd</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package httpd.x86_64 0:2.4.6-12.el7 will be updated</span><br><span class="line">---&gt; Package httpd.x86_64 0:2.4.6-13.el7 will be an update</span><br><span class="line">--&gt; Processing Dependency: 2.4.6-13.el7 <span class="keyword">for</span> package: httpd-2.4.6-13.el7.x86_64</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package httpd-tools.x86_64 0:2.4.6-12.el7 will be updated</span><br><span class="line">---&gt; Package httpd-tools.x86_64 0:2.4.6-13.el7 will be an update</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，<strong>yum</strong>加载必要的插件并运行事务检查。在这种情况下，httpd已经安装。由于安装的软件包比最新的当前可用版本旧，因此将进行更新。这同样适用于httpd所依赖的httpd-tools包。然后，显示事务摘要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">================================================================================</span><br><span class="line"> Package        Arch      Version                 Repository               Size</span><br><span class="line">================================================================================</span><br><span class="line">Updating:</span><br><span class="line"> httpd          x86_64    2.4.6-13.el7            rhel-x86_64-server-7    1.2 M</span><br><span class="line">Updating <span class="keyword">for</span> dependencies:</span><br><span class="line"> httpd-tools    x86_64    2.4.6-13.el7            rhel-x86_64-server-7     77 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">================================================================================</span><br><span class="line">Upgrade  1 Package (+1 Dependent package)</span><br><span class="line"></span><br><span class="line">Total size: 1.2 M</span><br><span class="line">Is this ok [y/d/N]:</span><br></pre></td></tr></table></figure>
<p>在此步骤中，<strong>yum</strong>会提示您确认安装。除<code>y</code>（是）和<code>N</code>（否）选项外，您可以选择<code>d</code>（仅下载）下载软件包，但不能直接安装它们。如果选择<code>y</code>，安装将继续以下消息，直到成功完成。</p>
<p>要从系统上的本地目录安装以前下载的软件包，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum localinstall path</span><br></pre></td></tr></table></figure>
<p>将<em>path</em>替换为要安装的程序包的路径。</p>
<h2 id="下载包"><a href="#下载包" class="headerlink" title="下载包"></a>下载包</h2><p>在某个安装过程中，系统会提示您使用以下消息确认安装：</p>
<p>使用<code>d</code>选项，yum下载包而不立即安装它们。您可以稍后使用<code>yum localinstall</code>命令脱机安装这些软件包，也可以使用其他设备共享它们。默认情况下，下载的包保存在缓存目录的一个子目录中<code>/var/cache/yum/$basearch/$releasever/packages/</code>。下载以后台模式进行，以便您可以并行使用<strong>yum</strong>进行其他操作。</p>
<h2 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h2><p>与软件包安装类似，yum允许您卸载它们。要卸载特定软件包以及依赖于它的任何软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove package_name…</span><br></pre></td></tr></table></figure>
<h1 id="使用包组"><a href="#使用包组" class="headerlink" title="使用包组"></a>使用包组</h1><p>包组是一组用于通用目的的包，例如<em>System Tools</em>或<em>Sound and Video</em>。安装软件包组会提取一组依赖软件包，从而大大节省了时间。<code>yum groups</code>命令是一个顶级命令，它涵盖了yum中对包组进行操作的所有操作。</p>
<h2 id="列出包组"><a href="#列出包组" class="headerlink" title="列出包组"></a>列出包组</h2><p><code>summary</code>选项用于查看已安装组，可用组，可用环境组以及已安装和可用语言组的数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groups summary</span><br></pre></td></tr></table></figure>
<p>要列出yum存储库中的所有软件包组，请添加该<code>list</code>选项。您可以按组名称过滤命令输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group list glob_expression ...</span><br></pre></td></tr></table></figure>
<h3 id="安装包组"><a href="#安装包组" class="headerlink" title="安装包组"></a>安装包组</h3><p>每个包组都有一个名称和一个组ID（<em>groupid</em>）。要列出括号中显示的所有包组的名称及其组ID，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group list ids</span><br></pre></td></tr></table></figure>
<p><strong>查找包组的名称和groupid</strong></p>
<p>要查找程序包组的名称或ID，例如与KDE桌面环境相关的组，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]$ yum group list ids kde\*</span><br><span class="line">Available environment groups:</span><br><span class="line">   KDE Plasma Workspaces (kde-desktop-environment)</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<p>某些组被配置的存储库中的设置隐藏。例如，在服务器上，也可以使用<code>hidden</code>命令选项列出隐藏的组:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]$ yum group list hidden ids kde\*</span><br><span class="line">Loaded plugins: product-id, subscription-manager</span><br><span class="line">Available Groups:</span><br><span class="line">   KDE (kde-desktop)</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<p>您可以通过将其完整组名称（不带groupid部分）传递给<code>group install</code>命令来安装程序包组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group install <span class="string">"group name"</span></span><br></pre></td></tr></table></figure>
<p>您也可以通过groupid安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group install groupid</span><br></pre></td></tr></table></figure>
<p>可以将groupid或带引号的组名称传递给该命令，<code>yum</code>表示您要执行该命令<code>group install</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install @group</span><br></pre></td></tr></table></figure>
<p><strong>安装KDE桌面组的四种等效方法</strong></p>
<p>可以使用四种替代但等效的方法来安装软件包组。对于KDE Desktop，命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum group install "KDE Desktop"</span></span><br><span class="line">~]<span class="comment"># yum group install kde-desktop</span></span><br><span class="line">~]<span class="comment"># yum install @"KDE Desktop"</span></span><br><span class="line">~]<span class="comment"># yum install @kde-desktop</span></span><br></pre></td></tr></table></figure>
<h2 id="删除包组"><a href="#删除包组" class="headerlink" title="删除包组"></a>删除包组</h2><p>可以使用类似于<code>install</code>语法的语法删除包组，并使用包组的名称或其ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum group remove group_name</span><br><span class="line">yum group remove groupid</span><br></pre></td></tr></table></figure>
<p>此外，<code>remove</code>如果您使用@ -symbol 前面的命令，可以将groupid或带引号的名称传递给该命令，命令告诉yum您要执行该命令<code>group remove</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove @group</span><br></pre></td></tr></table></figure>
<p>将<em>group</em>替换为groupid或带引号的组名。同样，您可以替换环境组:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove @^group</span><br></pre></td></tr></table></figure>
<p><strong>删除KDE Desktop组的四种等效方法</strong></p>
<p>与安装类似，您可以使用四种替代但等效的方法来删除软件包组。对于KDE Desktop，命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum group remove "KDE Desktop"</span></span><br><span class="line">~]<span class="comment"># yum group remove kde-desktop</span></span><br><span class="line">~]<span class="comment"># yum remove @"KDE Desktop"</span></span><br><span class="line">~]<span class="comment"># yum remove @kde-desktop</span></span><br></pre></td></tr></table></figure>
<h2 id="yum-历史记录"><a href="#yum-历史记录" class="headerlink" title="yum 历史记录"></a>yum 历史记录</h2><p><code>yum history</code>命令使用户能够查看有关yum事务的时间线, 它们发生的日期和时间，受影响的包的数量，这些事务是成功还是中止以及RPM数据库是否在事务之间更改的信息。此外，此命令可用于撤消或重做某些事务. 所有历史数据都存储在目录<code>/var/lib/yum/history/</code>中的历史DB中 </p>
<h2 id="事务列表"><a href="#事务列表" class="headerlink" title="事务列表"></a>事务列表</h2><p>To display a list of the twenty most recent transactions, as <code>root</code>, either run <code>yum history</code>with no additional arguments, or type the following at a shell prompt:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> list</span><br></pre></td></tr></table></figure>
<p>要显示所有事务，请添加<code>all</code>关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum history list all</span><br></pre></td></tr></table></figure>
<p>要仅显示给定范围内的事务，请使用以下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> list start_id..end_id</span><br></pre></td></tr></table></figure>
<p>您还可以仅列出有关特定包或包的事务。为此，请使用包名称或glob表达式的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum history list glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>列出五个最旧的事务</strong></p>
<p>在<code>yum history list</code>输出中，最近的事务显示在列表的顶部。要显示有关历史数据库中存储的五个最旧事务的信息，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history list 1..5</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">ID     | Login user               | Date and time    | Action(s)      | Altered</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">     5 | User &lt;user&gt;              | 2013-07-29 15:33 | Install        |    1</span><br><span class="line">     4 | User &lt;user&gt;              | 2013-07-21 15:10 | Install        |    1</span><br><span class="line">     3 | User &lt;user&gt;              | 2013-07-16 15:27 | I, U           |   73</span><br><span class="line">     2 | System &lt;<span class="built_in">unset</span>&gt;           | 2013-07-16 15:19 | Update         |    1</span><br><span class="line">     1 | System &lt;<span class="built_in">unset</span>&gt;           | 2013-07-16 14:38 | Install        | 1106</span><br><span class="line"><span class="built_in">history</span> list</span><br></pre></td></tr></table></figure>
<p>所有形式的<code>yum history list</code>命令都会生成表格输出，每行包含以下列：</p>
<ul>
<li><code>ID</code> — 标识特定事务的整数值.</li>
<li><code>Login user</code> — 登录会话用于启动事务的用户的名称。</li>
<li><code>Date and time</code> — 事务发生的日期和时间。</li>
<li><code>Action(s)</code> — 事务期间执行的操作列表。</li>
<li><code>Altered</code> — 受事务影响的软件包数量。</li>
</ul>
<p><strong>Action（s）字段的可能值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Action</th>
<th>Abbreviation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Downgrade</code></td>
<td><code>D</code></td>
<td>至少有一个软件包已降级为旧版本。</td>
</tr>
<tr>
<td><code>Erase</code></td>
<td><code>E</code></td>
<td>至少有一个包已被删除。</td>
</tr>
<tr>
<td><code>Install</code></td>
<td><code>I</code></td>
<td>至少安装了一个新软件包。</td>
</tr>
<tr>
<td><code>Obsoleting</code></td>
<td><code>O</code></td>
<td>至少有一个包被标记为已过时。</td>
</tr>
<tr>
<td><code>Reinstall</code></td>
<td><code>R</code></td>
<td>至少已重新安装一个软件包。</td>
</tr>
<tr>
<td><code>Update</code></td>
<td><code>U</code></td>
<td>至少有一个软件包已更新为更新版本。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Altered 字段的可能值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;</code></td>
<td>在事务完成之前，<code>rpmdb</code>数据库在yum之外被更改。</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>事务完成后，<code>rpmdb</code>数据库在yum之外更改。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>交易未能完成。</td>
</tr>
<tr>
<td><code>#</code></td>
<td>事务成功完成，但yum返回非零退出代码。</td>
</tr>
<tr>
<td><code>E</code></td>
<td>事务成功完成，但显示错误或警告。</td>
</tr>
<tr>
<td><code>P</code></td>
<td>事务已成功完成，但<code>rpmdb</code>数据库中已存在问题。</td>
</tr>
<tr>
<td><code>s</code></td>
<td>事务成功完成，但使用了<code>--skip-broken</code>命令行选项并跳过了某些包。</td>
</tr>
</tbody>
</table>
</div>
<p>同步的<code>rpmdb</code>或<code>yumdb</code>为任何已安装的包与当前使用的数据库的内容<code>rpmdb</code>或<code>yumdb</code>数据库，键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> sync</span><br></pre></td></tr></table></figure>
<p>要显示有关当前使用的历史数据库的一些统计信息，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> stats</span><br></pre></td></tr></table></figure>
<p><strong>yum历史统计信息的示例输出</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history stats</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager </span><br><span class="line">File        : //var/lib/yum/<span class="built_in">history</span>/<span class="built_in">history</span>-2012-08-15.sqlite</span><br><span class="line">Size        : 2,766,848</span><br><span class="line">Transactions: 41</span><br><span class="line">Begin time  : Wed Aug 15 16:18:25 2012</span><br><span class="line">End time    : Wed Feb 27 14:52:30 2013</span><br><span class="line">Counts      :</span><br><span class="line">  NEVRAC :  2,204</span><br><span class="line">  NEVRA  :  2,204</span><br><span class="line">  NA     :  1,759</span><br><span class="line">  NEVR   :  2,204</span><br><span class="line">  rpm DB :  2,204</span><br><span class="line">  yum DB :  2,204</span><br><span class="line"><span class="built_in">history</span> stats</span><br></pre></td></tr></table></figure>
<p>yum还允许您显示所有过去交易的摘要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> summary</span><br></pre></td></tr></table></figure>
<p>要仅显示给定范围内的事务，请键入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> summary start_id..end_id</span><br></pre></td></tr></table></figure>
<p>与<code>yum history list</code>命令类似，您还可以通过提供包名称或glob表达式来显示有关某个包或某些包的事务摘要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> summary glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>五项最新事务摘要</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history summary 1..5</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">Login user                 | Time                | Action(s)        | Altered </span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Jaromir ... &lt;jhradilek&gt;    | Last day            | Install          |        1</span><br><span class="line">Jaromir ... &lt;jhradilek&gt;    | Last week           | Install          |        1</span><br><span class="line">Jaromir ... &lt;jhradilek&gt;    | Last 2 weeks        | I, U             |       73</span><br><span class="line">System &lt;<span class="built_in">unset</span>&gt;             | Last 2 weeks        | I, U             |     1107</span><br><span class="line"><span class="built_in">history</span> summary</span><br></pre></td></tr></table></figure>
<p>有形式的<code>yum history summary</code>命令都产生类似于输出的简化表格输出<code>yum history list</code>。</p>
<p>从包的角度列出事务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> package-list glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>追踪包的历史</strong></p>
<p>要跟踪订阅管理器和相关包的历史记录，请在shell提示符下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history package-list subscription-manager\*</span></span><br><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">ID     | Action(s)      | Package</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">     2 | Updated        | subscription-manager-1.13.22-1.el7.x86_64          EE</span><br><span class="line">     2 | Update         |                      1.15.9-15.el7.x86_64          EE</span><br><span class="line">     2 | Obsoleted      | subscription-manager-firstboot-1.13.22-1.el7.x86_64 EE</span><br><span class="line">     2 | Updated        | subscription-manager-gui-1.13.22-1.el7.x86_64      EE</span><br><span class="line">     2 | Update         |                          1.15.9-15.el7.x86_64      EE</span><br><span class="line">     2 | Obsoleting     | subscription-manager-initial-setup-addon-1.15.9-15.el7.x86_64 EE</span><br><span class="line">     1 | Install        | subscription-manager-1.13.22-1.el7.x86_64</span><br><span class="line">     1 | Install        | subscription-manager-firstboot-1.13.22-1.el7.x86_64</span><br><span class="line">     1 | Install        | subscription-manager-gui-1.13.22-1.el7.x86_64</span><br><span class="line"><span class="built_in">history</span> package-list</span><br></pre></td></tr></table></figure>
<p>在此示例中，在初始系统安装期间安装了三个软件包：subscription-manager，subscription-manager-firstboot和subscription-manager-gui。在第三个事务中，所有这些包都从版本1.10.11更新到版本1.10.17。</p>
<h2 id="检查事务"><a href="#检查事务" class="headerlink" title="检查事务"></a>检查事务</h2><p>要显示单个事务的摘要，请使用<code>yum history summary</code>以下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> summary id</span><br></pre></td></tr></table></figure>
<p>这里，<em>id</em>代表事务的ID。</p>
<p>要更详细地检查特定事务或事务，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info id…</span><br></pre></td></tr></table></figure>
<p><em>ID</em>参数是可选的，当你忽略它，yum会自动使用最后一个事务。请注意，在指定多个事务时，您还可以使用范围：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> info start_id..end_id</span><br></pre></td></tr></table></figure>
<p><strong>yum历史信息的示例输出</strong></p>
<p>以下是两个事务的示例输出，每个事务安装一个新包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history info 4..5</span></span><br><span class="line">Loaded plugins: langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">Transaction ID : 4..5</span><br><span class="line">Begin time     : Mon Dec  7 16:51:07 2015</span><br><span class="line">Begin rpmdb    : 1252:d2b62b7b5768e855723954852fd7e55f641fbad9</span><br><span class="line">End time       :            17:18:49 2015 (27 minutes)</span><br><span class="line">End rpmdb      : 1253:cf8449dc4c53fc0cbc0a4c48e496a6c50f3d43c5</span><br><span class="line">User           : Maxim Svistunov &lt;msvistun&gt;</span><br><span class="line">Return-Code    : Success</span><br><span class="line">Command Line   : install tigervnc-server.x86_64</span><br><span class="line">Command Line   : reinstall tigervnc-server</span><br><span class="line">Transaction performed with:</span><br><span class="line">    Installed     rpm-4.11.3-17.el7.x86_64                  @rhel-7-server-rpms</span><br><span class="line">    Installed     subscription-manager-1.15.9-15.el7.x86_64 @rhel-7-server-rpms</span><br><span class="line">    Installed     yum-3.4.3-132.el7.noarch                  @rhel-7-server-rpms</span><br><span class="line">Packages Altered:</span><br><span class="line">    Reinstall tigervnc-server-1.3.1-3.el7.x86_64 @rhel-7-server-rpms</span><br><span class="line"><span class="built_in">history</span> info</span><br></pre></td></tr></table></figure>
<p>您还可以查看其他信息，例如在事务处理时使用的配置选项，或者从哪个存储库以及安装某些软件包的原因。要确定某个特定事务可用的附加信息，在shell提示符下键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> addon-info id</span><br></pre></td></tr></table></figure>
<p>与此类似<code>yum history info</code>，当没有提供<em>id</em>时，yum会自动使用最新的事务。引用最新事务的另一种方法是使用<code>last</code>关键字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> addon-info last</span><br></pre></td></tr></table></figure>
<p><strong>示例输出yum history addon-info</strong></p>
<p>对于历史记录中的第四个事务，该<code>yum history addon-info</code>命令提供以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum history addon-info 4</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">Transaction ID: 4</span><br><span class="line">Available additional <span class="built_in">history</span> information:</span><br><span class="line">  config-main</span><br><span class="line">  config-repos</span><br><span class="line">  saved_tx</span><br><span class="line"></span><br><span class="line"><span class="built_in">history</span> addon-info</span><br></pre></td></tr></table></figure>
<h2 id="恢复和重复事务"><a href="#恢复和重复事务" class="headerlink" title="恢复和重复事务"></a>恢复和重复事务</h2><p>除了查看事务历史之外，该<code>yum history</code>命令还提供了还原或重复所选事务的方法。要还原事务，请在shell提示符下键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> undo id</span><br></pre></td></tr></table></figure>
<p>要重复特定事务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> redo id</span><br></pre></td></tr></table></figure>
<p>这两个命令还接受<code>last</code>关键字来撤消或重复最新的事务。</p>
<p>请注意，两者<code>yum history undo</code>和<code>yum history redo</code>命令仅还原或重复事务期间执行的步骤。如果事务安装了一个新包，该<code>yum history undo</code>命令将卸载它，如果事务卸载了一个包，该命令将再次安装它。如果这些旧软件包仍然可用，此命令还会尝试将所有更新的软件包降级到其先前的版本。</p>
<p>在管理多个相同的系统时，yum还允许您在其中一个系统上执行事务，将事务详细信息存储在文件中，经过一段时间的测试后，在其余系统上重复相同的事务。要将事务详细信息存储到文件，请在shell提示符下键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -q <span class="built_in">history</span> addon-info id saved_tx &gt; file_name</span><br></pre></td></tr></table></figure>
<p>Once you copy this file to the target system, you can repeat the transaction by using the following command as <code>root</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum load-transaction file_name</span><br></pre></td></tr></table></figure>
<p>您可以配置<code>load-transaction</code>为忽略缺少的软件包或rpmdb版本。有关这些配置选项的更多信息，请参见<code>yum.conf</code>（5）手册页。</p>
<h2 id="启动新的事务记录"><a href="#启动新的事务记录" class="headerlink" title="启动新的事务记录"></a>启动新的事务记录</h2><p>Yum将事务历史记录存储在单个SQLite数据库文件中。要启动新的事务历史记录，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum <span class="built_in">history</span> new</span><br></pre></td></tr></table></figure>
<p>这将在<code>/var/lib/yum/history/</code>目录中创建一个新的空数据库文件。旧的事务历史记录将保留，但只要目录中存在较新的数据库文件，就无法访问。</p>
<h1 id="配置YUM和YUM存储库"><a href="#配置YUM和YUM存储库" class="headerlink" title="配置YUM和YUM存储库"></a>配置YUM和YUM存储库</h1><p>yum和相关实用程序的配置信息位于 <code>/etc/yum.conf</code>. 此文件包含一个必需的<code>[main]</code> 部分, 使您可以设置具有全局效果的yum选项，还可以包含一个或多个 <code>[*repository*]</code> 部分, 这些部分允许您设置特定于存储库的选项. 但是，建议在目录中的新文件或现有文件中定义单个存储库 <code>.repo</code>文件在 <code>/etc/yum.repos.d/</code>目录中. 在文件的各个部分定义[<em>repository</em>]<code>部分覆盖</code>/etc/yum.conf<code>文件中</code>[main]` 部分设置的值.</p>
<h2 id="设置-main-选项"><a href="#设置-main-选项" class="headerlink" title="设置[main]选项"></a>设置[main]选项</h2><p><code>/etc/yum.conf</code> 配置文件只包含一个 <code>[main]</code> 部分, 本节中的一些键值对会影响yum的运行方式，但其他键值会影响yum对待存储库的方式. 您可以在 <code>/etc/yum.conf</code>下<code>[main]</code>部分添加许多其他选项 .</p>
<p><code>/etc/yum.conf</code>配置文件可能如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[main]</span><br><span class="line">cachedir=/var/cache/yum/<span class="variable">$basearch</span>/<span class="variable">$releasever</span></span><br><span class="line">keepcache=0</span><br><span class="line">debuglevel=2</span><br><span class="line">logfile=/var/<span class="built_in">log</span>/yum.log</span><br><span class="line">exactarch=1</span><br><span class="line">obsoletes=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">plugins=1</span><br><span class="line">installonly_limit=5</span><br><span class="line">bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum</span><br><span class="line">distroverpkg=centos-release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  This is the default, if you make this bigger yum won't see if the metadata</span></span><br><span class="line"><span class="comment"># is newer on the remote and so you'll "gain" the bandwidth of not having to</span></span><br><span class="line"><span class="comment"># download the new metadata and "pay" for it by yum not having correct</span></span><br><span class="line"><span class="comment"># information.</span></span><br><span class="line"><span class="comment">#  It is esp. important, to have correct metadata, for distributions like</span></span><br><span class="line"><span class="comment"># Fedora which don't keep old packages around. If you don't like this checking</span></span><br><span class="line"><span class="comment"># interupting your command line usage, it's much better to have something</span></span><br><span class="line"><span class="comment"># manually check the metadata once an hour (yum-updatesd will do this).</span></span><br><span class="line"><span class="comment"># metadata_expire=90m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PUT YOUR REPOS HERE OR IN separate files named file.repo</span></span><br><span class="line"><span class="comment"># in /etc/yum.repos.d</span></span><br></pre></td></tr></table></figure>
<p><code>[main]</code>部分最常用的选项：</p>
<ul>
<li><p><code>assumeyes</code>=<em>value</em></p>
<p><code>assumeyes</code>选项确定yum是否提示确认关键操作。用以下之一替换<em>value</em>:</p>
<p><code>0</code> (<em>default</em>) — 提示确认其执行的关键操作。</p>
<p><code>1</code> — 不要提示确认关键<code>yum</code>行为。如果<code>assumeyes=1</code>设置，yum的行为以同样的方式作为命令行选项<code>-y</code>和<code>--assumeyes</code></p>
</li>
<li><p><code>cachedir</code>=<em>directory</em></p>
<p>使用此选项可设置yum存储其缓存和数据库文件的目录。将<em>目录</em>替换为<em>目录</em>的绝对路径。默认情况下，yum的缓存目录是<code>/var/cache/yum/$basearch/$releasever/</code>。</p>
</li>
<li><p><code>debuglevel</code>=<em>value</em></p>
<p>此选项指定yum生成的调试输出的详细信息。这里，<em>value</em>是<code>1</code>和之间的整数<code>10</code>。设置更高的<code>debuglevel</code>值会导致yum显示更详细的调试输出。<code>debuglevel=2</code>是默认值，同时<code>debuglevel=0</code>禁用调试输出。</p>
</li>
<li><p><code>exactarch</code>=<em>value</em></p>
<p>使用此选项，您可以将yum设置为在更新已安装的软件包时考虑确切的体系结构。替换<em>值</em>：</p>
<p><code>0</code> - 更新包时不要考虑确切的体系结构。</p>
<p><code>1</code>（<em>默认</em>） - 在更新包时考虑确切的体系结构。使用此设置，yum不会安装32位体系结构的软件包来更新已安装在具有64位体系结构的系统上的软件包。</p>
</li>
<li><p><code>exclude</code>=<em>package_name</em> [<em>more_package_names</em>]</p>
<p><code>exclude</code>选项使您可以在安装或系统更新期间按关键字排除包。列出多个要排除的包可以通过引用以空格分隔的包列表来完成。允许使用通配符（例如，<code>*</code>和<code>?</code>）的Shell glob表达式。</p>
</li>
<li><p><code>gpgcheck</code>=<em>value</em></p>
<p>使用该<code>gpgcheck</code>选项指定yum是否应对包执行GPG签名检查。替换<em>value</em>：</p>
<p><code>0</code> — 禁用所有存储库中软件包的GPG签名检查，包括本地软件包安装。</p>
<p><code>1</code> (<em>default</em>) — 启用检查所有存储库中所有软件包的GPG签名，包括本地软件包安装。与<code>gpgcheck</code>启用，所有包的签名进行检查。</p>
</li>
</ul>
<ul>
<li><p><code>group_command</code>=<em>value</em></p>
<p>使用<code>group_command</code>选项指定如何<code>yum group install</code>，<code>yum group upgrade</code>和<code>yum group remove</code>命令处理程序包组。用以下内容替换<em>值</em>：</p>
<p><code>simple</code> - 安装软件包组的所有成员。仅升级以前安装的软件包，但不要同时安装已添加到组中的软件包。</p>
<p><code>compat</code>- 类似于<code>simple</code>但<code>yum upgrade</code>也安装自上次升级以来添加到组中的软件包。</p>
<p><code>objects</code>- （<em>默认值</em>。）使用此选项，yum会跟踪以前安装的组，并区分作为组的一部分安装的软件包和单独安装的软件包。</p>
</li>
<li><p><code>group_package_types</code>=<em>package_type</em> [<em>more_package_types</em>]</p>
<p>您可以在此处指定调用<code>yum</code> <code>group</code> <code>install</code>命令时安装的软件包类型 (<em>optional</em>, <em>default</em> or <em>mandatory</em>) is installed when the . <em>默认</em>和<em>强制</em>封装类型是默认选择的.</p>
</li>
<li><p><code>history_record</code>=<em>value</em></p>
<p>使用此选项，您可以设置yum以记录交易历史记录。用以下之一替换<em>value</em></p>
<p><code>0</code> — yum应该<em>没有</em>记录的交易历史记录条目。</p>
<p><code>1</code> (<em>default</em>) — yum应记录事务的历史记录条目。此操作占用一定数量的磁盘空间，并在事务中占用一些额外时间，但它提供了有关过去操作的大量信息，可以使用该<code>yum</code> <code>history</code>命令显示。<code>history_record=1</code>是默认值。</p>
</li>
</ul>
<ul>
<li><p><code>installonlypkgs</code>= <em>space</em> <em>separated</em> <em>list</em> <em>of</em> <em>packages</em></p>
<p>在这里，您可以提供以空格分隔的软件包列表，yum可以<em>安装</em>这些软件包，但永远不会<em>更新</em>。请参阅<code>yum.conf</code>（5）手册页以获取默认情况下仅安装的软件包列表。</p>
<p>如果您将<code>installonlypkgs</code>指令添加到<code>/etc/yum.conf</code>，则应确保列出<em>所有</em>应仅安装的软件包，包括（5）<code>installonlypkgs</code>部分中列出的任何软件包<code>yum.conf</code>。特别是，应始终列出内核包<code>installonlypkgs</code>（默认情况下），并且<code>installonly_limit</code>应始终将其设置为大于某个值，<code>2</code>以便在默认启动无法启动时始终可以使用备份内核。</p>
<p>-<code>installonly_limit</code>= <em>value</em></p>
<p>此选项设置<code>installonlypkgs</code>可以同时安装指令中列出的包数。将<em>value</em>替换为一个整数，该整数表示可以同时为其中列出的任何单个程序包安装的最大版本数<code>installonlypkgs</code>。</p>
</li>
<li><p><code>installonlypkgs</code>指令的默认值包括几个不同的内核包，因此请注意，更改值<code>installonly_limit</code>也会影响任何单个内核包的最大安装版本数。在列出的默认值<code>/etc/yum.conf</code>是<code>installonly_limit=3</code>，并且不建议减小该值，特别是低于<code>2</code>。</p>
</li>
<li><p><code>keepcache</code>= <em>value</em></p>
<p><code>keepcache</code>选项确定yum在成功安装后是否保留标头和包的缓存。在这里，<em>value</em>是以下之一：</p>
<p><code>0</code>（<em>默认</em>） - 成功安装后，不要保留标头和包的缓存。</p>
<p><code>1</code> - 成功安装后保留缓存。</p>
</li>
<li><p><code>logfile</code>= <em>file_name</em></p>
<p>要指定日志记录输出的位置，请将<em>file_name</em>替换为yum应写入其日志记录输出的文件的绝对路径。默认情况下，yum会记录到<code>/var/log/yum.log</code>。</p>
</li>
<li><p><code>max_connenctions</code>= <em>number</em></p>
<p>此处<em>value</em>表示最大并发连接数，默认值为5。</p>
</li>
<li><p><code>multilib_policy</code>= <em>value</em></p>
<p><code>multilib_policy</code>如果有多个体系结构版本可用于程序包安装，则 该选项会设置安装行为。这里，<em>value</em>代表：</p>
<p><code>best</code> - 为此系统安装最佳选择架构。例如，<code>multilib_policy=best</code>在AMD64系统上进行设置会导致yum安装所有软件包的64位版本。</p>
<p><code>all</code> - 始终为每个包安装每个可能的架构。例如，如果<code>multilib_policy</code>设置为<code>all</code>AMD64系统，yum将同时安装i686和AMD64版本的软件包（如果两者都可用）。</p>
</li>
<li><p><code>obsoletes</code>= <em>value</em></p>
<p><code>obsoletes</code>选项在更新期间启用过时的进程逻辑。当一个包在其spec文件中声明它<em>废弃了</em>另一个包时，后一个包在安装前一个包时被前一个包替换。例如，在重命名包时声明过时。用以下之一替换<em>value</em>：</p>
<p><code>0</code> - 执行更新时禁用yum的过时处理逻辑。</p>
<p><code>1</code>（<em>默认</em>） - 执行更新时启用yum的过时处理逻辑。</p>
</li>
<li><p><code>plugins</code>= <em>值</em></p>
<p>这是一个启用或禁用yum插件的全局开关，<em>value</em>是以下之一：</p>
<p><code>0</code> - 全局禁用所有yum插件。</p>
<p><code>1</code> (<em>default</em>) —  全局启用所有yum插件。使用<code>plugins=1</code>，您仍然可以通过设置<code>enabled=0</code>该插件的配置文件来禁用特定的yum插件。</p>
</li>
</ul>
<ul>
<li><p><code>reposdir</code>= <em>directory</em></p>
<p>这里，<em>directory</em>是<code>.repo</code>文件所在<em>目录</em>的绝对路径。所有<code>.repo</code>文件都包含存储库信息（类似于部分）。Yum从.repo文件和/etc/yum.conf文件[<em>repository</em>]部分收集所有存储库信息，以创建用于事务的存储库主列表。如果<code>reposdir</code>未设置，则yum使用默认目录<code>/etc/yum.repos.d/</code>。</p>
</li>
<li><p><code>retries</code>= <em>value</em></p>
<p>此选项设置yum在返回错误之前应尝试检索文件的次数。<em>value</em>是整数<code>0</code>或更大。设置值<code>0</code>使yum永远重试。默认值为<code>10</code>。</p>
</li>
</ul>
<h3 id="设置-repository-选项"><a href="#设置-repository-选项" class="headerlink" title="设置[repository]选项"></a>设置[repository]选项</h3><p><em><code>[repository]</code></em> 部分,  <em>repository</em> 是一个唯一的存储库ID如 <code>my_personal_repo</code> (不允许空格), 为避免冲突，自定义存储库不应使用Red Hat存储库使用的名称</p>
<p>以下是一个 <code>[*repository*]</code>部分的最小例子 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[repository]</span><br><span class="line">name=repository_name</span><br><span class="line">baseurl=repository_url</span><br></pre></td></tr></table></figure>
<p>每个 <code>[*repository*]</code> 部分必须包含以下指令： </p>
<p><code>name</code>=<em>repository_name</em></p>
<p>这里，<em>repository_name</em>是描述存储库的可读字符串。</p>
<p><code>baseurl</code>=<em>repository_url</em></p>
<p>将<em>repository_url</em>替换为<em>存储库</em>的repodata目录所在目录的URL：</p>
<ul>
<li>如果存储库可通过HTTP使用，请使用： <code>http://path/to/repo</code></li>
<li>如果存储库可通过FTP使用，请使用： <code>ftp://path/to/repo</code></li>
<li>如果存储库是计算机的本地存储库，请使用： <code>file:///path/to/local/repo</code></li>
<li>如果特定的在线存储库需要基本的HTTP身份验证，您可以通过将其作为前缀添加到URL来指定您的用户名和密码。. 例如，如果 <a href="http://www.example.com/repo/" target="_blank" rel="noopener">http://www.example.com/repo/</a> 需要用户名”user”和密码”password” 则可将链接指定为 <code>http://user:password@www.example.com/repo/</code>.</li>
</ul>
<p>通常此URL是HTTP链接，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">baseurl=http://path/to/repo/releases/<span class="variable">$releasever</span>/server/<span class="variable">$basearch</span>/os/</span><br></pre></td></tr></table></figure>
<p>其他可用于 <em><code>[repository]</code></em>部分的选项:</p>
<ul>
<li><p><code>enabled</code>=<em>value</em></p>
<p>这是告诉yum使用或忽略特定存储库的简单方法，<em>value</em>是以下<em>值</em>之一：</p>
<p><code>0</code> - 执行更新和安装时，请勿将此存储库包含为包源。这是一种快速打开和关闭存储库的简单方法，当您需要来自存储库的单个包时，这是非常有用的，您不希望为更新或安装启用。</p>
<p><code>1</code> - 将此存储库包含为包源。</p>
</li>
<li><p><code>async</code>=<em>value</em></p>
<p>控制存储库包的并行下载，value为以下之一：</p>
<p><code>auto</code>（<em>默认</em>） - 如果可能，使用并行下载，这意味着<strong>yum会</strong>自动为插件创建的存储库禁用它，以避免出现故障。</p>
<p><code>on</code> - 为存储库启用了并行下载。</p>
<p><code>off</code> - 为存储库禁用并行下载。</p>
</li>
</ul>
<h2 id="使用Yum变量"><a href="#使用Yum变量" class="headerlink" title="使用Yum变量"></a>使用Yum变量</h2><p>您可以在<code>yum</code>命令和所有yum配置文件（即目录中的<code>/etc/yum.conf</code>所有<code>.repo</code>文件）中使用和引用以下内置变量<code>/etc/yum.repos.d/</code>：</p>
<ul>
<li><p><code>$releasever</code></p>
<p>您可以使用此变量来引用Red Hat Enterprise Linux的发行版本.  <code>$releasever</code> 从配置文件<code>/etc/yum.conf</code>中 <code>distroverpkg=value</code> 行获取值. 如果没有这样的行，那么yum通过从提供文件的包中获取版本号来推断出正确的值</p>
</li>
<li><p><code>$arch</code></p>
<p>您可以使用此变量来引用在调用Python <code>os.uname()</code>函数时返回的系统CPU体系结构。<code>$arch</code>包含的有效值：<code>i586</code>，<code>i686</code>和<code>x86_64</code>。</p>
</li>
<li><p><code>$basearch</code></p>
<p>您可以使用它<code>$basearch</code>来引用系统的基本体系结构。例如，i686和i586机器都有基本架构<code>i386</code>，而AMD64和Intel 64机器都有基本架构<code>x86_64</code>。</p>
</li>
<li><p><code>$YUM0-9</code></p>
<p>这十个变量每个都被替换为具有相同名称的任何shell环境变量的值。如果引用其中一个变量（例如<code>/etc/yum.conf</code>）并且不存在具有相同名称的shell环境变量，则不替换配置文件变量。</p>
</li>
</ul>
<p>要定义自定义变量或覆盖现有变量的值，请在目录中创建与变量同名（不带“ <code>$</code>”符号）的<code>/etc/yum/vars/</code>文件，并在其第一行添加所需的值。</p>
<p>库描述通常包括操作系统名称。要定义一个名为的新变量<code>$osname</code>，请在第一行创建一个带有“ Red Hat Enterprise Linux ”的新文件，并将其另存为<code>/etc/yum/vars/osname</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># echo "Red Hat Enterprise Linux 7" &gt; /etc/yum/vars/osname</span></span><br></pre></td></tr></table></figure>
<p>您现在可以在文件中使用以下内容， 而不是“ Red Hat Enterprise Linux 7”<code>.repo</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name=<span class="variable">$osname</span> <span class="variable">$releasever</span></span><br></pre></td></tr></table></figure>
<h2 id="查看当前配置"><a href="#查看当前配置" class="headerlink" title="查看当前配置"></a>查看当前配置</h2><p>要显示全局yum选项的当前值（即文件<code>[main]</code>部分中指定的选项<code>/etc/yum.conf</code>），请执行<code>yum-config-manager</code>不带命令行选项的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager</span><br></pre></td></tr></table></figure>
<p>要列出不同配置节的内容，请使用以下格式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager section…</span><br></pre></td></tr></table></figure>
<p>You can also use a glob expression to display the configuration of all matching sections:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>查看主要部分的配置</strong></p>
<p>要列出主要部分的所有配置选项及其对应值，请在shell提示符下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]$ yum-config-manager main \*</span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">================================== main ===================================</span><br><span class="line">[main]</span><br><span class="line">alwaysprompt = True</span><br><span class="line">assumeyes = False</span><br><span class="line">bandwith = 0</span><br><span class="line">bugtracker_url = https://bugzilla.redhat.com/enter_bug.cgi?product=Red%20Hat%20Enterprise%20Linux%206&amp;component=yum</span><br><span class="line">cache = 0</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<h2 id="添加，启用和禁用Yum存储库"><a href="#添加，启用和禁用Yum存储库" class="headerlink" title="添加，启用和禁用Yum存储库"></a>添加，启用和禁用Yum存储库</h2><h3 id="添加Yum存储库"><a href="#添加Yum存储库" class="headerlink" title="添加Yum存储库"></a>添加Yum存储库</h3><p>要定义新存储库，可以在文件中添加一个<code>[repository]</code>部分，也可以在<code>/etc/yum.repos.d/</code>目录中添加一个<code>.repo</code>文件。yum读取此目录中具有文件扩展名的所有文件，建议您在此处而不是在<code>/etc/yum.conf</code>中定义存储库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo repository_url</span><br></pre></td></tr></table></figure>
<p>…其中<em>repository_url</em>是<code>.repo</code>文件的链接。</p>
<p><strong>添加example.repo</strong></p>
<p>要添加位于<a href="http://www.example.com/example.repo的存储库，请在shell提示符下键入以下内容：" target="_blank" rel="noopener">http://www.example.com/example.repo的存储库，请在shell提示符下键入以下内容：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum-config-manager --add-repo http://www.example.com/example.repo</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">adding repo from: http://www.example.com/example.repo</span><br><span class="line">grabbing file http://www.example.com/example.repo to /etc/yum.repos.d/example.repo</span><br><span class="line">example.repo                                             |  413 B     00:00</span><br><span class="line">repo saved to /etc/yum.repos.d/example.repo</span><br></pre></td></tr></table></figure>
<h4 id="启用Yum存储库"><a href="#启用Yum存储库" class="headerlink" title="启用Yum存储库"></a>启用Yum存储库</h4><p>要启用特定存储库或存储库，请在shell提示符下键入以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> repository…</span><br></pre></td></tr></table></figure>
<p>…其中<em>repository</em>是唯一的存储库ID（用于<code>yum repolist all</code>列出可用的存储库ID）。或者，您可以使用glob表达式来启用所有匹配的存储库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>启用在/etc/yum.conf的自定义部分中定义的存储库。</strong></p>
<p>启用定义的<code>[example]</code>, <code>[example-debuginfo]</code>, 和 <code>[example-source]</code>部分:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum-config-manager --enable example\*</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">============================== repo: example ==============================</span><br><span class="line">[example]</span><br><span class="line">bandwidth = 0</span><br><span class="line">base_persistdir = /var/lib/yum/repos/x86_64/7Server</span><br><span class="line">baseurl = http://www.example.com/repo/7Server/x86_64/</span><br><span class="line">cache = 0</span><br><span class="line">cachedir = /var/cache/yum/x86_64/7Server/example</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<p><strong>启用所有存储库</strong></p>
<p>要启用<code>/etc/yum.conf</code>文件和<code>/etc/yum.repos.d/</code>目录中定义的所有存储库，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum-config-manager --enable \*</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">============================== repo: example ==============================</span><br><span class="line">[example]</span><br><span class="line">bandwidth = 0</span><br><span class="line">base_persistdir = /var/lib/yum/repos/x86_64/7Server</span><br><span class="line">baseurl = http://www.example.com/repo/7Server/x86_64/</span><br><span class="line">cache = 0</span><br><span class="line">cachedir = /var/cache/yum/x86_64/7Server/example</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<p>成功后，该<code>yum-config-manager --enable</code>命令将显示当前存储库配置。</p>
<h3 id="禁用Yum存储库"><a href="#禁用Yum存储库" class="headerlink" title="禁用Yum存储库"></a>禁用Yum存储库</h3><p>要禁用yum存储库，请运行以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">disable</span> repository…</span><br></pre></td></tr></table></figure>
<p>…其中<em>repository</em>是唯一的存储库ID（用于<code>yum repolist all</code>列出可用的存储库ID）。与之类似<code>yum-config-manager --enable</code>，您可以使用glob表达式同时禁用所有匹配的存储库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">disable</span> glob_expression…</span><br></pre></td></tr></table></figure>
<p><strong>禁用所有存储库</strong></p>
<p>要禁用<code>/etc/yum.conf</code>文件和<code>/etc/yum.repos.d/</code>目录中定义的所有存储库，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># yum-config-manager --disable \*</span></span><br><span class="line">Loaded plugins: langpacks, product-id, subscription-manager</span><br><span class="line">============================== repo: example ==============================</span><br><span class="line">[example]</span><br><span class="line">bandwidth = 0</span><br><span class="line">base_persistdir = /var/lib/yum/repos/x86_64/7Server</span><br><span class="line">baseurl = http://www.example.com/repo/7Server/x86_64/</span><br><span class="line">cache = 0</span><br><span class="line">cachedir = /var/cache/yum/x86_64/7Server/example</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<p>成功后，该<code>yum-config-manager --disable</code>命令将显示当前配置。</p>
<h2 id="创建Yum存储库"><a href="#创建Yum存储库" class="headerlink" title="创建Yum存储库"></a>创建Yum存储库</h2><p>要设置yum存储库：</p>
<ol>
<li><p>安装createrepo包:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install createrepo</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将新存储库的所有包复制到一个目录中，例如 <code>/tmp/local_repo/</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /your/packages/*.rpm /tmp/local_repo/</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行创建存储库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">createrepo /tmp/local_repo/</span><br></pre></td></tr></table></figure>
<p>这将为yum存储库创建必要的元数据，并将元数据放在新创建的子目录中<code>repodata</code>。</p>
</li>
</ol>
<h3 id="将包添加到已创建的yum存储库"><a href="#将包添加到已创建的yum存储库" class="headerlink" title="将包添加到已创建的yum存储库"></a>将包添加到已创建的yum存储库</h3><p>要将包添加到已创建的yum存储库：</p>
<ol>
<li><p>将新包复制到存储库目录，例如<code>/tmp/local_repo/</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /your/packages/*.rpm /tmp/local_repo/</span><br></pre></td></tr></table></figure>
</li>
<li><p>要反映元数据中新添加的包，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">createrepo --update /tmp/local_repo/</span><br></pre></td></tr></table></figure>
</li>
<li><p>Optional:如果您已使用任何yum命令和新更新的存储库，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean expire-cache</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="YUM-插件"><a href="#YUM-插件" class="headerlink" title="YUM 插件"></a>YUM 插件</h1><p>Yum提供扩展和增强其操作的插件。默认情况下会安装某些插件。当您调用任何<code>yum</code>命令时，yum总会通知您哪些插件（如果有）已加载并处于活动状态。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost repodata]<span class="comment"># yum info yum</span></span><br><span class="line">Loaded plugins: fastestmirror, langpacks, product-id, search-disabled-repos, subscription-manager</span><br><span class="line">This system is not registered with an entitlement server. You can use subscription-manager to register.</span><br></pre></td></tr></table></figure>
<p>使用 <code>--disableplugin=plugin_name</code> 选项来选择哪个yum插件被禁用</p>
<h2 id="启用，配置和禁用Yum插件"><a href="#启用，配置和禁用Yum插件" class="headerlink" title="启用，配置和禁用Yum插件"></a>启用，配置和禁用Yum插件</h2><p>要启用yum插件。请确认在<code>/etc/yum.conf</code>文件的<code>[main]</code>部分plugin=1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=1</span><br></pre></td></tr></table></figure>
<p>您可以通过将此行更改为<code>plugins=0</code>禁用所有插件。</p>
<p>每个已安装的插件在<code>/etc/yum/pluginconf.d/</code>目录中都有自己的配置文件。您可以在这些文件中设置插件特定选项。例如，以下是<strong>别名</strong>插件的<code>aliases.conf</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[main] </span><br><span class="line">enabled = 1</span><br></pre></td></tr></table></figure>
<p>与<code>/etc/yum.conf</code>文件类似，插件配置文件始终包含一个<code>[main]</code>部分，其中该<code>enabled=</code>选项控制在运行<code>yum</code>命令时是否启用插件。如果缺少此选项，则可以手动将其添加到文件中。</p>
<p>如果您通过设置<code>/etc/yum.conf</code>中<code>enabled=0</code>中禁用所有插件，那么所有的插件，无论他们在各个配置文件是否启用禁用。</p>
<p>如果您只想为单个<code>yum</code>命令禁用所有yum插件，请使用<code>--noplugins</code>选项。</p>
<p>如果要为单个<code>yum</code>命令禁用一个或多个yum插件，请将该选项添加到该命令。例如，要在更新系统时禁用<strong>别名</strong>插件，请键入： <code>--disableplugin=plugin_name</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ yum update --disableplugin=aliases</span><br></pre></td></tr></table></figure>
<p>为该<code>--disableplugin=</code>选项提供的插件名称<code>Loaded plugins</code>与任何<code>yum</code>命令输出中的行后面列出的名称相同。您可以通过用逗号分隔名称来禁用多个插件。此外，您可以使用glob表达式匹配多个插件名称或缩短长插件名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ yum update --disableplugin=aliases,lang*</span><br></pre></td></tr></table></figure>
<h2 id="安装其他Yum插件"><a href="#安装其他Yum插件" class="headerlink" title="安装其他Yum插件"></a>安装其他Yum插件</h2><p>Yum插件通常遵循包命名约定，但并非总是如此：例如，提供<strong>kabi</strong>插件的包被命名。您可以像安装其他软件包一样安装yum插件。例如，要安装<strong>yum-aliases</strong>插件，请在shell提示符下键入以下内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">〜]＃ yum install yum-plugin-aliases</span><br></pre></td></tr></table></figure>
<h2 id="使用Yum插件"><a href="#使用Yum插件" class="headerlink" title="使用Yum插件"></a>使用Yum插件</h2><p>以下列表提供了几个有用的yum插件的说明和使用说明。插件按名称列出，括号包含包的名称。</p>
<p><strong>search-disabled-repos</strong></p>
<p><strong>search-disabled-repos</strong>插件可以让你暂时或永久启用已禁用的存储库，以帮助解决依赖关系。启用此插件后，当Yum由于依赖项解析失败而无法安装软件包时，它会暂时启用已禁用的存储库并重试。如果安装成功，Yum还提供永久启用使用的存储库。请注意，该插件仅适用于由<strong>subscription-manager</strong>管理的存储库，而不适用于自定义存储库。</p>
<p>To configure the <strong>search-disabled-repos</strong> plug-in, edit the configuration file located in <code>/etc/yum/pluginconf.d/search-disabled-repos.conf</code>. For the list of directives you can use in the <code>[main]</code> section, see the table below.</p>
<p><strong>Table 9.3. Supported search-disabled-repos.conf directives</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Directive</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>enabled</code>=<em>value</em></td>
<td>Allows you to enable or disable the plug-in. The <em>value</em> must be either <code>1</code> (enabled), or <code>0</code> (disabled). The plug-in is enabled by default.</td>
</tr>
<tr>
<td><code>notify_only</code>=<em>value</em></td>
<td>Allows you to restrict the behavior of the plug-in to notifications only. The <em>value</em> must be either <code>1</code> (notify only without modifying the behavior of Yum), or <code>0</code> (modify the behavior of Yum). By default the plug-in only notifies the user.</td>
</tr>
<tr>
<td><code>ignored_repos</code>=<em>repositories</em></td>
<td>Allows you to specify the repositories that will not be enabled by the plug-in.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>kabi</strong> (kabi-yum-plugins)</p>
<p>The <strong>kabi</strong> plug-in checks whether a driver update package conforms with the official Red Hat <em>kernel Application Binary Interface</em> (kABI). With this plug-in enabled, when a user attempts to install a package that uses kernel symbols which are not on a whitelist, a warning message is written to the system log. Additionally, configuring the plug-in to run in enforcing mode prevents such packages from being installed at all.</p>
<p>To configure the <strong>kabi</strong> plug-in, edit the configuration file located in <code>/etc/yum/pluginconf.d/kabi.conf</code>. A list of directives that can be used in the <code>[main]</code>section is shown in the table below.</p>
<p><strong>Table 9.4. Supported kabi.conf directives</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Directive</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>enabled</code>=<em>value</em></td>
<td>Allows you to enable or disable the plug-in. The <em>value</em> must be either <code>1</code> (enabled), or <code>0</code> (disabled). When installed, the plug-in is enabled by default.</td>
</tr>
<tr>
<td><code>whitelists</code>=<em>directory</em></td>
<td>Allows you to specify the <em>directory</em> in which the files with supported kernel symbols are located. By default, the <strong>kabi</strong> plug-in uses files provided by the kernel-abi-whitelists package (that is, the <code>/usr/lib/modules/kabi-rhel70/</code> directory).</td>
</tr>
<tr>
<td><code>enforce</code>=<em>value</em></td>
<td>Allows you to enable or disable enforcing mode. The <em>value</em> must be either <code>1</code> (enabled), or <code>0</code> (disabled). By default, this option is commented out and the <strong>kabi</strong> plug-in only displays a warning message.</td>
</tr>
</tbody>
</table>
</div>
<p><strong>product-id</strong> (subscription-manager)</p>
<p>The <strong>product-id</strong> plug-in manages product identity certificates for products installed from the Content Delivery Network. The <strong>product-id</strong> plug-in is installed by default.</p>
<p><strong>langpacks</strong> (yum-langpacks)</p>
<p>The <strong>langpacks</strong> plug-in is used to search for locale packages of a selected language for every package that is installed. The <strong>langpacks</strong> plug-in is installed by default.</p>
<p><strong>aliases</strong> (yum-plugin-aliases)</p>
<p>The <strong>aliases</strong> plug-in adds the <code>alias</code> command-line option which enables configuring and using aliases for <code>yum</code> commands.</p>
<p><strong>yum-changelog</strong> (yum-plugin-changelog)</p>
<p>The <strong>yum-changelog</strong> plug-in adds the <code>--changelog</code> command-line option that enables viewing package change logs before and after updating.</p>
<p><strong>yum-tmprepo</strong> (yum-plugin-tmprepo)</p>
<p>The <strong>yum-tmprepo</strong> plug-in adds the <code>--tmprepo</code> command-line option that takes the URL of a repository file, downloads and enables it for only one transaction. This plug-in tries to ensure the safe temporary usage of repositories. By default, it does not allow to disable the gpg check.</p>
<p><strong>yum-verify</strong> (yum-plugin-verify)</p>
<p>The <strong>yum-verify</strong> plug-in adds the <code>verify</code>, <code>verify-rpm</code>, and <code>verify-all</code> command-line options for viewing verification data on the system.</p>
<p><strong>yum-versionlock</strong> (yum-plugin-versionlock)</p>
<p>The <strong>yum-versionlock</strong> plug-in excludes other versions of selected packages, which enables protecting packages from being updated by newer versions. With the <code>versionlock</code>command-line option, you can view and edit the list of locked packages.</p>
<h1 id="自动刷新包数据库并使用YUM-CRON下载更新"><a href="#自动刷新包数据库并使用YUM-CRON下载更新" class="headerlink" title="自动刷新包数据库并使用YUM-CRON下载更新"></a>自动刷新包数据库并使用YUM-CRON下载更新</h1><p>该<code>yum-cron</code>服务自动检查和下载包更新。<code>yum-cron</code>安装yum-cron软件包后，服务提供的cron作业立即生效。该<code>yum-cron</code>服务还可以自动安装下载的更新。</p>
<p>使用默认设置，<code>yum-cron</code>服务：</p>
<ul>
<li>每小时更新yum缓存中的元数据一次。</li>
<li>每天下载一次对yum缓存的包更新。如果存储库中有新包，则会发送电子邮件。</li>
</ul>
<p>该<code>yum-cron</code>服务有两个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/yum/yum-cron.conf</span><br></pre></td></tr></table></figure>
<p>对于日常任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/yum/yum-cron-hourly.conf</span><br></pre></td></tr></table></figure>
<p>每小时任务。</p>
<h2 id="启用自动安装更新"><a href="#启用自动安装更新" class="headerlink" title="启用自动安装更新"></a>启用自动安装更新</h2><p>要启用下载更新的自动安装，请通过设置以下<code>apply_updates</code>选项编辑每日安装的每日配置文件或每小时安装的每小时配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apply_updates = yes</span><br></pre></td></tr></table></figure>
<h2 id="设置可选的电子邮件通知"><a href="#设置可选的电子邮件通知" class="headerlink" title="设置可选的电子邮件通知"></a>设置可选的电子邮件通知</h2><p>默认情况下，该<code>yum-cron</code>服务用于<code>cron</code>发送包含已执行命令输出的电子邮件。此电子邮件根据<code>cron</code>配置发送，通常发送给本地超级用户并存储在<code>/var/spool/mail/root</code>文件中。</p>
<p>您可以使用与影响所有<code>cron</code>作业的设置不同的特定电子邮件配置。但是，此电子邮件配置不支持TLS，整体电子邮件内置逻辑非常基本。</p>
<p>要启用<code>yum-cron</code>内置电子邮件通知：</p>
<ol>
<li><p>打开选定的<code>yum-cron</code>配置文件：</p>
<ul>
<li><p><code>/etc/yum/yum-cron.conf</code></p>
<p>对于日常任务。</p>
</li>
<li><p><code>/etc/yum/yum-cron-hourly.conf</code></p>
<p>每小时任务。</p>
</li>
</ul>
</li>
<li><p>在该<code>[emitters]</code>部分中，设置以下选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">emit_via = email</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置<code>email_from</code>，<code>email_to</code>，<code>email_host</code>因为所需的选项</p>
</li>
</ol>
<h2 id="启用或禁用特定存储库"><a href="#启用或禁用特定存储库" class="headerlink" title="启用或禁用特定存储库"></a>启用或禁用特定存储库</h2><p>在<code>yum-cron</code>不支持存储库的具体配置。至于启用或禁用特定仓库的解决方法，<code>yum-cron</code>而不是<code>yum</code>一般的请执行下列步骤：</p>
<ol>
<li><p>在系统的任何位置创建一个空的存储库配置目录。</p>
</li>
<li><p>将所有配置文件从<code>/etc/yum.repos.d/</code>目录复制到此新创建的目录。</p>
</li>
<li><p>在其中的相应<code>.repo</code>配置文件中<code>/etc/yum.repos.d/</code>，设置<code>enabled</code>选项如下：</p>
<ul>
<li><p><code>enabled = 1</code></p>
<p>要启用存储库。</p>
</li>
<li><p><code>enabled = 0</code></p>
<p>要禁用存储库。</p>
</li>
</ul>
</li>
<li><p>在所选<code>yum-cron</code>配置文件的末尾添加以下选项，该选项指向新创建的存储库目录：</p>
</li>
</ol>
<ol>
<li><p>```bash<br>reposdir=/path/to/new/reposdir</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 测试Yum-cron设置</span><br><span class="line"></span><br><span class="line">要在&#96;yum-cron&#96;不等待下一个计划&#96;yum-cron&#96;任务的情况下测试设置：</span><br><span class="line"></span><br><span class="line">1. 打开选定的&#96;yum-cron&#96;配置文件：</span><br><span class="line"></span><br><span class="line">   - &#96;&#x2F;etc&#x2F;yum&#x2F;yum-cron.conf&#96;</span><br><span class="line"></span><br><span class="line">     对于日常任务。</span><br><span class="line"></span><br><span class="line">   - &#96;&#x2F;etc&#x2F;yum&#x2F;yum-cron-hourly.conf&#96;</span><br><span class="line"></span><br><span class="line">     每小时任务。</span><br><span class="line"></span><br><span class="line">2. &#96;random_sleep&#96;在所选配置文件中 设置选项，如下所示：</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;bash</span><br><span class="line">   random_sleep &#x3D; 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum -cron /etc/yum/yum-cron.conf</span></span><br><span class="line"><span class="comment">#yum-cron/etc/yum/yum-cron-hourly.conf</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="禁用Yum-cron消息"><a href="#禁用Yum-cron消息" class="headerlink" title="禁用Yum-cron消息"></a>禁用Yum-cron消息</h2><p><code>yum-cron</code>消息不能完全禁用，但可被限制为仅具有临界优先级的消息。限制消息：</p>
<ol>
<li><p>打开选定的<code>yum-cron</code>配置文件：</p>
<ul>
<li><p><code>/etc/yum/yum-cron.conf</code></p>
<p>对于日常任务。</p>
</li>
<li><p><code>/etc/yum/yum-cron-hourly.conf</code></p>
<p>每小时任务。</p>
</li>
</ul>
</li>
<li><p>[base] 在配置文件 的部分中设置以下选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debuglevel = -4</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="自动清洁包"><a href="#自动清洁包" class="headerlink" title="自动清洁包"></a>自动清洁包</h2><p><code>yum-cron</code>服务不支持任何用于删除与<code>yum clean all</code>命令类似的包的配置选项。要自动清理包，可以将cron作业创建为可执行shell脚本：</p>
<ol>
<li><p>在<code>/etc/cron.daily/</code>包含以下内容的目录中创建shell脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure>
</li>
<li><p>使脚本可执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chmod + x /etc/cron.daily/ script-name.sh</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Package Manager</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化资源管理简介</title>
    <url>/2018/08/22/Virtualized-Resource/Introduction-to-Virtual-Resource-Management/</url>
    <content><![CDATA[<p>了解虚拟化原理，首先要了解虚拟化都设计哪些资源，清楚其组件及其实现。</p>
<p>资源管理是将资源从资源提供方分配给资源用户的一个过程。</p>
<p>我们之所以需要资源管理，原因就是因为资源会过度分配，以及需求容量会随着时间推移而变化。</p>
<h1 id="虚拟化资源类型"><a href="#虚拟化资源类型" class="headerlink" title="虚拟化资源类型"></a>虚拟化资源类型</h1><p>资源包括CPU、内存、电源、存储器和网络。</p>
<a id="more"></a>
<h1 id="资源提供方"><a href="#资源提供方" class="headerlink" title="资源提供方"></a>资源提供方</h1><p>虚拟机的资源是哪里来的呢？当然是物理设备。物理设备资源就是资源提供方。</p>
<p>对于主机，可用的资源是主机的硬件规格减去虚拟化软件所使用的资源。</p>
<h1 id="资源用户"><a href="#资源用户" class="headerlink" title="　资源用户"></a>　资源用户</h1><p>虚拟机实例就是消耗资源的用户。</p>
<h1 id="资源管理的目标"><a href="#资源管理的目标" class="headerlink" title="资源管理的目标"></a>资源管理的目标</h1><p>管理资源，必须清楚目标。</p>
<p>除了结束资源过量置备问题，资源管理还可以实现一下目标：</p>
<ul>
<li>性能隔离：防止虚拟机独占资源并保证服务率的可预测。</li>
<li>高效使用：利用分配不足的资源并在过量置备时让性能正常降低。</li>
<li>容易管理：控制虚拟机的相对重要性，提供灵活的动态分区并且符合服务级别。</li>
</ul>
]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化资源分配（vsphere）</title>
    <url>/2018/08/22/Virtualized-Resource/Introduction-to-Virtualized-Resource-Allocation/</url>
    <content><![CDATA[<p>当可用资源无法满足资源用户的需求时，需要对分配给虚拟机的资源量进行自定义。</p>
<p>资源分配设置用于确定虚拟机提供的CPU、内存和存储资源。</p>
<ul>
<li>预留主机或集群的物理资源。</li>
<li>为可以分配给虚拟机的资源量设置上限。</li>
<li>保证为特定虚拟机跟配的物理资源始终高于其他虚拟机。<a id="more"></a>
<h1 id="资源分配份额"><a href="#资源分配份额" class="headerlink" title="资源分配份额"></a>资源分配份额</h1></li>
</ul>
<p>如果某个虚拟机的资源份额是另一个虚拟机的两倍，则在这两个虚拟机争用资源时，第一个虚拟机有权消耗两倍于第二个虚拟机的资源。</p>
<p>份额通常指定为<strong>高</strong>、<strong>正常</strong>或<strong>低</strong>，这些值分别按4:2:1 的比例指定份额。还可以选择自定义(权重)。</p>
<p>指定份额仅对同级虚拟机或资源池（资源池层级结构中具有相同父级的虚拟机或资源池）有意义。同级将根据其相对份额值共享资源，该份额值受预留和限制的约束。为虚拟机分配份额时，始终会将相对于其他已打开电源的虚拟机来为虚拟机指定优先级。</p>
<p>下表显示了虚拟机的默认CPU和内存份额值。对于资源池，默认的CPU份额和内存份额都相同，但是必须将二者相乘，就好像资源池是具有四个虚拟cpu和16GB内存的虚拟机一样。</p>
<p><strong>份额值</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设置</th>
<th>CPU份额值</th>
<th>内存份额值</th>
</tr>
</thead>
<tbody>
<tr>
<td>高</td>
<td>每个虚拟CPU具有2000份额</td>
<td>所配置的虚拟机内存每兆字节具有20个</td>
</tr>
<tr>
<td>正常</td>
<td>每个虚拟CPU具有1000份额</td>
<td>所配置的虚拟机内存每兆字节具有10个</td>
</tr>
<tr>
<td>低</td>
<td>每个虚拟CPU具有500份额</td>
<td>所配置的虚拟机内存每兆字节具有5个</td>
</tr>
</tbody>
</table>
</div>
<p>例如，一台具有两个虚拟CPU和1GB内存且CPU和内存份额设置为正常，虚拟机具有2×1000个cpu份额和10*1024个内存份额。</p>
<h2 id="资源分配预留"><a href="#资源分配预留" class="headerlink" title="　资源分配预留"></a>　资源分配预留</h2><p>预留是vaozheng为虚拟机分配的最少资源量。</p>
<p>仅在有足够的资源满足虚拟机预留时，才允许开机，即使物理机负载较重，服务器也会确保该资源量。</p>
<p>例如，假定有2GHz可用，并且为VM1和VM2各指定了1GHz的预留量，现在每个虚拟机都能保证在需要时获得1GHz，但是如果VM1只用了500MHz，则VM2可以使用1.5GHz。</p>
<p>预留默认为0，可以指定预留保证迅疾始终可以使用最少的必要CPU或内存。</p>
<h1 id="资源分配限制"><a href="#资源分配限制" class="headerlink" title="资源分配限制"></a>资源分配限制</h1><p>限制功能为可以分配到虚拟机的CPU、内存或存储I/O资源指定上限。</p>
<p>服务器分配给虚拟机的资源可大于预留，但不可大于限制，即使系统上有未使用的资源也是如此。</p>
<p>CPU、内存和存储I/O资源限制默认为无限制。如果内存无限制，则在创建虚拟机时为该虚拟机配置内存量成为其有效限制。</p>
<p>多数情况下，无需指定限制。</p>
<h1 id="资源分配设置建议"><a href="#资源分配设置建议" class="headerlink" title="资源分配设置建议"></a>资源分配设置建议</h1><p>遵循一下准则：</p>
<ul>
<li>使用<strong>预留</strong>来指定可接受的最低CPU量，而不是想要的量，预留标识的具体资源不会随环境变化而变。主机可以根据虚拟机的限制、份额的数量和估计需求将额外的资源指定为可用资源。</li>
<li>请不要将所有资源全部指定为虚拟机预留（请计划经至少10%的资源保留为未预留）。系统容量越接近于被全部预留，想要在不违反接入控制的情况下更改预留和资源池层级结构越困难。在支持DRS的集群内，如果预留完全占用集群或集群内各台主机的容量，则会组织DRS在主机之间迁移。</li>
<li>如需频繁更改总可用资源，可使用<strong>份额</strong>在虚拟机之间合理分配资源。例如，如果使用<strong>份额</strong>，并且升级主机，那么即使每个份额代表较大的内存量、CPU量或存储I/O资源量，每个虚拟机也保持相同的优先级（保持相同数量的份额）。</li>
</ul>
]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>Vsphere</tag>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>sys模块介绍（Python）</title>
    <url>/2018/08/22/Program-design/Python/sys-Module/</url>
    <content><![CDATA[<h1 id="平台和版本"><a href="#平台和版本" class="headerlink" title="平台和版本"></a>平台和版本</h1><p>和大多数模块一样，<code>sys</code>既包括富含信息的名称，也包括完成具体工作的函数。例如，他的属性可以告诉我们底层操作系统名称，当前计算机可容纳的最大的<strong>“原生”</strong>整型（<em>虽然python3.X版本中整型的长度可以是任意长的</em>），异机正在运行我们代码的Python解释器的版本号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.platform,sys.maxsize,sys.version</span><br><span class="line">(<span class="string">'win32'</span>, <span class="number">9223372036854775807</span>, <span class="string">'3.6.4 (v3.6.4:d48eceb, Dec 19 2017, 06:54:40) [MSC v.1900 64 bit (AMD64)]'</span>)</span><br><span class="line"><span class="keyword">if</span> sys.platform[:<span class="number">3</span>] == <span class="string">'win'</span>:</span><br><span class="line">    print(<span class="string">'Hello Windows'</span>)</span><br><span class="line">...</span><br><span class="line">Hello Windows</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果你的代码确定要在不同的机器上表现出不同的行为，只需向刚才那样测试<code>sys.platform</code>字符串；虽然Python的大部分功能是跨平台的， 但也可以把不可抑制的工具封装在<code>if</code>语句测试中，就像上面一样，比方说没等下我们会看到一些程序的运行和底层控制台交互工具可能因平台而异。只需测试<code>sys.platform</code>，就可以胃运行你的脚本的计算机挑选合适的工具。</p>
<h1 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h1><p><code>sys</code>模块使得我们可以在Python程序内部或者交互地查看模块搜索路径。<code>sys.path</code>是一个由目录名称字符串组成的列表，每个目录名称字符串代表正在运行Python解释器的真正的搜索路径。模块导入时，Python会自左向右扫描列表，在列表中的每个目录下搜索模块文件。因此，在这里你可以验证设定的搜索路径是否正确。</p>
<p><code>sys.path</code>列表在解释器启动时根据<code>PYTHONPATH</code>设置进行初始化，你电脑中的Python目录下的所有<code>.pyh</code>路径文件的内容，以及系统默认设置。其实如果你交互地查看<code>sys.path</code>，就会注意到相当多的目录并不在你的<code>PYTHONPATH</code>中：<code>sys.path</code>还包含了一个代表脚本主目录的指示器和一组标准库目录，因安装而异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure>
<p><code>sys.path</code>可以用程序进行更改。脚本可以借助多种列表操作来设置搜索路径，比如<code>append</code>、<code>extend</code>、<code>insert</code>、<code>pop</code>、<code>remove</code>和<code>del</code>，以便把所需的源目录全部包括进来。无罗你如何更改，Python在导入时总是使用当前<code>sys.path</code>设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r'C:\mydir'</span>)</span><br></pre></td></tr></table></figure>
<p>设置shell变量PYTHONPATH的另一个办法时向上面这样直接更改<code>sys.path</code>，不过这不是永久性的。对<code>sys.path</code>的更改只维持到Python结束时，而且每次启动新的Python程序或会话时，都必须重新设置。</p>
<h1 id="已加载模块表"><a href="#已加载模块表" class="headerlink" title="已加载模块表"></a>已加载模块表</h1><p><code>sys</code>模块还包含嵌入解释器的钩子。例如，<code>sys.modules</code>是个字典，你的Python会话或程序（准确说是进程）所导入的每个模块在其中都有一个<code>name:module</code>项:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.modules</span><br><span class="line">list(sys.modules.key())</span><br><span class="line">sys.modules[<span class="string">'sys'</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以使用这个钩子来编写程序，让程序显示或者处理某个程序加载的所有模块（对<code>sys.modules</code>的键列表进行迭代即可）。</p>
<p>另外，借助解释器的钩子，可以通过<code>sys.getrefcount</code>来查看对象的引用次数，而Python可执行程序的内置模块名称则在<code>sys.builtin_module_names</code>中列出。</p>
<h1 id="异常的详细信息"><a href="#异常的详细信息" class="headerlink" title="异常的详细信息"></a>异常的详细信息</h1><p>通过sys模块中的另一些属性为我们提供最近抛出的Python异常的所有相关信息。如果想以更一般的方式来处理异常，这一点就变得非常方便。例如，<code>sys.exc_info</code>函数会返回一个元组，其中含有最近异常的类型、值和追踪对象，在Python使用的所有基于类的异常模型中，前两个异常模型对应着最近的异常所属的类及其实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> IndexError</span><br><span class="line">execpt:</span><br><span class="line">    print(sys.exc_info())</span><br></pre></td></tr></table></figure>
<p>可以利用这些信息来格式化显示我们自己的错误信息，将其显示在GUI弹出窗口或HTML网页中（默认设置下，未能捕获的异常将终止程序并显示一条Python错误消息）。这个调用返回的前两项直接打印时显示具有一定格式的字符串，而第三项是追踪对象，可以用标准模块<code>traceback</code>处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback, sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grail</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'already got one'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    grail(<span class="string">'arthur'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    exc_info = sys.exc_info()</span><br><span class="line">    print(exc_info[<span class="number">0</span>])</span><br><span class="line">    print(exc_info[<span class="number">1</span>])</span><br><span class="line">    traceback.print_tb(exc_info[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>traceback模块还可以将消息格式化为字符串并将其到想到特定文档对象</p>
</blockquote>
<h1 id="sys模块到处的其他工具"><a href="#sys模块到处的其他工具" class="headerlink" title="sys模块到处的其他工具"></a>sys模块到处的其他工具</h1><p>sys模块还导出其他一些常用工具，例如：</p>
<ul>
<li>显示为由字符串组成的列表的命令行参数，称为<code>sys.argv</code>。</li>
<li>标准流，包括<code>sys.stdin</code>、<code>sys.stdout</code>和<code>sys.stderr</code>。</li>
<li>程序可以通过调用<code>sys.exit</code>强制退出。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Sys</tag>
      </tags>
  </entry>
  <entry>
    <title>介绍OS模块（Python）</title>
    <url>/2018/08/20/Program-design/Python/OS-Module/</url>
    <content><![CDATA[<h1 id="介绍Python-OS模块"><a href="#介绍Python-OS模块" class="headerlink" title="介绍Python OS模块"></a>介绍Python OS模块</h1><p><code>os</code>模块是两大核心系统模块中较大的那个。它包含了在C程序和shell脚本中经常用到的所有操作系统调用。它的调用设计目录、进程和shell变量等。准确地说，该模块提供了<em>POSIX</em>工具，操作系统调用的跨平台移植标准，以及不依赖平台的目录处理工具，如内嵌模块<code>os.path</code>便携的脚本通常无需改动即可在其他平台上运行。某些平台，os还包括了专属该平台的额外工具。不过总的来说，只要技术上可行，os都能做到跨平台。</p>
<a id="more"></a>
<h2 id="os模块中的工具"><a href="#os模块中的工具" class="headerlink" title="os模块中的工具"></a>os模块中的工具</h2><p>os模块中常用的一些工具：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>任务</th>
<th>工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shell变量</td>
<td><code>os.enviros</code></td>
</tr>
<tr>
<td>运行程序</td>
<td><code>os.system</code>,  <code>os.popen</code>,  <code>os.execv</code>,  <code>os.swawnv</code></td>
</tr>
<tr>
<td>派生</td>
<td><code>os.fork</code>,  <code>os.pipe</code>,  <code>os.waitpid</code>, <code>os.kill</code></td>
</tr>
<tr>
<td>文件描述符，文件锁</td>
<td><code>os.open</code>, <code>os.read</code> , <code>os.write</code></td>
</tr>
<tr>
<td>文件处理</td>
<td><code>os.remove</code>, <code>os.rename</code>, <code>os.mkfifo</code>, <code>os.mkdir</code>, <code>os.rmdir</code></td>
</tr>
<tr>
<td>管理工具</td>
<td><code>os.getcwd</code>, <code>os.chdir</code>, <code>os.chmod</code>, <code>os.getpid</code>, <code>os.listdir</code>, <code>os.access</code></td>
</tr>
<tr>
<td>移植工具</td>
<td><code>os.sep</code> , <code>os.pathsep</code>, <code>os.curdir</code>, <code>os.path.split</code>, <code>os.path.join</code></td>
</tr>
<tr>
<td>路径名工具</td>
<td><code>os.path.exists(&#39;path&#39;)</code>, <code>os.path.isdir(&#39;path&#39;)</code>, <code>os.path.getsize(&#39;path&#39;)</code></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>如果交互地查看这个模块的属性， 你会得到一大串名称， 他们会因Python的版本和运行平台而异，所以你必须了解每一个名称的意义才能很好地利用他们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir(os)</span><br><span class="line">[<span class="string">'CLD_CONTINUED'</span>, <span class="string">'CLD_DUMPED'</span>, <span class="string">'CLD_EXITED'</span>, <span class="string">'CLD_TRAPPED'</span>, <span class="string">'DirEntry'</span>, <span class="string">'EX_CANTCREAT'</span>, <span class="string">'EX_CONFIG'</span>, <span class="string">'EX_DATAERR'</span>, <span class="string">'EX_IOERR'</span>, <span class="string">'EX_NOHOST'</span>, <span class="string">'EX_NOINPUT'</span>, <span class="string">'EX_NOPERM'</span>, <span class="string">'EX_NOUSER'</span>, <span class="string">'EX_OK'</span>, <span class="string">'EX_OSERR'</span>, <span class="string">'EX_OSFILE'</span>, <span class="string">'EX_PROTOCOL'</span>, <span class="string">'EX_SOFTWARE'</span>, <span class="string">'EX_TEMPFAIL'</span>, <span class="string">'EX_UNAVAILABLE'</span>, <span class="string">'EX_USAGE'</span>, <span class="string">'F_LOCK'</span>, <span class="string">'F_OK'</span>, <span class="string">'F_TEST'</span>, <span class="string">'F_TLOCK'</span>, <span class="string">'F_ULOCK'</span>, <span class="string">'GRND_NONBLOCK'</span>, <span class="string">'GRND_RANDOM'</span>, <span class="string">'MutableMapping'</span>, <span class="string">'NGROUPS_MAX'</span>, <span class="string">'O_ACCMODE'</span>, <span class="string">'O_APPEND'</span>, <span class="string">'O_ASYNC'</span>, <span class="string">'O_CLOEXEC'</span>, <span class="string">'O_CREAT'</span>, <span class="string">'O_DIRECT'</span>, <span class="string">'O_DIRECTORY'</span>, <span class="string">'O_DSYNC'</span>, <span class="string">'O_EXCL'</span>, <span class="string">'O_LARGEFILE'</span>, <span class="string">'O_NDELAY'</span>, <span class="string">'O_NOATIME'</span>, <span class="string">'O_NOCTTY'</span>, <span class="string">'O_NOFOLLOW'</span>, <span class="string">'O_NONBLOCK'</span>, <span class="string">'O_PATH'</span>, <span class="string">'O_RDONLY'</span>, <span class="string">'O_RDWR'</span>, <span class="string">'O_RSYNC'</span>, <span class="string">'O_SYNC'</span>, <span class="string">'O_TMPFILE'</span>, <span class="string">'O_TRUNC'</span>, <span class="string">'O_WRONLY'</span>, <span class="string">'POSIX_FADV_DONTNEED'</span>, <span class="string">'POSIX_FADV_NOREUSE'</span>, <span class="string">'POSIX_FADV_NORMAL'</span>, <span class="string">'POSIX_FADV_RANDOM'</span>, <span class="string">'POSIX_FADV_SEQUENTIAL'</span>, <span class="string">'POSIX_FADV_WILLNEED'</span>, <span class="string">'PRIO_PGRP'</span>, <span class="string">'PRIO_PROCESS'</span>, <span class="string">'PRIO_USER'</span>, <span class="string">'P_ALL'</span>, <span class="string">'P_NOWAIT'</span>, <span class="string">'P_NOWAITO'</span>, <span class="string">'P_PGID'</span>, <span class="string">'P_PID'</span>, <span class="string">'P_WAIT'</span>, <span class="string">'PathLike'</span>, <span class="string">'RTLD_DEEPBIND'</span>, <span class="string">'RTLD_GLOBAL'</span>, <span class="string">'RTLD_LAZY'</span>, <span class="string">'RTLD_LOCAL'</span>, <span class="string">'RTLD_NODELETE'</span>, <span class="string">'RTLD_NOLOAD'</span>, <span class="string">'RTLD_NOW'</span>, <span class="string">'R_OK'</span>, <span class="string">'SCHED_BATCH'</span>, <span class="string">'SCHED_FIFO'</span>, <span class="string">'SCHED_IDLE'</span>, <span class="string">'SCHED_OTHER'</span>, <span class="string">'SCHED_RESET_ON_FORK'</span>, <span class="string">'SCHED_RR'</span>, <span class="string">'SEEK_CUR'</span>, <span class="string">'SEEK_DATA'</span>, <span class="string">'SEEK_END'</span>, <span class="string">'SEEK_HOLE'</span>, <span class="string">'SEEK_SET'</span>, <span class="string">'ST_APPEND'</span>, <span class="string">'ST_MANDLOCK'</span>, <span class="string">'ST_NOATIME'</span>, <span class="string">'ST_NODEV'</span>, <span class="string">'ST_NODIRATIME'</span>, <span class="string">'ST_NOEXEC'</span>, <span class="string">'ST_NOSUID'</span>, <span class="string">'ST_RDONLY'</span>, <span class="string">'ST_RELATIME'</span>, <span class="string">'ST_SYNCHRONOUS'</span>, <span class="string">'ST_WRITE'</span>, <span class="string">'TMP_MAX'</span>, <span class="string">'WCONTINUED'</span>, <span class="string">'WCOREDUMP'</span>, <span class="string">'WEXITED'</span>, <span class="string">'WEXITSTATUS'</span>, <span class="string">'WIFCONTINUED'</span>, <span class="string">'WIFEXITED'</span>, <span class="string">'WIFSIGNALED'</span>, <span class="string">'WIFSTOPPED'</span>, <span class="string">'WNOHANG'</span>, <span class="string">'WNOWAIT'</span>, <span class="string">'WSTOPPED'</span>, <span class="string">'WSTOPSIG'</span>, <span class="string">'WTERMSIG'</span>, <span class="string">'WUNTRACED'</span>, <span class="string">'W_OK'</span>, <span class="string">'XATTR_CREATE'</span>, <span class="string">'XATTR_REPLACE'</span>, <span class="string">'XATTR_SIZE_MAX'</span>, <span class="string">'X_OK'</span>, <span class="string">'_Environ'</span>, <span class="string">'__all__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'_execvpe'</span>, <span class="string">'_exists'</span>, <span class="string">'_exit'</span>, <span class="string">'_fspath'</span>, <span class="string">'_fwalk'</span>, <span class="string">'_get_exports_list'</span>, <span class="string">'_putenv'</span>, <span class="string">'_spawnvef'</span>, <span class="string">'_unsetenv'</span>, <span class="string">'_wrap_close'</span>, <span class="string">'abc'</span>, <span class="string">'abort'</span>, <span class="string">'access'</span>, <span class="string">'altsep'</span>, <span class="string">'chdir'</span>, <span class="string">'chmod'</span>, <span class="string">'chown'</span>, <span class="string">'chroot'</span>, <span class="string">'close'</span>, <span class="string">'closerange'</span>, <span class="string">'confstr'</span>, <span class="string">'confstr_names'</span>, <span class="string">'cpu_count'</span>, <span class="string">'ctermid'</span>, <span class="string">'curdir'</span>, <span class="string">'defpath'</span>, <span class="string">'device_encoding'</span>, <span class="string">'devnull'</span>, <span class="string">'dup'</span>, <span class="string">'dup2'</span>, <span class="string">'environ'</span>, <span class="string">'environb'</span>, <span class="string">'errno'</span>, <span class="string">'error'</span>, <span class="string">'execl'</span>, <span class="string">'execle'</span>, <span class="string">'execlp'</span>, <span class="string">'execlpe'</span>, <span class="string">'execv'</span>, <span class="string">'execve'</span>, <span class="string">'execvp'</span>, <span class="string">'execvpe'</span>, <span class="string">'extsep'</span>, <span class="string">'fchdir'</span>, <span class="string">'fchmod'</span>, <span class="string">'fchown'</span>, <span class="string">'fdatasync'</span>, <span class="string">'fdopen'</span>, <span class="string">'fork'</span>, <span class="string">'forkpty'</span>, <span class="string">'fpathconf'</span>, <span class="string">'fsdecode'</span>, <span class="string">'fsencode'</span>, <span class="string">'fspath'</span>, <span class="string">'fstat'</span>, <span class="string">'fstatvfs'</span>, <span class="string">'fsync'</span>, <span class="string">'ftruncate'</span>, <span class="string">'fwalk'</span>, <span class="string">'get_blocking'</span>, <span class="string">'get_exec_path'</span>, <span class="string">'get_inheritable'</span>, <span class="string">'get_terminal_size'</span>, <span class="string">'getcwd'</span>, <span class="string">'getcwdb'</span>, <span class="string">'getegid'</span>, <span class="string">'getenv'</span>, <span class="string">'getenvb'</span>, <span class="string">'geteuid'</span>, <span class="string">'getgid'</span>, <span class="string">'getgrouplist'</span>, <span class="string">'getgroups'</span>, <span class="string">'getloadavg'</span>, <span class="string">'getlogin'</span>, <span class="string">'getpgid'</span>, <span class="string">'getpgrp'</span>, <span class="string">'getpid'</span>, <span class="string">'getppid'</span>, <span class="string">'getpriority'</span>, <span class="string">'getrandom'</span>, <span class="string">'getresgid'</span>, <span class="string">'getresuid'</span>, <span class="string">'getsid'</span>, <span class="string">'getuid'</span>, <span class="string">'getxattr'</span>, <span class="string">'initgroups'</span>, <span class="string">'isatty'</span>, <span class="string">'kill'</span>, <span class="string">'killpg'</span>, <span class="string">'lchown'</span>, <span class="string">'linesep'</span>, <span class="string">'link'</span>, <span class="string">'listdir'</span>, <span class="string">'listxattr'</span>, <span class="string">'lockf'</span>, <span class="string">'lseek'</span>, <span class="string">'lstat'</span>, <span class="string">'major'</span>, <span class="string">'makedev'</span>, <span class="string">'makedirs'</span>, <span class="string">'minor'</span>, <span class="string">'mkdir'</span>, <span class="string">'mkfifo'</span>, <span class="string">'mknod'</span>, <span class="string">'name'</span>, <span class="string">'nice'</span>, <span class="string">'open'</span>, <span class="string">'openpty'</span>, <span class="string">'pardir'</span>, <span class="string">'path'</span>, <span class="string">'pathconf'</span>, <span class="string">'pathconf_names'</span>, <span class="string">'pathsep'</span>, <span class="string">'pipe'</span>, <span class="string">'pipe2'</span>, <span class="string">'popen'</span>, <span class="string">'posix_fadvise'</span>, <span class="string">'posix_fallocate'</span>, <span class="string">'pread'</span>, <span class="string">'putenv'</span>, <span class="string">'pwrite'</span>, <span class="string">'read'</span>, <span class="string">'readlink'</span>, <span class="string">'readv'</span>, <span class="string">'remove'</span>, <span class="string">'removedirs'</span>, <span class="string">'removexattr'</span>, <span class="string">'rename'</span>, <span class="string">'renames'</span>, <span class="string">'replace'</span>, <span class="string">'rmdir'</span>, <span class="string">'scandir'</span>, <span class="string">'sched_get_priority_max'</span>, <span class="string">'sched_get_priority_min'</span>, <span class="string">'sched_getaffinity'</span>, <span class="string">'sched_getparam'</span>, <span class="string">'sched_getscheduler'</span>, <span class="string">'sched_param'</span>, <span class="string">'sched_rr_get_interval'</span>, <span class="string">'sched_setaffinity'</span>, <span class="string">'sched_setparam'</span>, <span class="string">'sched_setscheduler'</span>, <span class="string">'sched_yield'</span>, <span class="string">'sendfile'</span>, <span class="string">'sep'</span>, <span class="string">'set_blocking'</span>, <span class="string">'set_inheritable'</span>, <span class="string">'setegid'</span>, <span class="string">'seteuid'</span>, <span class="string">'setgid'</span>, <span class="string">'setgroups'</span>, <span class="string">'setpgid'</span>, <span class="string">'setpgrp'</span>, <span class="string">'setpriority'</span>, <span class="string">'setregid'</span>, <span class="string">'setresgid'</span>, <span class="string">'setresuid'</span>, <span class="string">'setreuid'</span>, <span class="string">'setsid'</span>, <span class="string">'setuid'</span>, <span class="string">'setxattr'</span>, <span class="string">'spawnl'</span>, <span class="string">'spawnle'</span>, <span class="string">'spawnlp'</span>, <span class="string">'spawnlpe'</span>, <span class="string">'spawnv'</span>, <span class="string">'spawnve'</span>, <span class="string">'spawnvp'</span>, <span class="string">'spawnvpe'</span>, <span class="string">'st'</span>, <span class="string">'stat'</span>, <span class="string">'stat_float_times'</span>, <span class="string">'stat_result'</span>, <span class="string">'statvfs'</span>, <span class="string">'statvfs_result'</span>, <span class="string">'strerror'</span>, <span class="string">'supports_bytes_environ'</span>, <span class="string">'supports_dir_fd'</span>, <span class="string">'supports_effective_ids'</span>, <span class="string">'supports_fd'</span>, <span class="string">'supports_follow_symlinks'</span>, <span class="string">'symlink'</span>, <span class="string">'sync'</span>, <span class="string">'sys'</span>, <span class="string">'sysconf'</span>, <span class="string">'sysconf_names'</span>, <span class="string">'system'</span>, <span class="string">'tcgetpgrp'</span>, <span class="string">'tcsetpgrp'</span>, <span class="string">'terminal_size'</span>, <span class="string">'times'</span>, <span class="string">'times_result'</span>, <span class="string">'truncate'</span>, <span class="string">'ttyname'</span>, <span class="string">'umask'</span>, <span class="string">'uname'</span>, <span class="string">'uname_result'</span>, <span class="string">'unlink'</span>, <span class="string">'unsetenv'</span>, <span class="string">'urandom'</span>, <span class="string">'utime'</span>, <span class="string">'wait'</span>, <span class="string">'wait3'</span>, <span class="string">'wait4'</span>, <span class="string">'waitid'</span>, <span class="string">'waitid_result'</span>, <span class="string">'waitpid'</span>, <span class="string">'walk'</span>, <span class="string">'write'</span>, <span class="string">'writev'</span>]</span><br></pre></td></tr></table></figure>
<p>除了以上这些，内嵌的<code>os.path</code>模块还能导出更多的工具，他们大多都涉及可移植地处理文档和目录名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir(os.path)</span><br><span class="line">[<span class="string">'__all__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'_get_sep'</span>, <span class="string">'_joinrealpath'</span>, <span class="string">'_varprog'</span>, <span class="string">'_varprogb'</span>, <span class="string">'abspath'</span>, <span class="string">'altsep'</span>, <span class="string">'basename'</span>, <span class="string">'commonpath'</span>, <span class="string">'commonprefix'</span>, <span class="string">'curdir'</span>, <span class="string">'defpath'</span>, <span class="string">'devnull'</span>, <span class="string">'dirname'</span>, <span class="string">'exists'</span>, <span class="string">'expanduser'</span>, <span class="string">'expandvars'</span>, <span class="string">'extsep'</span>, <span class="string">'genericpath'</span>, <span class="string">'getatime'</span>, <span class="string">'getctime'</span>, <span class="string">'getmtime'</span>, <span class="string">'getsize'</span>, <span class="string">'isabs'</span>, <span class="string">'isdir'</span>, <span class="string">'isfile'</span>, <span class="string">'islink'</span>, <span class="string">'ismount'</span>, <span class="string">'join'</span>, <span class="string">'lexists'</span>, <span class="string">'normcase'</span>, <span class="string">'normpath'</span>, <span class="string">'os'</span>, <span class="string">'pardir'</span>, <span class="string">'pathsep'</span>, <span class="string">'realpath'</span>, <span class="string">'relpath'</span>, <span class="string">'samefile'</span>, <span class="string">'sameopenfile'</span>, <span class="string">'samestat'</span>, <span class="string">'sep'</span>, <span class="string">'split'</span>, <span class="string">'splitdrive'</span>, <span class="string">'splitext'</span>, <span class="string">'stat'</span>, <span class="string">'supports_unicode_filenames'</span>, <span class="string">'sys'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h2><p>和<code>sys</code>模块一样，os模块也代用一套提供信息、帮助管理的工具：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getpid</span><br><span class="line"><span class="number">14539</span></span><br><span class="line"></span><br><span class="line">os.chdir(<span class="string">r'C:\User'</span>)</span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="string">'C:\User'</span></span><br></pre></td></tr></table></figure>
<p><code>os.getpid()</code>给出调用函数的进程的ID（这是系统为当前运行程序定义的唯一标识符，可用于进程控制和唯一命名），<code>os.fercwd</code>则返回当前的工作目录。当前的工作目录是你的脚本所打开的文档应当放置的位置，除非文件名里显式的包含了目录路径。</p>
<h2 id="可移植的常量"><a href="#可移植的常量" class="headerlink" title="可移植的常量"></a>可移植的常量</h2><p><code>os</code>模块同事导出了一组用于简化跨平台编程的名称，包括与具体平台相关的路径和目录分隔符、父目录和当前目录指示器，以及底层计算机所采用的换行符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.pathsep, os.sep, os,pardir, os.curdir, os.linesep</span><br><span class="line">(<span class="string">':'</span>, <span class="string">'/'</span>, <span class="string">'..'</span>, <span class="string">'.'</span>, <span class="string">'\n'</span>)				<span class="comment"># linux</span></span><br><span class="line">(<span class="string">';'</span>, <span class="string">'\\'</span>, <span class="string">'..'</span>, <span class="string">'.'</span>, <span class="string">'\r\n'</span>)				<span class="comment"># win</span></span><br></pre></td></tr></table></figure>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:Notes/笔记/Python编程/系统编程/系统工具/os模块.md<br><code>os.sep</code>是Python底层运行平台所采用的目录组分隔符号。他在windows下自动预设为“\” ，POSIX则是“/” ,某些Mac则是“:”。类似的，os.pathsep提供用于在目录列表中分隔目录的字符，POSIX使用“:”，DOS和Windows使用“；”。</p>
<p><code>os.sep</code>是Python底层运行平台所采用的目录组分隔符号。他在windows下自动预设为</p>
<p>“\“,POSIX计算机则是”/“, 某些Mac上则使用”:“。类似地，<code>os.pathsep</code>提供用于在目录列表中分隔目录的字符，POSIX使用”:”,DOS和windows使用”;“。</p>
<p>当我们在脚本中拼装和分解这些系统相关字符串时，借助这些属性，可以充分实现脚本的可移植性。例如，虽然<code>dirpath</code>在windows中是<em>dir\dir</em>，在Linux中是<em>dir/dir</em> ,但<code>dir path.split(os.sep)</code>的调用可以准确无误地将与平台相关的目录名称分解为各个部分。在Windows中你通常可以在列出待打开的文件名时用斜杠代替反斜杠，但这些可移植的常量允许脚本在目录处理部分的代码不依赖平台。</p>
<p>另外请注意，<code>os.linesep</code>在这里使用的是\r\n,这个符号转义码在Windows下代表回车加换行惯例，在使用Python处理文本时一般不会注意这一点。</p>
<h2 id="常见os-path工具"><a href="#常见os-path工具" class="headerlink" title="常见os.path工具"></a>常见os.path工具</h2><p>内嵌的<code>os.path</code>模块提供了一整套目录处理相关工具。举例来说，它提供的可移植函数可以用来检查文件类型（<code>isdir</code>,<code>isfile</code>等）、测试文件是否存在（<code>exists</code>)，以及通过文件名来获取文件的大小（<code>getsize</code>）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.isdir(<span class="string">r'C:\Users'</span>), os.path.isfile(<span class="string">r'C:\Users'</span>)</span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">os.path.isdir(<span class="string">r'C:\config.sys'</span>), os.path.isfile(<span class="string">r'C:\config.sys'</span>)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line">os.path.isdir(<span class="string">'nonesuch'</span>), os.path.isfile(<span class="string">'nonesuch'</span>)</span><br><span class="line">(<span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">os.path.exists(<span class="string">r'c\Users\Xie'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">os.path.exists(<span class="string">r'c:\Users\Default'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">os.path.getsize(<span class="string">r'C:\autoexec.bat'</span>)</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p><code>os.path.isdir</code>和<code>os.path.isfile</code>调用可以告诉我们文件名是目录还是一个简单的文件。如果文件不存在，二者都会返回<em>False</em>(也就是说不存在即暗示否定的意思)。我们还能得到用于分割和合并目录路径字符串的函数，它们会自动应用Python所在底层平台的目录命名惯例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.path.split(<span class="string">r'C:\temp\data.txt'</span>)</span><br><span class="line">(<span class="string">'C:\\temp'</span>, <span class="string">'data.txt'</span>)</span><br><span class="line"></span><br><span class="line">os.path.join(<span class="string">r'C:\temp'</span>,<span class="string">'output.txt'</span>)</span><br><span class="line">(<span class="string">'C:\\temp\\output.txt'</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">r'C:\temp\data.txt'</span>		<span class="comment"># windows路径风格</span></span><br><span class="line">os.path.dirname(name), os.path.basename(name)</span><br><span class="line">(<span class="string">'C:\temp'</span>, <span class="string">'data.txt'</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">'/home/xth/temp/data.txt'</span>	<span class="comment"># Unix风格路径</span></span><br><span class="line">os.path.dirname(name), os.path.basename(name)</span><br><span class="line">(<span class="string">'/home/xth/temp'</span>, <span class="string">'data.txt'</span>)</span><br><span class="line"></span><br><span class="line">os.path.splitext(<span class="string">r'C:\example\python\demo.py'</span>)</span><br><span class="line">(<span class="string">'C:\\example\\python\\demo'</span>, <span class="string">'.py'</span>)</span><br></pre></td></tr></table></figure>
<p><code>os.path.split</code>将文件名从它的目录路径中剥离出来，<code>os.path.join</code>则将它们合并起来，这两个调用都是可移植的，都自动采用所在平台的路径命名惯例。为了简便起见<code>dirname</code>和<code>basename</code>则调用返回了<code>split</code>返回结果的前两项，<code>splitext</code>则剥离了文件的扩展名。微妙之处在于，使用字符串的<code>split</code>和<code>join</code>方法几乎可以起到<code>os.sep</code>相同的作用，只是有细微区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.sep</span><br><span class="line"><span class="string">'\\'</span></span><br><span class="line"></span><br><span class="line">pathname = <span class="string">r'C:\example\python\demo.py'</span></span><br><span class="line">os.path.split(pathname)		<span class="comment"># 分割文件和目录</span></span><br><span class="line">(<span class="string">'C:\\example\\python\\'</span>, <span class="string">'demo.py'</span>)</span><br><span class="line">pathname.split(os.sep)		<span class="comment"># 在每个斜杠处做分割</span></span><br><span class="line">(<span class="string">'C'</span>, <span class="string">'example'</span>, <span class="string">'python'</span>, <span class="string">'demo.py'</span>)</span><br><span class="line"></span><br><span class="line">os.sep.join(pathname.split(os.sep))</span><br><span class="line"><span class="string">'C:\\example\\python\\demo.py'</span></span><br><span class="line"></span><br><span class="line">os.path.join(*pathname.split(os.sep))</span><br><span class="line"><span class="string">'C:example\\python\\demo.py'</span></span><br></pre></td></tr></table></figure>
<p>最后一个<code>join</code>调用要求传入参数（因此用了*），但因为Windows的驱动器句法的关系不插入第一个斜杠；如果这种区别影响到程序，可以转而使用前面的<code>str.join</code>方法。如果你的路径混用了<br>Unix和Windows分隔符，这时<code>normpath</code>调用显得格外好用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">mixed = <span class="string">'C:\\temp\\public/files/index.html'</span></span><br><span class="line">os.path.normpath(mixed)</span><br><span class="line"><span class="string">'C:\\temp\\public\\files\\index.html'</span></span><br><span class="line">print(os.path.normpath(<span class="string">r'C\trmp\\sub\.\file,ext'</span>))</span><br><span class="line">C:\temp\sub\file.ext</span><br></pre></td></tr></table></figure>
<p>这个模块还有<code>abspath</code>调用，他能可移植地返回文件的完整目录路径名。它负责将当前目录添加为前缀以及处理..父目录句法等：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="string">'C:\\Users'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">''</span>)			<span class="comment"># 空字符串代表当前工作目录</span></span><br><span class="line"><span class="string">'C:\\Users'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">'temp'</span>)		<span class="comment"># 扩展为当前工作目录下的完整路径名</span></span><br><span class="line"><span class="string">'C:\\Users\\temp'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">r'demo\dev'</span>)	<span class="comment">#相对于当前工作目录的不完整路径</span></span><br><span class="line"><span class="string">'C:\\Users\\demo\\dev'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">'.'</span>)			<span class="comment"># 扩展相对路径句法</span></span><br><span class="line"><span class="string">'C:\\Users'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">'..'</span>)</span><br><span class="line"><span class="string">'C:\\'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">r'..\examples'</span>)</span><br><span class="line"><span class="string">'C:\\examples'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">r'C:\Python\examples'</span>)		<span class="comment"># 绝对路径不变</span></span><br><span class="line"><span class="string">'C:\\Python\\examples'</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">r'C:\temp\spam.txt'</span>)</span><br><span class="line"><span class="string">'C:\\temp\\spam.txt'</span></span><br></pre></td></tr></table></figure>
<p>在给出完整路径之前，文件名采用基于当前工作目录的相对路径，因此如果你想了解用户展示文件真正存储于哪个目录下，可以使用<code>os.path.abspath</code>函数来帮忙。</p>
<h2 id="在脚本里运行shell命令"><a href="#在脚本里运行shell命令" class="headerlink" title="　在脚本里运行shell命令"></a>　在脚本里运行shell命令</h2><p>os模块也是使得我们可以从Python脚本运行Shell命令。这个概念与流等密切相关，以下两个os函数使得脚本可以运行你在控制窗口输入的任意命令行：</p>
<p><code>os.system</code></p>
<p>​    在Python脚本中运行shell命令。</p>
<p><code>os.popen</code></p>
<p>​    运行shell命令并与其输入或输出流相连接。</p>
<hr>
<p><em>另外，相对较新的<code>subprocess</code></em>模块可以对生成的shell命令流进行精细控制，而且可以代替(会增加代码复杂性)。</p>
<h3 id="运行shell命令"><a href="#运行shell命令" class="headerlink" title="运行shell命令"></a>运行shell命令</h3><p>虽然Python的命令行脚本有时被误解为“shell工具”，由于os模块的system和popen调用使得Python脚本可以运行底层系统shell可理解的任意命令，物流他们是用Python还是其他语言编写的。例如下面这段代码，他在shell提示符后运行了刚才演示的那两条DOS shell命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system.(<span class="string">'dir /B'</span>)</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'type helloworld.py'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="与shell命令进行通信"><a href="#与shell命令进行通信" class="headerlink" title="　与shell命令进行通信"></a>　与shell命令进行通信</h3><p><code>os.system</code>函数只是简单地执行一条shell命令，<code>os.popen</code>还会连接到这个命令的标准输入\输出流；我们将得到一个类似文件的对象，他默认与命令的输出相连（向<strong>popen</strong>传入<strong>w</strong>模式标识符则与命令的输入流相连）。借助这个对象可以读取<code>popen</code>所派生的命令的输出结果，从而在输入命令行之后拦截那些在正常情况下将出现在控制窗口中的文字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">open(<span class="string">'helloshell.py'</span>).read()</span><br><span class="line"><span class="string">"# a Python program\nprint('The meaning of Life')\n"</span></span><br><span class="line"></span><br><span class="line">text = os.popen(<span class="string">'type helloshell.py'</span>).read()</span><br><span class="line">listing = os.popen(<span class="string">'dir /B'</span>).readlinesd()</span><br><span class="line">print(listing)</span><br><span class="line">[<span class="string">'helloshell.py\n'</span>, <span class="string">'more.py'</span>, <span class="string">'more.pyc'</span>, <span class="string">'spam.txt'</span>, <span class="string">'__init__.py'</span>]</span><br></pre></td></tr></table></figure>
<p>这里，我们先用常用的方法来抓取文件内容，然后将文件内容作为shell中<code>type</code>命令的输出。通过阅读<code>dir</code>命令的输出结果，我们可以获取目录中文件的列表，进而对这个列表进行迭代处理。</p>
<p>到目前为止，我们运行了一些基本dos命令。因为这些调用可以运行我们能够在shell提示符输入任何命令，所以它们也可以用来启动其他Python脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.system(<span class="string">'python helloshell.py'</span>)			<span class="comment"># 运行一个Python程序</span></span><br><span class="line"></span><br><span class="line">output = os.popen(<span class="string">'python helloshell.py'</span>).read()</span><br></pre></td></tr></table></figure>
<p>在这些例子里，发送到system和popen的命令行字符串都是硬编码的，然而并不是说Python程序不能在运行时用普通的字符串运算（+，%等）来构建这种字符串。因为可以以这种方式动态地来创建并运行命令，所以<code>system</code>和<code>popen</code>将Pyrhon脚本变成了用于启动和组织其他程序灵活而可移植的工具。</p>
<h3 id="替代方法：subprocess模块"><a href="#替代方法：subprocess模块" class="headerlink" title="　替代方法：subprocess模块"></a>　替代方法：subprocess模块</h3><p>一般来说，<code>subprocess</code>模块要求更多的代码，但对流的连接和使用提供跟完善的控制。当流的链接方式更为复杂时，显得格外有用。</p>
<p>例如，这个新模块的<code>call</code>函数在运行简单的shell命令方面和<code>os.system</code>差不多，（运行<code>type</code>这种Windows下的shell命令是需要额外的协议，不过像“Python”这种普通的可执行程序是不需要的）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">subprocess.call(<span class="string">'python helloshell.py'</span>)			<span class="comment">#　类似os.system</span></span><br><span class="line"></span><br><span class="line">subprocess.call(<span class="string">'cmd /C "type helloshell.py"'</span>)	 <span class="comment">#	内建shell命令</span></span><br><span class="line"></span><br><span class="line">subprocess.call(<span class="string">'type helloshell.py'</span>, shell=<span class="literal">True</span>)	<span class="comment"># 相当于内建函数</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>这里请注意，最后一行代码中的<code>shell = True</code>。这个用法比较微妙，而且与平台相关。</em></p>
<ul>
<li>在Windows下，需要将<code>shell = True</code>的参数传给<code>call</code>等<code>subprocess</code>工具和<code>popen</code>工具，这样才能够运行shell内建命令。像<code>type</code>之类的Windows命令要求装有额外协议，但像“Python”这种普通程序不需要。</li>
<li>在类Unix平台上，当<code>shell = False</code>（默认值）时，程序命令行直接由<code>os.execvp</code>运行，如果参数是True，那么这个程序将转由shell运行，而且你还可以借助其他参数来指定shell。</li>
</ul>
<p>除了模拟<code>os.system</code>,我们可以用类似方式让这个模块模拟前面用到的<code>os.popen</code>函数，在脚本中运行shell命令并获取其标准输出文本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">pipe = subprocess.Popen(<span class="string">'python helloshell.py'</span>, stdout=subprocess.PIPE)</span><br><span class="line">pipe.communicate()</span><br><span class="line">(<span class="string">b'The Meaning of Life\r\n'</span>, <span class="literal">None</span>)</span><br><span class="line">pipe.returncode</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里，我们将<code>stdout</code>流与管道连接，然后用<code>communicate</code>来运行命令，并接收它的标准输出流和错误输出流文本；运行完成后，命令的退出状态可作为属性来查看。或者，我们可以用其他接口直接读取命令的标准输出流，然后等待命令退出（并返回退出状态）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">pipe = subprocess.Popen(<span class="string">'python helloshell.py'</span>, stdout=subprocess.PIPE)</span><br><span class="line">pipe.communicate()</span><br><span class="line">(<span class="string">b'The Meaning of Life\r\n'</span>, <span class="literal">None</span>)</span><br><span class="line">pipe.wait()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>实际上，<code>os.popen</code>函数和<code>subprocess.Popen</code>对象之间存在直接的映射关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line">Popen(<span class="string">'python helloshell.py'</span>, stdout=PIPE).communicate()[<span class="number">0</span>]</span><br><span class="line"><span class="string">b'The Meaning of Life\r\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.popen(<span class="string">'python helloshell.py'</span>).read()</span><br><span class="line"><span class="string">'The Meaning of Life\n'</span></span><br></pre></td></tr></table></figure>
<p><code>subprocess</code>在这些简单的示例中显得多余。但我们需要更灵活地控制其他流时，它的作用就开始显现出来了。实际上，由于它允许我们以类似的方式处理命令的错误流和输出流，在Python3.X中<code>subprocess</code>取代了原先的<code>os.popen2</code>、<code>os.popen3</code>和<code>os.popen4</code>函数，他们都曾出现在Python2.X中，现在都只是<code>subprocess</code>对象接口的应用实例。因为这个模块更高级的应用实例涉及到标准流，</p>
<h3 id="shell的局限"><a href="#shell的局限" class="headerlink" title="　shell的局限"></a>　shell的局限</h3><p><code>system</code>和<code>popen</code>的两大局限。首先，尽管两个函数本身具有非常好的可移植性，但其真正分可移植程度决定于所运行的命令。例如前面那个DOS的<code>dir</code>和<code>type</code>shell命令的示例只在windows下有效，如果要在类Unix系统下运行，那么必须改为<code>ls</code>和<code>cat</code>命令。</p>
<p>其次，像这样将Python文件作为程序运行与导入程序文件再调用其中的函数是截然不同的做法，而且一般来说前者要比后者慢得多。调用<code>os.system</code>和<code>os.popen</code>时，他们必须在你的操作系统中启动完全不同的独立程序，当程序文件作为模块导入时，Python解释器只是简单地在同一个进程里加载和运行文件的代码，借此生成模板对象。整个过程中不会派生出其他程序。</p>
<p>将系统作为独立的程序来构建也有许多好处，他们允许程序间往返传递信息，但在很多情况下，导入模块构建系统更加快捷并且直接。</p>
<p>如果打算用这些函数，还应当记住<code>os.system</code>函数通常会阻塞（其实是暂停）它的调用者，直到所启动的命令行程序退出。在Linux和类Unix平台上，所启动的命令行一般可独立于调用者，并与之并行地运行，只需要在命令行代码末尾追加上shell后台运算符<code>&amp;</code>即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.system(<span class="string">"python program.py arg arg &amp;"</span>)</span><br></pre></td></tr></table></figure>
<p>在windows下，用dos的<code>start</code>命令通常也能使命令并行启动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.system(<span class="string">"start program.py arg arg"</span>)</span><br></pre></td></tr></table></figure>
<p>实际上，新近的Python版本中加入了<code>os.startfile</code>函数，这个函数会打开一个文件，无论文件类型是什么，就像鼠标单击一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.startfile(<span class="string">"webpage.html"</span>)		<span class="comment"># 在你的浏览器中打开文件</span></span><br><span class="line">os.startfile(<span class="string">"document.doc"</span>)		<span class="comment"># 在Microsoft Word 中打开文件</span></span><br><span class="line">os.startfile(<span class="string">"myscript.py"</span>)			<span class="comment"># 用python运行文件</span></span><br></pre></td></tr></table></figure>
<p><code>os.popen</code>函数一般不会阻塞其调用者，但无论在Windows还是Linux下，如果管道对象在所启动的程序退出前关闭（如进行垃圾回收时），或是管道一次性完成读取（如<code>read()</code>方法），那么仍然有可能阻塞调用者。Unix分<code>os.fork/exec</code>调用和Windows的<code>os.spawnv</code>调用有人可用来不受阻塞困扰地调用并行运行程序。</p>
<p>因为<code>os</code>模块的<code>system</code>和<code>popen</code>调用，以及<code>subprocess</code>模块也可归为程序启动、流量定向和进程间通信手段。</p>
<h3 id="os模块到处的其他工具"><a href="#os模块到处的其他工具" class="headerlink" title="os模块到处的其他工具"></a>os模块到处的其他工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>工具名</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>os.environ</code></td>
<td>获取和设置shell环境变量</td>
</tr>
<tr>
<td><code>os.fork</code></td>
<td>在类Unix系统下派生新的子进程</td>
</tr>
<tr>
<td><code>os.pipe</code></td>
<td>负责程序间通信</td>
</tr>
<tr>
<td><code>os.execlp</code></td>
<td>启动新程序</td>
</tr>
<tr>
<td><code>os.spawnv</code></td>
<td>启动带有底层控制的新程序</td>
</tr>
<tr>
<td><code>os.open</code></td>
<td>打开基于底层描述符的文件</td>
</tr>
<tr>
<td><code>os.mkdir</code></td>
<td>创建新目录</td>
</tr>
<tr>
<td><code>os.mkfifo</code></td>
<td>创建新的命名管道</td>
</tr>
<tr>
<td><code>os.stat</code></td>
<td>获取文件底层信息</td>
</tr>
<tr>
<td><code>os.remove</code></td>
<td>根据文件名删除文件</td>
</tr>
<tr>
<td><code>os.walk</code></td>
<td>将函数或循环应用于整个目录树的各个部分</td>
</tr>
</tbody>
</table>
</div>
<p>诸如此类还有很多，特别需要注意的一点，<code>os</code>模块提供了一套文件处理调用，如<code>open</code>、<code>read</code>和<code>write</code>，但所有这些涉及底层的文件访问，它们与用Python内建<code>open</code>函数创建的<code>stdio</code>文件对象截然不同。通常情况下，除了非常特殊的文件处理需求（比如排他性访问文件锁打开文件），你应当使用内建的<code>open</code>函数，而不是<code>os</code>模块，来处理所有文件。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>shell环境变量（Python）</title>
    <url>/2018/08/20/Program-design/Python/shell-environment-variables(Python)/</url>
    <content><![CDATA[<h1 id="shell环境变量"><a href="#shell环境变量" class="headerlink" title="shell环境变量"></a>shell环境变量</h1><p>shell变量有时称之为环境变量，Python脚本可以通过一个类似Python字典的对象<code>os.environ</code>来访问它们，其中在该对象里每项（entry）对应一个shell的变量设置。shell变量独立于Python系统，通常在你的系统启动、startup文件或控制面板中设置，他能为程序提供系统级的配置。</p>
<p>现在你应该很熟悉这例子： Python使用shell变量PYTHONPATH模块搜索路径来加载模块。在操作系统中配置后，每次Python程序运行都可以使用它。也可以在某些程序里设置shell变量，然后传递给其他程序。由于他们的值可以被子程序访问，因此也可以被用作简易的进程通信。<br><a id="more"></a></p>
<h2 id="获取shell变量"><a href="#获取shell变量" class="headerlink" title="获取shell变量"></a>获取shell变量</h2><p>在Python中，外部的shell环境被当作一个简单的预置对象。在<code>os.environ</code>中索引shell变量（如，<code>os.environ[&#39;USER&#39;]</code>）,类似Unix shell在变量名前添加一个<code>$</code>,(比如，<code>$USER</code>),在DOS上使用<code>%</code>（<code>%USER%</code>），在C语言里里调用<code>getenv(&quot;USER&quot;)</code>。我们启动一个交互会话来进行演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.environ.keys()</span><br><span class="line"></span><br><span class="line">list(os.environ.keys())</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'SHELL'</span>]						<span class="comment"># linux下获取shell变量</span></span><br><span class="line">os.environ[<span class="string">'TEMP'</span>]						<span class="comment"># Windows下获取TEMP变量</span></span><br></pre></td></tr></table></figure>
<p>在Windows下，keys方法可以得到所有变量名的迭代子，通过变量名如TEMP可以搜索出它的值，Linux也一样，不同的是在Python启动时有一些其他的变量被预设。我们已经接触过<code>PYTHONPATH</code>，所以以它为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.environ[<span class="string">'PYTHONPATH'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> srcdir <span class="keyword">in</span> os,environ[<span class="string">'PYTHONPATH'</span>].split(os.pathsep):</span><br><span class="line">    print(srcdir)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line">sys.path[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><code>PYTHONPATH</code>是一个包含多个路径的字符串，路径之间以路径分隔隔开。为了分割路径，我们传给字符串函数split一个分隔符<code>os.pathsep</code>，它会自动适配目标平台，<code>sys.path</code>是运行期的实际模块搜索路径，它会合并<code>PYTHONPATH</code>的值并附到当前路径后面。</p>
<h2 id="修改shell变量"><a href="#修改shell变量" class="headerlink" title="修改shell变量"></a>修改shell变量</h2><p><code>os.environ</code>对象支持像普通字典一样的键索引以及赋值功能。对于字典，赋值会改变对应的键值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.environ[<span class="string">'TEMP'</span>] = <span class="string">r'c:\temp'</span></span><br><span class="line">os.environ[<span class="string">'TEMP'</span>]</span><br><span class="line"><span class="string">'c:\temp'</span></span><br></pre></td></tr></table></figure>
<p>然而，还存在别的影响：在最新版本的Python中，赋值给<code>os.environ</code>的键值将自动被导出到应用的其他部分。即赋值将同时改变Python程序中的<code>os.environ</code>对象，以及该进程对应的shell环境变量。Python程序、所有链入的C模块，所有该Python进程派生的子程序都可以看到新的赋值。</p>
<p>在内部，对<code>os.environ</code>的键赋值将会调用<code>os.putenv</code>，它负责改变Python解释器外部的shell变量。我们用一组脚本来演示shell变量的设置和读取，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">print(<span class="string">'setenv...'</span>, end=<span class="string">' '</span>)	</span><br><span class="line">print(os.environ[<span class="string">'USER'</span>])		<span class="comment"># 输出当前shell的变量值</span></span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'USER'</span>] = <span class="string">'Brian'</span>	<span class="comment"># 在后台运行 os.putenv</span></span><br><span class="line">os.system(<span class="string">'python echoenv.py'</span>)</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'USER'</span>] = <span class="string">'Arthur'</span>	<span class="comment"># 传递更新到衍生程序</span></span><br><span class="line">os.system(<span class="string">'pytho;n echoenv.py'</span>)	<span class="comment"># 链接的C语言库模块</span></span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'USER'</span>] = input(<span class="string">'?'</span>)</span><br><span class="line">print(os.popen(<span class="string">'python echoenv.py'</span>).read())</span><br></pre></td></tr></table></figure>
<p>脚本setenv.py简单地修改shell变量USER。然后派生另外一个脚本进程读取该变量值，</p>
<hr>
<p><strong>echoenv.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">print(<span class="string">'echoenv...'</span>,end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">'Hello,'</span> os.environ[<span class="string">'USER'</span>])</span><br></pre></td></tr></table></figure>
<p>总而言之，一个子进程始终从它的父进程那里集成环境设置。子程序是由如下方式启动的程序：在Unix下<code>os.spawnv</code>、<code>os.fork/exec</code>，或者所有平台下的<code>os.popen</code>、<code>os.system</code>、subprocess。他们在启动时都会获得父进程的环境变量。</p>
<p>从更广泛的视角来看，像这样在启动程序前设置shell变量，是一种给程序传递信息的方式，比如，一个Python配置脚本在启动另外一个脚本程序前，可以修改<code>PYTHONPATH</code>变量以包含某种特定的目录。由于shell变量会传递给子进程，因而被启动程序的<code>sys.path</code>将会包含该目录。</p>
<h2 id="shell变量要点：父进程、putenv和getenv"><a href="#shell变量要点：父进程、putenv和getenv" class="headerlink" title="shell变量要点：父进程、putenv和getenv"></a>shell变量要点：父进程、putenv和getenv</h2><p>在Python的最顶层程序退出后，USER变量会变回初始值，赋给<code>os.environ</code>的键值被传到解释器外部，然后向下传给子进程；然而它永远不会向上传递到父进程（包括系统shell）。这个规划不是Python缺陷，在调用<code>putenv</code>库的C程序中同样如此。</p>
<p>如果Python脚本处在你的应用顶层，这不会有什么问题，然而要谨记，在你的程序中对shell所做的设置只对程序本身以及它所衍生的子程序有效，如果想让你的设置在Python退出后仍然生效，你可以通过平台相关的扩展来实现。</p>
<p>另一个微妙之处：在当前实现中，对<code>os.environ</code>的修改会自动调用<code>os.putenv</code>，后者将调用C库里的<code>putenv</code>把该设置导出到Python链接的C库里。然而，虽然对<code>os.environ</code>因此，与<code>os.putenv</code>相比，更推荐使用<code>os.environ</code>映射接口。</p>
<p>同时要注意，环境设置是在程序启动时一次性载入<code>os.environ</code>，而非实时读取。因此，当程序启动后，底层的C库对环境设置的改动不会反应到<code>os.environ</code>上。如今，Python集中<code>os.getenv</code>调用，然而在绝大多数平台中，它也只是简单地转换对<code>os.environ</code>的读取，而不是通过C库的<code>getenv</code>接口的调用实现。大多数应用，尤其是纯Python代码不必介意于此，在没有<code>putenv</code>底层接口的平台上，可以将<code>os.environ</code>作为参数传递给启动程序来启动子程序。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>ICMP 类型</title>
    <url>/2018/08/13/ICMP/</url>
    <content><![CDATA[<p><strong>Address Unreachable    地址无法访问</strong>  </p>
<p>This error message is generated by a router, or by the IPv6 layer in the originating node, in response to a packet that cannot be delivered to its destination address for reasons other than congestion.<br>此错误消息由路由器或始发节点中的IPv6层生成，以响应由于拥塞以外的原因而无法传送到其目标地址的数据包。<br><strong>Bad Header 坏标题</strong><br>This error message is created if there has been an error in the header of a packet<br>如果数据包的标头中存在错误，则会创建此错误消息<br><strong>Beyond Scope 超越范围</strong><br>This error message is sent if transmitting a package whould cross a zone boundary of the scope of the source address.<br>如果传输包跨越源地址范围的区域边界，则会发送此错误消息。<br><strong>Communication Prohibited 禁止通信</strong><br>This error message is sent if communication with destination administratively prohibited.<br>如果在管理上禁止与目标通信，则会发送此错误消息<br><strong>Destination Unreachable 目的地无法到达</strong><br>This error message is generated by a host or gateway if the destination is not reachable.<br>如果无法访问目标，则由主机或网关生成此错误消息<br><strong>Echo Reply (pong) Echo回复（pong）</strong><br>This message is the answer to an Echo Request.<br>此消息是Echo请求的答案。<br><strong>Echo Request (ping) 回应请求（ping）</strong><br>This message is used to test if a host is reachable mostly with the ping utility.<br>此消息用于测试主机是否可通过ping实用程序访问。<br><a id="more"></a><br><strong>Failed Policy 策略失败</strong><br>This error message is generated if the source address failed ingress/egress policy.<br>如果源地址入口/出口策略失败，则会生成此错误消息。<br><strong>Fragmentation Needed 需要分段</strong><br>This error message is sent if fragmentation is required, and Don not Fragment (DF) flag is set.<br>如果需要分段，则发送此错误消息，并设置Don not Fragment（DF）标志。<br><strong>Host Precedence Violation 主机优先权违规</strong><br>This error message is sent if the communication administratively prohibited.<br>如果管理上禁止通信，则会发送此错误消息。<br><strong>Host Prohibited  主机禁止</strong><br>This error message is sent if access from a host administratively prohibited.<br>如果在管理上禁止从主机访问，则会发送此错误消息。<br><strong>Host Redirect 主机重定向</strong><br>This message is sent if the datagram is redirected for the host.<br>如果为主机重定向数据报，则会发送此消息。<br><strong>Host Unknown 主机未知</strong><br>This error message is sent if the destination host is unknown.<br>如果目标主机未知，则会发送此错误消息。<br><strong>Host Unreachable 主机无法访问</strong><br>This error message is sent if the destination host is unreachable.<br>如果目标主机无法访问，则会发送此错误消息。<br><strong>Ip Header Bad</strong><br>This error message is sent if the IP header is bad.<br>如果IP标头错误，则会发送此错误消息。<br><strong>Neighbour Advertisement (Neighbor Advertisement) 邻居广告（邻居广告）</strong><br>This informational message is sent in response to a neighbour-solicitation message in order to (unreliably) propagate new information quickly.<br>响应于邻居请求消息发送该信息性消息，以便（不可靠地）快速传播新信息。<br><strong>Neighbour Solicitation (Neighbor Solicitation) 邻居请求（邻居请求）</strong><br>This informational message is sent by a node to determine the link-layer address of a neighbor, or to verify that a neighbor is still reachable via a cached link-layer address. Neighbor Solicitations are also used for Duplicate Address Detection.<br>该信息性消息由节点发送以确定邻居的链路层地址，或者验证通过高速缓存的链路层地址仍可到达邻居。 Neighbor Solicitations也用于重复地址检测。<br><strong>Network Prohibited 网络禁止</strong><br>This message is sent if the network is administratively prohibited.<br>如果管理上禁止网络，则会发送此消息。<br><strong>Network Redirect 网络重定向</strong><br>This message is sent if the datagram is redirected for the network.<br>如果为网络重定向数据报，则会发送此消息。<br><strong>Network Unknown 网络未知</strong><br>This message is sent if the destination network is unknown.<br>如果目标网络未知，则发送此消息。<br><strong>Network Unreachable 网络无法访问</strong><br>This message is sent if the destination network is unreachable.<br>如果目标网络无法访问，则会发送此消息。<br><strong>No Route 没有路由</strong><br>This error message is set if there is no route to the destination.<br>如果没有到目标的路由，则会设置此错误消息。<br><strong>Packet Too Big 数据包太大了</strong><br>This error message is sent by a router in response to a packet that it cannot forward because the packet is larger than the MTU of the outgoing link.<br>此错误消息由路由器发送，以响应无法转发的数据包，因为数据包大于传出链路的MTU。<br><strong>Parameter Problem 参数问题</strong><br>This error message is generated if the IP header is bad, either by a missing option or bad length.<br>如果IP标头错误，则会生成此错误消息，无论是缺少选项还是错误长度。<br><strong>Port Unreachable 端口无法访问</strong><br>This error message is sent if the port unreachable.<br>如果端口无法访问，则会发送此错误消息。<br><strong>Precedence Cutoff 优先截止</strong><br>This message is sent if the precedence is lower than the required minimum.<br>如果优先级低于所需的最小值，则发送此消息。<br><strong>Protocol Unreachable 协议无法访问</strong><br>This message is sent if the destination protocol is unreachable.<br>如果目标协议无法访问，则会发送此消息。<br><strong>Redirect 重定向</strong><br>This error message informs a host to send packets on another route.<br>此错误消息通知主机在另一个路由上发送数据包。<br><strong>Reject Route 拒绝路由</strong><br>This error message is sent if the route to destination is rejected.<br>如果拒绝到目的地的路由，则会发送此错误消息。<br><strong>Required Option Missing 必需选项缺失</strong><br>This message is sent if a required option is missing.<br>如果缺少必需选项，则会发送此消息。<br><strong>Router Advertisement 路由器广告</strong><br>This message is used by routers to periodically announce the IP address of a multicast interface.<br>路由器使用此消息定期通告多播接口的IP地址。<br><strong>Router Solicitation 路由器征集</strong><br>This message is used by a host attached to a multicast link to request a Router Advertisement.<br>连接到多播链路的主机使用此消息来请求路由器通告。<br><strong>Source Quench 来源Quench</strong><br>This error message is generated to tell a host to reduce the pace at which it is sending packets.<br>生成此错误消息是为了告诉主机减少发送数据包的速度。<br><strong>Source Route Failed 源路由失败</strong><br>This message is sent if the source route has failed.<br>如果源路由失败，则发送此消息。<br><strong>Time Exceeded 超过时间</strong><br>This error message is generated if the time-to-live was exceeded either of a packet or of the reassembling of a fragmented packet.<br>如果超过数据包或重新组装分段数据包的生存时间，则会生成此错误消息。<br><strong>Timestamp Reply 时间戳回复</strong><br>This message is used to reply to a timestamp message.<br>此消息用于回复时间戳消息。<br><strong>Timestamp Request时间戳请求</strong><br>This message is used for time synchronization.<br>此消息用于时间同步。<br><strong>TOS Host Redirect TOS主机重定向</strong><br>This message is the datagram is redirected for the type of service and host.<br>此消息是数据报被重定向为服务类型和主机。<br><strong>TOS Host Unreachable TOS主机无法访问</strong><br>This message is sent if the host is unreachable for the type of service.<br>如果主机无法访问该服务类型，则会发送此消息。<br><strong>TOS Network RedirectTOS网络重定向</strong><br>This message is sent if the datagram is redirected for the type of service and network.<br>如果针对服务类型和网络重定向数据报，则会发送此消息。<br><strong>TOS Network Unreachable TOS网络无法访问</strong><br>This error message is sent if the network is unreachable for the type of service.<br>如果网络无法访问该类型的服务，则会发送此错误消息。<br><strong>TTL Zero During Reassembly 重组期间TTL为零</strong><br>This error message is sent if a host fails to reassemble a fragmented datagram within its time limit.<br>如果主机无法在其时间限制内重新组合碎片数据报，则会发送此错误消息。<br><strong>TTL Zero During Transit 在过境期间TTL零</strong><br>This error message is sent if the time to live exceeded in transit.<br>如果在传输过程中超时，则会发送此错误消息。<br><strong>Unknown Header Type 未知标题类型</strong><br>This error message is sent if an unrecognized Next Header type encountered.<br>如果遇到无法识别的Next Header类型，则会发送此错误消息。<br><strong>Unknown Option 未知选项</strong><br>This error message is sent if an unrecognized IPv6 option encountered.<br>如果遇到无法识别的IPv6选项，则会发送此错误消息。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ICMP</tag>
      </tags>
  </entry>
  <entry>
    <title>变量（Python）</title>
    <url>/2018/08/01/Program-design/Python/Python-variables/</url>
    <content><![CDATA[<h1 id="增加一个变量"><a href="#增加一个变量" class="headerlink" title="增加一个变量"></a>增加一个变量</h1><p>Python脚本的运行并非天马行空，它取决于不同的平台和启动方式，Python程序可能有各种特定的环境，即程序启动时，操作系统会自动传给程序的信息。比如，脚本可以获取如下几类系统级的输入和接口：</p>
<p><em>当前工作路径（CWD）</em></p>
<p>​    <code>os.getcwd</code>可以获取脚本启动目录，许多文件工具隐式地使用该变量。</p>
<p><em>命令行参数</em></p>
<p>​    <code>sys.argv</code>可以获取在命令行键入的启动参数，将其作为脚本的输入。</p>
<p><em>shell变量</em></p>
<p>​    <code>os.environ</code>可以获取运行它的shell（或父程序）中命名的变量，并传给脚本。</p>
<p><em>标准流</em></p>
<p>​    <code>sys.stdin</code>、<code>sys.stdout</code>和<code>sys.stderr</code>是三个核心的命令行shell工具，负责输入/输出流，他们可以被脚本以如下方式使用：<code>print</code>,<code>os.popen</code>调用以及<code>subprocess</code>模块，<code>io.StringIO</code>l类等。</p>
<a id="more"></a>
<h1 id="当前工作路径"><a href="#当前工作路径" class="headerlink" title="当前工作路径"></a>当前工作路径</h1><p>当前工作路径（CWD）在脚本的执行中是一个重要概念。除非指定绝对路径，否则当脚本处理文件时将始终默认他们存在于CWD。脚本可以使用<code>os.getcwd</code>获取明确的CWD路径，使用<code>os.chdir</code>可以改变它的CWD。</p>
<p>谨记，没有完整目录路径的文件名将被映射到CWD路径，和你的<code>PYTHONPATH</code>设置无关。从技术上讲，一个脚本总是启动于CWD，而非它所在的目录。反之，<code>import</code>永远首先先搜索文件所在目录，而非<code>CWD</code> （除非该脚本刚好在CWD目录）。</p>
<h1 id="CWD、文件和import路径"><a href="#CWD、文件和import路径" class="headerlink" title="CWD、文件和import路径"></a>CWD、文件和import路径</h1><p>当你输入一个shell命令行，比<code>python dir1\dir2\file.py</code> 来运行该脚本时，CWD是你键入该命令时所处的路径，而非<code>dir1\dir2</code>。另一方面，Python自动将脚本所在的目录添加到模块搜索路径的最前面，因而无论如何从哪里运行，<em>file.py</em>总是可以导入<code>dir1\dir2</code>中的其他文件。我们写一个简单的脚本，打印出它的CWD和模块搜索路径来说明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line">print(<span class="string">'my os.getcwd =&gt;'</span>, os.getcwd())			<span class="comment"># 输出cwd执行命令</span></span><br><span class="line">print(<span class="string">'my sys.path =&gt;'</span>, os.path[:<span class="number">6</span>])			<span class="comment"># 输出前六个导入路径</span></span><br><span class="line">input()									      <span class="comment"># 等待输入</span></span><br></pre></td></tr></table></figure>
<p>现在，在该脚本所在路径运行它，CWD会如预期所设，同时该路径将会加到模块搜索路径的最前面。当在交互模式下运行时，它的第一个实体可能是一个空字符串：</p>
<p>但是如果我们早别的路径下运行该脚本，CWD将会随之而变（即我们输入命令的路径），并且Python会把脚本所在路径添加到木块搜索路径最前面，从而使得脚本能够看到它所在的目录的所有文件。</p>
<p>实际效果是，脚本没有目录路径的文件名将被映射到输入命令行的地方（<code>os.getcwd</code>），而通过<code>sys.path</code>列表中的首项，<code>import</code>总是可以看到当前正在运行脚本的路径，最后，当通过单机图标执行一个脚本时，CWD将被设置为该文件的所在路径。</p>
<p>在这种情况下，文件名所用的CWD以及第一个模块搜索路径都将是该脚本所在路径。有一下两个陷阱需要避免：</p>
<ul>
<li>如果不确定脚本的执行路径，最好使用完整的目录路径限定文件名。</li>
<li>命令行脚本不能总是依赖于CWD来导入不在它所处目录的文件，而应使用<code>PYTHONPATH</code>的设置和包导入路径来访问其他目录中的模块。</li>
</ul>
<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><p> Python可以通过<code>sys</code>模块获取脚本启动时命令行的输入信息，通常，他们被称为命令行参数，以内置字符串列表的形式存在于<code>sys.argv</code>中，C语言的程序员可能注意到它和C的<code>argv</code>数组类似，交互命令行方式启动，的Python没有命令行参数被传入，所以<code>argv</code>将是空串。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line">&gt;&gt;&gt;　sys.argv</span><br><span class="line">[<span class="string">''</span>]</span><br></pre></td></tr></table></figure>
<p>如同函数参数的作用，命令行参数扮演着同样的角色，他们都为程序传递可变信息。由于不需要编码，他们时脚本更通用，比如，一个人间处理脚本可以使用一个命令行参数传递要处理的文件名，还可以处理模式的flag、Internet地址等。</p>
<h2 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h2><p>一旦使用命令行参数，你会发现直接操作参数列表是不容易的。更具代表性的是，程序在启动的时候将它们转为更易用的结构。举例说明，这个脚本是扫描<code>argv</code>列表查找<code>-optionname optionvalue</code>值对，并以<code>optionname</code>为键值保存到字典结构中方便使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"collect command-line options in a directionary"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getopts</span><span class="params">(argv)</span>:</span></span><br><span class="line">    opts = &#123;&#125;</span><br><span class="line">    <span class="keyword">while</span> argv:</span><br><span class="line">        <span class="keyword">if</span> argv[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">'-'</span>		<span class="comment">#　找到　“－名称　值”　键值对</span></span><br><span class="line">        	opts[argv[<span class="number">0</span>]] = argv[<span class="number">1</span>]　<span class="comment"># 字典关键字为参数 “-名称”</span></span><br><span class="line">            argv = argv[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            argv = argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">return</span> opts</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line">    myargs = getopts(argv)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'-i'</span> <span class="keyword">in</span> myargs:</span><br><span class="line">        print(myargs[<span class="string">'-i'</span>])</span><br><span class="line">print(myargs)</span><br></pre></td></tr></table></figure>
<p>你可以在你的命令行工具中导入并使用该函数，在独立运行时，它将打印如下格式化的参数字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python testargv.py</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">python testargv.py -i data.txt -o results.txt data.txt</span><br><span class="line">&#123;<span class="string">'-o'</span>: <span class="string">'results.txt'</span>, <span class="string">'-i'</span>: <span class="string">'data.txt'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>自然地，我们还可以为它增加参数模式、错误检查等复杂功能。对于更复杂的命令行，我们可以使用Python标准库中的命令行处理工具来解析：</p>
<ul>
<li><code>getopt</code>模块，仿效Unix/C中的同名工具。</li>
<li><code>optparse</code>模块，一个新的替代只选，通常认为它的功能更强大。</li>
</ul>
<p>Python库手册中对二者都有介绍，同时提供了使用示例，通常，脚本可配置性越高，命令行处理逻辑的复杂度就越高。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>vSphere 网络连接（分布式交换机）</title>
    <url>/2018/06/16/vSphereNetwork2/</url>
    <content><![CDATA[<h1 id="vSphere-Distributed-Switch-架构"><a href="#vSphere-Distributed-Switch-架构" class="headerlink" title="vSphere Distributed Switch 架构"></a>vSphere Distributed Switch 架构</h1><p>vSphere Distributed Switch 为与交换机相关的所有交换机的网络连接配置提供集中化管理和监控。可以在vCenterServer 系统上设置Distributed Switch，其设置将传播与该交换机关联的所有主机。</p>
<p><strong>vSphere Distrubuted Switch 架构</strong></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/eh4h6j4a7h.png?imageslim" alt="mark"></p>
<p>vSphere 中的网络交换机由两个逻辑部分组成：数据面板和管理面板。数据面板可实现软件包交换、筛选和标记等。</p>
<p>管理面板是用于配置数据面板功能和控制结构。vSphere 标准交换机包含数据面板和管理面板，可以单独配置和维护每个标准交换机。</p>
<p>vSphere Distributed Switch 的数据面板和管理面板相互分离，Distributed Switch 的管理功能主流在vCenter Server系统上， 可以在数据中心级别管理环境的网络配置， 数据面板则保留在与Distributed Switch关联的每台主机本地，Distributed Switch的数据面板部分称为主机代理交换机，在vCenter Server（管理面板）上创建的网络配置将被自动乡下推送至所有主机代理交换机（数据面板）。</p>
<p>vSphere Distributed Switch 引入了连个抽象概念可用于为物理网卡、虚拟机和VMkernel 服务创建一致的网络配置。</p>
<a id="more"></a>
<p><strong>上行链路端口组</strong></p>
<p>上行链路端口组或dvuplink端口组在创建Distributed Switch期间进行定义，可以具有一个或多个上行链路。上行链路是可用于配置主机物理连接以及故障切换的负载平衡策略的模板。您可以将主机的物理网卡映射到Distributed Switch 上的上行链路。在主机级别，每个物理网卡将连接到特定ID的上行链路端口。您可以对上行链路设置故障切换和负载平衡策略，这些策略将自动传播到主机代理交换机或数据面板。因此，您可以为与Distributed Switch 关联的所有主机的物理网卡应用一直的故障切换和负载平衡配置。</p>
<p><strong>分布式端口组</strong></p>
<p>分布式端口组可向虚拟机提供网络连接并供VMkernel流量使用。 使用对当前数据中心唯一的网络标签来标识每个分布式端口组。可以在分布式端口组上配置网卡成组、故障切换、负载平衡、VLAN、安全、流量调整和其他策略。连接到分布式端口组的虚拟端口为该分布式端口组配置的相同属性。与上行链路端口组一样，在vCenter Server（管理面板） 上为分布式端口组设置和配置将通过主机代理交换机（数据面板）自动传播到Distributed Switch 上的所有主机。因此，可以配置一组虚拟机以共享相同的网络配置，方法就是讲虚拟机与同一分布式端口组相关联。</p>
<p>例如，假设在数据中心创建一个vSphere Distributed Switch ， 然后将两个主机与其相关联。为上行链路端口组配置了三个上行链路，然后将每个主机的一个物理网卡连接到一个上行链路，通过此方法，每个上行链路可将每个主机的两个物理网卡映射到其中，例如上行链路1使用主机1和主机2 的vmnic0进行配置。接下来，可以为虚拟机网络和VMkernel服务创建生产和VMkernel网络分布式端口组，此外还会分别在主机1和主机2上创建生产和VMkernel网络段端口组的标识， 为生产和VMkernel网络端口组设置的所有策略传播到主机1 和主机2上的表示。</p>
<p><strong>vSphere Distributed Switch数据流</strong></p>
<p>从虚拟机和VMkernel适配器向下传递到物理网络的数据流取决于为分布式端口组设置的网卡成组和负载平衡策略。</p>
<p>数据流还取决于Distributed Switch上的端口分配。</p>
<p><strong>vSphere DIstributed Switch 上的网卡组成和端口分配</strong></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/JiHH88f8IJ.png?imageslim" alt="mark"></p>
<p>例如，假设创建分别包含3个和2个分布式端口的虚拟机网络和VMkernel网络分布式端口组。Distributed Switch 会按ID从0到4的顺序分配端口，按顺序与创建分布式端口组的顺序相同，然后将主机1和主机2 与Distributed Switch关联。Distrubuted Swicth 会以为主机上的每个物理网卡分配端口，端口将按添加主机的顺序从5继续编号。要在每个主机上提供网络连接，请将vmnic0映射到上行链路1、将vmnic1映射到上行链路2、将vmnic2映射到上行链路3。</p>
<p>要向虚拟机提供连接并供VMkernel流量使用， 可以为虚拟机网络端口组和VMkernel网络端口组配置成组和故障切换。上行链路1和上行链路2处理虚拟机网络端口组的流量，而上行链路3处理VMkernel网络端口组流量。</p>
<p><strong>主机代理交换机上的数据包流量</strong>  </p>
<p><img src="https://blog-image.nos-eastchina1.126.net/7Dba7j6c95.png?imageslim" alt="mark"></p>
<p>在主机端，虚拟机和VMkernel服务的数据包流量将通过特定端口传递到物理网络。例如，从主机1上的VM1发送的数据包将先到达虚拟机网络分布式端口组上的端口0。由于上行链路1和上行链路2处理虚拟机网络端口组的流量，数据包可以通过上行链路端口5或上行链路端口6继续传递，如果数据包通过上行链路端口5，则将传递vmnic0；如果数据包通过上行链路端口0，则将继续传递到vmnic1。</p>
<h2 id="创建vSphere-Distributed-Switch"><a href="#创建vSphere-Distributed-Switch" class="headerlink" title="创建vSphere Distributed Switch"></a>创建vSphere Distributed Switch</h2><p>在数据中心创建 vSphere Distributed Switch，以便在一个中央位置同时处理多个主机的网络配置。  </p>
<p><strong>过程</strong></p>
<ol>
<li><p>在vSphere Web Client中导航到数据中心。</p>
</li>
<li><p>在导航器中， 右键单击<strong>数据中心</strong>， 选择<strong>Distributed Switch</strong>  &gt; <strong>新建Distributed Switch</strong>。</p>
</li>
<li><p>在名称和位置页面上， 键入新的名称， 或接收生成的名称， 然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在版本选择页面上， 祖安泽Distributed Switch 版本， 然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在编辑设置页面上， 配置Distributed Switch 设置。</p>
<ol>
<li><p>使用箭头按钮选择<strong>上行链路数</strong>。</p>
<p>上行链路端口将Distributed Switch 连接到关联主机上的物理网卡。上行链路端口数是允许每台主机与Distributed Switch 建立最大物理连接数。</p>
</li>
<li><p>使用下拉菜单启用或禁用<strong>Network I/O Control</strong>。</p>
<p>利用Network I/O Control 可以根据部署要求设定特定类型基础架构网络资源以及工作负载的访问优先级。Network I/O Control 会持续监控整个网络的I/O负载，并动态地分配可用资源。</p>
</li>
<li><p>选中<strong>创建默认端口组</strong>复选框使用默认设置为该交换机创建新的分布式端口组。</p>
</li>
<li><p>（可选）要创建默认的分布式端口组，可以在端口组名称键入端口组名称，或接收生成的名称。</p>
</li>
<li><p><strong>下一步</strong>。</p>
</li>
</ol>
</li>
<li><p>在即将完成页面查看选择的设置， 单击<strong>完成</strong>。</p>
<p>使用<strong>上一步</strong>可编辑之前的配置。</p>
</li>
</ol>
<h3 id="将vSphere-Distributed-Switch升级到更高版本"><a href="#将vSphere-Distributed-Switch升级到更高版本" class="headerlink" title="将vSphere Distributed Switch升级到更高版本"></a>将vSphere Distributed Switch升级到更高版本</h3><p>可以将vSphere Distributed Switch5.x以上版本升级到可用的更高版本。</p>
<p>升级的过程是一个非破坏性的操作，不会造成停机。</p>
<p>要能够在升级失败时还原虚拟机和VMkernel适配器的连接，请备份Distributed Switch。</p>
<p>过程</p>
<ol>
<li><p>在vSphere Web Client 中导航到Distributed Switch。</p>
</li>
<li><p>邮件单击Distributed Switch， 然后选择<strong>升级</strong>&gt; <strong>升级Distributed Switch</strong>。</p>
</li>
<li><p>选择要将交换机升级到的版本， 然后<strong>下一步</strong>。</p>
</li>
<li><p>检查主机兼容性， 然后单击<strong>下一步</strong>。</p>
<p>连接到该Distributed Switch 的一些ESXI 实例可能与选定的目标版本不兼容，进行升级或移除不兼容的主机，或者选择其他版本。</p>
</li>
<li><p>完成升级配置然后单击<strong>完成</strong>。</p>
<ol>
<li>查看升级设置。</li>
<li>如果从vSphere Distributed Switch5.1进行升级， 请计划转换为增强型LACP支持。</li>
<li>如果从vSphere Distributed Switch 5.1及更高版本进行升级，请计划转换为Network I/O Control 版本3。</li>
</ol>
</li>
</ol>
<h3 id="编辑-vSphere-Distributed-Switch-常规和高级设置"><a href="#编辑-vSphere-Distributed-Switch-常规和高级设置" class="headerlink" title="编辑 vSphere Distributed Switch 常规和高级设置"></a>编辑 vSphere Distributed Switch 常规和高级设置</h3><p>vSphere Distributed Switch 的常规设置包括交换机名称和上行链路数量。Distributed Switch 的高级设置包括 Cisco 发现协议和交换机的最大 MTU。 </p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到 Distributed Switch。</li>
<li>在<strong>配置</strong>选项卡上，展开<strong>设置</strong>并选择<strong>属性</strong>。</li>
<li>单击<strong>编辑</strong>。</li>
<li>单击<strong>常规</strong>以编辑 vSphere Distributed Switch 设置。</li>
<li>单击高级编辑 vSphere Distributed Switch 设置。 </li>
<li>单击<strong>确定</strong>。</li>
</ol>
<h2 id="在-vSphere-Distributed-Switch-上管理多个主机上的网络连接"><a href="#在-vSphere-Distributed-Switch-上管理多个主机上的网络连接" class="headerlink" title="在 vSphere Distributed Switch 上管理多个主机上的网络连接"></a>在 vSphere Distributed Switch 上管理多个主机上的网络连接</h2><p>可以通过将主机添加到交换机并将其网络适配器连接到交换机，在vSphere Distributed Switch 上创建和管理虚拟网络，要在Distributed Switch 的多个主机上创建统一的网络连接配置，可以选择一个主机作为模板，并将其配置应用到其他主机。</p>
<h3 id="在-vSphere-Distributed-Switch-上管理主机网络的任务"><a href="#在-vSphere-Distributed-Switch-上管理主机网络的任务" class="headerlink" title="在 vSphere Distributed Switch 上管理主机网络的任务"></a>在 vSphere Distributed Switch 上管理主机网络的任务</h3><p>可以为vSphere Distributed Switch 添加新主机、将网络适配器连接到交换机及其从交换机移除主机。在生产环境中， 当您管理Distributed Switch 上的主机时，可能需要保持虚拟机和VMkernel 服务的网络连接有效。</p>
<p><strong>为vSphere Distributed Switch 添加主机</strong></p>
<p>在为Distributed Switch 添加到主机之前，应该考虑做好环境准备。</p>
<ul>
<li>为虚拟机网络创建分布式端口组</li>
<li>为VMkernel 服务创建分布式端口组。例如为管理网络、vMotion和Fault Tolerance 创建分布式端口组。</li>
<li>在Distributed Switch 上为要连接交换机的所有物理网卡配置足够的上行链路。例如如果要连接Distributed Switch 的每个主机都有八个物理网卡，则在Distributed Switch上配置八个上行链路。</li>
<li>确保为具有特殊要求的服务准备Distributed Switch的配置。 例如，iSCSI 对于连接iSCSI VMkernel适配器的分布式端口组的绑定和故障切换配置具有特使要求。</li>
</ul>
<p>可以在vSphere Web Client 中使用<strong>添加和管理主机</strong>向导一次添加多个主机。</p>
<p><strong>在vSphere Distributed Switch 上管理网络适配器</strong></p>
<p>为Distributed Switch 添加主机后， 可以将物理网卡连接到交换机上的上行链路、配置虚拟机网络适配器以及管理VMkernel网络。</p>
<p>如果Distributed Switch 上的部分主机与数据中心的其他主机关联，可以将网络适配器迁移到Distributed Switch ，或者从Distributed Switch中迁移出网络适配器。</p>
<p>如果迁移虚拟机网络适配器或者VMkernel适配器，应确保目标分布式端口组至少有一个活动的上行链路，并且该链路与主机上的物理网卡连接。另一个方法是同事迁移物理网卡、虚拟机网络适配器和VMkernel 适配器。</p>
<p>如果迁移物理网卡，至少应使一个网卡处于活动状态，以处理端口组流量， 例如如果vmnic0和vmnic1处理VMNetwork端口组的流量， 则迁移vmnic0，并使vmnic1与该组保持连接。</p>
<p><strong>从vSphere Distributed Switch 移除主机</strong></p>
<p>从Distributed Switch 移除主机之前， 必须将使用中的网络适配器迁移到不同的交换机。</p>
<ul>
<li>要在不同的Distributed Switch 中添加主机， 可以使用<strong>添加和管理主机</strong>向导将主机上的所有物理适配器一起迁移到新的交换机，然后便可以从当前的Distributed Switch中安全的移除主机。</li>
<li>要将主机网络迁移到标准交换机，必须分阶段迁移网络适配器。例如，使每个主机上的一个物理网卡与交换机保持连接以保证网络连接有效，即可从 Distributed Switch 移除主机上的物理网卡。接着，将物理网卡连接到标准交换机，并将 VMkernel 适配器和虚拟机网络适配器迁移到交换机。最后，将与 Distributed Switch 保持连接的物理网卡迁移到标准交换机。 </li>
</ul>
<h3 id="将主机添加到-vSphere-Distributed-Switch"><a href="#将主机添加到-vSphere-Distributed-Switch" class="headerlink" title="将主机添加到 vSphere Distributed Switch"></a>将主机添加到 vSphere Distributed Switch</h3><p>要使用 vSphere Distributed Switch 管理 vSphere 环境的网络，必须将主机与交换机关联。可以将主机的物理网卡、VMkernel 适配器和虚拟机网络适配器连接到 Distributed Switch。</p>
<ul>
<li>验证 Distributed Switch 上有足够的可用上行链路，可以分配给要连接交换机的物理网卡。</li>
<li>确认在 Distributed Switch 上至少有一个分布式端口组。</li>
<li>确认分布式端口组的绑定和故障切换策略中已配置了活动上行链路。</li>
</ul>
<p>如果为 iSCSI 迁移或创建 VMkernel 适配器，请确认目标分布式端口组的绑定和故障切换策略满足 iSCSI 的要求：</p>
<ul>
<li>确认只有一个上行链路处于活动状态，待机列表为空，其余上行链路未被使用。</li>
<li>确认每个主机只有一个物理网卡分配给活动上行链路。</li>
</ul>
<ol>
<li><p>在 vSphere Web Client 中，导航到 Distributed Switch。</p>
</li>
<li><p>从<strong>操作</strong>菜单中，选择<strong>添加和管理主机</strong>。</p>
</li>
<li><p>在“选择任务”页面上，选择添加主机，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在“选择主机”页面上，单击新主机，选择数据中心内的主机，单击确定，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在“选择网络适配器任务”页面上，选择配置 Distributed Switch 的网络适配器的任务，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在“管理物理网络适配器”页面上，配置 Distributed Switch 上的物理网卡。</p>
<ol>
<li><p>从“其他交换机上/空闲”列表中选择一个物理网卡。</p>
<p>如果选择已经连接其他交换机的物理网卡，这些物理网卡即迁移到当前的 Distributed Switch 上。</p>
</li>
<li><p>单击<strong>分配上行链路</strong>。</p>
</li>
<li><p>选择一个上行链路，然后单击<strong>确定</strong>。</p>
</li>
</ol>
<p>为实现网络配置的一致性，可以将每个主机上的一个相同的物理网卡与 Distributed Switch 上的相同的上行链路连接。</p>
<p>例如，如果要添加两个主机，则将每个主机上的 vmnic1 与 Distributed Switch 上的 Uplink1 连接。</p>
</li>
<li><p>单击下一步。</p>
</li>
<li><p>在“管理 VMkernel 网络适配器”页面上，配置 VMkernel 适配器。</p>
<ol>
<li>选择 VMkernel 适配器并单击分配端口组。</li>
<li>选择分布式端口组，然后单击确定。</li>
</ol>
</li>
<li><p>查看受影响的服务以及影响的程度。</p>
<ol>
<li>如果 iSCSI 受到的影响非常重要或严重，请单击 iSCSI 条目，然后查看“分析详细信息”窗格中所显示的原因。</li>
<li>排除对 iSCSI 造成的影响之后，请继续进行网络连接配置。</li>
</ol>
</li>
<li><p>单击<strong>下一步</strong>。</p>
</li>
<li><p>在“迁移虚拟机网络”页面上，配置虚拟机网络连接。</p>
<ol>
<li>要将某个虚拟机的所有网络适配器连接到分布式端口组，请选择该虚拟机，或者选择单个网络适配器以仅连接该适配器。</li>
<li>单击<strong>分配端口组</strong>。</li>
<li>从列表中选择一个分布式端口组，然后单击<strong>确定</strong>。</li>
</ol>
</li>
<li><p>单击<strong>下一步</strong>，然后单击<strong>完成</strong>。</p>
</li>
</ol>
<h3 id="在-vSphere-Distributed-Switch-上配置物理网络适配器"><a href="#在-vSphere-Distributed-Switch-上配置物理网络适配器" class="headerlink" title="在 vSphere Distributed Switch 上配置物理网络适配器"></a>在 vSphere Distributed Switch 上配置物理网络适配器</h3><p>对于与 Distributed Switch 关联的主机，可以将物理网卡分配给交换机上的上行链路。可以在 Distributed Switch 上一次为多个主机配置物理网卡。</p>
<p>要确保所有主机的网络连接配置保持一致，可以将每个主机上的相同物理网卡分配到 Distributed Switch 上的相同上行链路。例如，可以将主机 ESXi A 和 ESXi B 中的 vmnic1 分配到 Uplink 1。</p>
<ol>
<li><p>在 vSphere Web Client 中，导航到 Distributed Switch。</p>
</li>
<li><p>从操作菜单中，选择添加和管理主机。</p>
</li>
<li><p>在选择任务中，选择管理主机网络，然后单击下一步。</p>
</li>
<li><p>在选择主机中，单击连接的主机，然后从与 Distributed Switch 关联的主机中进行选择。</p>
</li>
<li><p>单击下一步。</p>
</li>
<li><p>在选择网络适配器任务中，选择管理物理适配器，然后单击下一步。</p>
</li>
<li><p>在管理物理网络适配器中，从“其他交换机上/空闲”列表中选择一个物理网卡。</p>
<p>如果选择已分配到其他交换机的物理网卡，请将其迁移至当前的 Distributed Switch。</p>
</li>
<li><p>单击分配上行链路。</p>
</li>
<li><p>选择一个上行链路或选择自动分配。</p>
</li>
<li><p>单击下一步。</p>
</li>
<li><p>查看受影响的服务以及影响的程度。</p>
<ol>
<li>如果 iSCSI 受到的影响非常重要或严重，请单击 iSCSI 条目，然后查看“分析详细信息”窗格中所显示的原因。</li>
<li>排除对 iSCSI 造成的影响之后，请继续进行网络连接配置。</li>
</ol>
</li>
<li><p>单击下一步，然后单击完成。</p>
</li>
</ol>
<h3 id="将-VMkernel-适配器迁移到-vSphere-Distributed-Switch"><a href="#将-VMkernel-适配器迁移到-vSphere-Distributed-Switch" class="headerlink" title="将 VMkernel 适配器迁移到 vSphere Distributed Switch"></a>将 VMkernel 适配器迁移到 vSphere Distributed Switch</h3><p>如果想要仅使用 vSphere Distributed Switch 来处理 VMkernel 服务的流量，并且不再需要其他标准交换机或 Distributed Switch 上的适配器，请将 VMkernel 适配器迁移到 vSphere Distributed Switch。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到 Distributed Switch。</li>
<li>从<strong>操作</strong>菜单中，选择<strong>添加和管理主机</strong>。</li>
<li>在<strong>选择任务</strong>中，选择<strong>管理主机网络</strong>，然后单击下一步。</li>
<li>在<strong>选择主机</strong>中，单击<strong>连接的主机</strong>，然后从与 Distributed Switch 关联的主机中进行选择。</li>
<li>单击<strong>下一步</strong>。</li>
<li>在<strong>选择网络适配器</strong>任务中，选择<strong>管理 VMkernel 适配器</strong>，然后单击<strong>下一步</strong>。</li>
<li>在<strong>管理 VMkernel 网络适配器</strong>中，选择适配器并单击分配端口组。</li>
<li>选择分布式端口组，然后单击<strong>确定</strong>。</li>
<li>单击<strong>下一步</strong>。</li>
<li>查看受影响的服务以及影响的程度。<ol>
<li>如果 iSCSI 受到的影响非常重要或严重，请单击 iSCSI 条目，然后查看“分析详细信息”窗格中所显示的原因。</li>
<li>排除对 iSCSI 造成的影响之后，请继续进行网络连接配置。</li>
</ol>
</li>
<li>单击<strong>下一步</strong>，然后单击<strong>完成</strong>。</li>
</ol>
<h3 id="在-vSphere-Distributed-Switch-上创建-VMkernel-适配器"><a href="#在-vSphere-Distributed-Switch-上创建-VMkernel-适配器" class="headerlink" title="在 vSphere Distributed Switch 上创建 VMkernel 适配器"></a>在 vSphere Distributed Switch 上创建 VMkernel 适配器</h3><p>在与 Distributed Switch 关联的主机上创建 VMkernel 适配器，以便向主机提供网络连接并处理 vSphere vMotion、IP 存储、Fault Tolerance 日志记录和 vSAN 的流量。可以通过使用添加和管理主机向导同时在多个主机上创建 VMkernel 适配器。 </p>
<p>应专门针对每个 VMkernel 适配器使用一个分布式端口组。一个 VMkernel 适配器应仅处理一种流量类型。 </p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到 Distributed Switch。</p>
</li>
<li><p>从<strong>操作</strong>菜单中，选择<strong>添加和管理主机</strong>。</p>
</li>
<li><p>在<strong>选择任务</strong>中，选择<strong>管理主机网络</strong>，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在<strong>选择主机</strong>中，单击<strong>连接的主机</strong>，然后从与 Distributed Switch 关联的主机中进行选择。</p>
</li>
<li><p>单击<strong>下一步</strong>。</p>
</li>
<li><p>在<strong>选择网络适配器任务</strong>中，选择<strong>管理 VMkernel 适配器</strong>，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>单击<strong>新建适配器</strong>。</p>
<p>此时会打开<strong>添加网络</strong>向导。</p>
</li>
<li><p>在<strong>选择目标设备</strong>中，选择一个分布式端口组，然后单击<strong>下一步</strong>。</p>
</li>
<li><p>在“端口属性”页面上，配置 VMkernel 适配器的设置。</p>
</li>
<li><p>如果选择了 vMotion TCP/IP 或置备堆栈，在显示的警告对话框中单击<strong>确定</strong>。</p>
<p>如果实时迁移已启动，即使已在默认 TCP/IP 堆栈上禁止将涉及的 VMkernel 适配器用于 vMotion，该迁移也会成功完成。同样，在默认 TCP/IP 堆栈上包括为置备流量设置的 VMkernel 适配器也是一样。</p>
</li>
<li><p>（可选） 在“IPv4 设置”页面上，选择用于获取 IP 地址的选项。</p>
</li>
<li><p>（可选） 在“IPv6 设置”页面上，选择用于获取 IPv6 地址的选项。</p>
</li>
<li><p>检查“即将完成”页面上的设置选项，然后单击完成。</p>
</li>
<li><p>按照提示完成向导。</p>
</li>
</ol>
<h3 id="将虚拟机网络迁移到-vSphere-Distributed-Switch"><a href="#将虚拟机网络迁移到-vSphere-Distributed-Switch" class="headerlink" title="将虚拟机网络迁移到 vSphere Distributed Switch"></a>将虚拟机网络迁移到 vSphere Distributed Switch</h3><p>要使用 Distributed Switch 管理虚拟机网络连接，请将虚拟机网络适配器迁移到交换机上有标记的网络。 </p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到 Distributed Switch。</li>
<li>从<strong>操作</strong>菜单中，选择<strong>添加和管理主机</strong>。</li>
<li>在<strong>选择任务</strong>中，选择<strong>管理主机网络</strong>，然后单击下一步。</li>
<li>在<strong>选择主机</strong>中，单击<strong>连接的主机</strong>，然后从与 Distributed Switch 关联的主机中进行选择。</li>
<li>单击<strong>下一步</strong>。</li>
<li>在<strong>选择网络适配器</strong>任务中，选择<strong>迁移虚拟机网络</strong>，然后单击<strong>下一步</strong>。</li>
<li>为 Distributed Switch 配置虚拟机网络适配器。<ol>
<li>要将某个虚拟机的所有网络适配器连接到分布式端口组，请选择该虚拟机，或者选择单个网络适配器以仅连接该适配器。</li>
<li>单击<strong>分配端口组</strong>。</li>
<li>从列表中选择一个分布式端口组，然后单击<strong>确定</strong>。</li>
</ol>
</li>
<li>单击下一步，然后单击<strong>完成</strong>。</li>
</ol>
<h3 id="使用主机作为模板为-vSphere-Distributed-Switch-创建统一的网络配置"><a href="#使用主机作为模板为-vSphere-Distributed-Switch-创建统一的网络配置" class="headerlink" title="使用主机作为模板为 vSphere Distributed Switch 创建统一的网络配置"></a>使用主机作为模板为 vSphere Distributed Switch 创建统一的网络配置</h3><p>使多台主机拥有统一的网络配置，则可选择其中一台主机作为模板，并将其物理网卡和 VMkernel 适配器的配置应用到 Distributed Switch 上的其他主机。 </p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到 Distributed Switch。</li>
<li>从操作菜单中，选择添加和管理主机。</li>
<li>选择管理主机网络的任务，然后单击下一步。</li>
<li>选择要在 Distributed Switch 上添加或进行管理的主机。</li>
<li>在对话框的底部，选择在多个主机上配置相同的网络设置，然后单击下一步。</li>
<li>选择要用作模板的主机，然后单击下一步。</li>
<li>选择网络适配器任务，然后单击下一步。</li>
<li>在“管理物理网络适配器”和“管理 VMkernel 网络适配器”页面上，对模板主机进行所需的配置更改，然后针对所有其他主机单击应用于全部。</li>
<li>在“即将完成”页面上，单击完成。</li>
</ol>
<p><strong>使用模板主机配置物理适配器和 VMkernel 适配器</strong></p>
<p>使用添加和管理主机向导中的模板主机模式在 Distributed Switch 上的所有主机之间创建统一的网络配置。</p>
<p>在向导的“管理物理网络适配器”页面上，将一个物理网卡分配给模板主机上的上行链路，然后单击应用于全部以便在其他主机上创建相同的配置。</p>
<p>使用模板主机在 vSphere Distributed Switch 上应用物理网卡配置</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/JcA3BhdCDk.png?imageslim" alt="mark"></p>
<p>在“管理 VMkernel 网络适配器”页面，向端口组分配一个 VMkernel 适配器，并单击应用于全部以向其他主机应用相同的配置。</p>
<p>单击应用于全部按钮后，目标 VMkernel 适配器同时具有“已修改”和“已重新分配”限定符。之所以显示“已修改”限定符是因为，单击应用于全部按钮后，vCenter Server 会将模板 VMKernel 适配器的配置规范复制到目标 VMkernel 适配器，即使模板适配器和目标适配器的配置完全相同也是如此。因此，目标适配器总是会被修改。</p>
<p>使用模板主机在 vSphere Distributed Switch 上应用 VMkernel 适配器配置</p>
<p> <img src="https://blog-image.nos-eastchina1.126.net/kJ1el7FkjF.png?imageslim" alt="mark"></p>
<h3 id="从-vSphere-Distributed-Switch-中移除主机"><a href="#从-vSphere-Distributed-Switch-中移除主机" class="headerlink" title="从 vSphere Distributed Switch 中移除主机"></a>从 vSphere Distributed Switch 中移除主机</h3><p>如果为主机配置了其他交换机，则可以从 vSphere Distributed Switch 中移除主机。</p>
<p><strong>先决条件</strong></p>
<ul>
<li>确认将目标主机上的物理网卡迁移到其他交换机。</li>
<li>确认将主机上的 VMkernel 适配器迁移到其他交换机。</li>
<li>确认将虚拟机网络适配器迁移到其他交换机。</li>
</ul>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到 Distributed Switch。</li>
<li>从操作菜单中，选择添加和管理主机。</li>
<li>选择移除主机，然后单击下一步。</li>
<li>选择要移除的主机，然后单击下一步。</li>
<li>单击完成。</li>
</ol>
<h2 id="在主机代理交换机上管理网络连接"><a href="#在主机代理交换机上管理网络连接" class="headerlink" title="在主机代理交换机上管理网络连接"></a>在主机代理交换机上管理网络连接</h2><h3 id="将主机上的网络适配器迁移到-vSphere-Distributed-Switch"><a href="#将主机上的网络适配器迁移到-vSphere-Distributed-Switch" class="headerlink" title="将主机上的网络适配器迁移到 vSphere Distributed Switch"></a>将主机上的网络适配器迁移到 vSphere Distributed Switch</h3><p>对于与 Distributed Switch 关联的主机，可以将网络适配器从标准交换机迁移至 Distributed Switch。可以同时迁移物理网卡、VMkernel 适配器和虚拟机网络适配器。</p>
<p>如果迁移虚拟机网络适配器或 VMkernel 适配器，应确保目标分布式端口组至少有一个活动的上行链路，并且该链路与此主机上的物理网卡连接。或者，也可以同时迁移物理网卡、虚拟网络适配器和 VMkernel 适配器。</p>
<p>要迁移物理网卡，请确保标准交换机上的源端口组至少具有一个物理网卡以处理其流量。例如，如果要迁移分配给虚拟机网络的端口组的物理网卡，请确保该端口组至少连接到一个物理网卡。否则，标准交换机上同一 VLAN 中的虚拟机将相互连接，但与外部网络之间无连接。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>选择目标 Distributed Switch，然后单击将物理网络适配器或虚拟网络适配器迁移到此 Distributed Switch。</p>
</li>
<li><p>选择迁移网络适配器的任务，然后单击下一步。</p>
</li>
<li><p>配置物理网卡。</p>
<ol>
<li>从其他交换机上/空闲列表中，选择一个物理网卡，然后单击分配上行链路。</li>
<li>选择一个上行链路，然后单击确定。</li>
<li>单击下一步。</li>
</ol>
</li>
<li><p>配置 VMkernel 适配器。</p>
<ol>
<li><p>选择一个适配器，然后单击分配端口组。</p>
</li>
<li><p>选择分布式端口组，然后单击确定。</p>
<p>一次应将一个 VMkernel 适配器连接到一个分布式端口组。</p>
</li>
<li><p>单击下一步。</p>
</li>
</ol>
</li>
<li><p>检查受新网络配置影响的服务。</p>
<ol>
<li><p>如果某个服务中报告了重要的或严重的影响，请单击该服务并检查分析详细信息。</p>
<p>例如，可能会报告 iSCSI 上由迁移 iSCSI VMkernel 适配器的分布式端口组上不正确的绑定和故障切换配置导致的重要影响。必须在分布式端口组的绑定和故障切换顺序中保留一个活动的上行链路，将备用列表保留为空，并将其余的上行链路移至未使用。</p>
</li>
<li><p>对受影响的服务造成的任何影响进行故障排除后，单击下一步。</p>
</li>
</ol>
</li>
<li><p>配置虚拟机网络适配器。</p>
<ol>
<li><p>选择一个虚拟机或虚拟机网络适配器，然后单击分配端口组。</p>
<p>如果选择虚拟机，则应迁移虚拟机上的所有网络适配器。如果选择网络适配器，则只需迁移此网络适配器。</p>
</li>
<li><p>从列表中选择一个分布式端口组，然后单击确定。</p>
</li>
<li><p>单击下一步。</p>
</li>
</ol>
</li>
<li><p>在“即将完成”页上，检查新网络配置并单击完成。</p>
</li>
</ol>
<h3 id="将主机上的-VMkernel-适配器迁移到-vSphere-标准交换机"><a href="#将主机上的-VMkernel-适配器迁移到-vSphere-标准交换机" class="headerlink" title="将主机上的 VMkernel 适配器迁移到 vSphere 标准交换机"></a>将主机上的 VMkernel 适配器迁移到 vSphere 标准交换机</h3><p>果主机与 Distributed Switch 关联，则可以将 VMkernel 适配器从 Distributed Switch 迁移到标准交换机。</p>
<p>确认目标标准交换机至少有一个物理网卡。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>在列表中选择目标标准交换机。</p>
</li>
<li><p>单击将 VMkernel 网络适配器迁移到选定交换机。</p>
</li>
<li><p>在“选择 VMkernel 网络适配器”页面上，在列表中选择要迁移到标准交换机的虚拟网络适配器。</p>
</li>
<li><p>在“配置设置”页面上，编辑网络适配器的网络标签和 VLAN ID。</p>
</li>
<li><p>在“即将完成”页面上，检查迁移详细信息，然后单击完成。</p>
<p>单击上一步以编辑设置。</p>
</li>
</ol>
<h3 id="将主机上的-VMkernel-适配器迁移到-vSphere-标准交换机-1"><a href="#将主机上的-VMkernel-适配器迁移到-vSphere-标准交换机-1" class="headerlink" title="将主机上的 VMkernel 适配器迁移到 vSphere 标准交换机"></a>将主机上的 VMkernel 适配器迁移到 vSphere 标准交换机</h3><p>如果主机与 Distributed Switch 关联，则可以将 VMkernel 适配器从 Distributed Switch 迁移到标准交换机。  </p>
<p>确认目标标准交换机至少有一个物理网卡。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>在列表中选择目标标准交换机。</p>
</li>
<li><p>单击将 VMkernel 网络适配器迁移到选定交换机。</p>
</li>
<li><p>在“选择 VMkernel 网络适配器”页面上，在列表中选择要迁移到标准交换机的虚拟网络适配器。</p>
</li>
<li><p>在“配置设置”页面上，编辑网络适配器的网络标签和 VLAN ID。</p>
</li>
<li><p>在“即将完成”页面上，检查迁移详细信息，然后单击完成。</p>
<p>单击上一步以编辑设置。</p>
</li>
</ol>
<h3 id="将主机的物理网卡分配给-vSphere-Distributed-Switch"><a href="#将主机的物理网卡分配给-vSphere-Distributed-Switch" class="headerlink" title="将主机的物理网卡分配给 vSphere Distributed Switch"></a>将主机的物理网卡分配给 vSphere Distributed Switch</h3><p>可以将与 Distributed Switch 关联的主机的物理网卡分配给主机代理交换机上的上行链路端口。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到主机。</li>
<li>在配置选项卡上，展开网络，然后选择虚拟交换机。</li>
<li>从列表中选择 Distributed Switch。</li>
<li>单击管理已连接到选定交换机的物理网络适配器图标。</li>
<li>从列表中选择一个空闲的上行链路，然后单击添加适配器。</li>
<li>选择物理网卡，然后单击确定。</li>
</ol>
<h3 id="从-vSphere-Distributed-Switch-移除物理网卡"><a href="#从-vSphere-Distributed-Switch-移除物理网卡" class="headerlink" title="从 vSphere Distributed Switch 移除物理网卡"></a>从 vSphere Distributed Switch 移除物理网卡</h3><p>可以从 vSphere Distributed Switch 的上行链路中移除主机的物理网卡。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到主机。</li>
<li>在配置选项卡上，展开网络，然后选择虚拟交换机。</li>
<li>选择 Distributed Switch。</li>
<li>单击管理已连接到选定交换机的物理网络适配器图标。</li>
<li>选择上行链路，然后单击移除选定适配器。</li>
<li>单击确定。</li>
</ol>
<h3 id="从活动虚拟机中移除网卡"><a href="#从活动虚拟机中移除网卡" class="headerlink" title="从活动虚拟机中移除网卡"></a>从活动虚拟机中移除网卡</h3><p><strong>从未安装客户机操作系统的活动虚拟机中移除网卡</strong></p>
<p>不能从未安装任何操作系统的活动虚拟机中移除网卡。</p>
<p>vSphere Web Client 可能会报告网卡已被移除，但是您看到它仍然附加在虚拟机上。</p>
<p><strong>从已安装客户机操作系统的活动虚拟机中移除网卡</strong></p>
<p>可以从活动虚拟机中移除网卡，但有时这可能不会报告给 vSphere Web Client。如果您单击虚拟机的编辑设置，可能会看到被移除的网卡仍被列出，即便移除任务已完成。虚拟机的“编辑设置”对话框不会立即显示移除的网卡。</p>
<p>如果虚拟机的客户机操作系统不支持热移除网卡，则您可能仍会看到网卡附加在虚拟机上。</p>
<h2 id="分布式端口组"><a href="#分布式端口组" class="headerlink" title="分布式端口组"></a>分布式端口组</h2><p>分布式端口组为 vSphere Distributed Switch 上的每个成员端口指定端口配置选项。分布式端口组可定义连接到网络的方式。  </p>
<h3 id="添加分布式端口组"><a href="#添加分布式端口组" class="headerlink" title="添加分布式端口组"></a>添加分布式端口组</h3><p>将分布式端口组添加到 vSphere Distributed Switch 以为虚拟机创建 Distributed Switch 网络并关联 VMkernel 适配器。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到 Distributed Switch。</p>
</li>
<li><p>右键单击 Distributed Switch，然后选择分布式端口组 &gt; 新建分布式端口组。</p>
</li>
<li><p>在“选择名称和位置”页面上，输入新分布式端口组的名称，或接受生成的名称，然后单击下一步。</p>
</li>
<li><p>在“配置设置”页面上，设置新分布式端口组的常规属性，然后单击下一步。</p>
</li>
<li><p>（可选） 在“安全”页面上，编辑安全异常，然后单击下一步。</p>
</li>
<li><p>（可选） 在“流量调整”页面上，启用或禁用“输入流量调整”或“输出流量调整”，然后单击下一步。</p>
</li>
<li><p>（可选） 在“绑定和故障切换”页面上，编辑设置，然后单击下一步。</p>
</li>
<li><p>（可选） 在“监控”页面上，启用或禁用 NetFlow，然后单击下一步。</p>
</li>
<li><p>（可选） 在“其他”页面上，选择是或否，然后单击下一步。选择是可关闭端口组中的所有端口。该操作可能中断在使用这些端口的主机或虚拟机的正常网络操作。</p>
</li>
<li><p><strong>（可选）</strong> 在“编辑其他设置”页面上，添加对端口组的描述并设置每个端口的任何策略替代项，然后单击下一步。</p>
</li>
<li><p>在“即将完成”页面上，检查设置，然后单击完成。</p>
<p>要更改任何设置，请单击返回按钮。</p>
</li>
</ol>
<h3 id="编辑常规分布式端口组设置"><a href="#编辑常规分布式端口组设置" class="headerlink" title="编辑常规分布式端口组设置"></a>编辑常规分布式端口组设置</h3><p>可以编辑常规分布式端口组设置，例如分布式端口组名称、端口设置和网络资源池。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中找到分布式端口组。<ol>
<li>选择 Distributed Switch，然后单击网络选项卡。</li>
<li>单击分布式端口组。</li>
</ol>
</li>
<li>右键单击分布式端口组，然后选择编辑设置。</li>
<li>选择常规以编辑下面的分布式端口组设置。</li>
<li>单击确定。</li>
</ol>
<h3 id="在端口级别配置替代网络策略"><a href="#在端口级别配置替代网络策略" class="headerlink" title="在端口级别配置替代网络策略"></a>在端口级别配置替代网络策略</h3><p>要对分布式端口应用不同的策略，您可以配置在端口组级别设置的每个端口替代策略。当分布式端口与虚拟机断开连接时，您也可以启用重置在每个端口级别设置的任何配置。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中找到分布式端口组。<ol>
<li>选择 Distributed Switch，然后单击网络选项卡。</li>
<li>单击分布式端口组。</li>
</ol>
</li>
<li>右键单击分布式端口组，然后选择编辑设置。</li>
<li>选择高级页面。</li>
<li><strong>（可选）</strong> 使用策略页面设置每个端口策略的替代。</li>
<li>单击确定。</li>
</ol>
<h3 id="移除分布式端口组"><a href="#移除分布式端口组" class="headerlink" title="移除分布式端口组"></a>移除分布式端口组</h3><p>当您不再需要相应的有标记网络时，请移除分布式端口组，以便为虚拟机或 VMkernel 网络提供连接及配置连接设置。</p>
<ul>
<li>验证已将连接到相应有标记网络的所有虚拟机迁移到其他有标记网络。</li>
<li>验证已将连接到分布式端口组的所有 VMkernel 适配器迁移到其他端口组，或已将其删除。</li>
</ul>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中找到分布式端口组。<ol>
<li>选择 Distributed Switch，然后单击网络选项卡。</li>
<li>单击分布式端口组。</li>
</ol>
</li>
<li>选择分布式端口组。</li>
<li>在操作菜单中，选择删除。</li>
</ol>
<h2 id="使用分布式端口"><a href="#使用分布式端口" class="headerlink" title="使用分布式端口"></a>使用分布式端口</h2><p>分布式端口是连接到 VMkernel 或虚拟机的网络适配器的 vSphere Distributed Switch 上的一个端口。</p>
<p>默认分布式端口配置是由分布式端口组设置确定的，但可以替代各个分布式端口的某些设置。</p>
<h3 id="监控分布式端口的状况"><a href="#监控分布式端口的状况" class="headerlink" title="监控分布式端口的状况"></a>监控分布式端口的状况</h3><p>vSphere 可以监控分布式端口并提供关于每个端口的当前状况和运行时统计信息。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中找到分布式端口组。</p>
<ol>
<li>选择 Distributed Switch，然后单击网络选项卡。</li>
<li>单击分布式端口组。</li>
</ol>
</li>
<li><p>双击分布式端口组。</p>
</li>
<li><p>单击端口选项卡，然后从列表中选择端口。</p>
</li>
<li><p>单击开始监控端口状况图标。</p>
<p>分布式端口组的端口表将显示每个分布式端口的运行时统计信息。</p>
<p>状况列会显示每个分布式端口的当前状况。</p>
</li>
</ol>
<h3 id="配置分布式端口设置"><a href="#配置分布式端口设置" class="headerlink" title="配置分布式端口设置"></a>配置分布式端口设置</h3><p>可以更改分布式端口的常规设置，如端口名称和描述。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中找到分布式端口组。</p>
<ol>
<li>选择 Distributed Switch，然后单击网络选项卡。</li>
<li>单击分布式端口组。</li>
</ol>
</li>
<li><p>在列表中双击一个分布式端口组。</p>
</li>
<li><p>单击端口选项卡，然后从表中选择分布式端口。</p>
<p>有关分布式端口的信息会显示在屏幕底部。</p>
</li>
<li><p>单击编辑分布式端口设置图标。</p>
</li>
<li><p>在“属性”页面和策略页面上，编辑有关分布式端口的信息，然后单击确定。</p>
<p>如果不允许替代项，则策略选项将处于禁用状态。</p>
</li>
</ol>
<h2 id="在-vSphere-Distributed-Switch-上配置虚拟机网络连接"><a href="#在-vSphere-Distributed-Switch-上配置虚拟机网络连接" class="headerlink" title="在 vSphere Distributed Switch 上配置虚拟机网络连接"></a>在 vSphere Distributed Switch 上配置虚拟机网络连接</h2><p>可以通过配置单个虚拟机网卡，或通过从 vSphere Distributed Switch 自身迁移多组虚拟机，将虚拟机连接到 vSphere Distributed Switch。</p>
<p>通过将虚拟机关联的虚拟网络适配器连接到分布式端口组，可以将虚拟机连接到 vSphere Distributed Switch。对于单个虚拟机，可以通过修改虚拟机的网络适配器配置来完成；对于虚拟机组，可以通过将虚拟机从现有虚拟网络迁移到 vSphere Distributed Switch 来完成。</p>
<h3 id="将虚拟机迁入或迁出-vSphere-Distributed-Switch"><a href="#将虚拟机迁入或迁出-vSphere-Distributed-Switch" class="headerlink" title="将虚拟机迁入或迁出 vSphere Distributed Switch"></a>将虚拟机迁入或迁出 vSphere Distributed Switch</h3><p>除了在单个虚拟机级别将虚拟机连接到 Distributed Switch 以外，还可以在 vSphere Distributed Switch 网络和 vSphere 标准交换机网络之间迁移一组虚拟机。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到数据中心。</p>
</li>
<li><p>在导航器中右键单击数据中心，然后选择将虚拟机迁移到其他网络。</p>
</li>
<li><p>选择源网络。</p>
<ul>
<li>选择特定网络并使用浏览按钮选择一个特定源网络。</li>
<li>选择无网络可迁移未连接到任何其他网络的所有虚拟机网络适配器。</li>
</ul>
</li>
<li><p>使用浏览选择一个目标网络，然后单击下一步。</p>
</li>
<li><p>从列表中选择要从源网络迁移到目标网络的虚拟机，然后单击下一步。</p>
</li>
<li><p>检查选择内容，然后单击完成。</p>
<p>单击上一步以编辑任何选择。</p>
</li>
</ol>
<h3 id="将单个虚拟机连接到分布式端口组"><a href="#将单个虚拟机连接到分布式端口组" class="headerlink" title="将单个虚拟机连接到分布式端口组"></a>将单个虚拟机连接到分布式端口组</h3><p>通过修改虚拟机的网卡配置，可将单个虚拟机连接到 vSphere Distributed Switch。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中找到虚拟机。<ol>
<li>选择数据中心、文件夹、群集、资源池或主机，然后单击虚拟机选项卡。</li>
<li>单击虚拟机，然后从列表中双击虚拟机。</li>
</ol>
</li>
<li>在虚拟机的配置选项卡上，展开设置，然后选择虚拟机硬件。</li>
<li>单击编辑。</li>
<li>展开网络适配器部分，并从网络适配器下拉菜单选择显示更多网络。</li>
<li>在“选择网络”对话框中，选择一个分布式端口组，然后单击确定。</li>
<li>单击确定。</li>
</ol>
]]></content>
      <categories>
        <category>Vmware</category>
      </categories>
      <tags>
        <tag>Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>vSphere 网络连接（标准交换机）</title>
    <url>/2018/06/15/vSphereNetwork/</url>
    <content><![CDATA[<h2 id="网络简介"><a href="#网络简介" class="headerlink" title="网络简介"></a>网络简介</h2><h3 id="网络概念"><a href="#网络概念" class="headerlink" title="网络概念"></a>网络概念</h3><p>一些概念对透彻了解虚拟网络至关重要。如果您是 ESXi 的新用户，则了解这些概念将对您很有帮助。</p>
<ul>
<li><p>物理网络</p>
<p>为了使物理机之间能够收发数据，在物理机间建立的网络。VMware ESXi 运行于物理机之上。</p>
</li>
<li><p>虚拟网络</p>
<p>在单台物理机上运行的虚拟机之间为了互相发送和接收数据而相互逻辑连接所形成的网络。虚拟机可连接到在添加网络时创建的虚拟网络。</p>
</li>
<li><p>含糊网络</p>
<p>含糊网络是由 vSphere 以外的单独实体创建和管理的网络。例如，由 VMware NSX® 创建和管理的逻辑网络在 vCenter Server 中显示为 nsx.LogicalSwitch 类型的含糊网络。可以选择一个含糊网络作为虚拟机网络适配器的支持。要管理含糊网络，请使用与含糊网络关联的管理工具，例如 VMware NSX® Manager™ 或 VMware NSX® API™ 管理工具。</p>
</li>
<li><p>物理以太网交换机</p>
<a id="more"></a>
<p>管理物理网络上计算机之间的网络流量。一台交换机可具有多个端口，每个端口都可与网络上的一台计算机或其他交换机连接。可按某种方式对每个端口的行为进行配置，具体取决于其所连接的计算机的需求。交换机将会了解到连接其端口的主机，并使用该信息向正确的物理机转发流量。交换机是物理网络的核心。可将多个交换机连接在一起，以形成较大的网络。</p>
</li>
<li><p>vSphere 标准交换机</p>
<p>其运行方式与物理以太网交换机十分相似。它检测与其虚拟端口进行逻辑连接的虚拟机，并使用该信息向正确的虚拟机转发流量。可使用物理以太网适配器（也称为上行链路适配器）将虚拟网络连接至物理网络，以将 vSphere 标准交换机连接到物理交换机。此类型的连接类似于将物理交换机连接在一起以创建较大型的网络。即使 vSphere 标准交换机的运行方式与物理交换机十分相似，但它不具备物理交换机所拥有的一些高级功能。</p>
</li>
<li><p>标准端口组</p>
<p>标准端口组为每个成员端口指定了诸如带宽限制和 VLAN 标记策略之类的端口配置选项。网络服务通过端口组连接到标准交换机。端口组定义通过交换机连接网络的方式。通常，单个标准交换机与一个或多个端口组关联。</p>
</li>
<li><p>vSphere Distributed Switch</p>
<p>它可充当数据中心中所有关联主机的单一交换机，以提供虚拟网络的集中式置备、管理以及监控。您可以在 vCenter Server 系统上配置 vSphere Distributed Switch，该配置将传播至与该交换机关联的所有主机。这使得虚拟机可在跨多个主机进行迁移时确保其网络配置保持一致。</p>
</li>
<li><p>主机代理交换机</p>
<p>驻留在与 vSphere Distributed Switch 关联的每个主机上的隐藏标准交换机。主机代理交换机会将 vSphere Distributed Switch 上设置的网络配置复制到特定主机。</p>
</li>
<li><p>分布式端口</p>
<p>连接到主机的 VMkernel 或虚拟机的网络适配器的 vSphere Distributed Switch 上的一个端口。</p>
</li>
<li><p>分布式端口组</p>
<p>与 vSphere Distributed Switch 关联的一个端口组，并为每个成员端口指定端口配置选项。分布式端口组可定义通过 vSphere Distributed Switch 连接到网络的方式。</p>
</li>
<li><p>网卡绑定</p>
<p>当多个上行链路适配器与单个交换机相关联以形成小组时，就会发生网卡绑定。小组将物理网络和虚拟网络之间的流量负载分摊给其所有或部分成员，或在出现硬件故障或网络中断时提供被动故障切换。</p>
</li>
<li><p>VLAN</p>
<p>VLAN 可用于将单个物理 LAN 分段进一步分段，以便使端口组中的端口互相隔离，如同位于不同物理分段上一样。标准是 802.1Q。</p>
</li>
<li><p>VMkernel TCP/IP 网络层</p>
<p>VMkernel 网络层提供与主机的连接，并处理 vSphere vMotion、IP 存储、Fault Tolerance 和 vSAN 的标准基础架构流量。</p>
</li>
<li><p>IP 存储</p>
<p>将 TCP/IP 网络通信用作其基础的任何形式的存储。iSCSI 可用作虚拟机数据存储，NFS 可用作虚拟机数据存储并用于直接挂载 .ISO 文件，这些文件对于虚拟机显示为 CD-ROM。</p>
</li>
<li><p>TCP 分段卸载</p>
<p>TCP 分段卸载 (TSO) 可使 TCP/IP 堆栈发出非常大的帧（达到 64 KB），即使接口的最大传输单元 (MTU) 较小也是如此。然后网络适配器将较大的帧分成 MTU 大小的帧，并预置一份初始 TCP/IP 标头的调整后副本。</p>
</li>
</ul>
<h3 id="ESXi-中的网络服务"><a href="#ESXi-中的网络服务" class="headerlink" title="ESXi 中的网络服务"></a>ESXi 中的网络服务</h3><p>虚拟网络向主机和虚拟机提供了多种服务。</p>
<p>可以在 ESXi 中启用两种类型的网络服务：</p>
<ul>
<li>将虚拟机连接到物理网络以及相互连接虚拟机。</li>
<li>将 VMkernel 服务（如 NFS、iSCSI 或 vMotion）连接至物理网络。</li>
</ul>
<h3 id="VMware-ESXi-Dump-Collector-支持"><a href="#VMware-ESXi-Dump-Collector-支持" class="headerlink" title="VMware ESXi Dump Collector 支持"></a>VMware ESXi Dump Collector 支持</h3><p>当系统遇到重大故障时，ESXi Dump Collector 会将 VMkernel 内存（即核心转储）的状态发送到网络服务器。</p>
<p>ESXi 5.1 及更高版本中的 ESXi Dump Collector 支持 vSphere 标准交换机和 vSphere Distributed Switch。ESXi Dump Collector 还可将任意活动上行链路适配器运用于收集器，此活动上行链路适配器来自处理 VMkernel 适配器的端口组组合。</p>
<p>如果已配置的 VMkernel 适配器的 IP 地址发生更改，则对 ESXi Dump Collector 接口 IP 地址的更改也将自动更新。如果 VMkernel 适配器的网关配置发生更改，ESXi Dump Collector 也将调整其默认网关。</p>
<p>如果您尝试删除 ESXi Dump Collector 使用的 VMkernel 网络适配器，操作会失败并显示警告消息。要删除 VMkernel 网络适配器，请禁用转储收集，然后再删除适配器。</p>
<p>从已崩溃的主机到 ESXi Dump Collector 的文件传输会话中不存在身份验证或加密。您应尽可能在单独的 VLAN 上配置 ESXi Dump Collector，以便将 ESXi 核心转储与常规网络流量隔离。</p>
<h2 id="使用-vSphere-标准交换机设置网络连接"><a href="#使用-vSphere-标准交换机设置网络连接" class="headerlink" title="使用 vSphere 标准交换机设置网络连接"></a>使用 vSphere 标准交换机设置网络连接</h2><p>在 vSphere 部署中，vSphere 标准交换机在主机级别处理网络流量。</p>
<p><strong>vSphere 标准交换机</strong><br>可以创建名为 vSphere 标准交换机的抽象网络设备。使用标准交换机来提供主机和虚拟机的网络连接。标准交换机可在同一 VLAN 中的虚拟机之间进行内部流量桥接，并链接至外部网络。</p>
<p><strong>创建 vSphere 标准交换机</strong><br>创建 vSphere 标准交换机，以便为主机和虚拟机提供网络连接并处理 VMkernel 流量。根据要创建的连接类型，可以使用 VMkernel 适配器创建新的 vSphere 标准交换机，仅将物理网络适配器连接到新交换机，或使用虚拟机端口组创建交换机。</p>
<p><strong>虚拟机的端口组配置</strong><br>您可以添加或修改虚拟机端口组，以便对一组虚拟机设置流量管理。</p>
<p><strong>vSphere 标准交换机属性</strong><br>vSphere 标准交换机设置可控制端口的交换机层面默认值，而每个标准交换机的端口组设置均可覆盖这些值。您可以编辑标准交换机属性，如上行链路配置和可用端口数。</p>
<h3 id="vSphere-标准交换机"><a href="#vSphere-标准交换机" class="headerlink" title="vSphere 标准交换机"></a>vSphere 标准交换机</h3><p>可以创建名为 vSphere 标准交换机的抽象网络设备。使用标准交换机来提供主机和虚拟机的网络连接。标准交换机可在同一 VLAN 中的虚拟机之间进行内部流量桥接，并链接至外部网络。</p>
<p><strong>标准交换机概览</strong></p>
<p>要提供主机和虚拟机的网络连接，请在标准交换机上将主机的物理网卡连接到上行链路端口。虚拟机具有在标准交换机上连接到端口组的网络适配器 (vNIC)。每个端口组可使用一个或多个物理网卡来处理其网络流量。如果某个端口组没有与其连接的物理网卡，则相同端口组上的虚拟机只能彼此进行通信，而无法与外部网络进行通信。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/AFjllg4dj7.png?imageslim" alt="mark"></p>
<p>vSphere 标准交换机与物理以太网交换机非常相似。主机上的虚拟机网络适配器和物理网卡使用交换机上的逻辑端口，每个适配器使用一个端口。标准交换机上的每个逻辑端口都是单一端口组的成员。 </p>
<p><strong>标准端口组</strong></p>
<p>标准交换机上的每个标准端口组都由一个对于当前主机必须保持唯一的网络标签来标识。可以使用网络标签来使虚拟机的网络配置可在主机间移植。应为数据中心的端口组提供相同标签，这些端口组使用在物理网络中连接到一个广播域的物理网卡。反过来，如果两个端口组连接不同广播域中的物理网卡，则这两个端口组应具有不同的标签。</p>
<p>例如，可以创建生产和测试环境端口组来作为在物理网络中共享同一广播域的主机上的虚拟机网络。</p>
<p>VLAN ID 是可选的，它用于将端口组流量限制在物理网络内的一个逻辑以太网网段中。要使端口组接收同一个主机可见、但来自多个 VLAN 的流量，必须将 VLAN ID 设置为 VGT (VLAN 4095)。</p>
<h3 id="创建-vSphere-标准交换机"><a href="#创建-vSphere-标准交换机" class="headerlink" title="创建 vSphere 标准交换机"></a>创建 vSphere 标准交换机</h3><p>创建 vSphere 标准交换机，以便为主机和虚拟机提供网络连接并处理 VMkernel 流量。根据要创建的连接类型，可以使用 VMkernel 适配器创建新的 vSphere 标准交换机，仅将物理网络适配器连接到新交换机，或使用虚拟机端口组创建交换机。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>单击添加主机网络。</p>
</li>
<li><p>选择要使用新标准交换机的连接类型，然后单击下一步。</p>
</li>
<li><p>选择新建标准交换机，然后单击下一步。</p>
</li>
<li><p>将物理网络适配器添加到新的标准交换机。</p>
<ol>
<li><p>在“分配的适配器”下，单击添加适配器。</p>
</li>
<li><p>从列表中选择一个或多个物理网络适配器。</p>
</li>
<li><p>在故障切换顺序组下拉菜单中，从“活动”或“备用”故障切换列表中进行选择。</p>
<p>若要实现更高的吞吐量并提供冗余，请在“活动”列表中至少配置两个物理网络适配器。</p>
</li>
<li><p>单击确定。</p>
</li>
</ol>
</li>
<li><p>如果使用VMkernel适配器或者虚拟机端口组创建新的标准交换机，请输入适配器或端口组的连接设置。</p>
</li>
</ol>
<h2 id="虚拟机的端口组配置"><a href="#虚拟机的端口组配置" class="headerlink" title="虚拟机的端口组配置"></a>虚拟机的端口组配置</h2><p>可以添加或修改虚拟机端口组，以便对一组虚拟机设置流量管理。 </p>
<p>vSphere Web Client 中的<strong>添加网络</strong>向导将引导完成与虚拟机相连接的虚拟网络的创建过程，包括创建vSphere 标准交换机和配置网络标签设置。</p>
<p>设置虚拟机网络时，需要考虑是否在主机之间的网络中迁移虚拟机。如果需要，请确保两台主机均位于同一广播域（二层）内。</p>
<p>ESXI不支持在不同广播域中的主机之间进行虚拟机迁移，因为迁移后的虚拟机可能需要新网络中不在可访问的系统和资源。既是网络配置设置为高可用性环境或包括可解决不同网络中虚拟机需求的智能交换机，当ARP表格为虚拟机进行更新并恢复网络流量时，仍会遇到网络延迟。</p>
<p>虚拟机通过上行链路适配器接入物理网络。只有当一个或多个网络适配器附加到vSphere标准交换机时，vSphere标准交换机才能将数据创术到外部网络，当两个或多个适配器连接到单个标准交换机时，他们便以透明方式进行组合。</p>
<h3 id="添加虚拟机端口组"><a href="#添加虚拟机端口组" class="headerlink" title="添加虚拟机端口组"></a>添加虚拟机端口组</h3><p>在 vSphere 标准交换机中创建端口组，以便为虚拟机提供连接和常用网络配置。 </p>
<p><strong>过程</strong></p>
<ol>
<li><p>在vSphere Web Client中，导航到主机。</p>
</li>
<li><p>右键单击主机，然后选择<strong>添加网络</strong>。</p>
</li>
<li><p>在<strong>选择连接类型</strong>中，选择<strong>标准交换机的虚拟机端口组</strong>，<strong>下一步</strong>。</p>
</li>
<li><p>在<strong>选择目标设备</strong>中，选择现有的标准交换机或创建新的标准交换机。</p>
</li>
<li><p>如果新端口组用于现有标准交换机，请导航至该交换机。</p>
<ol>
<li>单击<strong>浏览</strong>。</li>
<li>从列表中选择标准交换机，然后单击<strong>确定</strong>。</li>
<li>单击<strong>下一步</strong>，然后转至7.</li>
</ol>
</li>
<li><p>（可选）在“创建标准交换机”页面上，将物理网络适配器分配给该标准交换机。</p>
<p>创建标准交换机不一定需要适配器。</p>
<p>如果创建的标准交换机不带物理网络适配器，则该交换机上的所有流量仅限于其内部。物理网络上的其他主机或其他标准交换机上的虚拟机均无法通过此标准交换机发送或接收流量。如果想要一组虚拟机互相进行通信但不与其他主机或者虚拟机组之外的虚拟机进行通信，则可创建一个不带物理适配器的标准交换机。</p>
<ol>
<li>单击<strong>添加适配器</strong>。</li>
<li>从<strong>网络适配器</strong>列表中选择一个适配器。</li>
<li>使用<strong>故障切换顺序组</strong>下拉菜单将该适配器分配到“活动适配器”、“备用适配器”或“未用的适配器”，然后单击确定。</li>
<li><strong>（可选）</strong> 根据需要在<strong>分配的适配器</strong>列表中使用向上和向下箭头更改适配器的位置。</li>
<li>单击<strong>下一步</strong>。</li>
</ol>
</li>
<li><p>在“连接设置”页面上，标识通过该组的各个端口的流量。</p>
<ol>
<li><p>为端口组键入网络标签，或接收生成的标签。</p>
</li>
<li><p>设置 VLAN ID ， 以便在端口组中配置VLAN 处理。</p>
<p>VLAN ID 也会在端口组中反映 VLAN 标记模式。</p>
</li>
<li><p>单击下一步。</p>
</li>
</ol>
</li>
<li><p>在“即将完成”页面中查看端口组设置，然后点击完成。</p>
</li>
</ol>
<p>如果要更改任何配置，点击上一步。</p>
<h3 id="编辑标准交换机端口组"><a href="#编辑标准交换机端口组" class="headerlink" title="编辑标准交换机端口组"></a>编辑标准交换机端口组</h3><p>可以使用 vSphere Web Client 编辑标准交换机端口组的名称和 VLAN ID，并在端口组级别替代网络策略。 </p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>在列表中选择一个标准交换机。</p>
<p>此时将显示交换机的拓扑图。</p>
</li>
<li><p>在交换机的拓扑图中，单击端口组的名称。</p>
</li>
<li><p>在拓扑图标题下，单击编辑设置图标。</p>
</li>
<li><p>在“属性”页面的网络标签文本字段中，重命名端口组。</p>
</li>
<li><p>在 VLAN ID 下拉菜单中配置 VLAN 标记。</p>
</li>
<li><p>在“安全”页面上，替代交换机设置，以防止 MAC 地址模拟，并在混杂模式下运行虚拟机。</p>
</li>
<li><p>在“流量调整”页面上，在端口组级别替代平均带宽、峰值带宽和突发的大小。</p>
</li>
<li><p>在“绑定和故障切换”页面上，替代从标准交换机继承的绑定和故障切换设置。</p>
<p>您可以在与端口组关联的物理适配器之间配置流量分布和重新路由。也可以更改发生故障时使用主机物理适配器的顺序。</p>
</li>
<li><p>单击确定。</p>
</li>
</ol>
<h3 id="从-vSphere-标准交换机移除端口组"><a href="#从-vSphere-标准交换机移除端口组" class="headerlink" title="从 vSphere 标准交换机移除端口组"></a>从 vSphere 标准交换机移除端口组</h3><p>如果不再需要关联的带标记网络，则可从 vSphere 标准交换机移除端口组。 </p>
<p><strong>先决条件</strong></p>
<p>确认要移除的端口组未连接任何已打开电源的虚拟机。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到主机。</li>
<li>在配置选项卡上，展开网络，然后选择虚拟交换机。</li>
<li>选择标准交换机。</li>
<li>从交换机的拓扑图中，单击端口组的标签以选择要移除的端口组。</li>
<li>在交换机拓扑的工具栏中，单击移除选定的端口组操作图标。</li>
</ol>
<h2 id="vSphere-标准交换机属性"><a href="#vSphere-标准交换机属性" class="headerlink" title="vSphere 标准交换机属性"></a>vSphere 标准交换机属性</h2><p>vSphere 标准交换机设置可控制端口的交换机层面默认值，而每个标准交换机的端口组设置均可覆盖这些值。您可以编辑标准交换机属性，如上行链路配置和可用端口数。 </p>
<p><strong>ESXi 主机上的端口数量</strong></p>
<p>为了确保高效使用主机资源，在运行 ESXi 5.5 及更高版本的主机上，虚拟交换机的端口数将按比例动态增加和减少。此主机上的交换机可扩展至主机上支持的最大端口数。端口限制基于主机可处理的最大虚拟机数来确定。</p>
<p>运行 ESXi 5.1 及更低版本的主机上的每个虚拟交换机均提供有限数量的端口，虚拟机和网络服务可以通过这些端口访问一个或多个网络。您必须根据您的部署要求手动增加或减少端口数。</p>
<p><strong>注：</strong></p>
<p>增加交换机的端口数将导致预留和消耗主机上更多的资源。如果某些端口未被占用，则某些可能需要用于其他操作的主机资源将保持锁定和未使用状态。</p>
<h3 id="更改vSphere-标准交换机上-MTU-的大小"><a href="#更改vSphere-标准交换机上-MTU-的大小" class="headerlink" title="更改vSphere 标准交换机上 MTU 的大小"></a>更改vSphere 标准交换机上 MTU 的大小</h3><p>更改 vSphere 标准交换机上最大传输单元 (MTU) 的大小，即增加使用单个数据包传输的负载数据量（也就是启用巨帧）来提高网络效率。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择虚拟交换机。</p>
</li>
<li><p>从表中选择一台标准交换机，然后单击编辑设置。</p>
</li>
<li><p>更改标准交换机的 MTU (字节) 值。</p>
<p>您可以通过设置大于 1500 的 MTU 值启用巨帧。设置的 MTU 大小不能超过 9000 字节。</p>
</li>
<li><p>单击确定。</p>
</li>
</ol>
<h3 id="更改物理适配器的速率"><a href="#更改物理适配器的速率" class="headerlink" title="更改物理适配器的速率"></a>更改物理适配器的速率</h3><p>如果物理适配器速度与应用程序要求不匹配，则该适配器可能会成为网络流量的瓶颈。您可以更改物理适配器的连接速度和双工模式，以便按照流量速率来传输数据。</p>
<p>如果该物理适配器支持 SR-IOV，可以启用它，并配置虚拟机网络连接要使用的虚拟功能数。</p>
<p>过程</p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在配置选项卡上，展开网络，然后选择物理适配器。</p>
<p>主机的物理网络适配器会显示在一个表中，该表包含每个物理网络适配器的详细信息。</p>
</li>
<li><p>从列表中选择物理网络适配器，然后单击编辑适配器设置图标。</p>
</li>
<li><p>从下拉菜单中选择该物理网络适配器的速度和双工模式。</p>
</li>
<li><p>单击确定。</p>
</li>
</ol>
<h3 id="在-vSphere-标准交换机中添加物理适配器并使这些适配器成组"><a href="#在-vSphere-标准交换机中添加物理适配器并使这些适配器成组" class="headerlink" title="在 vSphere 标准交换机中添加物理适配器并使这些适配器成组"></a>在 vSphere 标准交换机中添加物理适配器并使这些适配器成组</h3><p>向标准交换机分配物理适配器可提供与主机上的虚拟机和 VMkernel 适配器的连接。可以组建一个网卡组，以分布流量负载并配置故障切换。 </p>
<p>网卡绑定可将多个网络连接组合在一起来增加吞吐量，并在链路出现故障时提供冗余。要创建组，请将多个物理适配器与一个 vSphere 标准交换机关联起来。</p>
<p><strong>过程</strong></p>
<ol>
<li><p>在 vSphere Web Client 中，导航到主机。</p>
</li>
<li><p>在<strong>配置</strong>选项卡上，展开<strong>网络</strong>，然后选择<strong>虚拟交换</strong>机。</p>
</li>
<li><p>选择要添加物理适配器的标准交换机。</p>
</li>
<li><p>单击<strong>管理已连接到选定交换机的物理网络适配器</strong>图标。</p>
</li>
<li><p>向交换机添加一个或多个可用的物理网络适配器。</p>
<ol>
<li><p>单击添加适配器。</p>
</li>
<li><p>选择要向其分配适配器的故障切换顺序组。</p>
<p>该故障切换组将决定适配器与外部网络交换数据的角色，即活动、备用或未使用。默认情况下，适配器会作为活动角色添加到标准交换机。</p>
</li>
<li><p>单击确定</p>
</li>
</ol>
<p>选定适配器会显示在“分配的适配器”列表下的选定故障切换组列表中。</p>
</li>
<li><p><strong>（可选）</strong> 使用向上和向下箭头可更改适配器在故障切换组中的位置。</p>
</li>
<li><p>单击确定应用物理适配器配置。</p>
</li>
</ol>
<h3 id="查看-vSphere-标准交换机的拓扑图"><a href="#查看-vSphere-标准交换机的拓扑图" class="headerlink" title="查看 vSphere 标准交换机的拓扑图"></a>查看 vSphere 标准交换机的拓扑图</h3><p>可以使用 vSphere 标准交换机的拓扑图检查该交换机的结构和组件。 </p>
<p>标准交换机的拓扑图提供连接到该交换机的适配器和端口组的直观表示。</p>
<p>在该拓扑图中，您可以编辑所选端口组和所选适配器的设置。</p>
<p><strong>过程</strong></p>
<ol>
<li>在 vSphere Web Client 中，导航到主机。</li>
<li>在配置选项卡上，展开网络，然后选择虚拟交换机。</li>
<li>在列表中选择标准交换机。</li>
</ol>
<p><strong>结果</strong></p>
<p>拓扑图将显示在主机上虚拟交换机的列表下。</p>
<p><strong>将 VMkernel 和虚拟机连接到网络的标准交换机图</strong></p>
<p>在您的虚拟环境中，vSphere 标准交换机为 vSphere vMotion 和管理网络处理 VMkernel 适配器以及分组的虚拟机。可以使用中心拓扑图来检查虚拟机或 VMkernel 适配器是否连接到外部网络，并确定承载数据的物理适配器。</p>
<p>将 VMkernel 和虚拟机连接到网络的标准交换机拓扑图</p>
]]></content>
      <categories>
        <category>Vmware</category>
      </categories>
      <tags>
        <tag>Networking</tag>
      </tags>
  </entry>
  <entry>
    <title>Veeam B&amp;R 创建备份任务</title>
    <url>/2018/06/11/Veeambk1/</url>
    <content><![CDATA[<h1 id="启动新的备份向导"><a href="#启动新的备份向导" class="headerlink" title="启动新的备份向导"></a>启动新的备份向导</h1><p>要启动新的备份作业向导，请执行以下操作之一：</p>
<ul>
<li>在主页选项卡上，单击备份作业并选择VMware 。</li>
<li><p>打开主页视图。在清单窗格中，右键单击作业，然后选择Backup&gt; VMware vSphere 。</p>
</li>
<li><p>打开库存视图。在工作区中选择虚拟机，在功能区上单击添加到备份，然后选择新建作业或右键单击虚拟机并选择添加到备份作业&gt; 新建作业。Veeam Backup＆Replication 将启动“ 新建备份作业” 向导并将VM添加到此作业中。稍后您可以将其他虚拟机添加到该作业，当您通过向导步骤时。</p>
</li>
<li>您可以快速将虚拟机添加到现有的作业中。为此，请打开清单视图，在工作区中选择虚拟机，然后单击功能区上作业的名称或添加到备份&gt; 右键单击该虚拟机并选择添加到备份作业&gt; 名称这份工作。</li>
</ul>
<p><img src="https://blog-image.nos-eastchina1.126.net/48150464.jpg" alt=""></p>
<h2 id="指定作业名称和说明"><a href="#指定作业名称和说明" class="headerlink" title="指定作业名称和说明"></a>指定作业名称和说明</h2><p>在向导的名称步骤中，指定备份作业的名称和说明。</p>
<ol>
<li>在名称字段中，输入备份作业的名称。</li>
<li>在描述字段中，提供一个描述以备将来参考。默认说明包含有关创建作业的用户以及作业创建日期和时间的信息。</li>
</ol>
<a id="more"></a>
<p><img src="https://blog-image.nos-eastchina1.126.net/28520668.jpg" alt=""></p>
<h2 id="选择要备份的虚拟机"><a href="#选择要备份的虚拟机" class="headerlink" title="选择要备份的虚拟机"></a>选择要备份的虚拟机</h2><p>在向导的虚拟机步骤中，选择要备份的虚拟机和VM容器。</p>
<p>具有VM容器的作业本质上是动态的。如果在创建备份作业后将新虚拟机添加到虚拟基础架构的容器中，Veeam Backup＆Replication 将自动更新作业设置以包含添加的虚拟机。</p>
<p>向作业添加虚拟机：</p>
<ol>
<li>点击添加。</li>
<li>使用窗口右上角的工具栏在视图之间切换：主机和群集，虚拟机和模板，数据存储和虚拟机以及标签。根据您选择的视图，某些对象可能不可用。例如，如果切换到“ VM和模板” 视图，则树中不会显示资源池，主机或群集。</li>
<li>在列表中选择VM或VM容器，然后单击添加。</li>
</ol>
<p>要快速找到必要的对象，请使用添加对象窗口底部的搜索字段。</p>
<ol>
<li>单击搜索字段左侧的按钮，然后选择要搜索的对象类型：一切，文件夹，群集，主机，资源池，VirtualApp 或虚拟机。</li>
<li>在搜索字段中输入对象名称或其中的一部分。</li>
<li>点击右侧的开始搜索按钮或按[ENTER] 。</li>
</ol>
<p>添加到备份作业的VM和VM容器的初始大小显示在列表的“ 大小” 列中。对象的总大小显示在总大小字段中。将新对象添加到作业后，使用“ 重新计算” 按钮可以刷新总大小值。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/95965037.jpg" alt=""></p>
<h2 id="从备份作业中排除对象"><a href="#从备份作业中排除对象" class="headerlink" title="从备份作业中排除对象"></a>从备份作业中排除对象</h2><p>将VM和VM容器添加到作业后，可以指定要从备份中排除哪些对象。您可以排除以下类型的对象：</p>
<ul>
<li>来自VM容器的VM</li>
<li>特定的VM磁盘</li>
<li>VM模板</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>Veeam Backup＆Replication 自动从备份中排除虚拟机日志文件，以加快备份速度并减小备份文件的大小。</td>
</tr>
</tbody>
</table>
</div>
<p>从VM容器中排除VM：</p>
<ol>
<li>在向导的虚拟机步骤中，单击排除。</li>
<li>点击虚拟机标签。</li>
<li>点击添加。</li>
<li>使用窗口右上角的工具栏在视图之间切换：主机和群集，虚拟机和模板，数据存储和虚拟机以及标签。根据您选择的视图，某些对象可能不可用。例如，如果选择“ VM和模板” 视图，则树中不会显示资源池，主机或群集。</li>
<li>在显示的树中，选择必要的对象并单击添加。使用Show full hierarchy 复选框显示添加到备份基础架构的所有VMware Server的层次结构。</li>
<li>点击确定。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/57659522.jpg" alt="第4步。从备份作业中排除对象"> </p>
<p>排除VM磁盘：</p>
<ol>
<li>在向导的虚拟机步骤中，单击排除。</li>
<li>点击磁盘选项卡。</li>
<li>选择列表中的虚拟机，然后单击编辑。如果要排除作为容器一部分添加的虚拟机的磁盘，请单击添加将虚拟机作为独立对象包含在列表中。</li>
<li>选择要备份的磁盘。您可以选择处理所有磁盘，0:0磁盘（通常是系统磁盘），或者添加到列表中的自定义IDE，SCSI或SATA磁盘。</li>
<li>选择从VM配置中移除排除的磁盘复选框。Veeam Backup＆Replication 将修改备份VM的VMX文件，以从VM配置中移除排除的磁盘。如果将此虚拟机从备份文件还原到排除磁盘无法用原始路径访问的位置，则无需手动编辑VM配置文件即可启动虚拟机。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/14185964.jpg" alt="第4步。从备份作业中排除对象"> </p>
<p>排除VM模板：</p>
<ol>
<li>在该向导的“ 虚拟机” 步骤中，选择一个VM容器并单击“ 排除” 。</li>
<li>点击模板标签。</li>
<li>清除备份虚拟机模板复选框。</li>
<li>如果只想将虚拟机模板包含到完整备份中，请选中“ 备份虚拟机模板” 复选框，然后选中“ 从增量备份中排除模板” 复选框。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/12187527.jpg" alt="第4步。从备份作业中排除对象"> </p>
<h2 id="定义VM备份顺序"><a href="#定义VM备份顺序" class="headerlink" title="定义VM备份顺序"></a>定义VM备份顺序</h2><p>您可以定义备份作业必须处理VM的顺序。例如，如果您将一些关键任务虚拟机添加到作业中并希望作业首先处理它们，则设置VM顺序会很有帮助。您可以首先在列表中设置这些虚拟机，以确保其处理适合备份窗口。</p>
<p>VM容器内的VM随机处理。为确保虚拟机按照定义的顺序进行处理，您必须将它们添加为独立的虚拟机，而不是作为虚拟机容器的一部分。</p>
<p>要定义VM备份顺序：</p>
<ol>
<li>在向导的“ 虚拟机” 步骤中，选择一个VM或VM容器。</li>
<li>使用右侧的向上和向下按钮在列表中向上或向下移动VM或VM容器。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果您在Veeam Backup＆Replication 的全局设置中启用并行数据处理，则可能会按不同的顺序处理VM。例如，如果优先级列表中位置较高的虚拟机的备份基础架构资源不可用，并且列表中位置较低的虚拟机的资源可用，则Veeam Backup＆Replication 将开始处理列表中较低的虚拟机第一。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/14248379.jpg" alt="第5步。定义VM备份顺序"> </p>
<h2 id="指定备份存储设置"><a href="#指定备份存储设置" class="headerlink" title="指定备份存储设置"></a>指定备份存储设置</h2><p>在向导的存储步骤中，为作业备份代理和备份存储库选择备份基础架构组件，并指定备份存储设置。</p>
<ol>
<li><p>点击选择旁边的备份代理字段选择一个备份代理。</p>
<ul>
<li><p>如果选择自动选择，Veeam Backup＆Replication 将检测可访问源数据存储的备份代理，并自动分配最佳备份代理以处理作业中的虚拟机。</p>
<p>Veeam Backup＆Replication 将备份代理逐个分配给备份作业中包含的虚拟机。在VM列表中处理新VM之前，Veeam Backup＆Replication会检查可用的备份代理。如果有多个备份代理可用，Veeam Backup＆Replication 分析备份代理可用于检索VM数据的传输模式以及备份代理上的当前工作负载，以便为VM处理选择最合适的备份代理。</p>
</li>
<li><p>如果选择使用下面指定的选定备份代理服务器，则可以显式选择该作业必须使用的备份代理。建议您至少选择两个备份代理，以确保备份作业在其中一个代理发生故障或失去与源数据存储的连接时启动。</p>
</li>
</ul>
</li>
<li><p>从备份存储库列表中选择一个备份存储库，其中必须存储已创建的备份文件。当您选择备份存储库时，Veeam Backup＆Replication会自动检查备份存储库上有多少可用空间。</p>
</li>
<li><p>您可以将作业映射到存储在备份存储库中的特定备份。如果您已将备份文件移动到新的备份存储库并希望将作业指向此新的备份存储库上的现有备份，则备份作业映射会很有帮助。如果配置数据库损坏并且您需要重新配置备份作业，则还可以使用备份作业映射。</p>
<p>要将作业映射到备份，请单击映射备份链接，然后选择备份存储库上的备份。备份可以通过作业名称轻松识别。要查找备份，您还可以使用窗口底部的搜索字段。</p>
</li>
<li><p>在“ 保留策略” 部分中，指定要在备份存储库上存储的还原点数。超过此数字时，最早的还原点将从备份链中删除。还原点的数量不对应于存储还原点的天数。</p>
</li>
<li><p>如果要将使用备份作业创建的备份文件存档到辅助目标（备份存储库或磁带），请选中为此作业配置辅助目标复选框。启用此选项后，“ 新建备份作业” 向导将包含一个附加步骤 - 次要目标。在向导的“ 辅助目标” 步骤中，可以将备份作业链接到备份副本作业或备份到磁带备份作业。</p>
<p>只有在备份服务器上已经配置了备份复制作业或备份到磁带作业时，才能启用此选项。</p>
</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/10154707.jpg" alt="步骤6.指定备份存储设置"></p>
<h2 id="指定高级备份设置"><a href="#指定高级备份设置" class="headerlink" title="指定高级备份设置"></a>指定高级备份设置</h2><p>在向导的存储步骤中，指定备份作业的高级设置：</p>
<ul>
<li>备份设置</li>
<li>维护设置</li>
<li>存储设置</li>
<li>通知设置</li>
<li>vSphere设置</li>
<li>集成设置</li>
<li>脚本设置</li>
</ul>
<p>在为备份作业指定必要的设置后，可以将它们保存为默认设置。为此，请单击“ 高级设置” 窗口左下角的“ 另存为默认值” 。当您创建新的备份作业时，Veeam Backup＆Replication 将自动将默认设置应用于新作业。</p>
<h3 id="备份设置"><a href="#备份设置" class="headerlink" title="备份设置"></a>备份设置</h3><p>要指定使用备份作业创建的备份链的设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li><p>在“ 备份” 选项卡上，选择要用于在备份存储库上创建备份链的备份方法：</p>
<ul>
<li><p>要创建反向增量备份链，请选择反向增量。</p>
<p>Dell EMC Data Domain和HPE StoreOnce不支持反向增量备份方法。不要为针对这些类型的备份存储库的备份作业选择此选项。</p>
</li>
<li><p>要创建增量备份链，请选择增量并启用合成完整备份和/或活动完整备份.</p>
</li>
<li><p>要创建永久转发增量备份链，请选择增量备份，并且不要启用合成完整备份和/或活动完整备份.</p>
</li>
</ul>
</li>
<li><p>如果选择增量备份方法，则可以选择定期创建合成完整备份和/或活动完整备份。</p>
<ul>
<li><p>要创建合成完整备份，请选中“ 定期创建合成完全备份” 复选框，然后单击“ 天” 以在必要的工作日内安排合成完整备份。</p>
<p>  您还可以选择将以前的完整备份链转换为反向增量备份链。为此，请选中将以前的完整备份链转换为回滚复选框。</p>
</li>
<li><p>要定期创建完整备份，请选中定期创建活动完整备份复选框。使用“ 每月” 或“每周选定日期” 选项定义日程安排设置。</p>
<p>在调度定期完整备份之前，您必须确保备份存储库上有足够的可用空间。作为替代，您可以在需要时手动创建活动完整备份。</p>
</li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果在同一天安排有或无转换任务的活动完整备份和合成完整备份，Veeam Backup＆Replication 将仅执行活动完全备份。合成完整备份和转换任务将被跳过。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/63715678.jpg" alt="备份设置"> </p>
<h3 id="维护设置"><a href="#维护设置" class="headerlink" title="维护设置"></a>维护设置</h3><p>您可以指示Veeam Backup＆Replication 定期执行维护操作 - 服务操作，这有助于确保备份链保持有效且一致。</p>
<p>指定备份作业的维护设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li>点击维护标签。</li>
<li><p>定期执行的备份链最新的还原点进行健康检查，在该存储级别的腐败后卫节选择执行备份文件健康检查复选框，并指定时间表的健康检查。</p>
<p> 自动运行状况检查可帮助您避免在还原点损坏时导致所有相关还原点损坏的情况。如果在运行状况检查期间，Veeam Backup＆Replication检测到备份链中最新还原点中的损坏数据块（或者，如果是永久转发增量链和转发增量链，最新还原点之前还原点位于最新还原点之前），它将启动运行状况检查重试并将有效数据块从源数据存储区传输到备份存储库。根据数据损坏情况，传输的数据块将存储到备份链中的新备份文件或最新的备份文件中。</p>
</li>
<li><p>选中“ 删除后删除的虚拟机数据” 复选框，然后指定要为删除的虚拟机保留备份数据的天数。如果虚拟机不再可用（例如，它已被删除或从作业中排除），则Veeam Backup＆Replication 将在指定的时间段内将其数据保留在备份存储库中。这段时间结束后，删除的虚拟机的数据将从备份存储库中删除。</p>
<p>如果将作业配置为创建活动完全备份或通过后续转换创建合成完全备份，并且希望确保完全备份不包含冗余数据，则删除的VM的保留期很有用。</p>
<p>默认情况下，删除的VM保留期限为14天。不要将已删除的VM保留期限设置为1天或类似的较短时间间隔。在相反的情况下，备份作业可能不按预期工作，并删除您仍需要的虚拟机数据。</p>
</li>
<li><p>要定期压缩完整备份，请选择“ 碎片整理和压缩完整备份文件” 复选框并指定压缩操作的计划。</p>
<p>在紧凑型操作过程中，Veeam Backup＆Replication 创建一个新的空文件并从完整备份文件复制到它的数据块。因此，完整备份文件会进行碎片整理，并且从备份文件读取和写入文件的速度也会增加。</p>
<p>如果完整备份文件包含已删除虚拟机的数据块，Veeam Backup＆Replication 将删除这些数据块。如果完整备份文件包含仅具有一个还原点的虚拟机的数据，且该还原点早于7天，则Veeam Backup＆Replication 将执行取出操作。</p>
</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/44174927.jpg" alt="维护设置"></p>
<h3 id="存储设置"><a href="#存储设置" class="headerlink" title="存储设置"></a>存储设置</h3><p>为备份作业指定存储设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li>点击存储标签。</li>
<li>默认情况下，Veeam Backup＆Replication会在将虚拟机数据存储到备份存储库之前对其进行重复数据删除。重复数据删除提供了较小的备份文件大小，但可能会降低备份作业的性能。要禁用重复数据删除，请清除“ 启用嵌入式重复数据删除” 复选框。</li>
</ol>
<p>如果您禁用此选项，则还会更改增量备份的工作流程。如果为作业启用了更改块跟踪，则Veeam Backup＆Replication 会将所有标记为CBT的数据块保存为目标存储的新数据块，而无需执行额外的检查或使用Veeam的过滤机制。这将导致更快的增量备份。</p>
<ol>
<li>默认情况下，Veeam Backup＆Replication 使用Microsoft Windows操作系统检查虚拟机上的NTFS MFT文件，以识别hiberfil.sys 文件（用于休眠模式的文件）和pagefile.sys 文件（交换文件）的数据块，并排除这些数据处理块。交换文件本质上是动态的，并在备份作业会话之间密集变化，即使虚拟机本身变化不大。处理服务文件会降低作业性能并增加增量备份文件的大小。</li>
<li>如果您要包括的数据块中的的hiberfil.sys 文件pagefile.sys的文件备份，清除排除交换文件块复选框。</li>
<li>默认情况下，Veeam Backup＆Replication 不会将已删除的文件块（VM guest虚拟机操作系统上的“脏”块）复制到目标位置。该选项可以减小备份文件的大小并提高作业性能。如果要将脏数据块包含到备份中，请清除“排除已删除的文件块”复选框。</li>
<li>从压缩级别列表中选择备份的压缩级别：无，重复数据删除，最佳，高或极端。</li>
<li>在存储优化部分中，选择您计划使用的备份目标类型：本地目标（16 TB +备份文件），本地目标，LAN目标或WAN目标。根据所选的存储类型，Veeam Backup＆Replication 将使用不同大小的数据块来优化备份文件的大小和作业性能。</li>
<li>要加密备份文件的内容，请选中启用备份文件加密复选框。在密码字段中，选择您想要用于加密的密码。如果您尚未事先创建密码，请单击添加或使用管理密码链接指定新密码。</li>
</ol>
<p>如果备份服务器未连接到Veeam Backup企业管理器，则在丢失密码的情况下，您将无法从加密备份还原数据。Veeam Backup＆Replication 将显示关于它的警告。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果您为现有备份作业启用加密，则在下一个作业会话期间，Veeam Backup＆Replication 将创建完整备份文件。创建的完整备份文件和备份链中的后续增量备份文件将使用指定的密码进行加密。加密不具有追溯性。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/45196622.jpg" alt="存储设置"></p>
<h3 id="通知设置"><a href="#通知设置" class="headerlink" title="通知设置"></a>通知设置</h3><p>指定备份作业的通知设置：</p>
<ol>
<li><p>在向导的存储步骤中，单击高级。</p>
</li>
<li><p>点击通知标签。</p>
</li>
<li><p>选择此作业发送SNMP通知，如果你想要的工作成功完成时收到SNMP陷阱复选框。</p>
<p>如果您在Veeam Backup＆Replication中指定全局SNMP设置并在接收方机器上配置接收SNMP陷阱的软件，则SNMP陷阱将被发送。</p>
</li>
<li><p>选择发送电子邮件通知到下列收件人复选框，如果你希望收到有关电子邮件任务完成状态的通知。在下面的字段中，指定收件人的电子邮件地址。您可以输入以分号分隔的多个地址。</p>
<p>如果您在Veeam Backup＆Replication中配置全局电子邮件通知设置，将会发送电子邮件通知。</p>
</li>
<li><p>您可以选择使用全局通知设置或指定自定义通知设置。</p>
<p>要接收该作业的典型通知，请选择使用全局通知设置。在这种情况下，Veeam Backup＆Replication 将应用于为备份服务器指定的作业全局电子邮件通知设置。</p>
<p>要为作业配置自定义通知，请选中使用下面指定的自定义通知设置复选框。您可以指定以下通知设置</p>
</li>
</ol>
<ul>
<li>在主题字段中，指定通知主题。您可以在主题中使用以下变量：％Time％（完成时间），％JobName％，％JobResult％，％VmCount％（作业中的虚拟机数量）和％Issues％（作业中具有的虚拟机数量完成警告或失败状态）。</li>
<li>选择成功时通知，通知警告和/或通知错误复选框，以在作业成功完成，失败或完成时显示警告并接收电子邮件通知。</li>
<li>选择取消通知直到最后一次重试复选框才能接收有关最终作业状态的通知。如果您不启用此选项，Veeam Backup＆Replication 将在每次作业重试时发送一个通知。</li>
</ul>
<ol>
<li><p>选中“ 将成功的备份详细信息设置到该VM属性” 复选框，将有关成功执行的备份和备份结果（备份日期和时间，备份服务器名称和备份文件路径）的信息写入VM属性。在下面的字段中输入属性的名称。如果指定的属性不存在，Veeam Backup＆Replication 将创建它。</p>
</li>
<li><p>选中附加到现有属性的值复选框可将关于成功执行备份的信息附加到属性的现有值。在这种情况下，Veeam Backup＆Replication 将保留用户在属性中添加的值，并仅覆盖备份作业添加的值。如果您不选择此选项，则Veeam Backup＆Replication 将覆盖现有的属性值（由用户和备份作业完成）。</p>
</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/46431142.jpg" alt="通知设置"> </p>
<h3 id="vSphere设置"><a href="#vSphere设置" class="headerlink" title="vSphere设置"></a>vSphere设置</h3><p>为备份作业指定VMware vSphere设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li>点击vSphere 标签。</li>
<li>选中“ 启用VMware工具静止” 复选框可在备份期间冻结已处理虚拟机的文件系统。根据VM版本的不同，Veeam Backup＆Replication 将使用VMware Tools中的VMware FileSystem Sync Driver（vmsync）驱动程序或VMware VSS组件来创建VM快照。这些工具负责静默虚拟机文件系统，并使虚拟机处于适合备份的一致状态。</li>
<li>在更改块跟踪部分中，指定是否必须将VMware vSphere CBT用于VM备份。默认情况下，此选项已启用。如果即使在ESX（i）主机级别禁用了CBT，也要强制使用CBT，请选中“ 为所有处理的VM自动启用CBT” 复选框。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>重要！</th>
</tr>
</thead>
<tbody>
<tr>
<td>您可以将CBT用于具有虚拟硬件版本7或更高版本的VM。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/55658159.jpg" alt="vSphere设置"></p>
<h3 id="集成设置"><a href="#集成设置" class="headerlink" title="集成设置"></a>集成设置</h3><p>在“ 集成” 选项卡上，您可以定义是否要使用“从存储快照备份”技术创建备份。通过Storage Snapshots备份，您可以利用存储快照进行VM数据处理。该技术可改进RPO并降低备份活动对生产环境的影响。</p>
<p>为备份作业指定存储集成设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li>点击集成标签。</li>
<li>默认情况下，启用“从存储快照启用备份” 选项。如果您不想使用“从存储快照中备份”，请清除此复选框。</li>
<li><p>如果向作业添加许多其磁盘位于同一个卷或LUN上的虚拟机，请选中将每个存储快照限制处理的虚拟机数量限制为<N> 复选框，并指定必须为其创建一个存储快照的虚拟机数。Veeam Backup＆Replication 将VM划分为几个组，并为每个VM组触发一个单独的存储快照。结果，工作表现会增加。</p>
</li>
<li><p>如果Veeam Backup＆Replication 无法创建存储快照，其磁盘位于存储系统的虚拟机将不会被作业处理。要故障转移到常规VM处理模式并以常规处理模式备份或复制此类虚拟机，请选中故障转移到标准备份复选框。</p>
</li>
<li>[对于辅助NetApp存储系统]如果Veeam Backup＆Replication 无法在NetApp SnapMirror或SnapVault上创建存储快照，则作业将不备份其磁盘位于存储系统的虚拟机。要故障转移到生产存储上的从存储快照进行备份，请选中故障转移到主存储快照复选框。如果Veeam Backup＆Replication 无法在NetApp SnapMirror或SnapVault上创建存储快照，它将触发主NetApp存储上的存储快照，并将其用作备份源。不过，请注意，主NetApp存储上的“从存储快照进行备份”将会在生产环境中增加额外的负载。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/265190.jpg" alt="集成设置"></p>
<h3 id="脚本设置"><a href="#脚本设置" class="headerlink" title="脚本设置"></a>脚本设置</h3><p>为备份作业指定脚本设置：</p>
<ol>
<li><p>在向导的存储步骤中，单击高级。</p>
</li>
<li><p>点击脚本标签。</p>
</li>
<li><p>如果你想之前执行自定义脚本和/或备份作业后，选择作业之前运行以下脚本并运行后，作业以下脚本复选框，然后单击浏览选择从本地文件夹中的可执行文件（S）备份服务器。脚本在备份服务器上执行。</p>
<p>您可以选择在多个备份会话后或特定的一周后执行备份前和备份后的操作。</p>
</li>
</ol>
<ul>
<li>如果您选择每个<N>备份会话选项运行脚本，则指定必须执行脚本之后的备份作业会话数。</li>
<li>如果您选择仅在选定日期运行脚本选项，请单击天数并指定必须在其中执行脚本的周日。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>您在高级作业设置中定义的自定义脚本与备份作业本身相关，而不是虚拟机静默过程。要为VM映像静默添加预冻结和解冻后脚本，请使用向导的“ 来宾处理” 步骤。</td>
</tr>
</tbody>
</table>
</div>
<p>![脚本设置](脚本设置</p>
<p>为备份作业指定脚本设置：</p>
<ol>
<li>在向导的存储步骤中，单击高级。</li>
<li>点击脚本标签。</li>
<li>如果你想之前执行自定义脚本和/或备份作业后，选择作业之前运行以下脚本并运行后，作业以下脚本复选框，然后单击浏览选择从本地文件夹中的可执行文件（S）备份服务器。脚本在备份服务器上执行。</li>
</ol>
<p>您可以选择在多个备份会话后或特定的一周后执行备份前和备份后的操作。</p>
<ul>
<li>如果您选择每个<N>备份会话选项运行脚本，则指定必须执行脚本之后的备份作业会话数。</li>
<li>如果您选择仅在选定日期运行脚本选项，请单击天数并指定必须在其中执行脚本的周日。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>您在高级作业设置中定义的自定义脚本与备份作业本身相关，而不是虚拟机静默过程。要为VM映像静默添加预冻结和解冻后脚本，请使用向导的“ 来宾处理” 步骤。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/92494324.jpg" alt="脚本设置">)</p>
<h2 id="指定次要目标"><a href="#指定次要目标" class="headerlink" title="指定次要目标"></a>指定次要目标</h2><p>如果在向导的“ 存储” 步骤中启用了“为此作业配置辅助目标” 选项，则该向导的“ 辅助目标” 步骤可用。</p>
<p>在向导的“ 次要目标” 步骤中，可以将备份作业链接到磁带或备份复制作业的备份。因此，备份作业将作为备份源添加到磁带或备份复制作业。根据辅助作业计划，使用备份作业创建的备份文件将归档到磁带或复制到辅助备份存储库。</p>
<p>必须事先配置到磁带作业或备份副本作业的备份。您可以使用空白来源创建这些作业。当您将备份作业链接到这些作业时，Veeam Backup＆Replication 将自动更新链接作业，以将备份作业定义为这些作业的来源。</p>
<p>链接作业：</p>
<ol>
<li>点击添加。</li>
<li>从作业列表中，选择必须链接到备份作业的备份到磁带或备份复制作业。您可以将多个作业链接到备份作业，例如，一个备份到磁带作业和一个备份作业。要快速找到作业，请使用向导底部的搜索栏。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/3729457.jpg" alt="步骤8.指定次要目标"> </p>
<h2 id="指定访客处理设置"><a href="#指定访客处理设置" class="headerlink" title="指定访客处理设置"></a>指定访客处理设置</h2><p>在向导的客户处理步骤中，可以为VM客户机操作系统处理启用以下设置：</p>
<ul>
<li>应用程序感知处理</li>
<li>Microsoft SQL VM的事务日志处理</li>
<li>Oracle VM的归档日志处理</li>
<li>VM guest操作系统文件排除</li>
<li>使用预冻结和解冻后脚本</li>
<li>VM guest操作系统文件索引</li>
</ul>
<p>为了协调guest 虚拟机处理活动，Veeam Backup＆Replication 在VM guest虚拟机操作系统上部署运行时进程。该过程仅在来宾处理过程中运行，并在处理完成后立即停止（取决于所选的选项，在备份作业会话期间或备份作业完成后）。</p>
<p>您必须指定将用于连接VM guest虚拟机操作系统并部署运行时进程的用户帐户：</p>
<ol>
<li>从Guest OS凭据列表中，选择具有VM guest虚拟机操作系统上的本地管理员权限的用户帐户。如果您没有设置凭据事前，点击管理账户链接，或单击添加到添加凭证的权利。</li>
<li>默认情况下，Veeam Backup＆Replication 为作业中的所有虚拟机使用相同的凭据。如果某个虚拟机需要不同的用户帐户，请单击“ 凭证” 并输入虚拟机的自定义凭据。</li>
<li>如果您已将Microsoft Windows VM添加到作业中，请指定哪个guest虚拟机交互代理Veeam Backup＆Replication 可用于在VM guest虚拟机操作系统上部署运行时进程。在来宾互动代理字段的右侧，点击选择。</li>
</ol>
<ul>
<li><ul>
<li>保留自动选择以让Veeam Backup＆Replication 自动选择来宾交互代理。</li>
<li>选择“仅使用选定的来宾交互代理服务器” 可明确定义哪些服务器将执行来宾交互代理角色。服务器列表包含添加到备份基础架构的Microsoft Windows服务器。</li>
</ul>
</li>
</ul>
<p>要检查Veeam Backup＆Replication是否可以与添加到作业中的虚拟机进行通信，并在其客户操作系统上部署运行时进程，请单击立即测试。Veeam Backup＆Replication 将使用指定的凭证连接到列表中的所有虚拟机。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>来宾交互代理功能可在Veeam Backup＆Replication 的企业版和企业增强版中找到。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/67179067.jpg" alt="步骤9.指定访客处理设置"> </p>
<h3 id="应用程序感知处理"><a href="#应用程序感知处理" class="headerlink" title="应用程序感知处理"></a>应用程序感知处理</h3><p>如果添加到运行支持VSS的应用程序的备份作业VM，则可以启用应用程序感知处理以创建事务一致性备份。事务一致的备份保证在虚拟机上正确恢复应用程序而不会丢失数据。</p>
<p>要启用应用程序感知处理：</p>
<ol>
<li><p>在该向导的访客处理步骤中，选中启用应用程序感知处理复选框。</p>
</li>
<li><p>点击应用。</p>
</li>
<li><p>在显示的列表中，选择虚拟机并单击编辑。</p>
<p>要为作为VM容器一部分添加的VM定义自定义设置，必须将该VM作为独立对象包含在列表中。为此，请单击添加，然后选择要自定义其设置的虚拟机。然后选择列表中的虚拟机并定义必要的设置。</p>
</li>
<li><p>在“ 常规” 选项卡的“ 应用程序” 部分中，指定应用程序感知处理的行为场景：</p>
<ul>
<li>如果您希望Veeam Backup＆Replication 在应用程序感知处理期间发生任何错误时停止备份过程，请选择“ 需要成功处理”。</li>
<li>选择尝试应用程序处理，但如果要继续备份过程，即使在应用程序感知处理期间发生错误，也可以忽略故障。该选项保证备份作业的完成。但是，由此产生的备份不会在事务上保持一致，但会导致崩溃一致。</li>
<li>如果您不想为VM启用应用程序感知处理，请选择禁用应用程序处理。</li>
</ul>
</li>
<li><p>[对于Microsoft Exchange，Microsoft SQL和Oracle VM]在事务日志部分，指定Veeam Backup＆Replication是否必须处理事务日志或仅创建仅限备份的备份。</p>
</li>
<li><p>如果您希望Veeam Backup＆Replication 处理事务日志，请选择使用此作业处理事务日志。</p>
<p>​    [对于Microsoft Exchange VM]选中此选项后，在VM guest OS上运行的运行时进程将等待备份成功完成，然后触发事务日志的截断。如果备份作业失败，日志将保持不变，直到下次启动运行时进程。</p>
<p>​    [对于Microsoft SQL Server VM和Oracle VM]必须在“ VM处理设置” 窗口的SQL 和Oracle 选项卡上指定事务日志处理的设置。</p>
</li>
<li><p>仅当您使用其他备份工具执行VM guest虚拟机级备份时才选择执行复制，并且此工具保持数据库状态的一致性。Veeam Backup＆Replication 将为选定的VM创建一个仅复制备份。仅复制备份保留了虚拟机上的完整/差异备份文件和事务日志链。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>重要！</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果Microsoft SQL Server和Oracle Server都安装在一个虚拟机上，并且该虚拟机由启用了两个应用程序日志备份的作业处理，则  Veeam Backup＆Replication  将仅备份Oracle事务日志。Microsoft SQL Server事务日志将不会被处理。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/57822207.jpg" alt="应用程序感知处理"></p>
<h3 id="事务日志设置：Microsoft-SQL-Server"><a href="#事务日志设置：Microsoft-SQL-Server" class="headerlink" title="事务日志设置：Microsoft SQL Server"></a>事务日志设置：Microsoft SQL Server</h3><p>如果备份Microsoft SQL VM，则可以指定Veeam Backup＆Replication 如何处理此VM上的事务日志：</p>
<ol>
<li>在该向导的访客处理步骤中，选中启用应用程序感知处理复选框。</li>
<li>点击应用。</li>
<li>在显示的列表中，选择Microsoft SQL Server VM并单击编辑。</li>
<li>在“ 事务日志” 部分中，选择“ 使用此作业处理事务日志” 。</li>
<li>在“ VM处理设置” 窗口中，单击“ SQL” 选项卡。</li>
<li><p>指定如何处理事务日志。您可以选择以下选项之一：</p>
<ul>
<li><p>选择截断日志以在成功备份后截断事务日志。在VM guest OS上运行的运行时进程将等待备份成功完成，然后截断事务日志。如果作业无法备份Microsoft SQL Server VM，则在VM guest虚拟机操作系统上的日志将保持不变，直到运行时进程的下一次启动。</p>
</li>
<li><p>选择不截断日志以保留事务日志。备份作业完成后，Veeam Backup＆Replication 不会截断Microsoft SQL Server VM上的事务日志。</p>
<p>建议您为使用简单恢复模型的数据库启用此选项。如果为使用完整或大容量日志记录恢复模式的数据库启用此选项，则VM guest虚拟机操作系统上的事务日志可能会变大，并占用所有磁盘空间。在这种情况下，数据库管理员必须自己处理事务日志。</p>
</li>
<li><p>选择备份日志定期牛逼Ø备份事务日志与Veeam备份复制。Veeam Backup＆Replication 将定期将事务日志复制到备份存储库，并将它们与Microsoft SQL Server VM的映像级备份一起存储。在备份作业会话期间，VM guest虚拟机操作系统上的事务日志将被截断。</p>
</li>
</ul>
</li>
</ol>
<p>如果您选择使用Veeam Backup＆Replication备份事务日志，则必须指定事务日志备份的设置：</p>
<ol>
<li>在每隔<N>分钟的备份日志字段中，指定事务日志备份的频率。默认情况下，事务日志每15分钟备份一次。最大日志备份间隔为480分钟。</li>
<li><p>在“ 保留日志备份” 部分中，为存储在备份存储库上的事务日志指定保留策略。</p>
<ul>
<li>选择直到删除相应的映像级别备份，才能为映像级别的备份和事务日志备份应用相同的保留策略。</li>
<li>选择仅保留最后一天<N>日志备份可将事务日志保留特定天数。默认情况下，事务日志保存15天。如果选择此选项，则必须确保事务日志的保留时间不超过映像级备份的保留时间。</li>
</ul>
</li>
<li><p>在日志传送服务器部分中，单击选择以选择要用于传输事务日志的日志传送服务器：</p>
<ul>
<li>如果您想让Veeam Backup＆Replication 自动选择最佳日志传送服务器，请选择自动选择。如果最佳运输服务器处于繁忙状态，Veeam Backup＆Replication 会将数据流导向另一台运输服务器，以避免丢失数据并遵守RPO。交易日志出货过程不需要专用服务器—Veeam Backup＆Replication 可以使用任何添加到备份基础设施的Microsoft Windows服务器。</li>
<li>要明确定义日志传送服务器，请选择仅使用指定的服务器，然后选中要用作日志传送服务器的服务器旁边的复选框。服务器列表包括添加到备份基础架构的所有Microsoft Windows服务器。</li>
</ul>
</li>
</ol>
<p>确保您选择了一个不参与其他资源消耗任务的服务器。例如，您可能不希望将执行WAN加速器角色的服务器用作日志传送服务器。为了实现负载平衡和高可用性目的，建议您至少选择2个日志传送服务器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>重要！</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果在不使用SQL Server AlwaysOn可用性组的情况下托管数据库，Veeam Backup＆Replication会在备份期间自动从配置数据库中排除应用程序感知处理。不备份配置数据库的事务日志。如果使用SQL Server AlwaysOn可用性组托管Veeam Backup＆Replication 配置数据库，则应在备份期间手动从应用程序感知处理中排除此数据库。否则，作业处理将失败并出现以下错误：无法通过网络冻结来宾，请等待超时。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/6621298.jpg" alt="事务日志设置：Microsoft SQL Server"></p>
<h3 id="存档日志设置：Oracle"><a href="#存档日志设置：Oracle" class="headerlink" title="存档日志设置：Oracle"></a>存档日志设置：Oracle</h3><p>如果备份Oracle VM，则可以指定Veeam Backup＆Replication 如何在此VM上处理归档日志：</p>
<ol>
<li><p>在该向导的访客处理步骤中，选中启用应用程序感知处理复选框。</p>
</li>
<li><p>点击应用。</p>
</li>
<li><p>在显示的列表中，选择一个Oracle VM并单击编辑。</p>
</li>
<li><p>在“ 事务日志” 部分中，选择“ 使用此作业处理事务日志” 。</p>
</li>
<li><p>在“ VM处理设置” 窗口中，单击Oracle 选项卡。</p>
</li>
<li><p>在指定具有SYSDBA权限的Oracle帐户部分中，指定Veeam Backup＆Replication 将用于连接到Oracle数据库的用户帐户。该帐户必须具有Oracle数据库的SYSDBA权限。</p>
<p>您可以在用户帐户列表中选择使用访客凭证。在这种情况下，Veeam Backup＆Replication 将使用在向导的Guest处理步骤中指定的帐户来访问VM guest虚拟机操作系统并连接到Oracle数据库。</p>
</li>
<li><p>在“ 存档日志” 部分中，指定Veeam Backup＆Replication 必须如何处理Oracle VM上的存档日志：</p>
<ul>
<li><p>如果希望Veeam Backup＆Replication 保留VM guest虚拟机操作系统上的归档日志，请选择不要删除归档日志。备份作业完成时，运行时进程不会删除存档日志。</p>
<p> 建议您为ARCHIVELOG模式关闭的数据库选择此选项。如果打开ARCHIVELOG模式，VM guest虚拟机操作系统上的归档日志可能会变大并占用所有磁盘空间。在这种情况下，数据库管理员必须自己处理归档日志。</p>
</li>
<li><p>如果希望Veeam Backup＆Replication 删除早于<N>小时或大于<N> GB的归档日志，请选择删除<N>小时之前的日志或删除<N> GB之外的日志。日志大小阈值不是指所有数据库的所有日志的总大小，而是指所选Oracle服务器上每个数据库的日志大小。</p>
</li>
</ul>
<p>当父备份作业（创建映像级备份的作业）运行时，Veeam Backup＆Replication 将等待备份成功完成，然后通过Oracle调用接口（OCI）触发Oracle VM上的归档日志删除。如果主要作业无法备份Oracle VM，则在VM guest OS上的日志将保持不变，直到运行时进程的下一次启动。</p>
</li>
<li><p>要使用Veeam Backup＆Replication备份Oracle归档日志，请选中每隔<N>分钟备份日志复选框并指定归档日志备份的频率。默认情况下，存档日志每15分钟备份一次。最大日志备份间隔为480分钟。</p>
</li>
<li><p>在“ 保留日志备份” 部分中，为存储在备份存储库上的存档日志指定保留策略：</p>
<ul>
<li>选择直到删除相应的映像级别备份，才能为映像级别备份和归档日志备份应用相同的保留策略。</li>
<li>选择仅保留最后<n>天可将归档日志保留特定天数。默认情况下，存档日志将保留15天。如果选择此选项，则必须确保归档日志的保留时间不超过映像级备份的保留时间。</li>
</ul>
</li>
<li><p>在“ 日志传送服务器” 部分中，单击“选择” 以选择要用于传输存档日志的日志传送服务器：</p>
<ul>
<li>如果您希望Veeam Backup＆Replication 自动选择最佳日志传送服务器，请选择自动选择。归档日志装运过程不需要专用服务器—Veeam Backup＆Replication 可以使用任何添加到备份基础架构的Microsoft Windows或Linux服务器。</li>
<li>选择仅使用指定的服务器来明确定义日志传送服务器。在“ 日志传送服务器” 窗口中，选择要用作日志传送服务器的服务器旁边的复选框。服务器列表包括添加到备份基础架构的所有Microsoft Windows服务器。</li>
</ul>
<p>确保您选择了一个不参与其他资源消耗任务的服务器。例如，您可能不希望将执行WAN加速器角色的服务器用作日志传送服务器。为了实现负载平衡和高可用性目的，建议您至少选择2个日志传送服务器。</p>
</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/10554663.jpg" alt="存档日志设置：Oracle"></p>
<h3 id="VM-Guest-OS文件排除"><a href="#VM-Guest-OS文件排除" class="headerlink" title="VM Guest OS文件排除"></a>VM Guest OS文件排除</h3><p>如果您不想备份VM guest OS上的特定文件和文件夹，则可以将它们从备份中排除。</p>
<p>要定义必须排除的文件和文件夹：</p>
<ol>
<li>在该向导的访客处理步骤中，选中启用应用程序感知处理复选框。</li>
<li>点击应用。</li>
<li><p>在显示的列表中，选择虚拟机并单击编辑。</p>
<p> 要为作为VM容器一部分添加的VM定义自定义设置，必须将该VM作为独立对象包含在列表中。为此，请单击添加，然后选择要设置其自定义设置的虚拟机。然后选择列表中的虚拟机并定义必要的设置。</p>
</li>
<li><p>单击文件排除选项卡，并指定必须从备份中排除哪些文件：</p>
<ul>
<li>选择排除以下文件和文件夹以从备份中删除单个文件和文件夹。</li>
<li>选择仅包含以下文件和文件夹以仅保留备份中的指定文件和文件夹。</li>
</ul>
</li>
<li><p>单击添加并指定要包含或排除的文件和文件夹。要形成排除或包含列表，可以使用带星号（*）和问号（？）字符的文件和文件夹，环境变量和文件掩码的完整路径。</p>
</li>
<li>点击确定。</li>
<li>对要排除或包含的每个文件或文件夹重复步骤5-6。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/52557217.jpg" alt="VM Guest OS文件排除"></p>
<h3 id="预冻结和解冻后脚本"><a href="#预冻结和解冻后脚本" class="headerlink" title="预冻结和解冻后脚本"></a>预冻结和解冻后脚本</h3><p>如果您计划备份运行不支持VSS的应用程序的虚拟机，则可以指定Veeam Backup＆Replication 必须使用哪些脚本来停止虚拟机。在Veeam Backup＆Replication 触发VM快照之前，预冻结脚本使VM文件系统和应用程序数据静默以使VM处于一致状态。创建VM快照后，解冻后脚本会将VM和应用程序恢复到其初始状态。</p>
<p>要指定作业的预冻结和解冻后脚本，请执行以下操作：</p>
<ol>
<li>在客户处理步骤中，单击应用程序。</li>
<li>在显示的列表中，选择虚拟机并单击编辑。</li>
<li>点击脚本标签。</li>
<li><p>在“ 脚本处理模式” 部分中，指定脚本执行的场景：</p>
<ul>
<li>如果您希望Veeam Backup＆Replication 在脚本失败时停止备份过程，请选择“ 需要成功执行脚本”。</li>
<li>如果要继续执行备份过程，即使脚本错误发生，请选择忽略脚本执行失败。</li>
<li>如果您不想为VM运行脚本，请选择禁用脚本执行。</li>
</ul>
</li>
<li><p>在Windows脚本部分中，为Microsoft Windows VM指定预冻结和解冻后脚本的路径。Veeam Backup＆Replication 支持EXE，BAT和CMD格式的脚本。</p>
</li>
<li><p>在Linux脚本部分中，指定用于Linux VM的预冻结和/或解冻后脚本的路径。Veeam Backup＆Replication 支持SH文件类型的脚本。</p>
<p>如果您已将具有Microsoft Windows和Linux VM的VM容器添加到作业中，则可以选择为VM容器执行Microsoft Windows和Linux脚本。作业开始时，Veeam Backup＆Replication 将自动确定VM上安装的操作系统类型，并使用相应的脚本来暂停此VM。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>TIP</th>
</tr>
</thead>
<tbody>
<tr>
<td>除了VM静止的预冻结和解冻后脚本外，您还可以指示Veeam Backup＆Replication 在作业开始之前和作业完成之后运行自定义脚本。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/23943774.jpg" alt="预冻结和解冻后脚本"></p>
<h3 id="VM-Guest-OS文件索引"><a href="#VM-Guest-OS文件索引" class="headerlink" title="VM Guest OS文件索引"></a>VM Guest OS文件索引</h3><p>为VM指定VM guest虚拟机操作系统索引选项：</p>
<ol>
<li>在向导的客户处理步骤中，单击索引。</li>
<li>在列表中选择一个虚拟机，然后单击编辑&gt; Windows索引或Linux索引。</li>
<li><p>指定索引范围：</p>
<ul>
<li>如果您不想索引虚拟机的guest虚拟机操作系统文件，请选择禁用索引。</li>
<li>如果要索引所有VM guest OS文件，请选择Index index。</li>
<li><p>除索引除列表中定义的所有VM guest操作系统文件外，请选择索引。默认情况下，系统文件夹从索引中排除。您可以使用右侧的添加和删除按钮添加或删除文件夹。您还可以使用系统环境变量来形成列表，例如：％windir％，％ProgramFiles％和％Temp％。</p>
<p>要将文件夹列表重置为其初始状态，请单击“ 默认” 。</p>
</li>
<li><p>选择仅索引下一个文件夹以定义要索引的文件夹。您可以使用右侧的添加和删除按钮来添加或删除要索引的文件夹。您还可以使用系统环境变量来形成列表，例如：％windir％，％ProgramFiles％和％Temp％。</p>
</li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>对于Linux系统索引，Veeam Backup＆Replication 需要在Linux VM上安装几个实用程序：openssh，mlocate，gzip和tar。如果未找到这些实用程序，Veeam Backup＆Replication 将提示您将它们部署在VM guest虚拟机操作系统上。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/80437536.jpg" alt="VM Guest OS文件索引"></p>
<h2 id="定义作业时间表"><a href="#定义作业时间表" class="headerlink" title="定义作业时间表"></a>定义作业时间表</h2><p>在向导的“ 计划” 步骤中，选择手动运行备份作业或安排作业定期运行。</p>
<p>要指定作业计划：</p>
<ol>
<li>选择自动运行作业复选框。如果未选中此复选框，则必须手动启动作业才能创建VM备份。</li>
<li><p>为作业定义调度设置：</p>
<ul>
<li>要在特定时间每天，在规定的工作日或特定周期内运行作业，请在此时选择每日。使用右侧的字段来配置必要的时间表。</li>
<li>要在特定日期每月运行一次该作业，请选择每月一次。使用右侧的字段来配置必要的时间表。</li>
<li><p>要在特定的时间间隔内每天重复运行作业，请选择“ 每隔一段时间” 。在右侧的字段中，选择必要的时间单位：小时或分钟。单击“ 计划” 并使用时间表为作业定义允许的时间窗口。在小时内的开始时间字段中，指定作业必须开始的确切时间。</p>
<p>  重复运行的作业按以下规则启动：</p>
<ul>
<li>Veeam Backup＆Replication 始终从上午12:00开始计算定义的时间间隔。例如，如果您配置为以4小时为间隔运行作业，则作业将在上午12:00，上午4:00，上午8:00，下午12:00，下午4:00等等开始。</li>
<li><p>如果为作业定义了允许的小时数，则在拒绝时间间隔结束后，Veeam Backup＆Replication 将立即启动作业，然后按定义的时间表运行作业。</p>
<p>例如，您已将作业配置为以2小时的时间间隔运行，并定义了从上午9:00到下午5:00的允许时间。根据上述规则，该工作将首先在上午9:00运行，届时拒绝期结束。之后，工作将在上午10点，中午12点，下午2点和下午4点运行。</p>
</li>
<li><p>要连续运行作业，请选择“ 每隔一段时间” 选项，然后从右侧的列表中选择“ 连续”。前一个备份作业会话结束后，将立即开始新的备份作业会话。</p>
</li>
<li>要链接作业，请使用“ 此作业” 字段。在通常的做法中，工作是一个又一个开始的：当工作A 完成时，工作B 开始，等等。如果要创建一系列作业，则必须为链中的第一个作业定义时间表。对于链中的其他作业，请选择“ 此作业之后”选项，然后从列表中选择前一个作业。</li>
</ul>
</li>
</ul>
</li>
<li><p>在“ 自动重试” 部分中，定义如果由于某种原因导致作业失败，Veeam Backup＆Replication 是否必须再次尝试运行备份作业。在作业重试期间，Veeam Backup＆Replication 仅处理失败的VM。输入运行作业的尝试次数并定义它们之间的时间间隔。如果您选择连续备份，Veeam Backup＆Replication 将在作业运行之间没有任何时间间隔的情况下重试作业达定义的次数。</p>
</li>
<li><p>在“ 备份”窗口部分中，定义备份作业必须完成的时间间隔。备份窗口可防止作业与生产时间重叠，并确保作业不会在生产环境中提供不必要的开销。为作业设置备份窗口：</p>
<p> a. 如果超过允许的备份窗口，请选择终止作业复选框并单击窗口。<br> b. 在“ 时间段”部分中，定义备份的允许时间和禁止时间。如果作业超出允许的窗口，它将自动终止。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>在此作业后，如果链中的第一份工作是按计划自动启动功能才开始工作。如果第一个作业是手动启动的，链接到它的作业将不会启动。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/92744193.jpg" alt="第10步。定义作业时间表"></p>
]]></content>
      <categories>
        <category>Veeam</category>
      </categories>
      <tags>
        <tag>Backup</tag>
      </tags>
  </entry>
  <entry>
    <title>Veeam B&amp;R 关于备份的概念</title>
    <url>/2018/06/09/VeeamBack/</url>
    <content><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>Veeam Backup＆Replication 产生虚拟机的镜像级备份。它将VM视为对象，而不是一组文件。在备份虚拟机时，Veeam Backup＆Replication会在块级别上整体复制VM映像。图像级备份可用于不同类型的恢复，包括即时VM恢复，整个VM恢复，VM文件恢复，文件级恢复等。</p>
<p>备份技术通常用于RTO较低的虚拟机。当主虚拟机发生故障时，您需要一些时间从压缩和重复数据删除的备份文件中还原虚拟机数据。</p>
<h2 id="关于备份"><a href="#关于备份" class="headerlink" title="关于备份"></a>关于备份</h2><p>Veeam Backup＆Replication 是为虚拟环境而构建的。它在虚拟化层运行，并使用基于映像的方法进行虚拟机备份。</p>
<p>Veeam Backup＆Replication 不会在VM guest虚拟机操作系统内部安装代理软件来检索虚拟机数据。为了备份虚拟机，它利用了VMware vSphere快照功能。备份VM时，Veeam Backup＆Replication会请求VMware vSphere创建VM快照。虚拟机快照可以被认为是虚拟机的内聚时间点副本，包括其配置，操作系统，应用程序，相关数据，系统状态等等。Veeam Backup＆Replication 使用此时间点副本作为备份数据的来源。</p>
<p>Veeam Backup＆Replication 从块级别复制源数据存储中的VM数据。它检索虚拟机数据，压缩并重复数据删除，并以Veeam专有格式存储在备份存储库中的备份文件中。</p>
<p>在  Veeam Backup＆Replication中，备份是一个工作驱动的过程。要执行备份，您需要配置备份作业。备份作业是备份活动的配置单元。备份作业定义何时，如何以及在何处备份。一个备份作业可用于处理一个或多个VM。您可以指示Veeam Backup＆Replication 按计划自动运行作业，也可以手动启动它们。</p>
<p>第一个备份作业会话始终会生成VM映像的完整备份。随后的备份作业会话是增量式的 - Veeam Backup＆Replication 仅复制自上次备份作业会话后发生更改的那些数据块。为了跟踪更改的数据块，Veeam Backup＆Replication 使用不同的方法。</p>
<a id="more"></a>
<h2 id="备份如何工作"><a href="#备份如何工作" class="headerlink" title="备份如何工作"></a>备份如何工作</h2><p>Veeam Backup＆Replication 以下列方式执行虚拟机备份：</p>
<ol>
<li>当新的备份作业会话启动时，Veeam Backup＆Replication将启动备份服务器上的Veeam Backup Manager进程。Veeam备份管理器从配置数据库读取作业设置并创建要处理的VM任务列表。对于添加到作业中的每个虚拟机磁盘，Veeam Backup＆Replication 创建一项新任务。</li>
<li>Veeam备份管理器连接到Veeam备份服务。Veeam备份服务包括一个资源调度组件，用于管理备份基础架构中的所有任务和资源。资源调度程序检查可用的备份基础架构资源，并分配备份代理和备份存储库以处理作业任务。</li>
<li>Veeam备份管理器连接到目标存储库和备份代理上的Veeam传输服务。Veeam Transport Services则启动了Veeam Data Movers。为备份代理正在处理的每个任务启动一个新的Veeam Data Mover实例。</li>
<li>Veeam备份管理器与备份存储库和备份代理上的Veeam Data Movers建立连接，并为数据传输设置了许多规则，例如网络流量限制规则等。</li>
<li>备份代理和备份存储库上的Veeam Data Movers建立彼此之间的连接以进行数据传输。</li>
<li>Veeam Backup Manager 从Veeam Broker Service 查询有关VM和虚拟化主机的信息。</li>
<li>如果为作业启用了应用程序感知的图像处理功能，Veeam Backup＆Replication 连接到VM客户操作系统，在VM客户操作系统上部署运行时进程并执行客户机内处理任务。</li>
<li>Veeam Backup＆Replication 请求vCenter Server或ESXi主机创建VM快照。VM磁盘处于只读状态，每个虚拟磁盘都会收到一个增量文件。用户在备份过程中对虚拟机进行的所有更改都将写入增量文件。</li>
<li>源Veeam Data Mover从只读VM磁盘中读取VM数据，并以传输模式之一将数据传输到备份存储库。在增量作业会话期间，源Veeam数据移动器使用CBT仅检索自上一个作业会话后发生更改的那些数据块。如果CBT不可用，则源Veeam数据移动器与备份存储库上的目标Veeam数据移动器进行交互以获取备份元数据，并使用此元数据检测自上一个作业会话后发生更改的块。</li>
</ol>
<p>在传输虚拟机数据时，源Veeam数据移动器执行额外的处理。它会过滤掉零数据块，交换文件块和排除的VM guest OS文件块。源Veeam Data Mover压缩VM数据并将其传输到目标Veeam Data Mover。</p>
<ol>
<li>在备份代理完成读取虚拟机数据之后，Veeam Backup＆Replication 请求vCenter Server或ESXi主机提交VM快照。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/iLFAh3HK4J.png?imageslim" alt="mark"></p>
<h2 id="备份架构"><a href="#备份架构" class="headerlink" title="备份架构"></a>备份架构</h2><p>Veeam Backup＆Replication 使用以下组件进行备份过程：</p>
<ul>
<li><p>一个或多个具有关联数据存储的源主机</p>
</li>
<li><p>一个或多个备份代理</p>
</li>
<li>备份存储库</li>
<li>[可选]一个或多个访客交互代理</li>
<li>[用于共享文件夹备份存储库]网关服务器</li>
</ul>
<p>从事这项工作的所有备份基础架构组件构成了一个数据管道。源主机和备份存储库为数据流生成两个终端点。Veeam Backup＆Replication 在多个周期内处理虚拟机数据，通过数据管道逐块移动虚拟机数据。</p>
<p>Veeam Backup＆Replication 收集虚拟机数据，在Veeam数据移动器的帮助下将其转换并传输到目标。Veeam Backup＆Replication 采用双服务架构 - 一个Veeam Data Mover控制与源主机的交互，另一个控制与备份存储库的交互。Veeam数据移动器相互通信并保持稳定的连接。</p>
<p>当新的备份会话启动时，Veeam Backup＆Replication 执行以下操作：</p>
<ol>
<li><p>Veeam Backup＆Replication 通过来宾交互代理（对于Microsoft Windows VM）或备份服务器（对于具有其他操作系统的VM）在VM来宾操作系统上部署运行时进程。</p>
</li>
<li><p>目标端Veeam数据移动器获取作业指令并与源端Veeam Data Mover进行通信以开始数据收集。</p>
</li>
<li><p>源端Veeam Data Mover 以某种传输模式从源存储中复制虚拟机数据。在增量作业运行期间，源端Veeam数据移动器仅检索自上一个作业会话以来发生更改的那些数据块。</p>
<p>复制时，源端Veeam数据移动器执行额外的数据处理。它会过滤零数据块，交换文件块和排除的VM guest OS文件块，压缩并重复数据删除VM数据块并将其移至目标端Data Mover服务。</p>
</li>
<li><p>目标端Veeam Data Mover会对目标端的相似数据块进行重复数据删除，并将结果写入备份存储库中的备份文件。</p>
</li>
</ol>
<h3 id="现场备份"><a href="#现场备份" class="headerlink" title="现场备份"></a>现场备份</h3><p>要备份到本地站点中的Microsoft Windows或Linux备份存储库，您需要在可以访问源数据存储的计算机上部署备份代理，并将备份作业指向此备份代理。在这种情况下，将在备份代理上启动源端Veeam数据移动器，并在Microsoft Windows或Linux存储库上启动目标端Veeam数据移动器。VM数据通过LAN从备份代理发送到备份存储库。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/3dEGe2d9DF.png?imageslim" alt="mark"></p>
<p>要备份到本地站点中的共享文件夹，您需要部署可访问共享文件夹备份存储库的网关服务器。您可以将网关服务器的角色分配给备份服务器本身或添加到备份基础架构的任何Microsoft Windows计算机。</p>
<p>您可以使用相同的Microsoft Windows计算机作为SMB的备份代理和网关服务器。在这种情况下，Veeam Backup＆Replication 将在同一台计算机上启动源端和目标端Veeam数据移动器，并通过局域网将备份代理中的虚拟机数据发送到共享文件夹备份存储库。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/A8GlH72130.png?imageslim" alt="mark"></p>
<h3 id="异地备份"><a href="#异地备份" class="headerlink" title="异地备份"></a>异地备份</h3><p>异地备份的常见要求是，一个Veeam数据移动器在生产站点（靠近源数据仓库）运行，另一个Veeam数据移动器在远程站点运行，靠近备份存储库。在备份期间，Veeam数据移动器保持稳定的连接，从而允许在WAN上进行不间断的操作或慢速链接。</p>
<p>要备份到远程站点中的Microsoft Windows或Linux存储库，您需要在生产站点中更靠近源数据存储区部署备份代理。在这种情况下，将在备份代理上启动源端Veeam数据移动器，并在Microsoft Windows或Linux存储库上启动目标端Veeam数据移动器。VM数据通过WAN从备份代理发送到备份存储库。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/edCe8bag8C.png?imageslim" alt="mark"></p>
<p>要将虚拟机备份到远程站点中的共享文件夹备份存储库，必须在源站点和远程站点中的网关服务器中部署备份代理。共享文件夹备份库必须指向目标端网关服务器。在备份期间，将在生产站点的源备份代理中启动源端Veeam数据移动器，并在远程站点的目标网关服务器上启动目标端Veeam数据移动器。VM数据通过WAN在备份代理和网关服务器之间传输。 </p>
<p><img src="https://blog-image.nos-eastchina1.126.net/ChCl8485Dl.png?imageslim" alt="mark"></p>
<h2 id="备份链"><a href="#备份链" class="headerlink" title="备份链"></a>备份链</h2><p>Veeam Backup＆Replication 创建并维护以下类型的备份文件：</p>
<ul>
<li>VBK - 存储完整虚拟机映像副本的完整备份文件。</li>
<li>VIB或VRB - 增量备份文件，用于存储VM映像的增量更改。</li>
<li>VBM - 备份元数据文件，用于存储有关备份作业的信息，备份作业处理的VM，备份文件的编号和结构，还原点等。元数据文件便于导入备份，备份映射和其他操作。</li>
</ul>
<p>除这些文件类型外，Veeam Backup＆Replication 还可以在备份存储库上创建以下文件：</p>
<ul>
<li>VSB - 用于在磁带上生成虚拟完全备份的虚拟合成备份文件。</li>
<li>VLB和VSM - 存储Microsoft SQL Server事务日志数据的文件。</li>
<li>VLB和VOM - 存储Oracle归档日志数据的文件。</li>
</ul>
<p>备份作业创建的所有备份文件驻留在备份存储库上的专用作业文件夹中。例如，如果使用DC备份名称创建备份作业，Veeam Backup＆Replication 将在目标备份存储库上创建DC备份文件夹，并将通过此作业生成的所有备份文件存储在此文件夹中。</p>
<p>备份文件组成备份链。备份链由第一个完整备份文件，增量备份文件和备份元数据文件组成。完整备份文件和增量备份文件对应备份虚拟机的还原点。您可以将恢复点视为特定时间点的虚拟机数据的“快照”。还原点让您将虚拟机回滚到必要的状态。</p>
<p>要将虚拟机回滚到特定时间点，您需要一系列备份文件：完整备份文件和一组依赖于此完整备份文件的增量备份文件。如果备份链中的某个文件丢失，您将无法回滚到必要的状态。因此，您不得手动从备份存储库中删除单独的备份文件。相反，您必须指定保留策略设置，以便您可以在备份存储库上保留所需数量的备份文件。</p>
<p>Veeam Backup＆Replication 提供3种备份方法来创建备份链：</p>
<ul>
<li>永远转发增量备份</li>
<li>转发增量备份</li>
<li>反向增量备份</li>
</ul>
<p>默认情况下，在每个备份作业会话期间，Veeam Backup＆Replication 会将所有VM的数据写入同一个备份文件。如有必要，您可以指示Veeam Backup＆Replication 创建每个虚拟机备份链 - 即为每个添加到备份作业的虚拟机生成单独的备份链。</p>
<h3 id="备份方法"><a href="#备份方法" class="headerlink" title="备份方法"></a>备份方法</h3><p>Veeam Backup＆Replication 提供了三种创建备份链的方法：</p>
<ul>
<li>永远转发增量备份</li>
<li>转发增量备份</li>
<li>反向增量备份</li>
</ul>
<h4 id="永远转发增量备份"><a href="#永远转发增量备份" class="headerlink" title="永远转发增量备份"></a>永远转发增量备份</h4><p>永久正向增量备份方法会生成一个由第一个完整备份文件（VBK）和一组后续增量备份文件（VIB）组成的备份链。</p>
<p>Veeam Backup＆Replication 通过以下方式创建永远向前的增量备份链：</p>
<ol>
<li>在第一次备份作业期间，Veeam Backup＆Replication 会在备份存储库上创建完整备份文件。</li>
<li>在后续备份作业会话期间，Veeam Backup＆Replication 仅复制自上次备份作业会话（完整或增量）以来发生更改的VM数据块，并将这些块作为增量备份文件保存在备份链中。</li>
<li>在将新的还原点添加到备份链之后，Veeam Backup＆Replication会检查作业的保留策略。如果Veeam Backup＆Replication 检测到过时的还原点，它会转换备份链以为最近的还原点腾出空间。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/a7406heKd0.png?imageslim" alt="mark"></p>
<p>要使用永久转发增量备份方法，您必须在备份作业设置中选择以下选项：</p>
<ol>
<li>选择<strong>增量</strong>备份模式。</li>
<li>不要启用合成完整备份和/或活动完整备份。如果启用合成和/或活动完整备份，Veeam Backup＆Replication 将生成正向增量备份链</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/cLJh4hle6g.png?imageslim" alt="mark"></p>
<h4 id="转发增量备份"><a href="#转发增量备份" class="headerlink" title="转发增量备份"></a>转发增量备份</h4><p>正向增量备份方法会生成一个由第一个完整备份文件（VBK）和一组后续增量备份文件（VIB）组成的备份链。此外，正向增量备份链还包含合成完整备份文件和/或活动完整备份文件，可将备份链“拆分”为更短的系列文件。</p>
<p>Veeam Backup＆Replication 通过以下方式创建正向增量备份链：</p>
<ol>
<li>在第一次备份作业会话期间，Veeam Backup＆Replication 会在备份存储库上创建完整备份文件。</li>
<li>在后续备份作业会话期间，Veeam Backup＆Replication 仅复制自上次备份作业会话（完整或增量）以来发生更改的VM数据块，并将这些块作为增量备份文件保存在备份链中。</li>
<li>在排定合成的完全备份或活动完整备份的当天，Veeam Backup＆Replication 创建完整备份文件并将其添加到备份链。在完整备份文件之后生成的增量还原点将其用作新的起点。</li>
<li>在将新的还原点添加到备份链之后，Veeam Backup＆Replication会检查为该作业设置的保留策略。如果Veeam Backup＆Replication 检测到过时的还原点，它会尝试从备份链中删除此点。</li>
</ol>
<p><img src="https://helpcenter.veeam.com/docs/backup/vsphere/images/forward_incremental_chain.png" alt="mark"> </p>
<p>启用了合成完整备份的正向增量备份是创建备份链的默认方法。要使用正向增量备份方法，可以保留默认设置或在备份作业设置中选择以下选项：</p>
<ol>
<li>选择增量备份模式。</li>
<li>启用合成完整备份和/或活动完整备份。如果未启用合成完全备份和/或活动完整备份，Veeam Backup＆Replication 将生成永久转发增量备份链。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/4m5Jk79B3m.png?imageslim" alt="mark"></p>
<h4 id="反向增量备份"><a href="#反向增量备份" class="headerlink" title="反向增量备份"></a>反向增量备份</h4><p>反向增量备份方法会生成由最后一个完整备份文件（VBK）和一组反向增量备份文件（VRB）组成的备份链。</p>
<p>Veeam Backup＆Replication 通过以下方式创建反向增量备份链：</p>
<ol>
<li>在第一次备份作业会话期间，Veeam Backup＆Replication 会在备份存储库上创建完整备份文件。</li>
<li>在随后的备份作业会话期间，Veeam Backup＆Replication 仅复制自上次备份作业会话后发生更改的VM数据块。Veeam Backup＆Replication 将复制的数据块“注入”完整备份文件，以将其重建为VM的最新状态。此外，Veeam Backup＆Replication 创建反向增量备份文件，其中包含在重建完整备份文件时替换的数据块，并在备份链中的完全备份文件之前添加此反向增量备份文件。</li>
<li>在将新的还原点添加到备份链之后，Veeam Backup＆Replication会检查为该作业设置的保留策略。如果Veeam Backup＆Replication 检测到过时的还原点，它会从备份链中删除此点。</li>
</ol>
<p>因此，备份链中最新的还原点始终是完全备份，并且在每次成功备份作业会话后都会更新。</p>
<p>反向增量备份方法可让您立即将虚拟机还原到最新状态，而无需额外处理，因为最新的还原点是完整备份文件。如果您需要将虚拟机还原到特定时间点，Veeam Backup＆Replication 会将所需的VRB文件应用到VBK文件以达到所需的还原点。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/I4H8L0I8DK.png?imageslim" alt="mark"></p>
<p>要使用反向增量备份方法，您必须在备份作业设置中选择<strong>“反向增量”</strong> 选项。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/h8mKBddg6J.png?imageslim" alt="mark"></p>
<h4 id="在备份方法之间切换"><a href="#在备份方法之间切换" class="headerlink" title="在备份方法之间切换"></a>在备份方法之间切换</h4><p>您可以轻松切换备份方法。Veeam Backup＆Replication 不会转换以前创建的链。相反，它会按照以下方式在现有的备份链旁边创建一个新的备份链：</p>
<ul>
<li>如果从反向增量方法切换到永远向前增量或向前增量方法，Veeam Backup＆Replication 会在反向增量链旁边创建一组增量备份文件。反向增量链中的完整备份文件被用作增量备份文件的起点。</li>
<li>如果从永远向前增量或向前增量方法切换到反向增量方法，Veeam Backup＆Replication 首先会在增量备份文件旁边创建完整备份文件。在每个新的工作会话期间，Veeam Backup＆Replication都会转换此完整备份文件，并将反向增量备份文件添加到备份链。</li>
<li>如果您从永远向前增量方式切换到向前增量方式，Veeam Backup＆Replication 会根据指定的时间表创建合成完整备份。当新链中的还原点数达到保留限制时，旧的备份链将被删除。</li>
<li>如果从正向增量方法切换到永远向前增量方法，则不再创建合成完整备份。当还原点数达到保留限制时，最早的增量文件与完整备份文件合并。</li>
</ul>
<h3 id="活动完整备份"><a href="#活动完整备份" class="headerlink" title="活动完整备份"></a>活动完整备份</h3><p>在某些情况下，您需要定期创建完整备份。例如，您的公司备份策略可能需要您在周末创建完整备份并在工作日内运行增量备份。为了让您符合这些要求，Veeam Backup＆Replication 可让您创建活动的完整备份。</p>
<p>活动完整备份会生成VM的完整备份，就像您第一次运行备份作业一样。Veeam Backup＆Replication 从源中检索整个虚拟机的数据，压缩并重复数据删除并将其存储到完整备份文件 - VBK。</p>
<p>活动完整备份重置备份链。所有增量备份文件都使用最新的活动完整备份文件作为新的起点。先前使用的完整备份文件保留在磁盘上，直到根据保留策略自动删除它为止。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/CJeC9BIEmI.png?imageslim" alt="mark"></p>
<p>您可以手动创建活动完全备份，或者安排备份作业定期创建活动完整备份。</p>
<ul>
<li>要手动创建活动完全备份，请使用相应备份作业的快捷菜单中的“ 活动完整” 命令。</li>
<li>要安排活动完整备份，请在相应备份作业的“ 高级” 部分中指定日程安排设置。您可以将活动完整备份安排为每周运行一次，例如每周六或每月运行一次，例如每月的第四个星期日运行。</li>
</ul>
<p><img src="https://blog-image.nos-eastchina1.126.net/aKHLEbiD2k.png?imageslim" alt="mark"></p>
<h3 id="活动完整备份计划"><a href="#活动完整备份计划" class="headerlink" title="活动完整备份计划"></a>活动完整备份计划</h3><p>Veeam Backup＆Replication 自动触发备份作业来创建活动完整备份，即使在当天没有安排定期备份作业会话。在安排父备份作业的同时开始作业会话。例如，如果您在周日至周五的中午12:00安排父备份作业，并在周六安排活动的完整备份，则Veeam Backup＆Replication 将启动备份作业会话，该会话将在上午12:00星期六。</p>
<p>如果父备份作业未安排为自动运行或禁用，则Veeam Backup＆Replication 不会执行活动的完全备份。</p>
<p>如果将常规备份作业与活动完整备份一起计划，则Veeam Backup＆Replication 将只生成一个备份文件 - 一个活动的完整备份，其中将包含最新的源VM状态。应该由备份作业计划创建的增量备份文件不会被添加到备份链中。</p>
<p>Veeam Backup＆Replication  创建一个活动完整备份，每天只进行一次活动完整备份（除非手动创建完整备份）。如果您在同一天再次运行备份作业，  Veeam Backup＆Replication  将定期执行增量备份。</p>
<p>​    </p>
<h3 id="合成完整备份"><a href="#合成完整备份" class="headerlink" title="合成完整备份"></a>合成完整备份</h3><p>在某些情况下，定期运行活动的完整备份可能不是一种选择。主动完整备份占用大量资源，并占用大量网络带宽。作为替代，您可以创建合成完整备份。</p>
<p>在数据方面，合成完整备份与常规完整备份完全相同。合成完整备份产生一个包含整个虚拟机数据的VBK文件。活动和完全备份之间的区别在于如何检索VM数据：</p>
<ul>
<li>当您执行活动完整备份时，Veeam Backup＆Replication 将从VM所在的源数据存储中检索VM数据，对其进行压缩和重复数据删除，并将其写入备份存储库上的VBK文件。</li>
<li>在执行合成完全备份时，Veeam Backup＆Replication 不会从源数据存储检索虚拟机数据。相反，它会根据备份存储库中已有的数据合成完整备份。Veeam Backup＆Replication可访问备份存储库中的上一个完整备份文件和后续增量备份文件链，从这些文件合并VM数据并将统一数据写入新的完整备份文件。因此，创建的合成完整备份文件包含与创建活动完整备份时所用的数据相同的数据。</li>
</ul>
<p>合成完整备份具有许多优点：</p>
<ul>
<li>合成完整备份不使用网络资源：它是从磁盘上已有的备份文件创建的。</li>
<li>合成完整备份在生产环境中产生较少的负载：它在备份存储库上正确合成。</li>
</ul>
<p>Veeam Backup＆Replication 将合成完整备份视为常规完整备份。与任何其他完整备份文件一样，合成完整备份文件也会重置备份链。所有后续的增量备份文件都使用合成完整备份文件作为新的起点。先前使用的完整备份文件保留在磁盘上，直到根据保留策略自动删除它为止。</p>
<p>要创建综合完整备份，必须启用“ 定期创建合成完整备份” 选项并在备份作业设置中的特定日期中计划创建合成完全备份。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/C9dH1IdChl.png?imageslim" alt="mark"></p>
<h4 id="合成完全备份如何工作"><a href="#合成完全备份如何工作" class="headerlink" title="合成完全备份如何工作"></a>合成完全备份如何工作</h4><p>要创建综合完整备份，Veeam Backup＆Replication 执行以下步骤：</p>
<ol>
<li><p>在安排合成完整备份的当天，Veeam Backup＆Replication 会触发新的备份作业会话。在此会议期间，Veeam Backup＆Replication 首先以常规方式执行增量备份，并将新的增量备份文件添加到备份链。</p>
<p>Veeam Backup＆Replication 从生产存储中为此增量备份文件检索VM数据。增量备份有助于Veeam Backup＆Replication 确保合成完整备份包含生产环境中源VM的最新更改。</p>
</li>
</ol>
<p><img src="https://helpcenter.veeam.com/docs/backup/vsphere/images/synthetic_fulls_hiw_1.png" alt="åæå®å¨å¤ä&quot;½å¦ä½å·¥ä½"> </p>
<ol>
<li>在备份作业会话结束时，备份存储库上的Veeam Data Mover使用备份链中已有的备份文件（包括新创建的增量备份文件）构建新的合成完整备份。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/4i9LjKcGm3.png?imageslim" alt="mark"></p>
<ol>
<li>创建合成完全备份时，备份存储库上的Veeam Data Mover将删除在作业会话开始时创建的增量备份文件。因此，您有一个由完整备份文件，一组增量备份文件和合成完整备份文件组成的备份链。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/KA7Ba15kKj.png?imageslim" alt="mark"></p>
<ol>
<li>每下一个作业会话都会创建一个新的增量还原点，从合成完全备份开始直到合成完整备份的安排日。在这一天，Veeam Backup＆Replication 创建了一个新的合成完整备份。</li>
</ol>
<h5 id="综合完整备份计划"><a href="#综合完整备份计划" class="headerlink" title="综合完整备份计划"></a>综合完整备份计划</h5><p>Veeam Backup＆Replication 自动触发备份作业会话来创建合成完整备份，即使在当天不定期执行备份作业会话也是如此。在安排父备份作业的同时开始作业会话。例如，如果您在周日到周五的中午12:00安排父备份作业，并在周六安排合成完整备份，则Veeam Backup＆Replication 将启动备份作业会话，该会话将在上午12:00星期六。</p>
<p>如果将常规备份作业与合成完整备份一起计划，Veeam Backup＆Replication 将只生成一个备份文件 - 一个合成完整备份，其中将包含最新状态的源VM。应该由备份作业计划创建的增量备份文件不会被添加到备份链中。</p>
<p>Veeam Backup＆Replication 每天仅在合成完整备份计划的一天内创建一次综合完整备份。如果您在同一天再次运行备份作业，Veeam Backup＆Replication 将定期执行增量备份。</p>
<h4 id="备份链变换"><a href="#备份链变换" class="headerlink" title="备份链变换"></a>备份链变换</h4><p>如果您选择创建合成完整备份，则还可以选择将以前的正向增量备份链转换为反向增量备份链。Veeam Backup＆Replication 将把由完整（VBK）和增量（VIB）备份文件组成的最新备份链转换为反向增量备份文件（VRB）。</p>
<p>使用转换选项可以减少存储备份所需的空间量。而不是两个完整备份文件 - 常规完整备份和合成完整备份 - 磁盘上只有一个合成完整备份文件。但请注意，转换操作比创建定期合成完全备份需要更多的时间。</p>
<p>Veeam Backup＆Replication 总是转换最新的正向增量备份链（由完整备份文件和随后的正向增量备份文件组成的链）。例如，您有一个由一个完整备份文件和一组增量备份文件组成的备份链。在链的中间，您创建一个活动的完全备份。当Veeam Backup＆Replication 运行转换操作时，Veeam Backup＆Replication 将转换最新的活动完整备份文件以及后续的增量备份文件。活动完整备份文件之前的所有备份文件保持不变。</p>
<p>要转换备份链，必须在备份作业设置中启用“ 将先前备份链转换为回滚” 选项。 </p>
<p><img src="https://blog-image.nos-eastchina1.126.net/eEdK912j6H.png?imageslim" alt="mark"></p>
<p>备份链变换如何工作</p>
<p>例如，您已配置备份作业以在星期四执行日常转发增量式备份和排定的合成完整备份。另外，您已选择将增量备份链转换为反向增量备份链。备份作业从星期日开始。在这种情况下，Veeam Backup＆Replication 将按以下方式执行备份：</p>
<ol>
<li>周日，Veeam Backup＆Replication 将创建一个完整的备份文件。</li>
<li>周一到周三，Veeam Backup＆Replication 将创建增量备份文件并将其添加到备份链。</li>
<li>周四，Veeam Backup＆Replication 将首先以常规方式创建合成完整备份。</li>
<li>之后，Veeam Backup＆Replication 将把增量备份链转变为反向增量链。因此，您将在周四创建完整备份，并在周日至周三提供一组相反的增量。</li>
<li>当您下次运行备份作业时，Veeam Backup＆Replication 会将新的增量备份文件添加到备份链。合成完整备份将用作起点。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/KI83kIgF3F.png?imageslim" alt="mark"></p>
<p>混合备份链的保留策略</p>
<p>要在混合备份链（包含反向增量备份和转发增量备份文件的备份链）中保留必要数量的还原点，当作业将新的正向增量备份文件添加到链中时，Veeam Backup＆Replication将删除过时的反向增量备份文件。</p>
<h3 id="保留政策"><a href="#保留政策" class="headerlink" title="保留政策"></a>保留政策</h3><h4 id="永远转发增量备份保留策略"><a href="#永远转发增量备份保留策略" class="headerlink" title="永远转发增量备份保留策略"></a>永远转发增量备份保留策略</h4><p>如果永久转发增量备份链中的还原点数超过保留策略设置，则Veeam Backup＆Replication 将转换备份链以为最近的还原点腾出空间。转换过程按以下方式执行：</p>
<ol>
<li>Veeam Backup＆Replication 为备份链添加了一个新的增量备份文件，并检测到超过允许的还原点数。</li>
<li>Veeam Backup＆Replication 重新构建完整备份文件，以包含完整备份后增量备份文件的更改。为此，Veeam Backup＆Replication 将数据块从链中的第一个增量备份文件注入完整备份文件。因此，完整备份文件在备份链中向前移动了一步。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/KC8ifgEfe3.png?imageslim" alt="mark"></p>
<ol>
<li>第一个增量备份文件作为冗余从备份链中删除。其数据已被注入完整备份文件，完整备份文件包含与此增量备份文件相同的数据。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/5hc3B2E50c.png?imageslim" alt="mark"></p>
<p>例如，您想要在备份链中保留7个还原点。备份作业从星期日开始并每天运行。在这种情况下，Veeam Backup＆Replication 将按照以下方式创建备份链：</p>
<ol>
<li>在周日的第一次备份工作会议期间，Veeam Backup＆Replication 创建了第一个还原点 - 一个完整的备份文件。</li>
<li>星期一到星期六Veeam Backup＆Replication 为备份链增加了六个增量备份文件。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/hkiIAIA9F5.png?imageslim" alt="mark"></p>
<ol>
<li>下周日，Veeam Backup＆Replication 为备份链增加了一个新的增量备份文件。</li>
<li><p>Veeam Backup＆Replication 检测到超过允许的还原点数，并开始转换过程：</p>
<p> a. Veeam Backup＆Replication 将周一创建的增量备份文件中的数据块合并到周日创建的完整备份文件中。这样，完整的备份文件从星期天到星期一“向前迈进了一步”。</p>
</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/9Ae17caB8H.png?imageslim" alt="mark"></p>
<p>星期一创建的增量备份变为冗余备份，并从备份链中删除。</p>
<p> <img src="https://blog-image.nos-eastchina1.126.net/k3hA3hbB6C.png?imageslim" alt="mark"></p>
<p>因此，星期一您将拥有一个完整备份文件链，并在周二至周日有六个增量备份文件。</p>
<h4 id="转发增量备份保留策略"><a href="#转发增量备份保留策略" class="headerlink" title="转发增量备份保留策略"></a>转发增量备份保留策略</h4><p>为了能够从正向增量备份恢复，您需要在磁盘上拥有完整的备份文件和后续增量备份文件链。如果删除完整的备份文件，整个增量备份文件链将变得无用。以类似的方式，如果在要回滚的点之前删除任何增量备份文件，则无法还原VM数据（因为后面的增量备份文件取决于先前的增量备份文件）。</p>
<p>因此，如果选择正向增量备份方法，则在某些日期内磁盘上的还原点数会超过保留策略设置所指定的数量。只有链中最后一个增量备份文件过期后，Veeam Backup＆Replication 才会删除完整备份链。</p>
<p>例如，保留策略设置为3个还原点。周日创建完整备份文件，周一至周六创建增量备份文件，并在周四安排合成完整备份。尽管星期三保留策略已被违反，但完整备份不会被删除。如果没有完整备份，备份链将毫无用处，从而使您没有任何还原点。Veeam Backup＆Replication 将等待下一个完整备份文件和2个增量备份文件的创建，然后才会删除整个上一个链，这将在周六发生。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/fI27hIE0b9.png?imageslim" alt="mark"></p>
<h4 id="反向增量备份保留策略"><a href="#反向增量备份保留策略" class="headerlink" title="反向增量备份保留策略"></a>反向增量备份保留策略</h4><p>在反向增量备份的情况下，Veeam Backup＆Replication 立即删除最早的反向增量备份文件，只要它变得过时。</p>
<p>例如，您可以通过以下方式配置备份作业：</p>
<ul>
<li>备份作业从星期日开始。</li>
<li>备份方法是反向增量式。</li>
<li>保留策略设置为6个还原点。</li>
</ul>
<p>Veeam Backup＆Replication 将于周日开始备份工作。周一到周五，它会将新的还原点添加到备份链并重建完整备份文件。周六，Veeam Backup＆Replication 将添加一个新的还原点，并从备份链中删除最早的反向增量备份文件（VRB）。</p>
<h4 id="已删除虚拟机的保留策略"><a href="#已删除虚拟机的保留策略" class="headerlink" title="已删除虚拟机的保留策略"></a>已删除虚拟机的保留策略</h4><p>在某些情况下，在Veeam Backup＆Replication中配置并运行备份作业后，您可能需要更改虚拟基础架构或备份策略中的某些内容。例如，您可以从虚拟基础架构中删除一些虚拟机，或将它们移动到其他位置。您也可以从已运行一段时间的作业中排除一些虚拟机。</p>
<p>默认情况下，当您从虚拟基础架构中删除受Veeam Backup＆Replication 保护的虚拟机或将其从作业中排除时，包含该VM数据的备份文件仍保留在备份存储库中。为避免将冗余数据保留在磁盘上，可以为删除的虚拟机设置保留策略。在这种情况下，Veeam Backup＆Replication 将从备份存储库中删除不再由备份作业处理的VM的数据。</p>
<p>已删除虚拟机的保留策略设置在备份作业级别。您必须在备份作业设置中的<N>天后选项中启用“ 删除的虚拟机数据” 选项，并指定必须在备份存储库上保留已删除的虚拟机的数据所需的时间段。</p>
<p>注意以下几点：</p>
<ul>
<li><p>您必须明智地为删除的VM使用保留策略。强烈建议您将已删除虚拟机的保留策略设置为3天或更长时间，以防止不必要的数据丢失。</p>
</li>
<li><p>“ N天后删除已删除的虚拟机” 选项允许您控制已删除或已排除的虚拟机的数据。除此之外，Veeam Backup＆Replication还应用常规保留策略规则来维护备份链中必要数量的还原点。</p>
</li>
</ul>
<p><img src="https://blog-image.nos-eastchina1.126.net/K4D4120CcK.png?imageslim" alt="mark"></p>
<h4 id="删除还原点"><a href="#删除还原点" class="headerlink" title="删除还原点"></a>删除还原点</h4><p>为了跟上保留策略，Veeam Backup＆Replication 从备份链中删除整个备份文件，而不是从备份文件中分离单独虚拟机的数据。在某些情况下，特定虚拟机的恢复点数可能会比保留策略设置中指定的要少。如果备份作业处理多个VM或VM容器，并且某些作业会话期间某些VM或VM容器未能处理，则可能会发生这种情况。</p>
<p>从正向增量链删除还原点</p>
<p>如果是正向增量备份链，Veeam Backup＆Replication 不会立即删除还原点。相反，Veeam Backup＆Replication 等待创建新的完整备份（合成或活动）并启动新的备份链。只要“旧”备份链中的最后一个增量还原点标记为冗余，Veeam Backup＆Replication就会从备份存储库中删除整个“旧”备份链。</p>
<p>例如，备份作业处理2个VM：VM 1 和VM 2 。根据保留策略设置，备份链必须包含3个还原点。备份作业已经有5个作业会话，虚拟机已按以下方式处理：</p>
<ul>
<li>VM 1 已成功备份3次，并有3个还原点</li>
<li>VM 2 无法在2个作业会话中处理，并具有1个有效还原点</li>
</ul>
<p>当Veeam Backup＆Replication 将新的还原点添加到备份链时，它不会删除最早的还原点。Veeam Backup＆Replication 将等到新的完整备份文件和2个增量备份文件添加到备份链中。之后，它将从备份存储库中删除整个过时的备份链。新备份链中的还原点同时可能包含两个VM或一个VM的数据：Veeam Backup＆Replication 将备份文件视为还原点，而不是将这些文件中的独立VM视为还原点。</p>
<p>从反向增量链去除还原点</p>
<p>如果是反向增量备份链，当超过允许的还原点数时，Veeam Backup＆Replication会立即删除冗余还原点。</p>
<p>例如，备份作业处理两个VM：VM 1 和VM 2 。根据保留策略设置，备份链必须包含5个还原点。备份作业已经有5个作业会话，虚拟机已按以下方式处理：</p>
<ul>
<li>VM 1 已成功备份5次，并具有5个有效还原点</li>
<li>VM 2 未能在2个作业会话中处理，并且有3个有效的还原点</li>
</ul>
<p>之后，Veeam Backup＆Replication 将运行一个新的备份作业会话，其中成功处理VM 1 和VM 2 。当一个新的还原点被添加到链中时，Veeam Backup＆Replication 将删除最早的还原点，因为备份链中的还原点数量已超过5个。因此，对于VM 1 和3还原，您将有5 个还原点分数为VM 2 。 </p>
<h3 id="备份作业调度"><a href="#备份作业调度" class="headerlink" title="备份作业调度"></a>备份作业调度</h3><p>您可以手动启动备份作业或安排它们在特定时间自动启动。Veeam Backup＆Replication 可让您为作业配置以下设置：</p>
<h4 id="自动启动计划"><a href="#自动启动计划" class="headerlink" title="自动启动计划"></a>自动启动计划</h4><p>要在没有用户干预的情况下定期运行作业，可以安排作业自动启动。在备份服务器上运行的Veeam Backup Service会持续检查备份服务器上配置的所有作业的配置设置，并根据其时间表启动它们。</p>
<p>Veeam Backup＆Replication 可让您为作业配置下列计划设置：</p>
<ul>
<li>您可以安排工作在每天的特定时间或选定日期运行</li>
<li>您可以安排作业按特定时间间隔定期运行</li>
<li>您可以安排作业连续运行</li>
<li>你可以连锁工作</li>
</ul>
<p>在特定时间开始工作</p>
<p>您可以安排在特定时间每天，特定工作日或特定工作日每月开始工作。</p>
<p>这种类型的计划要求您定义必须开始作业的确切时间。例如，您可以将作业配置为每天上午10:00或每月的每个第一个星期日上午12:00开始。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/BaHaG90jI0.png?imageslim" alt="mark"></p>
<p>以特定时间间隔开始的工作</p>
<p>您可以安排工作在特定的时间间隔内每天定期开始工作。作业会话之间的时间间隔可以在几分钟或几小时内定义。例如，您可以将作业配置为每30分钟或每2小时启动一次。</p>
<p>对于定期运行的作业，参考时间是午夜（中午12:00）。Veeam Backup＆Replication 始终从凌晨12:00开始统计定义的时间间隔，第一个工作会议将于凌晨12:00开始。例如，如果将作业配置为以4小时为间隔运行，则作业将在上午12:00，上午4:00，上午8:00，下午12:00，下午4:00等等开始。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/clGHa3L2kL.png?imageslim" alt="mark"></p>
<p>如有必要，您可以为定期运行的作业指定偏移量。偏移量是工作必须开始的一小时内的确切时间。例如，您可以将作业配置为以4小时的时间间隔开始，并指定等于15分钟的偏移量。在这种情况下，工作将在12点15分，4点15分，8点15分，12点15分，4点15分等等开始。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/E0H4h7mD2f.png?imageslim" alt="mark"></p>
<p>如果定期运行的作业的会话不符合指定的时间间隔并与下一个计划的作业会话重叠，则Veeam Backup＆Replication 将以最近的计划时间间隔启动下一个备份作业会话。例如，您设置了一个以4小时为间隔运行的作业。第一次工作会议从上午12:00开始，需要5个小时，并在上午5:00完成。在这种情况下，Veeam Backup＆Replication 将在上午8:00开始新的工作会议。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/9hkjd3LJlK.png?imageslim" alt="mark"></p>
<p>工作连续运行</p>
<p>您可以安排作业连续运行 - 即以不间断的方式运行。一旦前一个工作会议完成，就会开始一个连续运行的作业的新会话。持续运行的作业可以帮助您为VM上安装的最关键应用程序实施近乎连续的数据保护（near-CDP）。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/2EcmJm5G52.png?imageslim" alt="mark"></p>
<p>链接作业</p>
<p>在通常的做法中，在虚拟环境中配置的数据保护作业一个接一个地开始：当作业A 完成时，作业B 开始，等等。您可以使用计划设置创建一系列作业。为此，您必须定义链中第一个作业的开始时间。对于链中的其他作业，您必须选择“ 此作业之后” 选项并从列表中选择前一个作业。</p>
<p>作业链不仅限于特定类型的作业。您可以创建一系列不同类型的作业。例如，您可以：</p>
<ol>
<li>将备份作业设置为链中的第一个作业。</li>
<li>配置SureBackup作业并链接备份作业。在这种情况下，Veeam Backup＆Replication 将在备份作业完成后自动验证使用备份作业创建的备份文件。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>注意：</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果您手动启动初始作业，Veeam Backup＆Replication 将为您提供启动与其链接的作业。点击是启动整个工作链或没有开始只在链中的第一份工作。如果您在初始作业运行时手动启动初始作业并链接另一个作业，则当初始作业完成时，链接作业将不会启动。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://blog-image.nos-eastchina1.126.net/FB1cm6C2eI.png?imageslim" alt="mark"></p>
<p>关于职位链的建议</p>
<p>你应该明智地使用职位链。作业链从作业调度中消除猜测，但有一些缺点：</p>
<ul>
<li>您无法准确预测初始工作需要多少时间，以及何时开始链接工作。根据情况，工作时间表可能会发生变化，有些操作甚至可能无法按计划执行。</li>
</ul>
<p>例如，您配置2个作业：</p>
<ul>
<li><ul>
<li>工作1 计划从每天下午10点开始，通常需要1小时。</li>
<li>工作2 计划在每天工作1 之后开始。合成完整备份计划在周六进行。</li>
</ul>
</li>
</ul>
<p>想象一下，工作1 从星期六开始，运行2.5小时而不是1小时。工作2 将在星期日午夜后开始，并且星期六计划的合成完整备份将不会创建。</p>
<ul>
<li>工作会话中的错误可能会导致工作时间安排发生变化。例如，如果链中的初始作业失败，Veeam Backup＆Replication 将尝试重试它，链接作业的计划将会改变。</li>
<li>在备份基础设施资源上加载可能不平衡。备份代理和备份存储库上的某些插槽可能可用，但不会使用，因为作业排队等待逐个运行。如果您使用支持多个I / O流的备份存储库，则其资源将无法有效使用。</li>
</ul>
<p>您可以安排作业同时运行并平衡备份基础架构组件的负载，而不是作业链。为此，您必须启用并行数据处理并限制备份代理和备份存储库上的并发任务数。</p>
]]></content>
      <categories>
        <category>Veeam</category>
      </categories>
      <tags>
        <tag>Backup</tag>
      </tags>
  </entry>
  <entry>
    <title>Veeam备份基础架构</title>
    <url>/2018/06/09/VeeamArch/</url>
    <content><![CDATA[<p>Veeam备份基础架构包含一组组件。一些组件可以在安装文件的帮助下部署。其他组件可以通过Veeam Backup＆Replication 控制台进行部署。</p>
<h1 id="备份服务器"><a href="#备份服务器" class="headerlink" title="备份服务器"></a>备份服务器</h1><p>备份服务器是安装有Veeam Backup＆Replication 的基于Windows的物理或虚拟机。它是备份基础架构中的核心组件，充当“配置和控制中心”的角色。备份服务器执行所有类型的管理活动：</p>
<ul>
<li>协调备份，复制，恢复验证和恢复任务</li>
<li>控制作业调度和资源分配</li>
<li>用于设置和管理备份基础架构组件以及指定备份基础架构的全局设置</li>
</ul>
<p>除了其主要功能外，新部署的备份服务器还执行默认备份代理和备份存储库（它管理数据处理和数据存储任务）的角色。</p>
<p>备份服务器服务和组件</p>
<p>备份服务器使用以下服务和组件：<br><a id="more"></a></p>
<ul>
<li>Veeam Backup Service 是一项Windows服务，可协调Veeam Backup＆Replication 执行的所有操作，如备份，复制，恢复验证和恢复任务。Veeam备份服务在本地系统帐户或在备份服务器上具有本地管理员权限的帐户下运行。</li>
<li>Veeam Broker Service 与虚拟基础架构交互以收集和缓存虚拟基础架构拓扑。作业和任务从代理服务查询有关虚拟基础架构拓扑的信息，从而加快作业和任务的性能。</li>
<li><p>Veeam访客目录服务管理虚拟机的访客操作系统文件系统索引，并复制系统索引数据文件以支持通过访客操作系统文件进行搜索。索引数据存储在备份服务器上的文件夹Veeam Backup Catalog中。在备份服务器上运行的Veeam客户目录服务与安装在Veeam Backup企业管理器和（可选）专用Microsoft Search Server 上的搜索组件配合使用。</p>
</li>
<li><p>装载服务装载备份和副本以进行文件级访问，浏览VM来宾文件系统并将VM来宾OS文件和应用程序项目恢复到原始位置。</p>
</li>
<li><p>备份代理服务。除了专用服务之外，备份服务器还运行一组Data Mover服务。</p>
</li>
<li><p>Veeam Backup＆Replication 配置数据库存储有关备份基础架构，作业，会话等的数据。数据库实例可以位于本地安装的SQL Server上（与运行备份服务器的机器相同），也可以位于远程安装。</p>
</li>
<li>Veeam Backup＆Replication Console 提供应用程序用户界面，并允许用户访问应用程序的功能。</li>
<li>Veeam Backup PowerShell Snap-In 是Microsoft Windows PowerShell 2.0或更高版本的扩展。Veeam Backup PowerShell添加了一组cmdlet，允许用户通过PowerShell的命令行界面执行备份，复制和恢复任务，或者运行自定义脚本来完全自动化Veeam Backup＆Replication的操作。</li>
</ul>
<h1 id="备份和复制控制台"><a href="#备份和复制控制台" class="headerlink" title="备份和复制控制台"></a>备份和复制控制台</h1><p>的Veeam备份复制控制台是一个客户端组件提供访问到备份服务器。该控制台允许您登录Veeam Backup＆Replication，并执行各种数据保护和灾难恢复操作，就像在备份服务器上工作一样。</p>
<p>控制台无法直接访问备份基础架构组件和配置数据库。用户凭证，密码，角色和权限等数据存储在备份服务器端。要访问此数据，控制台需要连接到备份服务器，并在工作会话期间定期查询此信息。</p>
<p>为了使用户的工作尽可能不中断，如果连接丢失，远程控制台会将会话维持5分钟。如果在此期间内重新建立连接，则可以继续工作而无需重新登录到控制台。</p>
<p>备份和复制控制台部署</p>
<p>控制台默认安装在备份服务器上本地。您也可以在独立模式下使用它 - 将控制台安装在专用计算机上，并通过网络远程访问Veeam Backup＆Replication 。</p>
<p>您可以根据需要安装尽可能多的远程控制台，以便多个用户可以同时访问Veeam Backup＆Replication 。Veeam Backup＆Replication 可防止在备份服务器上进行并发修改。如果多个用户同时使用Veeam Backup＆Replication ，则首先保存更改的用户具有优先权。其他用户将被提示重新加载向导或窗口以获取有关配置数据库中的更改的最新信息。</p>
<p>如果您在基础架构中有多个备份服务器，则可以从同一个控制台连接到它们中的任何一个。为了方便起见，您可以保存这些连接的几个快捷方式。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>重要！</th>
</tr>
</thead>
<tbody>
<tr>
<td>您无法使用相同的控制台连接到具有不同版本的Veeam Backup＆Replication的备份服务器。请注意，如果备份环境中有多个备份服务器，并且这些备份服务器运行不同版本的Veeam Backup＆Replication 。例如，如果其中一台备份服务器运行的是9.0版本，而另一台备份服务器运行的是版本9.5，则需要使用2个独立的控制台连接到这些服务器。</td>
</tr>
</tbody>
</table>
</div>
<p>控制台支持自动更新。每当您在本地或远程连接到备份服务器时，控制台都会检查更新。如果备份服务器安装了修补程序或更新，控制台将自动更新。</p>
<p>注意以下几点：</p>
<ul>
<li>不支持升级到另一个Veeam Backup＆Replication 主要产品版本。如果将Veeam Backup＆Replication 升级到另一个主要版本，则必须手动将控制台升级到相同版本。Veeam Backup＆Replication的预览，测试版或RTM版本不支持自动升级。</li>
<li>不支持控制台的降级。如果控制台的版本高于备份服务器（例如，您已手动升级控制台），则与服务器的连接将失败。</li>
</ul>
<p>如果其他Veeam Backup＆Replication 组件（如Veeam Cloud Connect Portal或Veeam Backup企业管理器）安装在运行控制台的计算机上，这些组件也将升级。</p>
<p>备份和复制控制台组件</p>
<p>在计算机上安装远程控制台时，Veeam Backup＆Replication 会安装以下组件：</p>
<ul>
<li>Veeam Backup PowerShell管理单元</li>
<li>适用于Microsoft Active Directory的Veeam Explorer</li>
<li>Veeam Explorer for Microsoft Exchange</li>
<li>Veeam Explorer for Oracle</li>
<li>适用于Microsoft SQL的Veeam Explorer</li>
<li>适用于Microsoft SharePoint的Veeam Explorer</li>
<li>装载服务器</li>
</ul>
<p>备份和复制控制台用户访问权限</p>
<p>要通过控制台登录Veeam Backup＆Replication ，必须将用户添加到备份服务器上的本地用户组或可以访问备份服务器的一组域用户。用户可以执行他或她在Veeam Backup＆Replication中的角色所允许的操作范围。</p>
<p>备份和复制控制台的要求</p>
<p>在其上安装Veeam Backup＆Replication 控制台的计算机必须满足以下要求：</p>
<ul>
<li><p>机器必须符合系统要求。</p>
</li>
<li><p>远程控制台可以安装在Microsoft Windows机器上（物理或虚拟）。</p>
</li>
<li>如果远程安装控制台，则可以将其部署在NAT后面。但是，备份服务器必须在NAT外部。不支持相反类型的部署：如果备份服务器部署在NAT后面，并且远程控制台部署在NAT外部，则无法连接到备份服务器。</li>
</ul>
<p>备份和复制控制台的局限性</p>
<p>该Veeam备份复制控制台有以下限制：</p>
<ul>
<li>您无法通过远程控制台执行配置备份中的恢复。</li>
<li>安装了远程控制台的机器不会自动添加到受控服务器列表中。因此，您无法执行某些操作，例如导入驻留在远程控制台计算机上的备份文件，或将备份基础架构组件的角色分配给此计算机。要执行这些操作，您必须将远程控制台计算机作为受管服务器添加到Veeam Backup＆Replication中。</li>
</ul>
<h1 id="虚拟化服务器和主机"><a href="#虚拟化服务器和主机" class="headerlink" title="虚拟化服务器和主机"></a>虚拟化服务器和主机</h1><p>您可以将以下类型的服务器和主机添加到备份基础架构中：</p>
<ul>
<li>VMware vSphere服务器</li>
<li>VMware vCloud Director</li>
<li>Microsoft Windows Server</li>
<li>Linux服务器</li>
</ul>
<h1 id="备份代理"><a href="#备份代理" class="headerlink" title="备份代理"></a>备份代理</h1><p>备份代理是位于备份服务器和备份基础架构其他组件之间的体系结构组件。当备份服务器管理任务时，代理处理作业并提供备份流量。</p>
<p>基本的备份代理任务包括以下内容：</p>
<ul>
<li>从生产存储中检索VM数据</li>
<li>压缩</li>
<li>重复数据删除</li>
<li>加密</li>
<li>将其发送到备份存储库（例如，如果您运行备份作业）或其他备份代理（例如，如果您运行复制作业）。</li>
</ul>
<p>备份代理传输模式</p>
<p>根据备份代理的类型和备份体系结构，备份代理可以使用以下数据传输模式之一：</p>
<ul>
<li>直接存储访问</li>
<li>虚拟设备</li>
<li>网络。</li>
</ul>
<p>如果VM磁盘位于存储系统上，并且存储系统已添加到Veeam Backup＆Replication 控制台，则备份代理也可以使用“从存储快照备份”模式。</p>
<p>您可以明确选择传输模式，也可以让Veeam Backup＆Replication 复制自动选择模式。</p>
<p>备份代理部署</p>
<p>默认情况下，代理的角色被分配给备份服务器本身。但是，这仅适用于小流量负载的小型设备。对于大型安装，建议部署专用备份代理。</p>
<p>使用备份代理可以让您根据自己的需求轻松地升级和降低备份基础架构。要优化几个并发作业的性能，可以使用多个备份代理。在这种情况下，Veeam Backup＆Replication 将在可用备份代理之间分配备份工作负载。您可以在主站点和远程站点中部署备份代理。</p>
<p>要部署代理，您需要将基于Windows的服务器添加到Veeam Backup＆Replication，并将备份代理的角色分配给添加的服务器。备份代理运行需要几秒钟才能部署的轻量级服务。部署完全自动化。Veeam Backup＆Replication 安装必要的组件并在其上启动所需的服务。</p>
<p>备份代理服务和组件</p>
<p>备份代理使用以下服务和组件：</p>
<ul>
<li>Veeam安装程序服务是一种辅助服务，一旦将其添加到Veeam Backup＆Replication 控制台中的托管服务器列表中，它就会在任何Windows服务器上安装并启动。该服务分析系统，根据为服务器选择的角色安装和升级必要的组件和服务。</li>
<li>Veeam Data Mover 是代表Veeam Backup＆Replication 执行数据处理任务的组件，例如检索源VM数据，执行重复数据删除和压缩以及将备份的数据存储在目标存储上。</li>
</ul>
<p>备份代理的要求</p>
<p>执行备份代理角色的计算机必须满足以下要求：</p>
<ul>
<li><p>机器必须符合系统要求。</p>
</li>
<li><p>备份代理的角色可以分配给专用的Microsoft Windows服务器（物理或虚拟）。</p>
</li>
<li><p>您必须将该计算机作为受管服务器添加到Veeam Backup＆Replication 控制台。</p>
</li>
</ul>
<p>备份代理的主要作用是为备份流量提供最佳路由并实现高效的数据传输。因此，在部署备份代理时，您需要分析备份代理与其正在工作的存储之间的连接。根据连接类型，备份代理可以通过以下方式之一进行配置（从最高效的开始）：</p>
<ul>
<li>用作备份代理的机器应该可以直接访问VM所在的存储或写入VM数据的存储。这样，备份代理将直接从数据存储检索数据，绕过LAN。</li>
<li>备份代理可以是具有HotAdd访问数据存储上的VM磁盘的VM。这种类型的代理还可以实现无LAN数据传输。</li>
<li>如果上述两种情况均不可行，则可以将备份代理的角色分配给更靠近代理将运行的源或目标存储的网络中的计算机。在这种情况下，虚拟机数据将通过局域网使用NBD协议传输。</li>
</ul>
<h1 id="备份库"><a href="#备份库" class="headerlink" title="备份库"></a>备份库</h1><p>备份存储库是Veeam 为复制的VM 保留备份文件，VM副本和元数据的存储位置。要配置备份存储库，可以使用以下服务器或存储系统：</p>
<ul>
<li>Microsoft Windows服务器</li>
<li>Linux服务器</li>
<li>CIFS（SMB）</li>
<li>使用驱动器备份存储库</li>
<li>DELL EMC Data Domain</li>
<li>ExaGrid</li>
<li>HPE StoreOnce</li>
</ul>
<h2 id="横向扩展备份库"><a href="#横向扩展备份库" class="headerlink" title="横向扩展备份库"></a>横向扩展备份库</h2><p>您可以在备份基础架构中配置向外扩展的备份存储库。向外扩展的备份存储库是一个逻辑实体。它将称为范围的几个备份存储库分组。在配置向外扩展备份存储库时，实际上会创建一个存储设备和系统池，并总结其容量。</p>
<p>您可以随时扩展横向扩展备份存储库。例如，如果备份数据增长并且备份存储库达到存储限制，则可以将新存储系统添加到扩展备份存储库。此存储系统上的可用空间将被添加到扩展备份存储库的容量中。因此，您不必将备份移动到更大尺寸的备份存储库。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/e2HejlHG55.png?imageslim" alt="mark"></p>
<p>部署横向扩展备份存储库，您必须配置多个备份存储库并将其作为扩展数据块添加到扩展备份存储库。您可以在一个扩展备份存储库中混合使用不同类型的备份存储库：</p>
<ul>
<li>Microsoft Windows备份存储库</li>
<li>Linux备份存储库</li>
<li>共享文件夹</li>
<li>重复使用存储设备</li>
</ul>
<p>例如，您可以添加Microsoft Windows备份存储库并将存储设备重复数据删除到同一个横向扩展备份存储库。</p>
<p>您可以将横向扩展备份存储库用于以下类型的作业和任务：</p>
<ul>
<li>备份工作。</li>
<li>备份复印作业。您可以复制位于横向扩展备份存储库上的备份并将备份副本存储在横向扩展备份存储库上。</li>
<li><p>VeeamZIP任务。</p>
</li>
<li><p>由Veeam Agent for Linux 2.0和更高版本创建的备份作业。</p>
</li>
<li>由Veeam Agent for Microsoft Windows 2.0和更高版本创建的备份作业</li>
</ul>
<p>存储在横向扩展存储库中的备份文件可用于所有类型的恢复，即从备份和备份副本作业进行复制。您可以使用SureBackup作业来验证这些备份。向外扩展的备份存储库可用作从磁带介质还原的分段备份存储库。根据为扩展备份存储库配置的数据放置策略将从磁带介质恢复的文件放入扩展盘区。</p>
<p>横向扩展备份存储库的限制</p>
<p>向外扩展的备份存储库具有以下限制：</p>
<ul>
<li>横向扩展备份存储库功能仅适用于Veeam Backup＆Replication的Enterprise和Enterprise Plus版本。</li>
</ul>
<p>如果您配置了向外扩展的备份存储库，然后降级到标准许可证，那么您将无法运行针对扩展备份存储库的作业。但是，您将能够从扩展备份存储库执行还原。</p>
<ul>
<li><p>您不能将扩展备份存储库用作以下类型作业的目标：</p>
</li>
<li><ul>
<li>配置备份作业</li>
<li>复制作业</li>
<li>VM复制作业</li>
<li>由Veeam Endpoint Backup 1.5或更早版本和Veeam Agent for Linux 1.0 Update 1或更早版本创建的Veeam Agent备份作业。</li>
</ul>
</li>
<li><p>如果任何不支持的类型的作业针对此备份存储库，或者备份存储库包含由不受支持类型的作业（例如，副本元数据）生成的数据，则无法将扩展备份存储库作为扩展数据库添加。要将此备份存储库作为扩展区来添加，您必须首先将不支持的作业作为另一个备份存储库的目标，并从备份存储库中删除作业数据。</p>
</li>
<li><p>横向扩展备份存储库不支持旋转的驱动器。如果启用此存储库由范围内的旋转硬盘驱动器设置支持，则Veeam Backup＆Replication 将忽略此设置，并将与此类存储库一起使用，与标准范围一样。</p>
</li>
<li><p>如果将备份存储库作为扩展备份存储库的扩展区添加，则不能将其用作常规备份存储库。</p>
</li>
<li><p>您不能将扩展备份存储库作为扩展添加到另一个向外扩展的备份存储库。</p>
</li>
<li>如果此备份存储库已添加为另一个向外扩展备份存储库的扩展盘区，则无法将备份存储库作为扩展盘区添加。</li>
<li>如果此备份存储库已被vCloud Director组织用作备份目标，则无法将备份存储库作为扩展添加。</li>
<li>您不能将正在执行某项活动的备份存储库（例如备份作业或还原任务）添加为向外扩展备份存储库的范围。</li>
<li>如果使用Enterprise Edition的Veeam Backup＆Replication ，则可以创建1个向外扩展的备份存储库，其中包含3个活动扩展盘区和1个非活动扩展盘区（扩展盘区位于维护模式）。例如，如果任何活动扩展数据块没有可用空间，并且您想从中撤出备份数据，则可以添加不活动扩展数据块。</li>
</ul>
<p>如果您添加4个扩展盘区并且不将其中的任何一个添加到维护模式，那么针对扩展备份存储库的作业将失败。</p>
<p>Enterprise Plus Edition对扩展备份存储库或扩展数量没有限制。</p>
<ul>
<li>Extract和Backup Validator实用程序不适用于存储在横向扩展备份存储库中的备份。</li>
<li><p>要让Veeam Backup＆Replication 在重新扫描扩展备份存储库期间自动导入备份，VBM文件的名称和VBM文件的路径（从备份存储库根文件开始到VBM文件）必须仅包含允许的字符：</p>
</li>
<li><ul>
<li>字母数字字符：a-zA-Z0-9</li>
<li>特殊字符：_-.+=@ ^</li>
</ul>
</li>
</ul>
<p>VBM文件的名称和VBM文件的路径不能包含空格。</p>
<p>如果VBM文件的名称或VBM文件的路径包含禁止的字符，Veeam Backup＆Replication 将无法在向外扩展备份存储库的重新扫描期间导入此类备份。要导入此类备份，可以使用下划线字符替换禁用的字符，例如：C：\ My Repository \ Backup_Job \ Backup_Job.vbm 。你不需要自己重命名备份文件。</p>
<ul>
<li>Veeam Backup＆Replication 不会将一个备份文件分成多个盘区。</li>
</ul>
<h2 id="访客互动代理"><a href="#访客互动代理" class="headerlink" title="访客互动代理"></a>访客互动代理</h2><p>来宾交互代理是位于备份服务器和已处理虚拟机之间的备份基础架构组件。如果备份或复制作业执行以下VM处理，则需要此组件：</p>
<ul>
<li>应用程序感知处理</li>
<li>来宾文件系统索引</li>
<li>事务日志处理</li>
</ul>
<p>为了与VM guest OS进行交互，Veeam Backup＆Replication 需要在每个VM中部署一个运行时进程。在虚拟机中部署运行时进程的任务由客户交互代理执行。</p>
<p>来宾交互代理允许您与VM来宾OS进行通信，即使备份服务器和已处理的VM运行在不同的网络中。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/jGg5EEJk3i.png?imageslim" alt="mark"></p>
<h2 id="网关服务器"><a href="#网关服务器" class="headerlink" title="网关服务器"></a>网关服务器</h2><p>网关服务器是“桥接”备份服务器和备份存储库的辅助备份基础架构组件。如果您在备份基础架构中部署以下类型的备份存储库，则需要网关服务器：</p>
<ul>
<li>共享文件夹备份存储库</li>
<li>DELL EMC Data Domain重复数据删除存储设备</li>
<li>HPE StoreOnce重复数据删除存储设备</li>
</ul>
<p>共享文件夹存储库，EMC Data Domain和HP StoreOnce无法托管Data Mover Services - 在备份代理和备份存储库（备份作业的情况下）之间建立连接的Veeam组件，或在备份存储库之间建立连接的备份副本作业的Veeam组件。为了克服这个限制，Veeam Backup＆Replication 使用网关服务器。</p>
<p>在备份基础架构中，网关服务器承载目标Veeam数据移动器。Veeam Backup＆Replication 在源Veeam Data Mover和目标Veeam Data Mover之间建立连接，并通过网关服务器将数据从/传输到备份存储库。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/f12bIbCJad.png?imageslim" alt="mark"></p>
<h2 id="装载服务器"><a href="#装载服务器" class="headerlink" title="装载服务器"></a>装载服务器</h2><p>如果将VM guest OS文件和应用程序项目还原到原始位置，则装载服务器是必需的。安装服务器可让您以最佳方式路由VM流量，减少网络负载并加速恢复过程。</p>
<p>在执行文件级还原或应用程序项还原时，Veeam Backup＆Replication 需要将备份文件的内容挂载到临时服务器（或用于还原到Microsoft SQL Server和Oracle VM的原始VM）。一旦挂载了VM备份，Veeam Backup＆Replication会通过此挂载服务器或VM将文件或项目复制到其目标。</p>
<p>登台服务器必须与存储备份文件的备份库位于同一站点。在这种情况下，您将能够将VM流量保留在一个站点中。如果登台服务器位于某个其他站点中，则数据将需要通过站点之间的网络传输。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/DKB28GH29L.png?imageslim" alt="mark"></p>
<h2 id="Veeam-Backup企业管理器"><a href="#Veeam-Backup企业管理器" class="headerlink" title="Veeam Backup企业管理器"></a>Veeam Backup企业管理器</h2><p>Veeam Backup Enterprise Manager 是一个可选组件，适用于具有多个备份服务器的分布式企业环境。Veeam Backup Enterprise Manager 联合备份服务器，并通过Web浏览器界面提供这些服务器的统一视图。您可以通过单个“面板”集中控制和管理所有作业，编辑和克隆作业，监控作业状态并获取所有备份服务器上的报告数据。Veeam Backup企业管理器还使您能够在备份基础架构中的所有当前备份和归档备份中搜索VM guest虚拟机操作系统文件，并且只需单击一次即可恢复这些文件。</p>
<h2 id="WAN加速器"><a href="#WAN加速器" class="headerlink" title="WAN加速器"></a>WAN加速器</h2><p>WAN加速器是Veeam Backup＆Replication 用于WAN加速的专用组件。WAN加速器负责全局数据缓存和重复数据删除。 </p>
<h2 id="日志传送服务器"><a href="#日志传送服务器" class="headerlink" title="日志传送服务器"></a>日志传送服务器</h2><p>日志传送服务器是Veeam Backup＆Replication 用于备份Microsoft SQL Server事务日志和Oracle归档日志的专用组件。</p>
<h2 id="磁带服务器"><a href="#磁带服务器" class="headerlink" title="磁带服务器"></a>磁带服务器</h2><p>磁带服务器是负责在数据源和磁带设备之间传输数据的专用组件。</p>
]]></content>
      <categories>
        <category>Veeam</category>
      </categories>
      <tags>
        <tag>Backup</tag>
        <tag>Veeam</tag>
      </tags>
  </entry>
  <entry>
    <title>Veeam B&amp;R部署</title>
    <url>/2018/06/05/VeeamDeploy/</url>
    <content><![CDATA[<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>要开始使用Veeam Backup＆Replication ，您必须配置备份服务器 - 在满足系统要求的机器上安装Veeam Backup＆Replication 。为此，您可以使用安装向导或以无人参与模式安装产品。</p>
<p>当您安装Veeam Backup＆Replication时，Veeam Backup＆Replication 控制台会自动安装在备份服务器上。如果您想远程访问Veeam Backup＆Replication ，则可以在专用机器上安装Veeam Backup＆Replication 控制台。</p>
<h1 id="安装Veeam-Backup＆Replication"><a href="#安装Veeam-Backup＆Replication" class="headerlink" title="安装Veeam Backup＆Replication"></a>安装Veeam Backup＆Replication</h1><h2 id="第1步。启动安装向导"><a href="#第1步。启动安装向导" class="headerlink" title="第1步。启动安装向导"></a>第1步。启动安装向导</h2><p>要启动安装向导：</p>
<ol>
<li>从<a href="http://www.veeam.com/downloads.html" target="_blank" rel="noopener">www.veeam.com/downloads.html </a>下载最新版本的Veeam Backup＆Replication 安装映像。</li>
<li>使用磁盘映像仿真软件将安装映像安装到您计划安装Veeam Backup＆Replication 的计算机上，或将映像文件刻录到空白CD / DVD上。如果您计划在虚拟机上安装Veeam Backup＆Replication ，请使用虚拟化管理软件的内置工具将安装映像安装到虚拟机上。</li>
</ol>
<p>要提取ISO的内容，还可以使用最新版本的实用程序，它们可以从大尺寸的ISO中正确提取数据，并且可以正确使用长文件路径。</p>
<ol>
<li>安装映像或插入磁盘后，自动运行将打开带有安装选项的启动画面。如果自动运行不可用或禁用，请从映像或磁盘运行Setup.exe 文件。</li>
<li>在启动画面的Veeam Backup＆Replication 部分中，单击安装</li>
</ol>
<a id="more"></a>
<p><img src="https://blog-image.nos-eastchina1.126.net/GCg2897i8H.png?imageslim" alt="mark"></p>
<h2 id="第2步。阅读并接受许可协议"><a href="#第2步。阅读并接受许可协议" class="headerlink" title="第2步。阅读并接受许可协议"></a>第2步。阅读并接受许可协议</h2><p>在向导的许可协议步骤中，您必须接受Veeam Backup＆Replication 的许可协议。如果您不接受许可协议，则无法传递到安装向导的下一步。</p>
<ol>
<li>阅读许可协议。</li>
<li>选择我接受许可协议选项中的条款，然后单击下一步。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/ijjjHeHjG5.png?imageslim" alt="mark"></p>
<h2 id="第3步。提供许可证文件"><a href="#第3步。提供许可证文件" class="headerlink" title="第3步。提供许可证文件"></a>第3步。提供许可证文件</h2><p>这步骤跳过许可，下一步</p>
<h2 id="第4步。查看组件并选择安装文件夹"><a href="#第4步。查看组件并选择安装文件夹" class="headerlink" title="第4步。查看组件并选择安装文件夹"></a>第4步。查看组件并选择安装文件夹</h2><p>在向导的“ 程序功能” 步骤中，您可以检查安装向导将在机器上安装的组件，并选择安装文件夹。</p>
<p>安装向导安装以下组件：</p>
<ul>
<li>Veeam备份和复制</li>
<li>Veeam Backup Catalog（负责存储VM guest OS索引数据的组件）</li>
<li>Veeam备份和复制控制台</li>
</ul>
<p>安装向导还会在后台安装以下组件：</p>
<ul>
<li>适用于Microsoft Active Directory的Veeam Explorer</li>
<li>Veeam Explorer for Microsoft Exchange</li>
<li>Veeam Explorer for Oracle</li>
<li>适用于Microsoft SQL Server的Veeam Explorer</li>
<li><p>适用于Microsoft SharePoint的Veeam Explorer</p>
</li>
<li><p>Veeam Backup PowerShell管理单元</p>
</li>
</ul>
<p>这些组件不需要额外的许可证。它们与Veeam Backup＆Replication 集成。</p>
<p>要选择安装文件夹：</p>
<ol>
<li>在“ 安装到” 字段的右侧，单击“ 浏览” 。</li>
<li>在“ 浏览文件夹” 窗口中，选择产品的安装文件夹。默认安装文件夹是C:\Program Files\Veeam\Backup and Replication\ 。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/8k8L2fk1eA.png?imageslim" alt="mark"></p>
<h2 id="第5步。安装缺少的软件"><a href="#第5步。安装缺少的软件" class="headerlink" title="第5步。安装缺少的软件"></a>第5步。安装缺少的软件</h2><p>在向导的“ 系统配置检查” 步骤中，安装向导将检查机器上是否安装了所有必备软件。如果缺少所需的软件组件，安装向导将提供您安装它们。</p>
<p>您可以自动或手动安装缺失的组件。</p>
<ul>
<li>要自动安装缺失的组件，请单击安装。安装向导不会中断安装过程并在当前工作会话期间安装缺失的组件。</li>
<li>手动安装缺失的组件：</li>
</ul>
<ol>
<li>单击取消并退出设置向导。</li>
<li>在机器上手动安装并启用必要的组件。</li>
<li>再次启动设置向导，进入向导的“ 系统配置检查” 步骤，然后单击“ 重新运行” 重复验证。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/mj1FeEfBGA.png?imageslim" alt="mark"></p>
<h2 id="第6步。指定安装设置"><a href="#第6步。指定安装设置" class="headerlink" title="第6步。指定安装设置"></a>第6步。指定安装设置</h2><p>在向导的默认配置步骤中，您可以选择使用默认安装设置来安装Veeam Backup＆Replication 或指定自定义安装设置。</p>
<p>默认情况下，安装向导会使用以下设置安装Veeam Backup＆Replication ：</p>
<ul>
<li>安装文件夹：C:\Program Files\Veeam\Backup and Replication 。</li>
<li>vPower缓存文件夹：C:\ProgramData\Veeam\Backup\NfsDatastore 。vPower缓存文件夹存储用于即时虚拟机恢复的写入缓存。确保您有至少10 GB的可用磁盘空间来存储写入缓存。</li>
<li>来宾目录文件夹：C:\VBRC 目录。来宾目录文件夹存储VM来宾操作系统文件的索引数据。索引数据对于浏览和搜索备份中的VM guest虚拟机操作系统文件并执行1次单击还原是必需的。</li>
<li>目录服务端口：9393 。目录服务端口由Veeam客服目录服务用于将目录数据从备份服务器复制到Veeam Backup企业管理器。</li>
<li>服务帐号：本地系统。服务帐户是Veeam Backup Service运行的帐户。</li>
<li>服务端口：9392 。Veeam Backup Enterprise Manager 使用服务端口从备份服务器收集数据。除此之外，Veeam Backup＆Replication 控制台还使用此服务端口连接到备份服务器。</li>
<li>安全连接端口：9401 。安装服务器使用安全连接端口与备份服务器进行通信。</li>
<li>SQL Server：LOCALHOST\VEEAMSQL2012 。在安装过程中，Veeam Backup＆Replication 将在备份服务器上本地安装一个新的Microsoft SQL Server 2012 SP3 Express Edition实例。</li>
<li>数据库名称：VeeamBackup 。Veeam Backup＆Replication 在本地安装的Microsoft SQL Server 2012 SP3 Express Edition实例上部署Veeam Backup＆Replication 配置数据库。</li>
</ul>
<p>要使用默认安装设置：</p>
<ol>
<li>离开让我指定不同的设置复选框未选中。</li>
<li>点击安装。安装过程将开始。</li>
</ol>
<p>要使用自定义安装设置，请选中让我指定不同的设置复选框。安装向导将包含额外的步骤，可让您配置安装设置。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/k62LdEAcdj.png?imageslim" alt="mark"></p>
<h2 id="第7步。指定服务帐户设置"><a href="#第7步。指定服务帐户设置" class="headerlink" title="第7步。指定服务帐户设置"></a>第7步。指定服务帐户设置</h2><p>如果您已选择手动配置安装设置，则向导的“ 服务帐户” 步骤可用。</p>
<p>您可以选择要运行Veeam Backup Service的帐户：</p>
<ul>
<li>本地系统帐户（建议，默认使用）</li>
<li>另一个用户帐户</li>
</ul>
<p>该帐户的用户名称必须以DOMAIN\USERNAME 格式指定。</p>
<p>用户帐户必须具有以下权限和权限：</p>
<ul>
<li>该帐户必须是安装了Veeam Backup＆Replication 的计算机上的Administrators 组的成员。</li>
<li>该帐户必须具有配置数据库的db_owner 权限。</li>
</ul>
<p>Veeam Backup＆Replication 自动授予作为服务登录权限到指定的用户帐户。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/2Ai4dL7LJD.png?imageslim" alt="mark"></p>
<h2 id="第8步。选择Microsoft-SQL-Server"><a href="#第8步。选择Microsoft-SQL-Server" class="headerlink" title="第8步。选择Microsoft SQL Server"></a>第8步。选择Microsoft SQL Server</h2><p>如果您已选择手动配置安装设置，则该向导的SQL Server实例步骤可用。</p>
<p>您可以选择要在其上部署配置数据库的Microsoft SQL Server，然后选择身份验证模式。</p>
<ol>
<li>选择一个Microsoft SQL Server：</li>
</ol>
<ul>
<li>如果未在本地或远程安装Microsoft SQL Server，请选择安装SQL Server的新实例选项。该安装程序将在备份服务器上本地安装Microsoft SQL Server 2012 SP3 Express Edition。</li>
<li>如果已经在本地或远程安装了Microsoft SQL Server，请选择“ 使用SQL Server的现有实例” 选项。以HOSTNAME\INSTANCE 格式输入实例名称。在数据库字段中，为Veeam Backup＆Replication 配置数据库指定一个名称</li>
</ul>
<ol>
<li>选择一个身份验证模式以连接到Microsoft SQL Server实例：Microsoft Windows身份验证或SQL服务器身份验证。如果您选择SQL Server身份验证，请输入Microsoft SQL Server帐户的凭据。</li>
</ol>
<p>如果配置数据库已经存在于Microsoft SQL Server上（例如，它是由以前安装的Veeam Backup＆Replication创建的），则安装向导将通知它。要连接到检测到的数据库，请单击是。如有必要，Veeam Backup＆Replication 将自动将数据库升级到最新版本。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/C77F41Fb20.png?imageslim" alt="mark"></p>
<h2 id="第9步-指定服务端口"><a href="#第9步-指定服务端口" class="headerlink" title="第9步.指定服务端口"></a>第9步.指定服务端口</h2><p>如果您已选择手动配置安装设置，则向导的端口配置步骤可用。</p>
<p>您可以自定义将用于备份基础架构组件之间通信的端口号值：</p>
<ul>
<li>目录服务端口。目录服务端口由Veeam客服目录服务用于将目录数据从备份服务器复制到Veeam Backup企业管理器。默认情况下，使用端口9393。</li>
<li>Veeam备份服务端口。Veeam Backup Enterprise Manager 使用服务端口从备份服务器收集数据。除此之外，Veeam Backup＆Replication 控制台还使用此服务端口连接到备份服务器。默认情况下，使用端口9392。</li>
<li>安全连接端口。安装服务器使用安全连接端口与备份服务器进行通信。默认情况下，使用端口9401。</li>
</ul>
<p><img src="https://blog-image.nos-eastchina1.126.net/8D5FH2aj64.png?imageslim" alt="mark"></p>
<h2 id="第10步-指定数据位置"><a href="#第10步-指定数据位置" class="headerlink" title="第10步.指定数据位置"></a>第10步.指定数据位置</h2><p>如果您已选择手动配置安装设置，则向导的“ 数据位置” 步骤可用。</p>
<p>您可以指定必须存储Instant VM Recovery写入缓存和索引数据的位置。</p>
<ol>
<li>在vPower NFS 部分中，指定必须存储Instant VM Recovery写入缓存的文件夹的路径。默认文件夹是C:\ ProgramData\Veeam\Backup\NfsDatastore 。确保您有至少10 GB的可用磁盘空间来存储写入缓存。</li>
<li>在Guest文件系统目录部分中，指定要存储索引文件的文件夹的路径。默认情况下，安装向导将使用最大可用空间在卷上创建VBRCatalog 文件夹，例如：C:\VBRCatalog 。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/K0E3GhdI7c.png?imageslim" alt="mark"></p>
<h2 id="第11步。开始安装"><a href="#第11步。开始安装" class="headerlink" title="第11步。开始安装"></a>第11步。开始安装</h2><p>如果已选择手动配置安装设置，则向导的“ 准备安装” 步骤可用。</p>
<p>您可以查看安装设置并开始安装过程。</p>
<ol>
<li>如果您希望Veeam Backup＆Replication 定期检查并通知您有关产品更新的信息，请选择安装产品后定期检查更新并定期复选框。</li>
<li>点击安装开始安装。</li>
<li>等待安装过程完成，然后单击完成退出安装向导。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/Fa2iBdihgC.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>Veeam</category>
      </categories>
      <tags>
        <tag>Backup</tag>
      </tags>
  </entry>
  <entry>
    <title>穷举</title>
    <url>/2018/06/01/Program-design/Exhaustion/</url>
    <content><![CDATA[<h1 id="穷举的基本思想"><a href="#穷举的基本思想" class="headerlink" title="穷举的基本思想"></a>穷举的基本思想</h1><ul>
<li>穷举法（Exhaustion），也成枚举法（Enumeration）<ul>
<li>列举所有可能，逐一试探</li>
</ul>
</li>
<li>基本思想<ul>
<li>根据问题的==部分==已知条件预估解的范围</li>
<li>在此范围内对所有可能的情况进行逐一验证<ul>
<li>若某个情况符合题目的全部条件，则该情况为本问题的一个解</li>
<li>若全部情况的验证结果均不符合题目的全部条件，则说明该题无解</li>
</ul>
</li>
<li>直到找到满足已知条件的解为止</li>
</ul>
</li>
</ul>
<h1 id="穷举法求解问题的两个基本要素"><a href="#穷举法求解问题的两个基本要素" class="headerlink" title="穷举法求解问题的两个基本要素"></a>穷举法求解问题的两个基本要素</h1><ul>
<li><p>影响算法的时间复杂度</p>
<ul>
<li>影响算法的时间复杂度</li>
<li>循环结构实现</li>
</ul>
</li>
<li><p>确定判断条件</p>
<ul>
<li>复合什么条件才能成为问题的答案</li>
<li>分支结构实现<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h1 id="穷举法的实际应用"><a href="#穷举法的实际应用" class="headerlink" title="穷举法的实际应用"></a>穷举法的实际应用</h1><ul>
<li>常用语密码破译<ul>
<li>将所有可能的密码逐个尝试，知道找出真正的密码为止</li>
</ul>
</li>
<li>也称蛮力法（Brute Force），或暴力搜索法<ul>
<li>理论上利用这种方法可破解任何一种密码，问题在于如何缩短试误时间</li>
</ul>
</li>
</ul>
<h1 id="穷举法的特点"><a href="#穷举法的特点" class="headerlink" title="穷举法的特点"></a>穷举法的特点</h1><ul>
<li>优点<ul>
<li>优点：算法简单，逻辑清晰，易于理解，程序易于实现</li>
</ul>
</li>
<li>缺点<ul>
<li>预算量较大</li>
<li>只适合于“有几种组合”、“是否存在”、求解不定方程等类型的问题求解</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Exhaustion</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 安装</title>
    <url>/2018/05/19/Jenkins/Jenkins-install/</url>
    <content><![CDATA[<p>Jenkins通常使用内置的<code>java servlet</code>容器/应用服务器（<code>Jetty</code>）在其自己的进程中作为独立应用程序运行。<br><a id="more"></a></p>
<h1 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h1><div class="table-container">
<table>
<thead>
<tr>
<th>规模</th>
<th>RAM</th>
<th>Drive Space</th>
</tr>
</thead>
<tbody>
<tr>
<td>最低</td>
<td>256MB</td>
<td>1GB（如果作为Dcoker容器运行，建议最小10GB）</td>
</tr>
<tr>
<td>小团队</td>
<td>1GB+</td>
<td>50GB+</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Docker大法好</p>
</blockquote>
<h1 id="安装平台"><a href="#安装平台" class="headerlink" title="安装平台"></a>安装平台</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h2 id="Linux-Mac"><a href="#Linux-Mac" class="headerlink" title="Linux/Mac"></a>Linux/Mac</h2><p>首先安装Docker，这里不介绍安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -u root \</span><br><span class="line">  --rm \</span><br><span class="line">  -d \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -p 50000:50000 \</span><br><span class="line">  -v jenkins-data:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<p>这里的<code>-v jenkins-data:/var/jenkins_home</code> 我解释一下，<code>-v</code>参数是将容器中的<code>/var/jenkins_home</code>映射到名字为<code>jenkins-data</code>的 <em>docker volume</em>，如果此docker volume不存在会自动创建，可以将<code>jenkins-data</code>替换为宿主机本地目录，如<code>$HOME/jenkins</code>。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>同样，安装Docker，然后参数基本是一样的，docker的相关参数请参考docker文档，</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run ^</span><br><span class="line">  <span class="literal">-u</span> root ^</span><br><span class="line">  -<span class="literal">-rm</span> ^</span><br><span class="line">  <span class="literal">-d</span> ^</span><br><span class="line">  <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">8080</span> ^</span><br><span class="line">  <span class="literal">-p</span> <span class="number">50000</span>:<span class="number">50000</span> ^</span><br><span class="line">  <span class="literal">-v</span> jenkins<span class="literal">-data</span>:/var/jenkins_home ^</span><br><span class="line">  <span class="literal">-v</span> /var/run/docker.sock:/var/run/docker.sock ^</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure>
<h1 id="访问Jenkins"><a href="#访问Jenkins" class="headerlink" title="访问Jenkins"></a>访问Jenkins</h1><p>容器运行起来之后，就可以通过映射到宿主机的端口来访问了，如果你想进入jenkins容器内部，比如查看个初始密码，可以运行如下命令进入jenkins容器的shell：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps <span class="comment"># 找到jenkins容器CONTAINER ID,</span></span><br><span class="line">docker <span class="built_in">exec</span> -it JENKINS_CONTAINER_ID /bin/bash</span><br></pre></td></tr></table></figure>
<p>当然，也可以通过如下命令查看日志获得初始密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs JENKINS_CONTAINER_ID</span><br></pre></td></tr></table></figure>
<p>浏览器访问 宿主机IP+PORT（这里端口是8080）.</p>
<h2 id="获取Administrator密码"><a href="#获取Administrator密码" class="headerlink" title="　获取Administrator密码"></a>　获取Administrator密码</h2><ul>
<li>进入容器，然后查看文件内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it JENKINS_CONTAINER_ID /bin/bash </span><br><span class="line">cat /var/jenkins_home/secrets/AdminPassword</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>docker logs</code>查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs JENKINS_CONTAINER_ID</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch指南</title>
    <url>/2018/05/18/Linux/ES/filebeat/</url>
    <content><![CDATA[<h1 id="Elasticsearch是什么"><a href="#Elasticsearch是什么" class="headerlink" title="Elasticsearch是什么"></a>Elasticsearch是什么</h1><p>Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据。它通常用作支持具有复杂搜索功能和需求的应用程序的底层引擎/技术。</p>
<a id="more"></a>
<h1 id="Elasticsearch诞生的故事"><a href="#Elasticsearch诞生的故事" class="headerlink" title="Elasticsearch诞生的故事"></a>Elasticsearch诞生的故事</h1><p>大佬的世界都是传奇的，其实这个搜索引擎的诞生是一个叫Shay Banon的待业工程师跟随他的新婚妻子来到伦敦，</p>
<p>他妻子想成为一名厨师，这位大佬想为妻子开发一个方便搜索菜谱的应用；他本想直接使用Lucene来构建搜索引擎，但是发现会议很多坑以及重复性工作，所以他就开始造轮子，记录Lucene的技术上进行不断的抽象让搜索引擎变得更容易，经过一段时间，Shay Banon的第一个开源作品诞生了，名字叫<em>“Compass”</em>；后来Shay Banon的工作处于一个高性能的分布式开发环境中， 他渐渐发现需要一个易用、高性能、实时的分布式搜索服务，然后开始重写<em>“Compass”</em>；把它打造一个独立的服务，改名为<em>“Elasticsearch”</em>。</p>
<p>后来<em>”Elasticsearch“</em>在github上非常受关注，再后来Shay Banon成立了Elasticsearch的公司，商业话的方式也是以技术支持的方式，但是，Elasticsearch承诺，永远都将是开源并且免费的。</p>
<p><strong>ps：菜谱没做出来，却做出来了github 31000+的开源搜索项目。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>核心概念</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Near Realtime (近时性)</td>
<td>接近实时性，轻微延迟，1s</td>
</tr>
<tr>
<td>Cluster(集群)</td>
<td>一个或多个Node组成的集合</td>
</tr>
<tr>
<td>Node(节点)</td>
<td>组成集群的独立Elasticsearch节点</td>
</tr>
<tr>
<td>Index(索引)</td>
<td>具有相似特征的文档集合</td>
</tr>
<tr>
<td>Document(文档)</td>
<td>可被索引的基本信息单位</td>
</tr>
<tr>
<td>Shards &amp; Replicas(分片&amp;复制)</td>
<td>数据分割存放，提高性能；复制分片存放多份，提供高可用</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>elastic</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>Log</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins Pipeline</title>
    <url>/2018/05/17/Jenkins/Jenkins%20pipeline/</url>
    <content><![CDATA[<h1 id="Jenkins-Pipeline"><a href="#Jenkins-Pipeline" class="headerlink" title="Jenkins Pipeline"></a>Jenkins Pipeline</h1><p>Jenkins Pipeline是一套插件，支持在Jenkins中实现和集成<em>持续交付管道</em>。</p>
<p>一个持续交付（CD）管道是将软件从版本控制直接传递给用户和客户的过程的自动化表达。对软件的每次更改（在源代码管理中提交）都会在发布的过程中经历一个复杂的过程。此过程涉及以可靠且可重复的方式构建软件，以及通过多个测试和部署阶段推进构建的软件。</p>
<p>Pipline提供了一组可拓展的工具，用于通过管道特定域语言（DSL）语法“作为代码”对简单到复杂的传输管道进行建模。</p>
<p>Jenkins Pipeline 的定义被写入一个文本文件（Jenkinsfile），该文件可以提交给项目的源代码控制库。这是“Pipeline as code”的基础；将CD管道视为应用程序的一部分，以便像任何其他代码一样进行版本控制和审查。</p>
<p>创建<code>jenkinsfile</code>并将其提交给源代码管理提供了许多直接的好处：</p>
<ul>
<li>自动为所有分支和拉取和请求创建Pipeline构建过程。</li>
<li>Pipeline上的代码审查/迭代（以及剩余的源代码）。</li>
<li>Pipeline的审计跟踪。</li>
<li>Pipeline的单一数据来源，可由项目的多个成员查看和编辑。</li>
</ul>
<p>虽然在Web UI或<code>Jenkinsfile</code>中定义Pipeline的语法是相同的，但通常认为最佳做法是在<code>Jenkinsfile</code>中定义Pipeline并检查其中的源码管理。<br><a id="more"></a></p>
<h1 id="声明式与校本化Pipeline语法"><a href="#声明式与校本化Pipeline语法" class="headerlink" title="声明式与校本化Pipeline语法"></a>声明式与校本化Pipeline语法</h1><p>一个<code>Jenkinsfile</code>可以使用两种语法编写 - Declarative和Scripted。</p>
<p>生命性和脚本化Pipeline的构造从根本上不同，生命性管道是Jenkins管道的最新特性，它具有：</p>
<ul>
<li>提供比Scripted Pipeline语法更丰富的语法功能，以及</li>
<li>旨在使写作和阅读Pipeline代码更容易。</li>
</ul>
<p>然而，写入<code>Jenkinsfile</code>文件的许多单独的语法组件（步骤）对应Declarative和ScriptedPipeline都是通用的。在下面的管道概念和管道语法概述中，详细了解这两种语法的不同之处。</p>
<h1 id="Why-Pipeline？"><a href="#Why-Pipeline？" class="headerlink" title="Why Pipeline？"></a>Why Pipeline？</h1><p>从根本上说，Jenkins是一个支持多种自动化模式的自动化引擎。Pipeline为Jenkins添加了一套功能强大的自动化工具，支持从简单的持续集成到全面的CD Pipeline的用例。通过对一系列相关任务建模，用户可以利用Pipeline的许多功能：</p>
<ul>
<li>代码：管理在代码中实现，通常检查到源代码控制，使团队能够编辑，审查和迭代其交付Pipeline。</li>
<li>持久： Pipeline可以在Jenkins master 的计划内核计划外重启中存活。</li>
<li>暂停：在继续Pipeline运行之前，Pipeline可以选择停止等待输入或批准。</li>
<li>多功能：Pipeline支持复杂的实际CD要求，包括并行分支/连接，循环和执行工作的能力。</li>
<li>可拓展：Pipeline插件支持其DSL自定义拓展和多个与其他插件集成的选项。</li>
</ul>
<p>虽然Jenkins总是允许将自由式工作链接在一起的基本形式来执行顺序任务，Pipeline使这个概念成为Jenkins的一等公民。</p>
<p>基于Jenkins和兴的可拓展性，Pipeline也可以通过<em>Pipeline shared libraries</em>和插件开发人员进行拓展。</p>
<p>下面的刘承宇是在Jenkins管道中轻松建模的一个CD场景的示例：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/realworld-pipeline-flow.png" alt="CD "></p>
<h1 id="Pipeline概念"><a href="#Pipeline概念" class="headerlink" title="Pipeline概念"></a>Pipeline概念</h1><blockquote>
<p>以下概念是Jenkins Pipeline的关键方面，它与Pipeline语法密切相关</p>
</blockquote>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Pipeline是CD Pipeline的用户定义模型。Pipeline的代码定义了整个构建过程，通常包括构建应用程序，测试然后交付应用程序的阶段。</p>
<p><em>此外，<code>pipeline</code>block 是Declarative Pipeline语法的关键部分。</em></p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node是一个机器，是Jenkins环境的一部分，能够执行Pipeline。</p>
<p><em>此外，<code>node</code> block是Scripted Pipeline语法的关键部分。</em></p>
<h2 id="Stage"><a href="#Stage" class="headerlink" title="Stage"></a>Stage</h2><p><code>stage</code> block定义了通过整个Pipeline执行的概念上不同的任务子集（例如“构建”、“测试”和“部署”阶段），许多插件使用它来可视化或呈现管道状态/进度。</p>
<h2 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h2><p>一项任务。从根本上说，一个步骤告诉Jenkins在特定时间点做什么（或者在过程中“步骤”）。例如，要执行shell命令<code>make</code>用<code>sh</code>,setp: sh‘ make’。当插件拓展Pipeline DSL时，通常意味着插件已经实现了一个新步骤。</p>
<h1 id="Pipeline-语法概述"><a href="#Pipeline-语法概述" class="headerlink" title="Pipeline 语法概述"></a>Pipeline 语法概述</h1><p>一下Pipeline代码框架说明了Declarative Pipeline语法和Scripted Pipeline语法之间的 区别。</p>
<h2 id="声明式Pipeline基础"><a href="#声明式Pipeline基础" class="headerlink" title="声明式Pipeline基础"></a>声明式Pipeline基础</h2><p>在Declarative Pipeline语法中，<code>pipeline</code>block定义了整个Pipeline中完成的所有工作。</p>
<p>Jenkinsfile (Declarative Pipeline)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>) &#123; </span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123; </span><br><span class="line">            steps &#123;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>agent any</code></td>
<td>在任何可用的代理上执行此Pipeline或其任何阶段</td>
</tr>
<tr>
<td><code>stage(&#39;Bulid&#39;)</code></td>
<td>定义构建阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行阶段相关的一些步骤</td>
</tr>
<tr>
<td><code>stage(&#39;Test&#39;)</code></td>
<td>定义测试阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行测试阶段相关的一些步骤</td>
</tr>
<tr>
<td><code>stage(&#39;Deploy)</code></td>
<td>定义部署阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行部署阶段相关的 一些步骤</td>
</tr>
</tbody>
</table>
</div>
<h2 id="脚本式Pipeline基础"><a href="#脚本式Pipeline基础" class="headerlink" title="　脚本式Pipeline基础"></a>　脚本式Pipeline基础</h2><p>在Scripted Pipeline语法中，一个或多个<code>node</code>在整个Pipeline中执行核心工作，虽然这不是Scripted Pipeline语法的强制要求，但将Pipeline的工作限制在<code>node</code>块内部有两个作用：</p>
<ol>
<li>通过向Jenkins队列添加项目来计划要运行的块中包含的步骤。只要执行程序在节点上空闲，步骤就会运行。</li>
<li>创建工作空间（特定于该特定Pipeline的目录），可以对从源控件检出的文件执行工作。</li>
</ol>
<p>Jenkinsfile (Scripted Pipeline)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">node &#123;  </span><br><span class="line">    stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy'</span>) &#123; </span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node</code></td>
<td>在任何可用的代理上执行此Pipeline或其任何阶段</td>
</tr>
<tr>
<td><code>stage(&#39;Build&#39;)</code></td>
<td>定义构建阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行阶段相关的一些步骤</td>
</tr>
<tr>
<td><code>stage(&#39;Test&#39;)</code></td>
<td>定义测试阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行测试阶段相关的一些步骤</td>
</tr>
<tr>
<td><code>stage(&#39;Deploy&#39;)</code></td>
<td>定义部署阶段</td>
</tr>
<tr>
<td><code>//</code></td>
<td>执行部署阶段相关的 一些步骤</td>
</tr>
</tbody>
</table>
</div>
<h1 id="管道示例"><a href="#管道示例" class="headerlink" title="管道示例"></a>管道示例</h1><p>下面是<code>Jenkinsfile</code>使用Declarative Pipeline 语法和Scripted Pipeline的示例：</p>
<p>Jenkinsfile (Declarative Pipeline)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123; </span><br><span class="line">    agent any </span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">            steps &#123; </span><br><span class="line">                sh <span class="string">'make'</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Test'</span>)&#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'make check'</span></span><br><span class="line">                junit <span class="string">'reports/**/*.xml'</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                sh <span class="string">'make publish'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Jenkinsfile (Scripted Pipeline)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">node &#123; </span><br><span class="line">    stage(<span class="string">'Build'</span>) &#123; </span><br><span class="line">        sh <span class="string">'make'</span> </span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Test'</span>) &#123;</span><br><span class="line">        sh <span class="string">'make check'</span></span><br><span class="line">        junit <span class="string">'reports/**/*.xml'</span> </span><br><span class="line">    &#125;</span><br><span class="line">    stage(<span class="string">'Deploy'</span>) &#123;</span><br><span class="line">        sh <span class="string">'make publish'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>pipeline</code></td>
<td style="text-align:left">Declarative Pipeline特定语法，定义一个块，包含用于执行整个管道的内容和指令</td>
</tr>
<tr>
<td style="text-align:left"><code>agent</code></td>
<td style="text-align:left">Declarative Pipeline特定语法，指定Jenkins为整个Pipeline分配执行程序和工作空间</td>
</tr>
<tr>
<td style="text-align:left"><code>stage</code></td>
<td style="text-align:left">描述此Pipeline的一个阶段</td>
</tr>
<tr>
<td style="text-align:left"><code>steps</code></td>
<td style="text-align:left">Declarative Pipeline特定语法，描述了stage</td>
</tr>
<tr>
<td style="text-align:left"><code>sh</code></td>
<td style="text-align:left">步骤，执行给定的shell命令</td>
</tr>
<tr>
<td style="text-align:left"><code>junit</code></td>
<td style="text-align:left">另一个Pipelline步骤，用于聚合测试报告</td>
</tr>
<tr>
<td style="text-align:left"><code>node</code></td>
<td style="text-align:left">Scripted Pipeline特定语法，指定了Jenkins在任何可用的代理/节点上执行此Pipeline</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins credentials</title>
    <url>/2018/05/16/Jenkins/Jenkins%20credentials/</url>
    <content><![CDATA[<p>许多第三方站点和应用可以与Jenkins交互，应用的管理员可以在应用中配置凭据以供Jenkins使用，通常是通过这些凭据应用访问控制。Jenkins管理员在Jenkins中添加/配置这些凭据，管道项目就可以使用凭据与这些第三方应用程序进行交互。</p>
<blockquote>
<p>注意：Jenkins凭据功能由Credentials Binding插件提供。</p>
</blockquote>
<p>可以使用存储在Jenkins中的凭据：</p>
<ul>
<li>任何适用于整个Jenkins的地方（全局证书），</li>
<li>通过特定的Pipeline项目，</li>
<li>由特定的Jenkins用户。</li>
</ul>
<p>Jenkins可以存储以下类型的凭据：</p>
<ul>
<li><strong>Secret text</strong> - 诸如API令牌之类的令牌（例如GitHub个人访问令牌），</li>
<li><strong>用户名和密码</strong> - 可以作为单独的组件处理，也可以作为格式的冒号分隔字符串<a href="https://jenkins.io/doc/book/pipeline/jenkinsfile#handling-credentials" target="_blank" rel="noopener">处理</a><code>username:password</code>（在<a href="https://jenkins.io/doc/book/pipeline/jenkinsfile#handling-credentials" target="_blank" rel="noopener">处理凭据中</a>详细了解此信息 ），</li>
<li><strong>Secret file</strong>  - 本质上是文件中的秘密内容，</li>
<li><strong>带有私钥的SSH用户名</strong> - <a href="http://www.snailbook.com/protocols.html" target="_blank" rel="noopener">SSH公钥/私钥对</a>，</li>
<li><strong>证书</strong> - <a href="https://tools.ietf.org/html/rfc7292" target="_blank" rel="noopener">PKCS＃12证书文件</a>和可选密码，或</li>
<li><strong>Docker主机证书身份验证</strong>凭据。<a id="more"></a>
<h1 id="凭据安全"><a href="#凭据安全" class="headerlink" title="凭据安全"></a>凭据安全</h1></li>
</ul>
<p>为了最大限度地提高安全性，Jenkins中配置的凭据以加密形式存储在主Jenkins实例上，并且仅通过其凭据ID在Pipeline项目中处理。</p>
<h1 id="配置凭据"><a href="#配置凭据" class="headerlink" title="配置凭据"></a>配置凭据</h1><p>如果是默认设置，将获得对Jenkins的全部控制权限，如果授权策略为其他，则需要确保Jenkins拥有凭据的创建权限。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/Jenkins-Authorization.jpg" alt="Jenkins-Authorization"></p>
<h1 id="添加新的全局凭据"><a href="#添加新的全局凭据" class="headerlink" title="添加新的全局凭据"></a>添加新的全局凭据</h1><p>要向Jenkins实例添加新的全局凭据：</p>
<ol>
<li>如果需要，请确保您已登录Jenkins（作为具有 <strong>凭据&gt;创建</strong>权限的用户）。</li>
<li>在Jenkins主页（即Jenkins经典UI的仪表板）中，单击左侧的<strong>凭据&gt;系统</strong>。</li>
<li>在“ <strong>系统”下</strong>，单击“ <strong>全局凭据（不受限制）”</strong>链接以访问此默认域。</li>
<li>单击左侧的“ <strong>添加凭据</strong> ”。<br><strong>注意：</strong>如果此默认域中没有凭据，您还可以单击“ <strong>添加一些凭据”</strong>链接（与单击“ <strong>添加凭据”</strong>链接相同）。</li>
<li>在<strong>Kind</strong>字段中，选择 要添加<a href="https://jenkins.io/doc/book/using/using-credentials/#types-of-credentials" target="_blank" rel="noopener">的凭据类型</a>。</li>
<li>在<strong>Scope</strong>字段中，选择以下任一项：<ul>
<li><strong>全局</strong> - 如果要添加的凭证是/是否为管道项目/项目。选择此选项会将crendentia/s的范围应用于Pipeline项目/项“对象”及其所有后代对象。</li>
<li><strong>系统</strong> - 如果要添加的凭据是/ Jenkins实例本身与系统管理功能交互，例如电子邮件身份验证，代理连接等。选择此选项将crendential/s的范围应用于单个对象只要。</li>
</ul>
</li>
<li>将凭据本身添加到所选凭据类型的相应字段中：<ul>
<li><strong>秘密文本</strong> - 复制秘密文本并将其粘贴到“ <strong>密码”</strong>字段中。</li>
<li><strong>用户名和密码</strong> - 在各自的字段中指定凭证的<strong>用户名</strong>和<strong>密码</strong>。</li>
<li><strong>秘密文件</strong> -单击<strong>选择文件</strong>按钮旁边的<strong>文件</strong>字段选择秘密文件上传到詹金斯。</li>
<li><strong>具有私钥的SSH用户名</strong> - 将凭据<strong>用户名</strong>， <strong>私钥</strong>和可选<strong>密码短语指定</strong>到其各自的字段中。<br><strong>注意：**</strong>直接<strong>选择</strong>Enter<strong>可以复制私钥的文本并将其粘贴到生成的</strong>密钥**文本框中。</li>
<li><strong>证书</strong> - 指定<strong>证书</strong>和可选<strong>密码</strong>。选择上 <strong>载PKCS＃12证书</strong>允许您通过生成的上<strong>载证书</strong>按钮将证书上载为文件。</li>
<li><strong>Docker主机证书身份验证</strong> - 将相应的详细信息复制并粘贴到<strong>客户端密钥</strong>，<strong>客户端证书</strong>和<strong>服务器CA证书</strong>字段中。</li>
</ul>
</li>
<li>在<strong>ID</strong>字段中，指定有意义的凭据ID值 - 例如， <code>jenkins-user-for-xyz-artifact-repository</code>。您可以使用大写或小写字母作为凭据ID，以及任何有效的分隔符。但是，为了Jenkins实例上的所有用户的利益，最好使用单一且一致的约定来指定凭据ID。<br><strong>注意：</strong>此字段是可选的。如果未指定其值，Jenkins将为凭据ID分配全局唯一ID（GUID）值。请记住，一旦设置了凭证ID，就无法再更改凭证ID。</li>
<li>为凭证指定可选<strong>描述</strong>。</li>
<li>单击“ <strong>确定”</strong>以保存凭据。</li>
</ol>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化程序设计</title>
    <url>/2018/05/01/Program-design/Modular-programming/</url>
    <content><![CDATA[<h1 id="模块化程序设计（Modular-Programming）"><a href="#模块化程序设计（Modular-Programming）" class="headerlink" title="模块化程序设计（Modular Programming）"></a>模块化程序设计（Modular Programming）</h1><p><em>将一个大规模程序自顶向下划分为一些较小的相对独立又相互关联的模块</em></p>
<ul>
<li>程序设计中最重要的思想之一</li>
<li>几乎所有的商用程序都采用了模块化程序设计的理念</li>
<li>面向对象编程在某种程度上也是对模块化程序思想的一种延伸</li>
</ul>
<p><strong>模块分解的目标</strong></p>
<ul>
<li>使模块内部的实现细节对外不可见，实现信息隐藏（Information Hiding）</li>
<li>限制模块的复杂性和规模</li>
<li>保证模块的相对独立性（Module Independence）和正确性<a id="more"></a>
<h1 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h1></li>
</ul>
<p><strong>信息隐藏</strong></p>
<ul>
<li>除了必要的信息之外，使得暴露在外面的信息尽量减小到最小限度</li>
<li>模块内部的数据和过程，对无需了解它的外部模块隐藏起来， 外部只知道What to do， 而不知道How to do</li>
<li>只要模块接口不变，修改模块内部的具体实现细节不影响对模块的使用</li>
</ul>
<p><strong>程序设计中需要处理的两类要素</strong></p>
<ul>
<li>过程，数据</li>
</ul>
<p><strong>如何实现信息隐藏</strong></p>
<ul>
<li>过程抽象， 数据抽象</li>
</ul>
<p><strong>模块分解的本质</strong></p>
<ul>
<li>实现不同层次的过程抽象和数据抽象</li>
</ul>
<h1 id="过程抽象"><a href="#过程抽象" class="headerlink" title="过程抽象"></a>过程抽象</h1><p><strong>过程抽象</strong></p>
<ul>
<li>将一个确定的完成子任务的操作序列看成一个黑箱</li>
<li>过程抽象的结果是函数————功能抽象</li>
<li>使程序员可以在不同的抽象层面上分析问题</li>
<li>面向过程语言实现模块化程序设计的基本手段，</li>
<li>通过将过程抽象为函数，实现信息隐藏和模块的可重用性</li>
</ul>
<h1 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h1><p><strong>数据抽象</strong></p>
<ul>
<li>面向对象语言实现模块化程序设计的基本手段</li>
<li>数据抽象的结果是数据类型</li>
</ul>
<p><strong>让数据类型的表示细节对外不可见</strong></p>
<ul>
<li>抽象数据类型（Abstract Data Type ADT）<ul>
<li>可以实现更好的信息隐藏效果</li>
</ul>
</li>
</ul>
<p><strong>抽象数据类型</strong></p>
<p><em>根据施加于数据智商的操作定义类型， 限定只能由这些操作来修改和观察数据值，强调把数据和操作封装起来，结合为一个不可分割的独立整体，不再单纯是一组数据的集合，二十数据及作用在骑上的操作的集合</em></p>
<p>==C++语言中的类（class） 通过封装数据和操作数据的方法并限制外部程序的访问来实现信息隐藏==</p>
<h1 id="模块分解"><a href="#模块分解" class="headerlink" title="模块分解"></a>模块分解</h1><p><strong>模块分解的基本思想</strong></p>
<ul>
<li>将一个复杂的任务划分为若干个较为简单的子任务</li>
<li>若子任务仍然比较复杂，则继续将子任务分解</li>
<li>直到分解成为一些足够简单，易于解决的子任务为止</li>
<li>分治思想的一种具体实现</li>
</ul>
<p><strong>为什么要分解</strong></p>
<ul>
<li>管理学的观点认为工作必须分工，各司其职。</li>
<li>分解是人们处理复杂问题的一种常见方法</li>
</ul>
<h1 id="模块的独立性"><a href="#模块的独立性" class="headerlink" title="模块的独立性"></a>模块的独立性</h1><p><strong>内聚度（Cohesion）</strong></p>
<p>也称聚合度，模块内成员之间联系的紧密程度（聚合能力）的一种度量，模块内各成员之间的联系越紧密，那模块独立性就越强。</p>
<p><strong>耦合度（Coupling）</strong></p>
<p>也称关联度，模块之间关联程度（即依赖关系，接口复杂性）的一种度量，模块间的联系越多，则模块的相对独立性越差。</p>
<h1 id="模块划分的准则"><a href="#模块划分的准则" class="headerlink" title="模块划分的准则"></a>模块划分的准则</h1><ul>
<li>按执行顺序划分<ul>
<li>使得每个模块对应一个处理步骤</li>
</ul>
</li>
<li>按问题模型划分<ul>
<li>让程序的模块化结构，正好与所要解决的问题的结构想对应</li>
</ul>
</li>
<li>按耦合-内聚类型划分<ul>
<li>尽量增大模块内成分的内聚度，减少模块间的耦合度</li>
</ul>
</li>
<li>按信息隐藏原则划分<ul>
<li>将模块内数据结构及其操作的实现细节隐藏起来，封装到一个模块里</li>
</ul>
</li>
</ul>
<p><strong>从抽象的角度来看， 模块划分主要有一下两种方法</strong></p>
<ul>
<li>基于过程抽象的划分方法<ul>
<li>按功能划分模块</li>
<li>面向过程的语言主要采用这种方法</li>
</ul>
</li>
<li>基于数据抽象的划分方法<ul>
<li>以数据为中心，将相关操作封装在模块里，就是基于信息隐藏的划分方法</li>
<li>面向对象的语言采用的主要方法</li>
</ul>
</li>
<li>基本原则<ul>
<li>实现高内聚、低耦合</li>
</ul>
</li>
</ul>
<h1 id="模块化设计的有点"><a href="#模块化设计的有点" class="headerlink" title="模块化设计的有点"></a>模块化设计的有点</h1><ul>
<li><p>提高程序的可读性，使程序结构更清晰</p>
<ul>
<li>在分析抽象层次较高的模块时，对较低层次的各个模块只需了解其做什么</li>
</ul>
</li>
<li><p>提高程序可维护性和可靠性</p>
<ul>
<li>程序的局部修改不会影响全局，使错误局部化，防止错误在模块间扩散</li>
</ul>
</li>
<li><p>缩短软件开发的周期，提高程序的开发效率</p>
<ul>
<li>模块分解后，开发人员可以各司其职，实现并发开发</li>
</ul>
</li>
<li><p>提高程序的测试效率和可验证性</p>
<ul>
<li>每个模块可以独立进行测试或验证</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Modular Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>rsyslog VS syslog-ng</title>
    <url>/2018/04/15/rsyslog%20VS%20syslog-ng/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>rsyslog</strong></th>
<th><strong>syslog-ng的</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入源</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>UNIX域套接字</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>UDP</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TCP</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="http://www.librelp.com/" target="_blank" rel="noopener">RELP</a></td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>RFC 3195 / BEEP</td>
<td>是（通过<a href="https://www.rsyslog.com/doc/im3195.html" target="_blank" rel="noopener">im3195</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>内核日志</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>文件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>将消息生成器标记为可选输入</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Windows事件日志</td>
<td>通过Windows事件记录软件，例如 <a href="http://www.eventreporter.com/" target="_blank" rel="noopener">EventReporter</a> 或<a href="http://www.mwagent.com/" target="_blank" rel="noopener">MonitorWare Agent</a> （都是商业软件，都是<a href="http://www.mwagent.com/" target="_blank" rel="noopener">基于rsyslog</a>开发的）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>网络（协议）支持</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持（普通）基于tcp的syslog</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持GSS-API</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够限制允许的网络发件人（系统日志ACL）</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在syslog / tcp连接上支持基于syslog-transport-tls的成帧</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>udp系统日志</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>syslog over RELP 真正可靠的消息传递（<a href="http://blog.gerhards.net/2008/05/why-you-cant-build-reliable-tcp.html" target="_blank" rel="noopener">为什么普通的tcp syslog不可靠？</a>）</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>（zlib）消息压缩</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持通过可靠的<a href="http://www.monitorware.com/Common/en/glossary/rfc3195.php" target="_blank" rel="noopener">RFC 3195</a>传送接收消息</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持<a href="https://www.rsyslog.com/doc/rsyslog_tls.html" target="_blank" rel="noopener">TLS / SSL保护的系统日志</a></td>
<td><a href="https://www.rsyslog.com/doc/rsyslog_tls.html" target="_blank" rel="noopener">本地</a>（从3.19.0）<a href="https://www.rsyslog.com/doc/rsyslog_stunnel.html" target="_blank" rel="noopener">通过stunnel</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持IETF新的系统日志协议草案</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持IETF新的syslog-transport-tls草案</td>
<td>是（自3.19.0开始 - 世界首次实施）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持IPv6</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>本地能够发送SNMP陷阱</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够在NAT环境和中继链中保留原始主机名</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>消息过滤</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤syslog设施和优先级</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤主机名</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>筛选应用程序</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤消息内容</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤发送IP地址</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够过滤上面未提到的任何其他消息字段（包括子字符串等）</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持复杂的过滤器，使用完整的布尔代数和/或/和运算符和括号</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持可重复使用的过滤器：指定一次过滤器并将其用于多个选择器行</td>
<td>没有</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持过滤器内的arbritrary复杂算术和字符串表达式</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在过滤器中使用正则表达式的能力</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持丢弃基于过滤器的消息</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够根据出现的顺序过滤出消息</td>
<td>是（从3.21.3开始）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>功能强大的BSD风格的主机名和程序名称块，以方便多主机支持</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>支持的数据库输出</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MySQL的</td>
<td><a href="https://www.rsyslog.com/doc/rsyslog_mysql.html" target="_blank" rel="noopener">yes</a> （原生ommysql，  <a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PostgreSQL的</td>
<td>yes（native ompgsql，  <a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>神谕</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SQLite的</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Microsoft SQL（Open TDS）</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sybase（Open TDS）</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>火鸟/ Interbase的</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>安格尔</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mSQL的</td>
<td>是（<a href="https://www.rsyslog.com/doc/omlibdbi.html" target="_blank" rel="noopener">omlibdbi</a>）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>企业功能</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持对消息进行按需磁盘后台处理</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够限制假脱机文件使用的磁盘空间</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>每个操作都可以使用自己独立的假脱机文件集</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同的假脱机文件集可以放在不同的磁盘上</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>仅在配置的时间范围内处理假脱机邮件的能力（例如，仅在非高峰时段处理邮件，在高峰时段仅处理邮件）</td>
<td><a href="http://wiki.rsyslog.com/index.php/OffPeakHours" target="_blank" rel="noopener">是</a>（可以独立配置主队列和每个操作队列）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够配置备份系统日志/数据库服务器</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>专业支持</td>
<td><a href="https://www.rsyslog.com/doc/professional_support.html" target="_blank" rel="noopener">是</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>配置文件</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>配置文件格式</td>
<td>兼容传统的syslogd，但很难看</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够从其他配置文件中包含配置文件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够包含存在于特定目录中的所有配置文件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>功能拆分在可单独加载的模块中</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持第三方输入插件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持第三方输出插件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>其他特性</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够动态生成文件名和目录（日志目标）</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>控制日志输出格式，包括将通道和优先级显示为可见日志数据的能力</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>本地发送邮件的能力</td>
<td>是（<a href="https://www.rsyslog.com/doc/ommail.html" target="_blank" rel="noopener">ommail</a>，在3.17.0中引入）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>良好的时间戳格式控制; 至少需要ISO 8601 / RFC 3339秒分辨率UTC区域</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够重新格式化消息内容并使用子字符串</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持大于2GB的日志文件</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持日志文件大小限制和自动翻转命令执行</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持在单台机器上运行多个syslogd实例</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够在收到的消息上执行shell脚本</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>将消息传递给连续运行的程序的能力</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>为未来的多核机器提供大规模多线程</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>能够在每个选择线的基础上控制重复行减少（“最后一条消息重复n次”）</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持每个选择器/过滤条件的多个操作</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>网页界面</td>
<td><a href="http://www.phplogcon.org/" target="_blank" rel="noopener">phpLogCon</a>[也适用于<a href="http://freshmeat.net/projects/php-syslog-ng/" target="_blank" rel="noopener"> php-syslog-ng</a> ]</td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用文本文件作为输入源</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>限速输出动作</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在系统压力下丢弃低优先级的消息</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>流量控制（当系统忙时减慢信息接收）</td>
<td>是的（先进的，有多种方式根据个别输入功能，基于水印来减慢输入）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>重写消息</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>将数据输出为各种格式</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>控制“消息重复n次”生成的能力</td>
<td>是</td>
<td></td>
<td></td>
</tr>
<tr>
<td>执照</td>
<td>GPLv3（GPLv2 for v2分支）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>支持的平台</td>
<td>在Solaris上看到的Linux，BSD，轶事; 编译和在HP UX上完成的基本测试</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DNS缓存</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>rsyslog 项目于2004年启动，它基于主要作者（Rainer Gerhards）12年以上的日志记录经验。例如，Rainer 在1996年初也编写了第一个<a href="http://www.winsyslog.com/Common/en/News/WinSyslog-1996-03-31.php" target="_blank" rel="noopener">Windows系统日志服务器</a>，并 于1997 年初发明了<a href="http://www.eventreporter.com/Common/en/News/EvntSLog-1997-03-23.php" target="_blank" rel="noopener">eventlog-to-syslog</a>类应用程序。甚至在他编写这些产品之前，他也进行了自定义日志开发和咨询。Rsyslog吸取了丰富的经验，有时甚至在代码上。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>logs</tag>
      </tags>
  </entry>
  <entry>
    <title>咖啡们</title>
    <url>/2018/04/15/coffee/</url>
    <content><![CDATA[<p><img src="https://blog-image.nos-eastchina1.126.net/4jG40539hl.JPG" alt="mark"></p>
<h2 id="手冲咖啡"><a href="#手冲咖啡" class="headerlink" title="手冲咖啡"></a>手冲咖啡</h2><p>第一篇非技术blog，先拿咖啡们开刀，</p>
<hr>
<a id="more"></a>
<p>装备</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>豆子</th>
<th>云南保山佐园厌氧发酵肯尼亚种S288</th>
</tr>
</thead>
<tbody>
<tr>
<td>手冲壶</td>
<td>Bonavita pro-Brewista 木纹手冲壶、Kalita 鹤嘴壶达人壶</td>
</tr>
<tr>
<td>磨</td>
<td>HARIO MSCS-2TB</td>
</tr>
<tr>
<td>滤杯</td>
<td>KALITA经典三孔、Bonavita pro-brewista 玻璃变色</td>
</tr>
<tr>
<td>称</td>
<td>淘宝 二十</td>
</tr>
<tr>
<td>杯子</td>
<td>Loveramics</td>
</tr>
<tr>
<td>分享壶</td>
<td>kalita</td>
</tr>
</tbody>
</table>
</div>
<p>本次冲两份， 每份15g豆子， 240ml水</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/mAc0FBEdlD.JPG" alt="mark"></p>
<p>垃圾手磨， 粉不均匀， 不建议买 要么直接电磨，便携一定要买不锈钢芯的，海勒，匿名一类的</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/Edg1G32I4e.JPG" alt="mark"></p>
<p>先湿滤纸，（kalita的滤纸真得奇葩， ）正好温下容器</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/lhie22i8Eb.JPG" alt="mark"></p>
<p>粉晃均匀， 先润湿粉，让粉充分膨胀</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/jfH8HBCGJH.JPG" alt="mark"></p>
<p>等待半分钟左右</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/cJj0egFDf5.JPG" alt="mark"></p>
<p>看看咖啡液</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/H3AfHaBf7k.JPG" alt="mark"></p>
<p>分享壶这个东西， 真得作用不是很大， 不建议入，不过颜值既正义</p>
<p>好了，开始继续注水</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/hj63k74iaE.JPG" alt="mark"></p>
<p>对比下两个手冲， 鹤嘴壶这个盖子真得可怕， 不把这，会掉， 把这贼鸡儿烫，不过好看，那款Bonavita就很好用， 不过手冲壶本身就不是看是否实用的，毕竟是艺术品， 达人壶颜值秒所有。</p>
<p>第一波注水完毕，</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/JmbGHD4ldd.JPG" alt="mark"></p>
<p>给水流一个特写， 新手真得不介意入鹤嘴壶， 真得会烫</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/f2G6Jh36Ac.JPG" alt="mark"></p>
<p>变色滤杯来一张</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/C1707jkaJB.JPG" alt="mark"></p>
<p>kalita 101 来一张（尽量别买白色，）</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/8J93HAIfkd.JPG" alt="mark"></p>
<p>最后一波注水， 大水流</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/7jKL8FF5E5.JPG" alt="mark"></p>
<p>三孔下水很慢， 比较倾向泡，v60一类的就很快，</p>
<p>咖啡液特写</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/1GHKG3DhDb.JPG" alt="mark"></p>
<p>最后， 倒入杯子</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/e9j59g2a49.JPG" alt="mark"></p>
<p>关于咖啡的味道，我只能喝出 酸不酸 苦不苦，至于咖啡的风味，我可能是木舌头， 喝不出来， 万物皆玄学！！</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/8k0K24KlBC.jpg?imageslim" alt="mark"></p>
<p>好了， 我还有正事要去做， 就到这了！</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/7dFg7LJfEg.jpg?imageslim" alt="mark"></p>
<p>下期预告， 键盘玄学！</p>
]]></content>
      <categories>
        <category>Coffee</category>
      </categories>
      <tags>
        <tag>Coffee</tag>
      </tags>
  </entry>
  <entry>
    <title>强迫将自己的操作迁移到Systemd（一）</title>
    <url>/2018/04/15/Systemd/</url>
    <content><![CDATA[<p>很久没更新博客了，原因有一下几个， 一是写这个东西真得很耗时（就算是借鉴博客文档），二是报了个自考（3月份报的4科，4月份考试），结果今天连考试都没去，因为书都没看完。</p>
<p>Systemd 并不是简单的把service、chkconfig等变成systemctl，而是管天管地管空气；为什么要强迫自己使用systemd？作为菜鸡的我，始终坚信，不管装什么软件都是用最新的，一方面能使自己体验到最新的技术（当然也会掉进深渊大坑），一方面强迫自己不去搜现成的博客，防止自己跟着大佬的脚步，一路复制粘贴就成功。</p>
<p>最近发现自己真得是什么都不会，你看别人工程师介绍自己的时候， 都可以说自己是xx工程师， 比如网络，安全存储系统  ，别人一问我 “你是做什么的阿？”，我只能说：“emmmm，就打打杂。”其实内心想说自己会linux， 然而 根本就不会阿， 任何一个模块 追踪到细节都不怎么了解，（当然了，有些模块压根就不知道）算下来，我也就是会 apt yum ， 会 servce systemctl 会 ls  rm ，还会终极神器（reboot） ，我要开始下一阶段的学习了，开始学习一些细节，以后好吹逼，今天，我们从systemd开始。</p>
<h1 id="systemd是什么？"><a href="#systemd是什么？" class="headerlink" title="systemd是什么？"></a>systemd是什么？</h1><p><code>systemd</code>是一套Linux系统的基本构建模块。它提供了一个作为PID 1运行的系统和服务管理器，并启动系统的其余部分。<code>systemd</code>提供了积极的并行化功能，使用套接字和D-Bus激活来启动服务，提供按需启动守护进程，使用Linux控制组跟踪进程，维护挂载和自动挂载点，并实现精心设计的基于事务的基于依赖关系的服务控制逻辑。<code>systemd</code>支持SysV和LSB初始化脚本，并作为sysvinit的替代品。其他部分包括日志守护程序，用于控制基本系统配置的实用程序，如主机名，日期，区域设置，维护登录用户列表以及运行容器和虚拟机，系统帐户，运行时目录和设置以及守护进程以管理简单网络配置，网络时间同步，日志转发和名称解析。</p>
<h1 id="比较Linux的三个最相关的init系统：sysvinit，Upstart和systemd"><a href="#比较Linux的三个最相关的init系统：sysvinit，Upstart和systemd" class="headerlink" title="比较Linux的三个最相关的init系统：sysvinit，Upstart和systemd"></a>比较Linux的三个最相关的init系统：sysvinit，Upstart和systemd</h1><h2 id="常规特性"><a href="#常规特性" class="headerlink" title="常规特性"></a>常规特性</h2><a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>sysvinit</th>
<th>Upstart</th>
<th>systemd</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过D-Bus连接</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>无壳启动</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>包括模块化C编码的早期启动服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>预读</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于Socket的激活</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于Socket的激活：inetd兼容性</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于总线的激活</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于设备的激活</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>使用udev规则配置设备依赖关系</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于路径的激活(inotify)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于计时器的激活</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>装载处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>fsck处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>配额处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>自动处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>交换处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>系统状态的快照</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>XDG_RUNTIME_DIR支持</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>可选地杀死剩余的用户注销进程</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Linux控制组集成</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>为启动的服务生成审计记录</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>SELinux集成</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>PAM整合</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>加密的硬盘处理（LUKS）</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>SSL证书/ LUKS密码处理，包括 Plymouth，console，wall，TTY和GNOME代理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>网络环回设备处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>binfmt_misc处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>系统范围的区域设置处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>控制台和键盘设置</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>用于创建，删除，清理临时和不稳定文件的基础架构</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>处理<code>/proc/sys/sysctl</code></td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>普利茅斯整合</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>保存/恢复随机种子</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>内核模块的静态加载</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>自动串行控制台处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>独特的机器ID处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>动态主机名称和机器元数据处理</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>可靠的终止服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>早期启动<code>/dev/log</code>日志记录</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>最小的基于kmsg的syslog守护进程用于嵌入式使用</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>重新生成服务崩溃而不会丢失连接</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>无缝升级服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>图形用户界面</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>内置的分析和工具</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>实例化服务</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>PolicyKit集成</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>客户端工具内置的远程访问/群集支持</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>可以列出服务的所有进程</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>可以识别进程的服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>自动每个服务CPU cgroups可以平衡它们之间的CPU使用率</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>自动每个用户的cgroups</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>SysV兼容性</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>SysV服务可以像本地服务一样进行控制</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>SysV兼容<code>/dev/initctl</code></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>完全序列化状态重新执行</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>交互式启动</td>
<td>no</td>
<td>no0</td>
<td>yes</td>
</tr>
<tr>
<td>容器支持(作为高级chroot()替换)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>基于依赖关系的启动</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>无需编辑文件即可禁用服务</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>无需编辑文件即可屏蔽服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>强大的系统在PID 1内关闭</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>内置kexec支持</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>动态服务生成</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>上游支持各种其他操作系统组件</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>服务文件在发行版之间兼容</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>信号传递到服务</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>在关机前可靠地终止用户会话</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>utmp/wtmp支持</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>轻松可写，可扩展和可解析的服务文件，适用于使用企业管理工具进行操作</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div>
<h2 id="可用的本地服务设置"><a href="#可用的本地服务设置" class="headerlink" title="可用的本地服务设置"></a>可用的本地服务设置</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>sysvinit</th>
<th>Upstart</th>
<th>systemd</th>
</tr>
</thead>
<tbody>
<tr>
<td>OOM  调整</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>工作目录</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>根目录 (chroot())</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>环境变量</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>环境变量(来自外部的文件)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>资源限制</td>
<td>no</td>
<td>some</td>
<td>yes</td>
</tr>
<tr>
<td>umask</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>User/Group/Supplementary Groups</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>IO调度类/优先级</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>CPU Scheduling Nice Value</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>CPU Scheduling Policy/Priority</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>CPU Scheduling Reset on fork() control</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>CPU affinity</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Timer Slack</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>功能Control</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>安全位 Control</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Control Group Control</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>High-level file system namespace control: making directories inacessible</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>High-level file system namespace control: making directories read-only</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>High-level file system namespace control: private /tmp</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>High-level file system namespace control: mount inheritance</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Input on Console</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Output on Syslog</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Output on kmsg/dmesg</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Output on arbitrary TTY</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Kill signal control</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Conditional execution: by identified CPU virtualization/container</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Conditional execution: by file existance</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Conditional execution: by security framework</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>Conditional execution: by kernel command line</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div>
<h1 id="关于Systemd的管理"><a href="#关于Systemd的管理" class="headerlink" title="关于Systemd的管理"></a>关于Systemd的管理</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>传统上，启动Linux系统时，屏幕上会显示很多小消息。当我们致力于加速和平行启动过程时，这些消息只能在更短和更短的时间内看到，并且可读性越来越差 - 如果完全显示它们，我们现在使用像普利茅斯这样的图形启动闪屏技术。尽管如此，启动屏幕的信息仍然非常相关，因为它显示了每个启动过程中正在启动的服务，它是否启动成功或失败（使用绿色或红色 <code>[OK]</code>或<code>[失败]</code>指标）。为了改善启动快速和并行化的机器的情况，并使这些信息在运行时更好地提供，我们向systemd添加了一项功能，该功能跟踪并记住每个服务是否启动成功，是否以非零退出代码，是否超时，是否在启动和运行时都异常终止（通过段错误或类似方式）。只需在shell中输入<code>systemctl</code>，就可以查询所有服务的状态，包括systemd native和SysV/LSB服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kubernetes-node1 ~]<span class="comment"># systemctl</span></span><br><span class="line">UNIT                                                              LOAD   ACTIVE SUB       DESCRIPTION</span><br><span class="line">proc-sys-fs-binfmt_misc.automount                                 loaded active waiting   Arbitrary Executable File Formats File System Automount Point</span><br><span class="line">sys-devices-pci0000:00-0000:00:11.0-0000:02:01.0-ata1-host1-target1:0:0-1:0:0:0-block-sr0.device loaded active plugged   VMware_Virtual_SATA_CDRW_Drive</span><br><span class="line">sys-devices-pci0000:00-0000:00:15.0-0000:03:00.0-host0-target0:0:0-0:0:0:0-block-sda-sda1.device loaded active plugged   Virtual_disk 1</span><br><span class="line">sys-devices-pci0000:00-0000:00:15.0-0000:03:00.0-host0-target0:0:0-0:0:0:0-block-sda-sda2.device loaded active plugged   LVM PV KJs0yz-aG67-nkFK-eELZ-LiLs-K</span><br><span class="line">sys-devices-pci0000:00-0000:00:15.0-0000:03:00.0-host0-target0:0:0-0:0:0:0-block-sda.device loaded active plugged   Virtual_disk</span><br><span class="line">sys-devices-pci0000:00-0000:00:16.0-0000:0b:00.0-net-ens192.device loaded active plugged   VMXNET3 Ethernet Controller</span><br><span class="line">sys-devices-platform-floppy.0-block-fd0.device                    loaded active plugged   /sys/devices/platform/floppy.0/block/fd0</span><br><span class="line">sys-devices-platform-serial8250-tty-ttyS0.device                  loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS0</span><br><span class="line">sys-devices-platform-serial8250-tty-ttyS1.device                  loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS1</span><br><span class="line">sys-devices-platform-serial8250-tty-ttyS2.device                  loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS2</span><br><span class="line">sys-devices-platform-serial8250-tty-ttyS3.device                  loaded active plugged   /sys/devices/platform/serial8250/tty/ttyS3</span><br><span class="line">sys-devices-virtual-block-dm\x2d0.device                          loaded active plugged   /sys/devices/virtual/block/dm-0</span><br><span class="line">sys-devices-virtual-block-dm\x2d1.device                          loaded active plugged   /sys/devices/virtual/block/dm-1</span><br><span class="line">sys-devices-virtual-net-cni0.device                               loaded active plugged   /sys/devices/virtual/net/cni0</span><br><span class="line">sys-devices-virtual-net-docker0.device                            loaded active plugged   /sys/devices/virtual/net/docker0</span><br><span class="line">sys-devices-virtual-net-flannel.1.device                          loaded active plugged   /sys/devices/virtual/net/flannel.1</span><br><span class="line">sys-devices-virtual-net-veth551eaded.device                       loaded active plugged   /sys/devices/virtual/net/veth551eaded</span><br><span class="line">sys-module-configfs.device                                        loaded active plugged   /sys/module/configfs</span><br><span class="line">sys-subsystem-net-devices-cni0.device                             loaded active plugged   /sys/subsystem/net/devices/cni0</span><br><span class="line">sys-subsystem-net-devices-docker0.device                          loaded active plugged   /sys/subsystem/net/devices/docker0</span><br><span class="line">sys-subsystem-net-devices-ens192.device                           loaded active plugged   VMXNET3 Ethernet Controller</span><br><span class="line">sys-subsystem-net-devices-flannel.1.device                        loaded active plugged   /sys/subsystem/net/devices/flannel.1</span><br><span class="line">sys-subsystem-net-devices-veth551eaded.device                     loaded active plugged   /sys/subsystem/net/devices/veth551eaded</span><br><span class="line">-.mount                                                           loaded active mounted   /</span><br><span class="line">boot.mount                                                        loaded active mounted   /boot</span><br><span class="line">dev-hugepages.mount                                               loaded active mounted   Huge Pages File System</span><br><span class="line">dev-mqueue.mount                                                  loaded active mounted   POSIX Message Queue File System</span><br><span class="line">run-user-0.mount                                                  loaded active mounted   /run/user/0</span><br><span class="line">sys-kernel-config.mount                                           loaded active mounted   Configuration File System</span><br><span class="line">sys-kernel-debug.mount                                            loaded active mounted   Debug File System</span><br><span class="line">var-lib-kubelet-pods-aea86e6c\x2d3cb7\x2d11e8\x2dbb32\x2d00505696e13c-volumes-kubernetes.io\x7esecret-kube\x2dproxy\x2dtoken\x2d6tgqt.mount loaded active mo</span><br><span class="line">var-lib-kubelet-pods-aebaceba\x2d3cb7\x2d11e8\x2dbb32\x2d00505696e13c-volumes-kubernetes.io\x7esecret-kube\x2ddns\x2dtoken\x2dhzzmv.mount loaded active moun</span><br><span class="line">var-lib-kubelet-pods-f461fa39\x2d3cb7\x2d11e8\x2dbb32\x2d00505696e13c-volumes-kubernetes.io\x7esecret-flannel\x2dtoken\x2drf77r.mount loaded active mounted</span><br><span class="line">brandbot.path                                                     loaded active waiting   Flexible branding</span><br><span class="line">systemd-ask-password-plymouth.path                                loaded active waiting   Forward Password Requests to Plymouth Directory Watch</span><br><span class="line">systemd-ask-password-wall.path                                    loaded active waiting   Forward Password Requests to Wall Directory Watch</span><br><span class="line">docker-121185d5f53ead31d941319e3042395f45b6cb8c1d7dd93fa89b773434b79b27.scope loaded active running   libcontainer container 121185d5f53ead31d941319e3042395</span><br><span class="line">docker-121a05887cfe505afc373824dbeb5265752b13f1e604312b5942fec6b2972978.scope loaded active running   libcontainer container 121a05887cfe505afc373824dbeb526</span><br><span class="line">docker-15ff649777e6904c365d82f043d1d961f2418c81da6f87758736ee44418ade08.scope loaded active running   libcontainer container 15ff649777e6904c365d82f043d1d96</span><br><span class="line">docker-17344939037d910e213e62acbe564f6c8b104d4fb000bc393ca360ff01972c5c.scope loaded active running   libcontainer container 17344939037d910e213e62acbe564f6</span><br><span class="line">docker-2995b17f7b1cf824c99ac68bd414f3784dc82942c427f26f7a08a3a384c20612.scope loaded active running   libcontainer container 2995b17f7b1cf824c99ac68bd414f37</span><br><span class="line">docker-656d2e92ba35f027e0e92fffac799555bd6ccff39524851ffe2d8808fdb6c907.scope loaded active running   libcontainer container 656d2e92ba35f027e0e92fffac79955</span><br><span class="line">docker-8b8770f404adda78586dc7235f6d0e056b821c83d06e3d662c34ae4474f85259.scope loaded active running   libcontainer container 8b8770f404adda78586dc7235f6d0e0</span><br><span class="line">docker-8e47ef924ee32f6d6107f7fb20632743824e9d8dfdce456c3692b13fbf6f9e52.scope loaded active running   libcontainer container 8e47ef924ee32f6d6107f7fb2063274</span><br><span class="line">docker-8f92f56afabea9689b1d9fb996318d5e2aad26c2c369fd246c15b86ba064b15f.scope loaded active running   libcontainer container 8f92f56afabea9689b1d9fb996318d5</span><br><span class="line">docker-a0e3d010c40a7732eff4c36160792a681f4e437c1cf34a71e9af990b7ecf0343.scope loaded active running   libcontainer container a0e3d010c40a7732eff4c36160792a6</span><br><span class="line">docker-a1f2c42182828f2f82ac581878034b185572eaa823ad807eaf503df39f820031.scope loaded active running   libcontainer container a1f2c42182828f2f82ac581878034b1</span><br><span class="line">docker-a87c101f9b6ea444a750c0f0b84cd71aada64fd6d707ea5aa48722603b2aba21.scope loaded active running   libcontainer container a87c101f9b6ea444a750c0f0b84cd71</span><br><span class="line">docker-bea14b22d6090441b8f4bc9f89fe416d06875b272816f2a0ffb30cb7f77509d5.scope loaded active running   libcontainer container bea14b22d6090441b8f4bc9f89fe416</span><br><span class="line">docker-cdc819cd61bc462cf5e86d0177899c228337c3894032964b3bc5a9fde7178f3c.scope loaded active running   libcontainer container cdc819cd61bc462cf5e86d0177899c2</span><br><span class="line">docker-cfdcde0fa4265b33d40c2059c070af0ae1ef7649d7933168bfa4cc12a5da5c59.scope loaded active running   libcontainer container cfdcde0fa4265b33d40c2059c070af0</span><br><span class="line">docker-eae566bf29ac4a378a7a9f651907830779fee7b213e15b090c5471d725a50601.scope loaded active running   libcontainer container eae566bf29ac4a378a7a9f651907830</span><br><span class="line">session-129.scope                                                 loaded active abandoned Session 129 of user root</span><br><span class="line">session-130.scope                                                 loaded active running   Session 130 of user root</span><br><span class="line">session-131.scope                                                 loaded active running   Session 131 of user root</span><br><span class="line">auditd.service                                                    loaded active running   Security Auditing Service</span><br><span class="line">crond.service                                                     loaded active running   Command Scheduler</span><br><span class="line">dbus.service                                                      loaded active running   D-Bus System Message Bus</span><br><span class="line">docker.service                                                    loaded active running   Docker Application Container Engine</span><br><span class="line">getty@tty1.service                                                loaded active running   Getty on tty1</span><br><span class="line">irqbalance.service                                                loaded active running   irqbalance daemon</span><br><span class="line">kdump.service                                                     loaded active exited    Crash recovery kernel arming</span><br><span class="line">kmod-static-nodes.service                                         loaded active exited    Create list of required static device nodes <span class="keyword">for</span> the current kernel</span><br><span class="line">kubelet.service                                                   loaded active running   kubelet: The Kubernetes Node Agent</span><br><span class="line">lvm2-lvmetad.service                                              loaded active running   LVM2 metadata daemon</span><br><span class="line">lvm2-monitor.service                                              loaded active exited    Monitoring of LVM2 mirrors, snapshots etc. using dmeventd or progr</span><br><span class="line">lvm2-pvscan@8:2.service                                           loaded active exited    LVM2 PV scan on device 8:2</span><br><span class="line">network.service                                                   loaded active exited    LSB: Bring up/down networking</span><br><span class="line">NetworkManager-wait-online.service                                loaded active exited    Network Manager Wait Online</span><br><span class="line">NetworkManager.service                                            loaded active running   Network Manager</span><br><span class="line">polkit.service                                                    loaded active running   Authorization Manager</span><br><span class="line">postfix.service                                                   loaded active running   Postfix Mail Transport Agent</span><br><span class="line">rhel-dmesg.service                                                loaded active exited    Dump dmesg to /var/<span class="built_in">log</span>/dmesg</span><br><span class="line">rhel-import-state.service                                         loaded active exited    Import network configuration from initramfs</span><br><span class="line">rhel-readonly.service                                             loaded active exited    Configure <span class="built_in">read</span>-only root support</span><br><span class="line">rsyslog.service                                                   loaded active running   System Logging Service</span><br><span class="line">sshd.service                                                      loaded active running   OpenSSH server daemon</span><br><span class="line">systemd-journal-flush.service                                     loaded active exited    Flush Journal to Persistent Storage</span><br><span class="line">systemd-journald.service                                          loaded active running   Journal Service</span><br><span class="line">systemd-logind.service                                            loaded active running   Login Service</span><br><span class="line">systemd-random-seed.service                                       loaded active exited    Load/Save Random Seed</span><br><span class="line">systemd-remount-fs.service                                        loaded active exited    Remount Root and Kernel File Systems</span><br><span class="line">systemd-sysctl.service                                            loaded active exited    Apply Kernel Variables</span><br><span class="line">systemd-tmpfiles-setup-dev.service                                loaded active exited    Create Static Device Nodes <span class="keyword">in</span> /dev</span><br><span class="line">systemd-tmpfiles-setup.service                                    loaded active exited    Create Volatile Files and Directories</span><br><span class="line">systemd-udev-trigger.service                                      loaded active exited    udev Coldplug all Devices</span><br><span class="line">systemd-udevd.service                                             loaded active running   udev Kernel Device Manager</span><br><span class="line">systemd-update-utmp.service                                       loaded active exited    Update UTMP about System Boot/Shutdown</span><br><span class="line">systemd-user-sessions.service                                     loaded active exited    Permit User Sessions</span><br><span class="line">systemd-vconsole-setup.service                                    loaded active exited    Setup Virtual Console</span><br><span class="line">tuned.service                                                     loaded active running   Dynamic System Tuning Daemon</span><br><span class="line">-.slice                                                           loaded active active    Root Slice</span><br><span class="line">kubepods-besteffort-podaea86e6c_3cb7_11e8_bb32_00505696e13c.slice loaded active active    libcontainer container kubepods-besteffort-podaea86e6c_3cb7_11e8_b</span><br><span class="line">kubepods-besteffort-podd0f5be64eb96701ecb2dfd99040bdae9.slice     loaded active active    libcontainer container kubepods-besteffort-podd0f5be64eb96701ecb2d</span><br><span class="line">kubepods-besteffort-podf461fa39_3cb7_11e8_bb32_00505696e13c.slice loaded active active    libcontainer container kubepods-besteffort-podf461fa39_3cb7_11e8_b</span><br><span class="line">kubepods-besteffort.slice                                         loaded active active    libcontainer container kubepods-besteffort.slice</span><br><span class="line">kubepods-burstable-pod099f1c2b79126109140a1f77e211df00.slice      loaded active active    libcontainer container kubepods-burstable-pod099f1c2b79126109140a1</span><br><span class="line">kubepods-burstable-pod498af058d9a8b33f17a3c7deeec06574.slice      loaded active active    libcontainer container kubepods-burstable-pod498af058d9a8b33f17a3c</span><br><span class="line">kubepods-burstable-podaebaceba_3cb7_11e8_bb32_00505696e13c.slice  loaded active active    libcontainer container kubepods-burstable-podaebaceba_3cb7_11e8_bb</span><br><span class="line">kubepods-burstable-podda46e5eb58febd64dd66deab8e98a51b.slice      loaded active active    libcontainer container kubepods-burstable-podda46e5eb58febd64dd66d</span><br><span class="line">kubepods-burstable.slice                                          loaded active active    libcontainer container kubepods-burstable.slice</span><br><span class="line">kubepods.slice                                                    loaded active active    libcontainer container kubepods.slice</span><br><span class="line">system-getty.slice                                                loaded active active    system-getty.slice</span><br><span class="line">system-lvm2\x2dpvscan.slice                                       loaded active active    system-lvm2\x2dpvscan.slice</span><br><span class="line">system-selinux\x2dpolicy\x2dmigrate\x2dlocal\x2dchanges.slice     loaded active active    system-selinux\x2dpolicy\x2dmigrate\x2dlocal\x2dchanges.slice</span><br><span class="line">system.slice                                                      loaded active active    System Slice</span><br><span class="line">user-0.slice                                                      loaded active active    User Slice of root</span><br><span class="line">user.slice                                                        loaded active active    User and Session Slice</span><br><span class="line">dbus.socket                                                       loaded active running   D-Bus System Message Bus Socket</span><br><span class="line">dm-event.socket                                                   loaded active listening Device-mapper event daemon FIFOs</span><br><span class="line">lvm2-lvmetad.socket                                               loaded active running   LVM2 metadata daemon socket</span><br><span class="line">lvm2-lvmpolld.socket                                              loaded active listening LVM2 poll daemon socket</span><br><span class="line">systemd-initctl.socket                                            loaded active listening /dev/initctl Compatibility Named Pipe</span><br><span class="line">systemd-journald.socket                                           loaded active running   Journal Socket</span><br><span class="line">systemd-shutdownd.socket                                          loaded active listening Delayed Shutdown Socket</span><br><span class="line">systemd-udevd-control.socket                                      loaded active running   udev Control Socket</span><br><span class="line">systemd-udevd-kernel.socket                                       loaded active running   udev Kernel Socket</span><br><span class="line">basic.target                                                      loaded active active    Basic System</span><br><span class="line">cryptsetup.target                                                 loaded active active    Encrypted Volumes</span><br><span class="line">getty.target                                                      loaded active active    Login Prompts</span><br><span class="line"><span class="built_in">local</span>-fs-pre.target                                               loaded active active    Local File Systems (Pre)</span><br><span class="line"><span class="built_in">local</span>-fs.target                                                   loaded active active    Local File Systems</span><br><span class="line">multi-user.target                                                 loaded active active    Multi-User System</span><br><span class="line">network-online.target                                             loaded active active    Network is Online</span><br><span class="line">network.target                                                    loaded active active    Network</span><br><span class="line">paths.target                                                      loaded active active    Paths</span><br><span class="line">remote-fs.target                                                  loaded active active    Remote File Systems</span><br><span class="line">slices.target                                                     loaded active active    Slices</span><br><span class="line">sockets.target                                                    loaded active active    Sockets</span><br><span class="line">swap.target                                                       loaded active active    Swap</span><br><span class="line">sysinit.target                                                    loaded active active    System Initialization</span><br><span class="line">timers.target                                                     loaded active active    Timers</span><br><span class="line">docker-cleanup.timer                                              loaded active waiting   Run docker-cleanup every hour</span><br><span class="line">systemd-tmpfiles-clean.timer                                      loaded active waiting   Daily Cleanup of Temporary Directories</span><br><span class="line"></span><br><span class="line">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class="line">ACTIVE = The high-level unit activation state, i.e. generalization of SUB.</span><br><span class="line">SUB    = The low-level unit activation state, values depend on unit <span class="built_in">type</span>.</span><br><span class="line"></span><br><span class="line">134 loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class="line">To show all installed unit files use <span class="string">'systemctl list-unit-files'</span>.</span><br><span class="line">lines 111-142/142 (END)</span><br></pre></td></tr></table></figure>
<p>看一下ACTIVE列，它显示了服务的高级状态（或者实际上任何类型的systemd维护的单元，它们不仅仅是服务），它是否<em>active</em>（即正在运行）， <em>inactive</em>（即未运行）还是处于任何其他状态。现在，让我们用<code>systemctl status</code> 命令查看kubelet ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kubernetes-node1 ~]<span class="comment"># systemctl status kubelet</span></span><br><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since Tue 2018-04-10 20:06:36 CST; 4 days ago</span><br><span class="line">     Docs: http://kubernetes.io/docs/</span><br><span class="line"> Main PID: 28032 (kubelet)</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           └─28032 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --pod-manifes...</span><br><span class="line"></span><br><span class="line">Apr 15 03:01:39 kubernetes-node1 kubelet[28032]: W0415 03:01:39.424039   28032 container_manager_linux.go:791] CPUAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br><span class="line">Apr 15 03:01:39 kubernetes-node1 kubelet[28032]: W0415 03:01:39.424051   28032 container_manager_linux.go:794] MemoryAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br><span class="line">Apr 15 03:06:39 kubernetes-node1 kubelet[28032]: W0415 03:06:39.424458   28032 container_manager_linux.go:791] CPUAccounting not enabled <span class="keyword">for</span> pid: 28707</span><br><span class="line">Apr 15 03:06:39 kubernetes-node1 kubelet[28032]: W0415 03:06:39.424498   28032 container_manager_linux.go:794] MemoryAccounting not enabled <span class="keyword">for</span> pid: 28707</span><br><span class="line">Apr 15 03:06:39 kubernetes-node1 kubelet[28032]: W0415 03:06:39.424634   28032 container_manager_linux.go:791] CPUAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br><span class="line">Apr 15 03:06:39 kubernetes-node1 kubelet[28032]: W0415 03:06:39.424646   28032 container_manager_linux.go:794] MemoryAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br><span class="line">Apr 15 03:11:39 kubernetes-node1 kubelet[28032]: W0415 03:11:39.425017   28032 container_manager_linux.go:791] CPUAccounting not enabled <span class="keyword">for</span> pid: 28707</span><br><span class="line">Apr 15 03:11:39 kubernetes-node1 kubelet[28032]: W0415 03:11:39.425052   28032 container_manager_linux.go:794] MemoryAccounting not enabled <span class="keyword">for</span> pid: 28707</span><br><span class="line">Apr 15 03:11:39 kubernetes-node1 kubelet[28032]: W0415 03:11:39.425213   28032 container_manager_linux.go:791] CPUAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br><span class="line">Apr 15 03:11:39 kubernetes-node1 kubelet[28032]: W0415 03:11:39.425227   28032 container_manager_linux.go:794] MemoryAccounting not enabled <span class="keyword">for</span> pid: 28032</span><br></pre></td></tr></table></figure>
<h1 id="哪个服务拥有哪个进程？"><a href="#哪个服务拥有哪个进程？" class="headerlink" title="哪个服务拥有哪个进程？"></a>哪个服务拥有哪个进程？</h1><p>在大多数Linux系统上，默认运行的进程数量很大。知道哪个过程做什么和它属于哪里变得越来越困难。一些服务甚至维护了一些工作进程，这些工作进程通过许多额外的进程来混淆“ <code>ps</code> ”输出，而这些进程往往不易识别。如果守护进程产生任意的第三方进程，如Apache对CGI进程的操作，或者cron对用户作业做的那样，这会更加复杂。</p>
<p>对此的一点补救通常是进程继承树，如“ <code>ps xaf</code> ”所示。然而，这通常是不可靠的，因为其父进程死亡的进程被重新设置为PID 1，因此关于继承的所有信息都会丢失。如果一个过程“双重分叉”，那么它就会失去与启动过程的关系。（实际上这应该是一个功能，并且依赖于传统的Unix守护进程逻辑。）此外，进程可以使用<code>PR_SETNAME</code>或修补<code>argv [0]</code>来自由更改其名称，从而使其更难识别它们。</p>
<p>在systemd中，我们将产生的每个进程放在以其服务命名的<em>控制组中</em>。最基本的控制组（或<em>cgroup</em>）只是一组进程，可以按层次结构排列并单独标记。当进程产生其他进程时，这些孩子将自动成为父cgroup的成员。离开cgroup对于非特权进程是不可能的。因此，cgroups可以作为一种有效的方式来标记它们所属服务之后的进程，并确保该服务无法从标签中逃脱，无论它多长时间分叉或重命名它自己。此外，这可以用来安全地杀死一个服务及其创建的所有进程。</p>
<p>可能用于关联systemd服务和进程的两个命令。第一个是众所周知的<code>ps</code>命令，该命令已经更新以显示沿着其他处理细节的cgroup信息。这就是它的外观：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kubernetes-node1 ~]<span class="comment"># ps xawf -eo pid,user,cgroup,args</span></span><br><span class="line">  PID USER     CGROUP                      COMMAND</span><br><span class="line">    2 root     -                           [kthreadd]</span><br><span class="line">    3 root     -                            \_ [ksoftirqd/0]</span><br><span class="line">    5 root     -                            \_ [kworker/0:0H]</span><br><span class="line">    7 root     -                            \_ [migration/0]</span><br><span class="line">    8 root     -                            \_ [rcu_bh]</span><br><span class="line">    9 root     -                            \_ [rcu_sched]</span><br><span class="line">   10 root     -                            \_ [watchdog/0]</span><br><span class="line">   11 root     -                            \_ [watchdog/1]</span><br><span class="line">   12 root     -                            \_ [migration/1]</span><br><span class="line">   13 root     -                            \_ [ksoftirqd/1]</span><br><span class="line">   15 root     -                            \_ [kworker/1:0H]</span><br><span class="line">   16 root     -                            \_ [watchdog/2]</span><br><span class="line">   17 root     -                            \_ [migration/2]</span><br><span class="line">   18 root     -                            \_ [ksoftirqd/2]</span><br><span class="line">   20 root     -                            \_ [kworker/2:0H]</span><br><span class="line">   21 root     -                            \_ [watchdog/3]</span><br><span class="line">   22 root     -                            \_ [migration/3]</span><br><span class="line">   23 root     -                            \_ [ksoftirqd/3]</span><br><span class="line">   25 root     -                            \_ [kworker/3:0H]</span><br><span class="line">   26 root     -                            \_ [watchdog/4]</span><br><span class="line">   27 root     -                            \_ [migration/4]</span><br><span class="line">   28 root     -                            \_ [ksoftirqd/4]</span><br><span class="line">   30 root     -                            \_ [kworker/4:0H]</span><br><span class="line">   31 root     -                            \_ [watchdog/5]</span><br><span class="line">   32 root     -                            \_ [migration/5]</span><br><span class="line">   33 root     -                            \_ [ksoftirqd/5]</span><br><span class="line">   35 root     -                            \_ [kworker/5:0H]</span><br><span class="line">   36 root     -                            \_ [watchdog/6]</span><br><span class="line">   37 root     -                            \_ [migration/6]</span><br><span class="line">   38 root     -                            \_ [ksoftirqd/6]</span><br><span class="line">   40 root     -                            \_ [kworker/6:0H]</span><br><span class="line">   41 root     -                            \_ [watchdog/7]</span><br><span class="line">   42 root     -                            \_ [migration/7]</span><br><span class="line">   43 root     -                            \_ [ksoftirqd/7]</span><br><span class="line">   45 root     -                            \_ [kworker/7:0H]</span><br><span class="line">   47 root     -                            \_ [kdevtmpfs]</span><br><span class="line">   48 root     -                            \_ [netns]</span><br><span class="line">   49 root     -                            \_ [khungtaskd]</span><br><span class="line">   50 root     -                            \_ [writeback]</span><br><span class="line">   51 root     -                            \_ [kintegrityd]</span><br><span class="line">   52 root     -                            \_ [bioset]</span><br><span class="line">   53 root     -                            \_ [kblockd]</span><br><span class="line">   54 root     -                            \_ [md]</span><br><span class="line">   60 root     -                            \_ [kswapd0]</span><br><span class="line">   61 root     -                            \_ [ksmd]</span><br><span class="line">   62 root     -                            \_ [khugepaged]</span><br><span class="line">   63 root     -                            \_ [crypto]</span><br><span class="line">   71 root     -                            \_ [kthrotld]</span><br><span class="line">   73 root     -                            \_ [kmpath_rdacd]</span><br><span class="line">   74 root     -                            \_ [kpsmoused]</span><br><span class="line">   76 root     -                            \_ [ipv6_addrconf]</span><br><span class="line">   95 root     -                            \_ [deferwq]</span><br><span class="line">  133 root     -                            \_ [kauditd]</span><br><span class="line">  318 root     -                            \_ [scsi_eh_0]</span><br><span class="line">  320 root     -                            \_ [scsi_tmf_0]</span><br><span class="line">  321 root     -                            \_ [vmw_pvscsi_wq_0]</span><br><span class="line">  326 root     -                            \_ [ata_sff]</span><br><span class="line">  334 root     -                            \_ [scsi_eh_1]</span><br><span class="line">  335 root     -                            \_ [scsi_tmf_1]</span><br><span class="line">  336 root     -                            \_ [scsi_eh_2]</span><br><span class="line">  337 root     -                            \_ [scsi_tmf_2]</span><br><span class="line">  338 root     -                            \_ [scsi_eh_3]</span><br><span class="line">  339 root     -                            \_ [scsi_tmf_3]</span><br><span class="line">  340 root     -                            \_ [scsi_eh_4]</span><br><span class="line">  341 root     -                            \_ [scsi_tmf_4]</span><br><span class="line">  342 root     -                            \_ [scsi_eh_5]</span><br><span class="line">  343 root     -                            \_ [scsi_tmf_5]</span><br><span class="line">  344 root     -                            \_ [scsi_eh_6]</span><br><span class="line">  345 root     -                            \_ [scsi_tmf_6]</span><br><span class="line">  346 root     -                            \_ [scsi_eh_7]</span><br><span class="line">  347 root     -                            \_ [scsi_tmf_7]</span><br><span class="line">  348 root     -                            \_ [scsi_eh_8]</span><br><span class="line">  349 root     -                            \_ [scsi_tmf_8]</span><br><span class="line">  350 root     -                            \_ [scsi_eh_9]</span><br><span class="line">  351 root     -                            \_ [scsi_tmf_9]</span><br><span class="line">  352 root     -                            \_ [scsi_eh_10]</span><br><span class="line">  353 root     -                            \_ [scsi_tmf_10]</span><br><span class="line">  354 root     -                            \_ [scsi_eh_11]</span><br><span class="line">  355 root     -                            \_ [scsi_tmf_11]</span><br><span class="line">  356 root     -                            \_ [scsi_eh_12]</span><br><span class="line">  357 root     -                            \_ [scsi_tmf_12]</span><br><span class="line">  358 root     -                            \_ [scsi_eh_13]</span><br><span class="line">  359 root     -                            \_ [scsi_tmf_13]</span><br><span class="line">  360 root     -                            \_ [scsi_eh_14]</span><br><span class="line">  361 root     -                            \_ [scsi_tmf_14]</span><br><span class="line">  362 root     -                            \_ [scsi_eh_15]</span><br><span class="line">  363 root     -                            \_ [scsi_tmf_15]</span><br><span class="line">  364 root     -                            \_ [scsi_eh_16]</span><br><span class="line">  365 root     -                            \_ [scsi_tmf_16]</span><br><span class="line">  366 root     -                            \_ [scsi_eh_17]</span><br><span class="line">  367 root     -                            \_ [scsi_tmf_17]</span><br><span class="line">  368 root     -                            \_ [scsi_eh_18]</span><br><span class="line">  369 root     -                            \_ [scsi_tmf_18]</span><br><span class="line">  370 root     -                            \_ [scsi_eh_19]</span><br><span class="line">  371 root     -                            \_ [scsi_tmf_19]</span><br><span class="line">  372 root     -                            \_ [scsi_eh_20]</span><br><span class="line">  373 root     -                            \_ [scsi_tmf_20]</span><br><span class="line">  374 root     -                            \_ [scsi_eh_21]</span><br><span class="line">  375 root     -                            \_ [scsi_tmf_21]</span><br><span class="line">  376 root     -                            \_ [scsi_eh_22]</span><br><span class="line">  377 root     -                            \_ [scsi_tmf_22]</span><br><span class="line">  378 root     -                            \_ [scsi_eh_23]</span><br><span class="line">  379 root     -                            \_ [scsi_tmf_23]</span><br><span class="line">  380 root     -                            \_ [scsi_eh_24]</span><br><span class="line">  381 root     -                            \_ [scsi_tmf_24]</span><br><span class="line">  382 root     -                            \_ [scsi_eh_25]</span><br><span class="line">  383 root     -                            \_ [scsi_tmf_25]</span><br><span class="line">  384 root     -                            \_ [scsi_eh_26]</span><br><span class="line">  385 root     -                            \_ [scsi_tmf_26]</span><br><span class="line">  386 root     -                            \_ [scsi_eh_27]</span><br><span class="line">  387 root     -                            \_ [scsi_tmf_27]</span><br><span class="line">  388 root     -                            \_ [scsi_eh_28]</span><br><span class="line">  389 root     -                            \_ [scsi_tmf_28]</span><br><span class="line">  390 root     -                            \_ [scsi_eh_29]</span><br><span class="line">  391 root     -                            \_ [scsi_tmf_29]</span><br><span class="line">  392 root     -                            \_ [scsi_eh_30]</span><br><span class="line">  393 root     -                            \_ [scsi_tmf_30]</span><br><span class="line">  422 root     -                            \_ [kworker/u16:31]</span><br><span class="line">  424 root     -                            \_ [scsi_eh_31]</span><br><span class="line">  425 root     -                            \_ [scsi_tmf_31]</span><br><span class="line">  426 root     -                            \_ [scsi_eh_32]</span><br><span class="line">  427 root     -                            \_ [scsi_tmf_32]</span><br><span class="line">  439 root     -                            \_ [ttm_swap]</span><br><span class="line">  470 root     -                            \_ [kworker/0:1H]</span><br><span class="line">  512 root     -                            \_ [kdmflush]</span><br><span class="line">  513 root     -                            \_ [bioset]</span><br><span class="line">  524 root     -                            \_ [kdmflush]</span><br><span class="line">  525 root     -                            \_ [bioset]</span><br><span class="line">  538 root     -                            \_ [bioset]</span><br><span class="line">  539 root     -                            \_ [xfsalloc]</span><br><span class="line">  540 root     -                            \_ [xfs_mru_cache]</span><br><span class="line">  541 root     -                            \_ [xfs-buf/dm-0]</span><br><span class="line">  542 root     -                            \_ [xfs-data/dm-0]</span><br><span class="line">  543 root     -                            \_ [xfs-conv/dm-0]</span><br><span class="line">  544 root     -                            \_ [xfs-cil/dm-0]</span><br><span class="line">  545 root     -                            \_ [xfs-reclaim/dm-]</span><br><span class="line">  546 root     -                            \_ [xfs-log/dm-0]</span><br><span class="line">  547 root     -                            \_ [xfs-eofblocks/d]</span><br><span class="line">  548 root     -                            \_ [xfsaild/dm-0]</span><br><span class="line">  549 root     -                            \_ [kworker/2:1H]</span><br><span class="line">  678 root     -                            \_ [nfit]</span><br><span class="line">  716 root     -                            \_ [xfs-buf/sda1]</span><br><span class="line">  717 root     -                            \_ [xfs-data/sda1]</span><br><span class="line">  718 root     -                            \_ [xfs-conv/sda1]</span><br><span class="line">  719 root     -                            \_ [xfs-cil/sda1]</span><br><span class="line">  720 root     -                            \_ [xfs-reclaim/sda]</span><br><span class="line">  721 root     -                            \_ [xfs-log/sda1]</span><br><span class="line">  722 root     -                            \_ [xfs-eofblocks/s]</span><br><span class="line">  723 root     -                            \_ [xfsaild/sda1]</span><br><span class="line">  754 root     -                            \_ [edac-poller]</span><br><span class="line">  758 root     -                            \_ [kworker/6:1H]</span><br><span class="line">  759 root     -                            \_ [kworker/1:1H]</span><br><span class="line">  895 root     -                            \_ [kworker/7:1H]</span><br><span class="line"> 1449 root     -                            \_ [kworker/4:1H]</span><br><span class="line"> 1505 root     -                            \_ [kworker/3:1H]</span><br><span class="line"> 2704 root     -                            \_ [kworker/5:1H]</span><br><span class="line">27415 root     -                            \_ [kworker/5:2]</span><br><span class="line">27509 root     -                            \_ [kworker/u16:0]</span><br><span class="line"> 6438 root     -                            \_ [kworker/6:6]</span><br><span class="line">14906 root     -                            \_ [kworker/1:2]</span><br><span class="line">17063 root     -                            \_ [kworker/4:2]</span><br><span class="line">23243 root     -                            \_ [kworker/5:0]</span><br><span class="line">25698 root     -                            \_ [kworker/7:1]</span><br><span class="line">29952 root     -                            \_ [kworker/2:0]</span><br><span class="line"> 5454 root     -                            \_ [kworker/4:1]</span><br><span class="line">15305 root     -                            \_ [kworker/2:1]</span><br><span class="line"> 4251 root     -                            \_ [kworker/7:2]</span><br><span class="line">  737 root     -                            \_ [kworker/6:1]</span><br><span class="line">31964 root     -                            \_ [kworker/1:0]</span><br><span class="line">11086 root     -                            \_ [kworker/0:2]</span><br><span class="line">27526 root     -                            \_ [kworker/3:1]</span><br><span class="line">31567 root     -                            \_ [kworker/3:0]</span><br><span class="line">  789 root     -                            \_ [kworker/0:1]</span><br><span class="line"> 1157 root     -                            \_ [kworker/3:2]</span><br><span class="line">    1 root     -                           /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">  619 root     10:devices:/system.slice,5: /usr/lib/systemd/systemd-journald</span><br><span class="line">  631 root     10:devices:/system.slice,5: /usr/lib/systemd/systemd-udevd</span><br><span class="line">  642 root     10:devices:/system.slice,5: /usr/sbin/lvmetad -f</span><br><span class="line">  775 root     10:devices:/system.slice,5: /sbin/auditd</span><br><span class="line">  799 polkitd  10:devices:/system.slice,5: /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">  801 dbus     10:devices:/system.slice,5: /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">  807 root     10:devices:/system.slice,5: /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">  808 root     10:devices:/system.slice,5: /usr/sbin/irqbalance --foreground</span><br><span class="line">  810 root     10:devices:/system.slice,5: /usr/lib/systemd/systemd-logind</span><br><span class="line">  811 root     10:devices:/system.slice,5: /usr/sbin/rsyslogd -n</span><br><span class="line">  822 root     10:devices:/system.slice,5: /usr/sbin/crond -n</span><br><span class="line">  828 root     10:devices:/system.slice/sy /sbin/agetty --noclear tty1 linux</span><br><span class="line"> 1067 root     10:devices:/system.slice,5: /usr/sbin/sshd -D</span><br><span class="line">30318 root     10:devices:/user.slice,5:me  \_ sshd: root@pts/0</span><br><span class="line">30330 root     10:devices:/user.slice,5:me  |   \_ -bash</span><br><span class="line"> 3792 root     10:devices:/user.slice,5:me  |       \_ ps xawf -eo pid,user,cgroup,args</span><br><span class="line">30321 root     10:devices:/user.slice,5:me  \_ sshd: root@notty</span><br><span class="line">30323 root     10:devices:/user.slice,5:me      \_ /usr/libexec/openssh/sftp-server</span><br><span class="line"> 1068 root     10:devices:/system.slice,5: /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class="line"> 1273 root     10:devices:/system.slice,5: /usr/libexec/postfix/master -w</span><br><span class="line"> 1278 postfix  10:devices:/system.slice,5:  \_ qmgr -l -t unix -u</span><br><span class="line">31586 postfix  10:devices:/system.slice,5:  \_ pickup -l -t unix -u</span><br><span class="line">28032 root     10:devices:/system.slice,5: /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubel</span><br><span class="line">28707 root     10:devices:/system.slice,5: /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=dock</span><br><span class="line">28718 root     10:devices:/system.slice,5:  \_ /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-i</span><br><span class="line">29263 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 656d2e92ba35f027e0e92fffac799555bd6ccff39524851ffe2d8808fdb6c907</span><br><span class="line">29282 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29302 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 15ff649777e6904c365d82f043d1d961f2418c81da6f87758736ee44418ade08</span><br><span class="line">29320 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29336 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current a1f2c42182828f2f82ac581878034b185572eaa823ad807eaf503df39f820031</span><br><span class="line">29388 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29337 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 121185d5f53ead31d941319e3042395f45b6cb8c1d7dd93fa89b773434b79b27</span><br><span class="line">29387 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29364 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current a87c101f9b6ea444a750c0f0b84cd71aada64fd6d707ea5aa48722603b2aba21</span><br><span class="line">29410 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29413 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current eae566bf29ac4a378a7a9f651907830779fee7b213e15b090c5471d725a50601</span><br><span class="line">29477 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29416 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 8b8770f404adda78586dc7235f6d0e056b821c83d06e3d662c34ae4474f85259</span><br><span class="line">29476 root     11:perf_event:/kubepods.sli      |   \_ /pause</span><br><span class="line">29604 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 8e47ef924ee32f6d6107f7fb20632743824e9d8dfdce456c3692b13fbf6f9e52</span><br><span class="line">29636 root     11:perf_event:/kubepods.sli      |   \_ kube-apiserver --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,</span><br><span class="line">29725 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current cdc819cd61bc462cf5e86d0177899c228337c3894032964b3bc5a9fde7178f3c</span><br><span class="line">29776 root     11:perf_event:/kubepods.sli      |   \_ /usr/<span class="built_in">local</span>/bin/kube-proxy --config=/var/lib/kube-proxy/config.conf</span><br><span class="line">29992 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current bea14b22d6090441b8f4bc9f89fe416d06875b272816f2a0ffb30cb7f77509d5</span><br><span class="line">30010 root     11:perf_event:/kubepods.sli      |   \_ /kube-dns --domain=cluster.local. --dns-port=10053 --config-dir=/kube-dns-config --v=2</span><br><span class="line">30052 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 121a05887cfe505afc373824dbeb5265752b13f1e604312b5942fec6b2972978</span><br><span class="line">30070 root     11:perf_event:/kubepods.sli      |   \_ /dnsmasq-nanny -v=2 -logtostderr -configDir=/etc/k8s/dns/dnsmasq-nanny -restartDnsmasq=<span class="literal">true</span> -- -k --c</span><br><span class="line">30109 root     11:perf_event:/kubepods.sli      |       \_ /usr/sbin/dnsmasq -k --cache-size=1000 --no-negcache --<span class="built_in">log</span>-facility=- --server=/cluster.local/127</span><br><span class="line">30110 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 17344939037d910e213e62acbe564f6c8b104d4fb000bc393ca360ff01972c5c</span><br><span class="line">30127 65534    11:perf_event:/kubepods.sli      |   \_ /sidecar --v=2 --logtostderr --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,S</span><br><span class="line">30168 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current a0e3d010c40a7732eff4c36160792a681f4e437c1cf34a71e9af990b7ecf0343</span><br><span class="line">30186 root     11:perf_event:/kubepods.sli      |   \_ /opt/bin/flanneld --ip-masq --kube-subnet-mgr</span><br><span class="line">10409 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 2995b17f7b1cf824c99ac68bd414f3784dc82942c427f26f7a08a3a384c20612</span><br><span class="line">10432 root     11:perf_event:/kubepods.sli      |   \_ etcd --advertise-client-urls=https://127.0.0.1:2379 --client-cert-auth=<span class="literal">true</span> --data-dir=/var/lib/etcd</span><br><span class="line">13536 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current 8f92f56afabea9689b1d9fb996318d5e2aad26c2c369fd246c15b86ba064b15f</span><br><span class="line">13554 root     11:perf_event:/kubepods.sli      |   \_ kube-controller-manager --kubeconfig=/etc/kubernetes/controller-manager.conf --cluster-signing-cert<span class="_">-f</span></span><br><span class="line">13594 root     10:devices:/system.slice,5:      \_ /usr/bin/docker-containerd-shim-current cfdcde0fa4265b33d40c2059c070af0ae1ef7649d7933168bfa4cc12a5da5c59</span><br><span class="line">13612 root     11:perf_event:/kubepods.sli          \_ kube-scheduler --leader-elect=<span class="literal">true</span> --kubeconfig=/etc/kubernetes/scheduler.conf --address=127.0.0.1</span><br><span class="line">28378 root     10:devices:/user.slice,5:me /usr/sbin/anacron -s</span><br></pre></td></tr></table></figure>
<p>提供相同信息的另一种方式是<code>systemd附带</code>的 <code>systemd-cgls</code>工具。它在树中显示cgroup层次结构。它的输出如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kubernetes-node1 ~]<span class="comment"># systemd-cgls</span></span><br><span class="line">├─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">├─kubepods.slice</span><br><span class="line">│ ├─kubepods-besteffort.slice</span><br><span class="line">│ │ ├─kubepods-besteffort-podf461fa39_3cb7_11e8_bb32_00505696e13c.slice</span><br><span class="line">│ │ │ ├─docker-a0e3d010c40a7732eff4c36160792a681f4e437c1cf34a71e9af990b7ecf0343.scope</span><br><span class="line">│ │ │ │ └─30186 /opt/bin/flanneld --ip-masq --kube-subnet-mgr</span><br><span class="line">│ │ │ └─docker-a1f2c42182828f2f82ac581878034b185572eaa823ad807eaf503df39f820031.scope</span><br><span class="line">│ │ │   └─29388 /pause</span><br><span class="line">│ │ ├─kubepods-besteffort-podaea86e6c_3cb7_11e8_bb32_00505696e13c.slice</span><br><span class="line">│ │ │ ├─docker-cdc819cd61bc462cf5e86d0177899c228337c3894032964b3bc5a9fde7178f3c.scope</span><br><span class="line">│ │ │ │ └─kube-proxy</span><br><span class="line">│ │ │ │   └─29776 /usr/<span class="built_in">local</span>/bin/kube-proxy --config=/var/lib/kube-proxy/config.conf</span><br><span class="line">│ │ │ └─docker-a87c101f9b6ea444a750c0f0b84cd71aada64fd6d707ea5aa48722603b2aba21.scope</span><br><span class="line">│ │ │   └─29410 /pause</span><br><span class="line">│ │ └─kubepods-besteffort-podd0f5be64eb96701ecb2dfd99040bdae9.slice</span><br><span class="line">│ │   ├─docker-2995b17f7b1cf824c99ac68bd414f3784dc82942c427f26f7a08a3a384c20612.scope</span><br><span class="line">│ │   │ └─10432 etcd --advertise-client-urls=https://127.0.0.1:2379 --client-cert-auth=<span class="literal">true</span> --data-dir=/var/lib/etcd --cert-file=/etc/kubernetes/pki/etcd/se</span><br><span class="line">│ │   └─docker-15ff649777e6904c365d82f043d1d961f2418c81da6f87758736ee44418ade08.scope</span><br><span class="line">│ │     └─29320 /pause</span><br><span class="line">│ └─kubepods-burstable.slice</span><br><span class="line">│   ├─kubepods-burstable-podaebaceba_3cb7_11e8_bb32_00505696e13c.slice</span><br><span class="line">│   │ ├─docker-17344939037d910e213e62acbe564f6c8b104d4fb000bc393ca360ff01972c5c.scope</span><br><span class="line">│   │ │ └─30127 /sidecar --v=2 --logtostderr --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,SRV --probe=dnsmasq,127.0.0.1:53,kuberne</span><br><span class="line">│   │ ├─docker-121a05887cfe505afc373824dbeb5265752b13f1e604312b5942fec6b2972978.scope</span><br><span class="line">│   │ │ ├─30070 /dnsmasq-nanny -v=2 -logtostderr -configDir=/etc/k8s/dns/dnsmasq-nanny -restartDnsmasq=<span class="literal">true</span> -- -k --cache-size=1000 --no-negcache --<span class="built_in">log</span>-faci</span><br><span class="line">│   │ │ └─30109 /usr/sbin/dnsmasq -k --cache-size=1000 --no-negcache --<span class="built_in">log</span>-facility=- --server=/cluster.local/127.0.0.1<span class="comment">#10053 --server=/in-addr.arpa/127.0.0</span></span><br><span class="line">│   │ ├─docker-bea14b22d6090441b8f4bc9f89fe416d06875b272816f2a0ffb30cb7f77509d5.scope</span><br><span class="line">│   │ │ └─30010 /kube-dns --domain=cluster.local. --dns-port=10053 --config-dir=/kube-dns-config --v=2</span><br><span class="line">│   │ └─docker-eae566bf29ac4a378a7a9f651907830779fee7b213e15b090c5471d725a50601.scope</span><br><span class="line">│   │   └─29477 /pause</span><br><span class="line">│   ├─kubepods-burstable-pod498af058d9a8b33f17a3c7deeec06574.slice</span><br><span class="line">│   │ ├─docker-8f92f56afabea9689b1d9fb996318d5e2aad26c2c369fd246c15b86ba064b15f.scope</span><br><span class="line">│   │ │ └─13554 kube-controller-manager --kubeconfig=/etc/kubernetes/controller-manager.conf --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt --contro</span><br><span class="line">│   │ └─docker-8b8770f404adda78586dc7235f6d0e056b821c83d06e3d662c34ae4474f85259.scope</span><br><span class="line">│   │   └─29476 /pause</span><br><span class="line">│   ├─kubepods-burstable-podda46e5eb58febd64dd66deab8e98a51b.slice</span><br><span class="line">│   │ ├─docker-8e47ef924ee32f6d6107f7fb20632743824e9d8dfdce456c3692b13fbf6f9e52.scope</span><br><span class="line">│   │ │ └─29636 kube-apiserver --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestrictio</span><br><span class="line">│   │ └─docker-656d2e92ba35f027e0e92fffac799555bd6ccff39524851ffe2d8808fdb6c907.scope</span><br><span class="line">│   │   └─29282 /pause</span><br><span class="line">│   └─kubepods-burstable-pod099f1c2b79126109140a1f77e211df00.slice</span><br><span class="line">│     ├─docker-cfdcde0fa4265b33d40c2059c070af0ae1ef7649d7933168bfa4cc12a5da5c59.scope</span><br><span class="line">│     │ └─13612 kube-scheduler --leader-elect=<span class="literal">true</span> --kubeconfig=/etc/kubernetes/scheduler.conf --address=127.0.0.1</span><br><span class="line">│     └─docker-121185d5f53ead31d941319e3042395f45b6cb8c1d7dd93fa89b773434b79b27.scope</span><br><span class="line">│       └─29387 /pause</span><br><span class="line">├─user.slice</span><br><span class="line">│ └─user-0.slice</span><br><span class="line">│   ├─session-131.scope</span><br><span class="line">│   │ ├─30321 sshd: root@notty</span><br><span class="line">│   │ └─30323 /usr/libexec/openssh/sftp-server</span><br><span class="line">│   ├─session-130.scope</span><br><span class="line">│   │ ├─ 4343 systemd-cgls</span><br><span class="line">│   │ ├─ 4344 less</span><br><span class="line">│   │ ├─30318 sshd: root@pts/0</span><br><span class="line">│   │ └─30330 -bash</span><br><span class="line">│   └─session-129.scope</span><br><span class="line">│     └─28378 /usr/sbin/anacron -s</span><br><span class="line">└─system.slice</span><br><span class="line">  ├─kubelet.service</span><br><span class="line">  │ └─28032 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --pod-manifest-path=/et</span><br><span class="line">  ├─tuned.service</span><br><span class="line">  │ └─1068 /usr/bin/python -Es /usr/sbin/tuned -l -P</span><br><span class="line">  ├─sshd.service</span><br><span class="line">  │ └─1067 /usr/sbin/sshd -D</span><br><span class="line">  ├─postfix.service</span><br><span class="line">  │ ├─ 1273 /usr/libexec/postfix/master -w</span><br><span class="line">  │ ├─ 1278 qmgr -l -t unix -u</span><br><span class="line">  │ └─31586 pickup -l -t unix -u</span><br><span class="line">  ├─docker.service</span><br><span class="line">  │ ├─10409 /usr/bin/docker-containerd-shim-current 2995b17f7b1cf824c99ac68bd414f3784dc82942c427f26f7a08a3a384c20612 /var/run/docker/libcontainerd/2995b17f7</span><br><span class="line">  │ ├─13536 /usr/bin/docker-containerd-shim-current 8f92f56afabea9689b1d9fb996318d5e2aad26c2c369fd246c15b86ba064b15f /var/run/docker/libcontainerd/8f92f56af</span><br><span class="line">  │ ├─13594 /usr/bin/docker-containerd-shim-current cfdcde0fa4265b33d40c2059c070af0ae1ef7649d7933168bfa4cc12a5da5c59 /var/run/docker/libcontainerd/cfdcde0fa</span><br><span class="line">  │ ├─28707 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --<span class="built_in">exec</span>-opt native.cgrou</span><br><span class="line">  │ ├─28718 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --<span class="built_in">stat</span></span><br><span class="line">  │ ├─29263 /usr/bin/docker-containerd-shim-current 656d2e92ba35f027e0e92fffac799555bd6ccff39524851ffe2d8808fdb6c907 /var/run/docker/libcontainerd/656d2e92b</span><br><span class="line">  │ ├─29302 /usr/bin/docker-containerd-shim-current 15ff649777e6904c365d82f043d1d961f2418c81da6f87758736ee44418ade08 /var/run/docker/libcontainerd/15ff64977</span><br><span class="line">  │ ├─29336 /usr/bin/docker-containerd-shim-current a1f2c42182828f2f82ac581878034b185572eaa823ad807eaf503df39f820031 /var/run/docker/libcontainerd/a1f2c4218</span><br><span class="line">  │ ├─29337 /usr/bin/docker-containerd-shim-current 121185d5f53ead31d941319e3042395f45b6cb8c1d7dd93fa89b773434b79b27 /var/run/docker/libcontainerd/121185d5f</span><br><span class="line">  │ ├─29364 /usr/bin/docker-containerd-shim-current a87c101f9b6ea444a750c0f0b84cd71aada64fd6d707ea5aa48722603b2aba21 /var/run/docker/libcontainerd/a87c101f9</span><br><span class="line">  │ ├─29413 /usr/bin/docker-containerd-shim-current eae566bf29ac4a378a7a9f651907830779fee7b213e15b090c5471d725a50601 /var/run/docker/libcontainerd/eae566bf2</span><br><span class="line">  │ ├─29416 /usr/bin/docker-containerd-shim-current 8b8770f404adda78586dc7235f6d0e056b821c83d06e3d662c34ae4474f85259 /var/run/docker/libcontainerd/8b8770f40</span><br><span class="line">  │ ├─29604 /usr/bin/docker-containerd-shim-current 8e47ef924ee32f6d6107f7fb20632743824e9d8dfdce456c3692b13fbf6f9e52 /var/run/docker/libcontainerd/8e47ef924</span><br><span class="line">  │ ├─29725 /usr/bin/docker-containerd-shim-current cdc819cd61bc462cf5e86d0177899c228337c3894032964b3bc5a9fde7178f3c /var/run/docker/libcontainerd/cdc819cd6</span><br><span class="line">  │ ├─29992 /usr/bin/docker-containerd-shim-current bea14b22d6090441b8f4bc9f89fe416d06875b272816f2a0ffb30cb7f77509d5 /var/run/docker/libcontainerd/bea14b22d</span><br><span class="line">  │ ├─30052 /usr/bin/docker-containerd-shim-current 121a05887cfe505afc373824dbeb5265752b13f1e604312b5942fec6b2972978 /var/run/docker/libcontainerd/121a05887</span><br><span class="line">  │ ├─30110 /usr/bin/docker-containerd-shim-current 17344939037d910e213e62acbe564f6c8b104d4fb000bc393ca360ff01972c5c /var/run/docker/libcontainerd/173449390</span><br><span class="line">  │ └─30168 /usr/bin/docker-containerd-shim-current a0e3d010c40a7732eff4c36160792a681f4e437c1cf34a71e9af990b7ecf0343 /var/run/docker/libcontainerd/a0e3d010c</span><br><span class="line">  ├─crond.service</span><br><span class="line">  │ └─822 /usr/sbin/crond -n</span><br><span class="line">  ├─rsyslog.service</span><br><span class="line">  │ └─811 /usr/sbin/rsyslogd -n</span><br><span class="line">  ├─systemd-logind.service</span><br><span class="line">  │ └─810 /usr/lib/systemd/systemd-logind</span><br><span class="line">  ├─irqbalance.service</span><br><span class="line">  │ └─808 /usr/sbin/irqbalance --foreground</span><br><span class="line">  ├─NetworkManager.service</span><br><span class="line">  │ └─807 /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">  ├─dbus.service</span><br><span class="line">  │ └─801 /bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation</span><br><span class="line">  ├─polkit.service</span><br><span class="line">  │ └─799 /usr/lib/polkit-1/polkitd --no-debug</span><br><span class="line">  ├─auditd.service</span><br><span class="line">  │ └─775 /sbin/auditd</span><br><span class="line">  ├─lvm2-lvmetad.service</span><br><span class="line">  │ └─642 /usr/sbin/lvmetad -f</span><br><span class="line">  ├─systemd-udevd.service</span><br><span class="line">  │ └─631 /usr/lib/systemd/systemd-udevd</span><br><span class="line">  ├─system-getty.slice</span><br><span class="line">  │ └─getty@tty1.service</span><br><span class="line">  │   └─828 /sbin/agetty --noclear tty1 linux</span><br><span class="line">  └─systemd-journald.service</span><br><span class="line">    └─619 /usr/lib/systemd/systemd-journald</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，这个命令显示了他们的cgroup进程以及服务，因为systemd在服务之后标记了cgroup。例如，您可以轻松看到审计服务 <code>auditd.service</code>生成三个单独的进程， <code>auditd</code>，<code>audisp</code>和<code>sedispatch</code>。</p>
<p>如果仔细观察，您会注意到已将一些进程分配给cgroup <code>/user/1</code>。在这一点，简单地将它留在该systemd中，不仅在cgroup中维护服务，还在用户会话进程中维护服务。</p>
<h1 id="如何将SysV-Init脚本转换为systemd服务文件？"><a href="#如何将SysV-Init脚本转换为systemd服务文件？" class="headerlink" title="如何将SysV Init脚本转换为systemd服务文件？"></a>如何将SysV Init脚本转换为systemd服务文件？</h1><p>传统上，Unix和Linux服务（<em>守护进程</em>）通过SysV init脚本启动。这些是Bourne Shell脚本，通常驻留在诸如<code>/etc/rc.d/init.d/</code>的目录中，当使用诸如<code>start</code>，<code>stop</code>或<code>restart</code>控制之类的一些标准化参数之一调用时 ，即启动，停止或重新启动有问题的服务。对于这个开始通常包括调用后台程序二进制文件，然后派生一个后台进程（更准确地说<em>daemonizes</em>）。Shell脚本通常很慢，很难阅读，非常冗长和脆弱。虽然它们非常灵活（毕竟它们只是代码），但有些事情很难与shell脚本正确配合，例如命令执行parallized执行，正确监督进程或只是配置执行上下文的所有细节。systemd提供了与这些shell脚本的兼容性，但由于指出了缺陷，建议为安装的所有守护程序安装本机systemd服务文件。另外，与SysV初始化脚本相比，它必须根据分发系统进行调整。服务文件与任何运行systemd的分发版（现在变得越来越多）兼容。接下来的内容是一个简洁的指南，指导如何使用SysV初始化脚本并将其转换为本地systemd服务文件。理想的情况下，上游项目应该将systemd服务文件发布并安装到它们的tarball中。如果您已经根据指导原则成功转换了一个SysV脚本，那么将该文件作为补丁提交给上游可能是一个好主意。如何准备这样的补丁将在稍后的部分中讨论，使用systemd手册页出货包含大量关于此的有用信息。</p>
<p>所以，让我们直接作为一个例子，我们将把ABRT守护进程的init脚本转换为一个systemd服务文件。ABRT是每个Fedora安装的标准组件，并且是Automatic Bug Reporting Tool的缩写，它很好地描述了它的功能，即它是用于收集崩溃转储的服务。</p>
<p>转换这种脚本时的第一步是读取它，并从通常非常长的脚本中提取有用的信息。在几乎所有情况下，脚本都由大部分样板代码组成，这些代码在所有init脚本中都相同或至少非常相似，并且通常从一个到另一个复制和粘贴。那么，让我们从上面链接的脚本中提取有趣的信息：</p>
<ul>
<li>该服务的描述字符串是“ <em>用于检测应用程序崩溃的守护程序</em> ”。事实证明，标题注释包括多余的描述字符串，其中一些描述的实际服务较少，但是启动脚本的init脚本较少。systemd服务也包含描述，它应该描述服务而不是服务文件。</li>
<li>LSB头包含依赖信息。systemd由于其围绕基于套接字的激活而设计，通常不需要（或很少）手动配置的依赖关系。（有关套接字激活的详细信息，在这种情况下，对<code>$syslog</code>（对abrtd进行编码需要syslog守护进程）的依赖关系 是唯一有价值的信息。虽然头文件列出了另一个依赖项（<code>$local_fs</code>），但这对于systemd是冗余的，因为正常的系统服务始终在所有本地文件系统可用的情况下启动。</li>
<li>LSB头部表明这个服务应该以运行级别3（多用户）和5（图形）开始。</li>
<li>守护进程二进制文件是<code>/usr/sbin/abrtd</code></li>
</ul>
<p>这已经是了。这个115行shell脚本的全部剩余内容仅仅是样板文件或其他冗余代码：处理同步和序列化启动（即与锁文件有关的代码）或输出状态消息（即代码调用回显）的代码，或者干脆解析动词。</p>
<p>从上面提取的信息中，我们现在可以编写我们的systemd服务文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Daemon to detect crashing apps</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/sbin/abrtd</span><br><span class="line">Type=forking</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>对该文件内容的一点解释： <code>[Unit]</code>部分包含有关服务的一般信息。systemd不仅管理系统服务，还管理系统的设备，挂载点，定时器和其他组件。systemd中所有这些对象的通用术语是一个<em>单元</em>， <code>[单元]</code>部分对其信息进行编码，这些信息不仅适用于服务，还适用于其他单元类型systemd维护。在这种情况下，我们设置以下单元设置：我们设置描述字符串并配置守护程序应在Syslog [2]之后启动，类似于原始初始化脚本的LSB标头中编码的内容。对于这个Syslog依赖关系，我们创建了一个<code>After=</code>类型的依赖关系<code>`在systemd单元</code>syslog.target上<code>。后者是systemd中的一个特殊目标单元，并且是引入syslog实现的标准化名称。请注意，</code>After=`类型的依赖关系只编码建议的顺序，但实际上并不会导致在abrtd时启动syslog - 而这正是我们想要的，因为即使没有syslog，abrtd实际上也能正常工作。但是，如果两者都开始（通常它们是），那么它们的顺序就由这种依赖性来控制。</p>
<p>下一部分是<code>[Service]</code>，它编码有关服务本身的信息。它包含所有那些仅适用于服务的设置，而不包括系统维护的其他类型的单元（挂载点，设备，定时器…）。这里使用两个设置： <code>ExecStart=</code>在启动服务时获取执行二进制文件的路径。使用<code>Type=</code>我们配置服务如何通知init系统启动完成。由于传统的Unix守护进程在分叉并初始化后台守护进程后返回父进程，我们将类型设置为<code>分叉</code>这里。这告诉systemd等待启动二进制返回，然后考虑进程在守护进程之后仍然运行。</p>
<p>最后一节是<code>[Install]</code>。它编码关于建议的安装应该是什么样子的信息，即在哪些情况下以及由哪些触发器启动服务。在这种情况下，我们简单地说，当多用户。<code>目标</code>单元被激活时，该服务应该开始。这是一个特殊的单元，它基本上扮演着经典的SysV Runlevel 3 的角色。<code>WantedBy=</code>设置在运行时对守护进程影响不大。它只能由<code>systemctl enable</code>命令读取 ，这是在systemd中启用服务的推荐方式。该命令将确保我们的小服务在<code>multi-user.target</code>立即自动激活。</p>
<p>就是这样。现在我们已经有了一个最小的工作systemd服务文件。为了测试它，我们将它复制到 <code>/etc/systemd/system/abrtd.service</code>并调用<code>systemctl daemon-reload</code>。这将使systemd注意到它，现在我们可以使用它启动服务：<code>systemctl start abrtd.service</code>。我们可以通过<code>systemctl status abrtd.service</code>来验证<code>状态</code>。我们可以通过<code>systemctl stop abrtd.service</code>再次停止它。最后，我们可以启用它，以便<code>systemctl enable abrtd.service</code>在将来的引导中默认激活它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=ABRT Automated Bug Reporting Tool</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=dbus</span><br><span class="line">BusName=com.redhat.abrt</span><br><span class="line">ExecStart=/usr/sbin/abrtd -d -s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>那么，我们改变了什么？有两件事：我们稍微改进了描述字符串。但更重要的是，我们将服务类型更改为<code>dbus</code>并配置了服务的D-Bus总线名称。我们为什么这样做？正如所提到的经典SysV服务 <em>守护进程</em>启动后，通常涉及双重分叉和从任何终端分离。当通过脚本调用守护进程时，这是非常有用和必要的，但在使用适当的进程保护程序（如systemd）时，这是不必要的（并且很慢），并且会适得其反。原因在于分叉守护进程通常与systemd启动的原始进程没有什么关系（在所有的守护进程方案的整个想法是去除这个关系之后），因此systemd很难在fork之后找出完成哪个进程属于服务实际上是主进程，哪些进程可能只是辅助进程。但是，这些信息对于实施高级保姆至关重要，即监督过程，异常终止的自动重生，collectig崩溃和退出代码信息等。为了让systemd更容易找出守护进程的主进程，我们将服务类型更改为 <code>dbus</code>。这种服务类型的语义适用于所有在D-Bus系统总线上取名的服务，作为其初始化的最后一步。ABRT就是其中之一。通过这个设置，systemd将生成ABRT进程，该进程将不再分叉（这是通过<code>-d -s</code>开关配置到守护进程中），并且只要<code>com.redhat.abrt</code>出现，systemd就会认为服务已完全启动公交车。这样systemd产生的进程是守护进程的主要进程，systemd有一个可靠的方法来确定守护进程何时完全启动，并且systemd可以很容易地监督它。</p>
<p>这就是它的全部。我们现在有一个简单的systemd服务文件，它比在115中编码的原始SysV init脚本编码10行更多的信息。即使现在，利用更多功能systemd提供了进一步改进的空间。例如，我们可以设置<code>Restart=restart-always</code> 总是<code>告诉systemd在它停止时自动重启这个服务。或者，我们可以使用</code>OOMScoreAdjust=-500<code>来请求内核在OOM杀手发生严重破坏时请留下这个过程。或者，我们可以使用</code>CPUSchedulingPolicy=idle`来确保abrtd进程仅在后台崩溃转储，始终允许内核优先考虑可能正在运行的任何其他操作并需要CPU时间。</p>
<p>当然，并非所有的SysV脚本都像这一个一样容易转换。但事实证明绝大多数实际上是。</p>
<h1 id="关闭的三个级别"><a href="#关闭的三个级别" class="headerlink" title="关闭的三个级别"></a>关闭的三个级别</h1><p>在systemd中，有三个关闭服务的级别。让我们来看看这些是：</p>
<ol>
<li>你可以 <strong>停止 </strong>一个服务. 这只是终止服务的运行实例，并没有别的。如果由于某种形式的激活（例如手动激活，套接字激活，总线激活，通过系统启动激活或通过硬件插头激活），则在服务被再次请求时将被启动。因此停止服务是一项非常简单，暂时和肤浅的操作。以下是如何为NTP服务执行此操作的示例：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl stop ntpd.service</span><br></pre></td></tr></table></figure>
<p>   这大致等同于大多数SysV灵感系统可用的以下传统命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ service ntpd stop</span><br></pre></td></tr></table></figure></p>
<p>   如果你执行后一个命令，它将被透明地转换为前者。</p>
<ol>
<li><p>您可以<strong>禁用</strong>服务。这从它的激活触发器中解除了一项服务。这意味着，取决于您的服务，它将不再在启动时通过套接字或总线激活或通过硬件插件（或任何其他适用于它的触发器）来激活。但是，如果您愿意，您仍然可以手动启动它。如果已经有一个已启动的实例，禁用一个服务将<em>不会</em>产生停止它的效果。以下是如何禁用服务的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> ntpd.service</span><br></pre></td></tr></table></figure>
<p>这大致等同于以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chkconfig ntpd off</span><br></pre></td></tr></table></figure>
<p>如果有必要，后者的命令也会透明地转换为前者。</p>
<p>通常，您希望合并停止和禁用服务，以摆脱当前实例并确保它不会再次启动（除非手动触发）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> ntpd.service </span><br><span class="line">$ systemctl stop ntpd.service</span><br></pre></td></tr></table></figure>
<p>这样的命令例如在Fedora上卸载systemd服务的过程中使用。</p>
<p>禁用服务是永久性的变化; 直到你撤销它，即使在重新启动时，它也会被保留。</p>
</li>
<li><p>你可以<strong>mask</strong>一项服务。这就像禁用服务，类似disable。它不仅确保服务不再自动启动，甚至可以确保服务甚至无法手动启动。这在systemd中是一个隐藏的功能，因为它通常不是很有用，可能会让用户感到困惑。但这是你如何做到的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ln -s /dev/null /etc/systemd/system/ntpd.service</span><br><span class="line">$ systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<p>通过将服务文件符号链接到 <code>/dev/null</code> 告诉 systemd永远不会启动相关服务并完全阻止其执行. 存储再<code>/etc/systemd/system</code> 中的单元将覆盖 <code>/lib/systemd/system</code> 具有相同名称的单元文件. 前一个目录是管理员区域，后者是您的软件包管理器的后者。通过在<code>/etc/systemd/system/ntpd.service</code> 安装符号链接， 您可以确保systemd永远不会读取上游提供的服务文件<code>/lib/systemd/system/ntpd.service</code>.</p>
<p>systemd会识别符号链接到 <code>/dev/null</code> 并将它们显示为<em>masked</em>.如果你尝试手动启动这样的服务（例如通过 <code>systemctl start</code>），这将失败并出现错误。.</p>
<p>SysV系统上的类似技巧并没有（正式）存在。但是，还有一些非官方的黑客攻击，例如编辑init脚本并在顶部放置一个 exit 0 者移除它的执行位。但是，这些解决方案有各种缺点，例如它们会干扰包管理器。</p>
<p>屏蔽服务是永久的变化，就像禁用服务一样。</p>
</li>
</ol>
<p>现在我们已经学会了如何关闭三个层面的服务,我们如何再次打开服务？<code>systemctl start</code>来撤销 <code>stop</code>,使用<code>systemctl enable</code>来撤销<code>systemctl disable</code> ,使用 <code>rm</code> 来撤销<code>ln</code></p>
<p>下一集介绍chroot sysconfig 等</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>循环不变式</title>
    <url>/2018/04/01/Program-design/Cyclic-structure-invariant/</url>
    <content><![CDATA[<h1 id="程序的正确性"><a href="#程序的正确性" class="headerlink" title="程序的正确性"></a>程序的正确性</h1><ul>
<li><p><strong>程序的正确性</strong></p>
<ul>
<li>程序能否按照预定的要求完成预定的功能，且打到预定的效果。</li>
<li>对于程序的任何一组允许的==输入数据==，程序执行后都能得到一组与之相对应的正确的==输出数据==。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>程序测试</strong></p>
<ul>
<li><p>不可能对所有可能的输入去测试其输出是否正确。</p>
</li>
<li><p>测试只能证明程序有错误，不能证明程序无错误。</p>
</li>
</ul>
</li>
<li><p><strong>程序正确性证明</strong></p>
<ul>
<li>直接对源程序证明其正确性的过程，是一种逻辑证明方法。</li>
</ul>
</li>
</ul>
<h1 id="确定循环过程是正确的"><a href="#确定循环过程是正确的" class="headerlink" title="确定循环过程是正确的"></a>确定循环过程是正确的</h1><ul>
<li><strong>找到循环不变式（<em>Loop Invariant</em>）</strong><ul>
<li>在循环体中选取一个点， 在该点处建立一个断言（<em>逻辑表达式</em>）</li>
<li>使得每次循环执行到该点时，这个逻辑表达式在循环体中总为“真”。</li>
<li>不依赖于前面所执行过的循环次数以及变化量的变化。</li>
<li>表示的是一种在循环过程进行时保持不变的性质。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p><strong>计算自然数的乘法</strong><script type="math/tex">a * b</script></p>
<ul>
<li><script type="math/tex">a+a+a+...</script> 用加法实现乘法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入a和b</span><br><span class="line">op1&#x3D;&gt;operation: i &#x3D; 0,sum &#x3D; 0</span><br><span class="line">cond&#x3D;&gt;condition: i &lt; b ?</span><br><span class="line">op2&#x3D;&gt;operation: sum &#x3D; sum + a</span><br><span class="line">op3&#x3D;&gt;operation: i &#x3D; i + 1</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出sum</span><br><span class="line">st-&gt;in-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;op2-&gt;op3(left)-&gt;cond</span><br><span class="line">cond(no)-&gt;out-&gt;e</span><br></pre></td></tr></table></figure>
<p><em>每次加一个a，循环b次</em></p>
<p><em>随着i值增加， sum逐渐趋近于所求的值</em></p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><script type="math/tex">sum = a * i</script></th>
<th>i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><script type="math/tex">sum = a * 1</script></td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">sum = a * 1</script></td>
<td>2</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">sum = a * 3</script></td>
<td>3</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>…</td>
</tr>
<tr>
<td style="text-align:left"><script type="math/tex">sum = a * b</script></td>
<td>b</td>
</tr>
</tbody>
</table>
</div>
<p>循环不变式P </p>
<ul>
<li><script type="math/tex; mode=display">sum + (b-i) * a = b * a</script></li>
<li><script type="math/tex">i = b</script> 时循环结束, sum为所求值</li>
<li>循环条件为: <script type="math/tex">i<b</script></li>
</ul>
<p><strong>采用迭代法计算两个正整数的商和余数</strong></p>
<ul>
<li>设被除数为x,除数为y,商为q,余数为r<ul>
<li>根据商和余数的关系: <script type="math/tex">x = q * y + r</script></li>
<li>令余数r的初值为被除数x</li>
<li>不断从r中减去除数y,知道无法从r中减去y时为止</li>
</ul>
</li>
<li>循环不变式P: <script type="math/tex">x = q * y + r</script><ul>
<li>r &lt; y时, 循环结束,q和r即为所求</li>
<li>循环条件为: r&gt;=y</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入x和y</span><br><span class="line">op1&#x3D;&gt;operation: q &#x3D; 0,r &#x3D; x</span><br><span class="line">cond&#x3D;&gt;condition: r &lt; y ?</span><br><span class="line">op2&#x3D;&gt;operation: r &#x3D; r - y</span><br><span class="line">op3&#x3D;&gt;operation: q &#x3D; q + 1</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出q和r</span><br><span class="line">st-&gt;in-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;op2-&gt;op3(left)-&gt;cond</span><br><span class="line">cond(no)-&gt;out-&gt;e</span><br></pre></td></tr></table></figure>
<p><em>找到合适的循环不变式只能庁程序的部分正确性,要想验证程序的完全正确行,需证明:1.循环体时可终止的;2.执行程序循环体时必须改变一个或多个变量的值,以保证在经过有限次重复后循环的控制条件不在满足.</em></p>
<h1 id="循环的可终止性"><a href="#循环的可终止性" class="headerlink" title="循环的可终止性"></a>循环的可终止性</h1><p><em>每次执行<script type="math/tex">i = i + 1</script>后, 都使得i增大,知道i值大到不再满足<script type="math/tex">i <= b</script>时,循环结束.</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入a和b</span><br><span class="line">op1&#x3D;&gt;operation: i &#x3D; 1,sum &#x3D; 0</span><br><span class="line">cond&#x3D;&gt;condition: i &lt;&#x3D; b ?</span><br><span class="line">op2&#x3D;&gt;operation: sum &#x3D; sum + a</span><br><span class="line">op3&#x3D;&gt;operation: i &#x3D; i + 1</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出sum</span><br><span class="line">st-&gt;in-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;op2-&gt;op3(left)-&gt;cond</span><br><span class="line">cond(no)-&gt;out-&gt;e</span><br></pre></td></tr></table></figure>
<p><em>每次执行 <script type="math/tex">r = r - y</script> 后,都使得r值减小,知道r值小到不再满足 <script type="math/tex">r >=y</script>时,循环结束,但不能用q作为循环控制变量.</em></p>
]]></content>
      <categories>
        <category>Program design</category>
      </categories>
      <tags>
        <tag>Cyclic invariant</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络存储管理</title>
    <url>/2018/01/24/Linux/storage/OnlineStorage/</url>
    <content><![CDATA[<p>在操作系统运行时，通常需要添加，删除或重新调整存储设备的大小，而无需重新引导。本章概述在系统运行时可用于在Red Hat Enterprise Linux 7主机系统上重新配置存储设备的过程。它涵盖了iSCSI和光纤通道存储互连; 其他互连类型可能会在未来添加。</p>
<p>本章重点介绍如何添加，删除，修改和监视存储设备。它没有详细讨论光纤通道或iSCSI协议。有关这些协议的更多信息，请参阅其他文档。</p>
<p>本章引用了各种<code>sysfs</code>对象。红帽建议<code>sysfs</code>对象名称和目录结构在主要的红帽企业Linux版本中可能会发生变化。这是因为上游Linux内核不提供稳定的内部API。有关如何以<code>sysfs</code>可移动方式引用对象的指导，请参阅内核源代码树中的文档以获取指导。<code>/usr/share/doc/kernel-doc-*version*/Documentation/sysfs-rules.txt</code></p>
<p>在线存储重新配置必须小心。过程中的系统故障或中断可能会导致意外的结果。红帽建议您在更改操作期间尽可能减少系统负载。这将减少I / O错误，内存不足错误或在配置更改期间发生的类似错误的可能性。以下部分提供了更具体的指导方针。</p>
<p>另外，Red Hat建议您在重新配置在线存储之前备份所有数据。<br><a id="more"></a></p>
<h2 id="Target-设置"><a href="#Target-设置" class="headerlink" title="Target 设置"></a>Target 设置</h2><p>帽企业版Linux 7使用<code>targetcli</code> shell作为查看，编辑和保存Linux-IO目标配置的前端，而无需直接操作内核目标的配置文件。<code>targetcli</code>工具是一个命令行界面，允许管理员将由文件，卷，本地SCSI设备或RAM磁盘支持的本地存储资源导出到远程系统。<code>targetcli</code>工具具有基于树的布局，包含内置的选项卡完成，并提供完整的自动完成支持和内联文档。</p>
<p> <code>targetcli</code>层次结构并不总是与内核接口完全匹配，因为<code>targetcli</code>在可能的情况下被简化了。</p>
<p>要确保所做的更改<code>targetcli</code>是持久性的，请启动并启用目标服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start target</span></span><br><span class="line"><span class="comment"># systemctl enable target</span></span><br></pre></td></tr></table></figure>
<h3 id="安装和运行targetcli"><a href="#安装和运行targetcli" class="headerlink" title="安装和运行targetcli"></a>安装和运行targetcli</h3><p>要安装<code>targetcli</code>, 使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install targetcli</span></span><br></pre></td></tr></table></figure>
<p>启动 <code>target</code> 服务:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start target</span></span><br></pre></td></tr></table></figure>
<p>配置<code>target</code> 开机启动:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl enable target</span></span><br></pre></td></tr></table></figure>
<p>使用<code>targetcli</code>命令，然后使用该<code>ls</code>命令进行树形界面的布局:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># targetcli</span></span><br><span class="line">:</span><br><span class="line">/&gt; ls</span><br><span class="line">o- /........................................[...]</span><br><span class="line">  o- backstores.............................[...]</span><br><span class="line">  | o- block.................[Storage Objects: 0]           </span><br><span class="line">  | o- fileio................[Storage Objects: 0]       </span><br><span class="line">  | o- pscsi.................[Storage Objects: 0]         </span><br><span class="line">  | o- ramdisk...............[Storage Ojbects: 0]          </span><br><span class="line">  o- iscsi...........................[Targets: 0]   </span><br><span class="line">  o- loopback........................[Targets: 0]</span><br></pre></td></tr></table></figure>
<p>例如，在红帽企业版Linux 7.0中，使用<code>targetcli</code>Bash命令<code>targetcli iscsi/ create</code>不起作用，并且不会返回错误。从红帽企业版Linux 7.1开始，提供了一个错误状态代码来使用<code>targetcli</code>shell脚本更有用。</p>
<h3 id="创建一个Backstore"><a href="#创建一个Backstore" class="headerlink" title="创建一个Backstore"></a>创建一个Backstore</h3><p>后台支持在本地机器上存储导出的LUN数据的不同方法。创建一个存储对象定义了backstore使用的资源。</p>
<p>在红帽企业Linux 6中，术语’backing-store’用来指代创建的映射。然而，为了避免混淆“后端存储”的各种方式，在红帽企业版Linux 7中，术语“存储对象”是指创建的映射，“后端”用于描述不同类型的后备设备。</p>
<p>LIO支持的后端设备是：</p>
<ul>
<li><p>FILEIO（Linux文件备份存储）</p>
<p>FILEIO存储对象可以支持<code>write_back</code>或<code>write_thru</code>操作。在<code>write_back</code>使本地文件系统缓存。这样可以提高性能，但会增加数据丢失的风险。建议使用<code>write_back=false</code>禁用，<code>write_back</code>以支持<code>write_thru</code>。</p>
</li>
</ul>
<p>  要创建文件夹存储对象，请运行该命令。例如： <code>/backstores/fileio create *file_name file_location file_size* write_back=false</code></p>
<p>  例如:</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; /backstores/fileio create file1 /tmp/disk1.img 200M write_back=<span class="literal">false</span></span><br><span class="line">Created fileio file1 with size 209715200</span><br></pre></td></tr></table></figure>
<ul>
<li><p>BLOCK（Linux BLOCK设备）</p>
<p>块驱动程序允许使用任何在<code>/sys/block</code>LIO中使用的块设备。这包括物理设备（例如，HDD，SSD，CD，DVD）和逻辑设备（例如软件或硬件RAID卷或LVM卷）。</p>
</li>
</ul>
<p>  <strong>BLOCK后台通常提供最好的性能。</strong></p>
<p>  要使用<code>/dev/sdb</code>块设备创建BLOCK backstore ，请使用以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; /backstores/block create name=block_backend dev=/dev/sdb</span><br><span class="line">Generating a wwn serial.</span><br><span class="line">Created block storage object block_backend using /dev/sdb.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>PSCSI（Linux直通SCSI设备）</p>
<p>任何支持直接传递SCSI命令而无需SCSI模拟的存储对象，以及与lsscsi一起出现的基础SCSI设备<code>/proc/scsi/scsi</code>（如SAS硬盘驱动器）都可以配置为后端存储。此子系统支持SCSI-3及更高版本。</p>
<p>PSCSI只能由高级用户使用。高级SCSI命令（如用于量测逻辑单元分配（ALUAs）或永久保留（例如VMware ESX和vSphere使用的那些））通常不会在设备固件中实现，并可能导致故障或崩溃。如有疑问，请使用BLOCK进行生产设置。</p>
<p>要为物理SCSI设备创建PSCSI后端存储，在本例中使用的<code>TYPE_ROM</code>设备<code>/dev/sr0</code>使用：</p>
</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">backstores/pscsi/ create name=pscsi_backend dev=/dev/sr0</span><br><span class="line">Generating a wwn serial.</span><br><span class="line">Created pscsi storage object pscsi_backend using /dev/sr0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>内存拷贝RAM磁盘（Linux RAMDISK_MCP）</p>
<p>内存拷贝RAM磁盘（<code>ramdisk</code>）为RAM磁盘提供完整的SCSI模拟，并为启动器使用内存拷贝分离内存映射。这为多会话提供了能力，并且对于用于生产目的的快速，易变的大容量存储特别有用。</p>
<p>要创建1GB RAM磁盘后端存储，请使用以下命令：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; backstores/ramdisk/ create name=rd_backend size=1GB</span><br><span class="line">Generating a wwn serial.</span><br><span class="line">Created rd_mcp ramdisk rd_backend with size 1GB.</span><br></pre></td></tr></table></figure>
<h3 id="创建-iSCSI-Target"><a href="#创建-iSCSI-Target" class="headerlink" title="创建 iSCSI Target"></a>创建 iSCSI Target</h3><p>要创建一个iSCSI目标：</p>
<ol>
<li><p>运行 <code>targetcli</code>.</p>
</li>
<li><p>进入iSCSI配置路径:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; iscsi/</span><br></pre></td></tr></table></figure>
<p>   <strong>注意</strong></p>
<p>   该<code>cd</code>命令也被接受来改变目录，以及简单地列出要移入的路径。</p>
<ol>
<li>使用默认目标名称创建一个iSCSI目标。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi&gt; create </span><br><span class="line">Created target </span><br><span class="line">iqn.2003-01.org.linux-iscsi.hostname.x8664:sn.78b473f296ff</span><br><span class="line">Created TPG1</span><br></pre></td></tr></table></figure>
<p>   或者使用指定的名称创建一个iSCSI目标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi &gt; create iqn.2006-04.com.example:444</span><br><span class="line">Created target iqn.2006-04.com.example:444</span><br><span class="line">Created TPG1</span><br></pre></td></tr></table></figure>
<ol>
<li>验证 <code>ls</code> 在列出目标时新创建的目标是否可见</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi &gt; ls</span><br><span class="line">o- iscsi.......................................[1 Target]</span><br><span class="line">    o- iqn.2006-04.com.example:444................[1 TPG] </span><br><span class="line">        o- tpg1...........................[enabled, auth]</span><br><span class="line">            o- acls...............................[0 ACL]</span><br><span class="line">            o- luns...............................[0 LUN]</span><br><span class="line">            o- portals.........................[0 Portal]</span><br></pre></td></tr></table></figure>
<h3 id="配置-iSCSI-门户"><a href="#配置-iSCSI-门户" class="headerlink" title="配置 iSCSI 门户"></a>配置 iSCSI 门户</h3><p>要配置iSCSI门户，必须首先创建iSCSI目标并将其与TPG相关联。</p>
<p><strong>Note</strong></p>
<p>从Red Hat Enterprise Linux 7.1创建iSCSI目标时，也会创建一个默认门户。此门户设置为使用默认端口号（即0.0.0.0:3260）监听所有IP地址 。删除此项并只添加指定的门户，请使用  <code>/iscsi/*iqn-name*/tpg1/portals delete ip_address=0.0.0.0 ip_port=3260</code>创建一个新门户 .</p>
<p><strong>创建一个iSCSI门户</strong></p>
<ol>
<li>进入TPG</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi&gt; iqn.2006-04.example:444/tpg1/</span><br></pre></td></tr></table></figure>
<ol>
<li><p>有两种方法可以创建一个门户网站：创建一个默认的门户网站，或创建一个门户网站来指定要监听的IP地址。</p>
<p>创建默认门户使用默认的iSCSI端口3260，并允许目标侦听该端口上的所有IP地址。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; portals/ create</span><br><span class="line">Using default IP port 3260</span><br><span class="line">Binding to INADDR_Any (0.0.0.0)</span><br><span class="line">Created network portal 0.0.0.0:3260</span><br></pre></td></tr></table></figure>
<p>   要创建指定要侦听的IP地址的门户，请使用以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; portals/ create 192.168.122.137</span><br><span class="line">Using default IP port 3260</span><br><span class="line">Created network portal 192.168.122.137:3260</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>ls</code>命令验证新创建的门户是否可见。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; ls</span><br><span class="line">o- tpg.................................. [enambled, auth]  </span><br><span class="line">    o- acls ......................................[0 ACL]</span><br><span class="line">    o- luns ......................................[0 LUN]</span><br><span class="line">    o- portals ................................[1 Portal]</span><br><span class="line">        o- 192.168.122.137:3260......................[OK]</span><br></pre></td></tr></table></figure>
<h3 id="配置LUN"><a href="#配置LUN" class="headerlink" title="配置LUN"></a>配置LUN</h3><p>要配置LUN，请先创建存储对象。</p>
<p><strong>配置LUN</strong></p>
<ol>
<li>创建已经创建的存储对象的LUN。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; luns/ create /backstores/ramdisk/ramdisk1</span><br><span class="line">Created LUN 0.</span><br><span class="line"></span><br><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; luns/ create /backstores/block/block1</span><br><span class="line">Created LUN 1.</span><br><span class="line"></span><br><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; luns/ create /backstores/fileio/file1</span><br><span class="line">Created LUN 2.</span><br></pre></td></tr></table></figure>
<ol>
<li>显示更改.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; ls</span><br><span class="line">o- tpg.................................. [enambled, auth]</span><br><span class="line">    o- acls ......................................[0 ACL]</span><br><span class="line">    o- luns .....................................[3 LUNs]</span><br><span class="line">    |  o- lun0.........................[ramdisk/ramdisk1]</span><br><span class="line">    |  o- lun1.................[block/block1 (/dev/vdb1)]</span><br><span class="line">    |  o- lun2...................[fileio/file1 (/foo.img)]</span><br><span class="line">    o- portals ................................[1 Portal]</span><br><span class="line">        o- 192.168.122.137:3260......................[OK]</span><br></pre></td></tr></table></figure>
<p>   请注意，与<code>tgtd</code>红帽企业版Linux 6中使用的情况相比，默认的LUN名称从0开始，而不是1 。</p>
<p>默认情况下，创建具有读写权限的LUN。如果在创建ACL后添加了新的LUN，该LUN将自动映射到所有可用的ACL。这可能会导致安全风险。使用以下过程以只读方式创建LUN。</p>
<p><strong>创建一个只读LUN</strong></p>
<ol>
<li>要创建具有只读权限的LUN，请首先使用以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; <span class="built_in">set</span> global auto_add_mapped_luns=<span class="literal">false</span></span><br><span class="line">Parameter auto_add_mapped_luns is now <span class="string">'false'</span>.</span><br></pre></td></tr></table></figure>
<p>   这可以防止将LUN自动映射到现有的ACL，从而允许手动映射LUN。</p>
<ol>
<li>接下来，使用该命令手动创建LUN ，<code>iscsi/*target_iqn_name*/tpg1/acls/*initiator_iqn_name*/ create mapped_lun=*next_sequential_LUN_number* tpg_lun_or_backstore=*backstore*write_protect=1</code>.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; iscsi/iqn.2015-06.com.redhat:target/tpg1/acls/iqn.2015-06.com.redhat:initiator/ create mapped_lun=1 tpg_lun_or_backstore=/backstores/block/block2 write_protect=1</span><br><span class="line">Created LUN 1.</span><br><span class="line">Created Mapped LUN 1.</span><br><span class="line">/&gt; ls</span><br><span class="line">o- / ...................................................... [...]</span><br><span class="line">  o- backstores ........................................... [...]</span><br><span class="line">  &lt;snip&gt;</span><br><span class="line">  o- iscsi ......................................... [Targets: 1]</span><br><span class="line">  | o- iqn.2015-06.com.redhat:target .................. [TPGs: 1]</span><br><span class="line">  |   o- tpg1 ............................ [no-gen-acls, no-auth]</span><br><span class="line">  |     o- acls ....................................... [ACLs: 2]</span><br><span class="line">  |     | o- iqn.2015-06.com.redhat:initiator .. [Mapped LUNs: 2]</span><br><span class="line">  |     | | o- mapped_lun0 .............. [lun0 block/disk1 (rw)]</span><br><span class="line">  |     | | o- mapped_lun1 .............. [lun1 block/disk2 (ro)]</span><br><span class="line">  |     o- luns ....................................... [LUNs: 2]</span><br><span class="line">  |     | o- lun0 ...................... [block/disk1 (/dev/vdb)]</span><br><span class="line">  |     | o- lun1 ...................... [block/disk2 (/dev/vdc)]</span><br><span class="line">  &lt;snip&gt;</span><br></pre></td></tr></table></figure>
<p>   mapped_lun1行现在在末尾有（ro）（与mapped_lun0（rw）不同），说明它是只读的。</p>
<h3 id="配置ACL"><a href="#配置ACL" class="headerlink" title="配置ACL"></a>配置ACL</h3><p>为将要连接的每个启动器创建一个ACL。这会在启动器连接时强制进行身份验证，从而只允许向每个启动器公开LUN。通常每个启动器都可以独占访问LUN。目标和发起者都有唯一的识别名称。必须知道启动程序的唯一名称才能配置ACL。对于open-iscsi启动器，可以在 <code>/etc/iscsi/initiatorname.iscsi</code> 找到。</p>
<p><strong>配置ACL</strong></p>
<ol>
<li>进入acls目录。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...mple:444/tpg1&gt; acls/</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个ACL。要么使用启动器中的启动器名称<code>/etc/iscsi/initiatorname.iscsi</code>，要么使用更容易记住的名称, 例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...444/tpg1/acls&gt; create iqn.2006-04.com.example.foo:888</span><br><span class="line">Created Node ACL <span class="keyword">for</span> iqn.2006-04.com.example.foo:888</span><br><span class="line">Created mapped LUN 2.</span><br><span class="line">Created mapped LUN 1.</span><br><span class="line">Created mapped LUN 0.</span><br></pre></td></tr></table></figure>
<p>   上面的例子的行为取决于使用的设置。在这种情况下，使用全局设置<code>auto_add_mapped_luns</code>。这会自动将LUN映射到任何创建的ACL。</p>
<ol>
<li>显示更改.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...444/tpg1/acls&gt; ls</span><br><span class="line">o- acls .................................................[1 ACL]</span><br><span class="line">    o- iqn.2006-04.com.example.foo:888 ....[3 Mapped LUNs, auth]</span><br><span class="line">        o- mapped_lun0 .............[lun0 ramdisk/ramdisk1 (rw)]</span><br><span class="line">        o- mapped_lun1 .................[lun1 block/block1 (rw)]</span><br><span class="line">        o- mapped_lun2 .................[lun2 fileio/file1 (rw)]</span><br></pre></td></tr></table></figure>
<h3 id="配置以太网光纤通道-FCoE-Target"><a href="#配置以太网光纤通道-FCoE-Target" class="headerlink" title="配置以太网光纤通道 (FCoE) Target"></a>配置以太网光纤通道 (FCoE) Target</h3><p>确认基本FCoE设置已完成，并<code>fcoeadm -i</code>显示配置的FCoE接口。</p>
<p><strong>配置FCoE目标</strong></p>
<ol>
<li><p>设置FCoE目标需要安装<code>targetcli</code>包及其相关性。</p>
</li>
<li><p>在FCoE接口上创建FCoE目标实例。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; tcm_fc/ create 00:11:22:33:44:55:66:77</span><br></pre></td></tr></table></figure>
<p>   如果系统上存在FCoE接口，则选项卡完成后将<code>create</code>列出可用接口。如果没有，请确保<code>fcoeadm -i</code>显示活动接口。</p>
<ol>
<li><p>将一个backstore映射到目标实例。</p>
<p><strong>将Backstore映射到目标实例的示例</strong></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; tcm_fc/00:11:22:33:44:55:66:77</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; luns/ create /backstores/fileio/example2</span><br></pre></td></tr></table></figure>
<ol>
<li>允许从FCoE启动器访问LUN。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; acls/ create 00:99:88:77:66:55:44:33</span><br></pre></td></tr></table></figure>
<p>   LUN现在应该可以被该启动器访问。</p>
<ol>
<li><p>要使更改在重新启动时保持不变，请在出现提示时使用<code>saveconfig</code>命令并键入<code>yes</code>。如果没有这样做，配置将在重启后丢失。</p>
</li>
<li><p>通过输入<code>exit</code>或输入 <strong>ctrl</strong>+<strong>D</strong> 退出<code>targetcli</code></p>
</li>
</ol>
<h3 id="使用-targetcli-删除对象"><a href="#使用-targetcli-删除对象" class="headerlink" title="使用 targetcli 删除对象"></a>使用 <code>targetcli</code> 删除对象</h3><p>要删除一个backstore，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; /backstores/backstore-type/backstore-name</span><br></pre></td></tr></table></figure>
<p>要删除iSCSI目标的某些部分（如ACL），请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; /iscsi/iqn-name/tpg/acls/ delete iqn-name</span><br></pre></td></tr></table></figure>
<p>要删除整个目标（包括所有ACL，LUN和门户），请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/&gt; /iscsi delete iqn-name</span><br></pre></td></tr></table></figure>
<h2 id="创建一个-ISCSI-INITIATOR"><a href="#创建一个-ISCSI-INITIATOR" class="headerlink" title="创建一个 ISCSI INITIATOR"></a>创建一个 ISCSI INITIATOR</h2><p>在红帽企业版Linux 7中，默认情况下，iSCSI服务是延迟启动的：运行<code>iscsiadm</code>命令后服务启动。</p>
<p><strong>创建一个iSCSI启动器</strong></p>
<ol>
<li>安装 <code>iscsi-initiator-utils</code>:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install iscsi-initiator-utils</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果ACL 中给出了自定义名称，则相应地修改该<code>/etc/iscsi/initiatorname.iscsi</code>文件。例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/iscsi/initiatorname.iscsi</span></span><br><span class="line">InitiatorName=iqn.2006-04.com.example.node1</span><br></pre></td></tr></table></figure>
<ol>
<li>发现 target:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t st -p target-ip-address </span></span><br><span class="line">10.64.24.179:3260,1 iqn.2006-04.com.example:3260</span><br></pre></td></tr></table></figure>
<ol>
<li>target 服务器上的TPG节点中设置用户创建的ACL：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/iscsi/iqn.20...scsi:444/tpg1&gt; <span class="built_in">set</span> attribute generate_node_acls=1</span><br></pre></td></tr></table></figure>
<pre><code>`exit` 退出
</code></pre><ol>
<li>使用在步骤3中发现的目标IQN登录到目标：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node -T iqn.2006-04.com.example:3260 -l </span></span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2006-04.com.example:3260, portal: 10.64.24.179,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2006-04.com.example:3260, portal: 10.64.24.179,3260] successful.</span><br></pre></td></tr></table></figure>
<h2 id="光纤通道"><a href="#光纤通道" class="headerlink" title="光纤通道"></a>光纤通道</h2><h3 id="Fibre-Channel-API"><a href="#Fibre-Channel-API" class="headerlink" title="Fibre Channel API"></a>Fibre Channel API</h3><p>以下是<code>/sys/class/</code>包含用于提供用户空间API的文件的目录列表。在每个项目中，主机号码由<code>*H*</code>总线号<code>*B*</code>，目标<code>*T*</code>，逻辑单元号（LUN）<code>*L*</code>和远程端口号指定<code>*R*</code>。</p>
<p>Transport: <code>/sys/class/fc_transport/target</code><em><code>H</code></em>: : <em><code>B</code></em> : <em><code>T</code></em>/</p>
<ul>
<li><code>port_id</code> — 24位端口ID /地址</li>
<li><code>node_name</code> —  64位节点名称</li>
<li><code>port_name</code> — 64位端口名称</li>
</ul>
<p>Remote Port: <code>/sys/class/fc_remote_ports/rport-H:B-R</code></p>
<ul>
<li><p><code>port_id</code></p>
</li>
<li><p><code>node_name</code></p>
</li>
<li><p><code>port_name</code></p>
</li>
<li><p><code>dev_loss_tmo</code>: 控制scsi设备何时从系统中移除。之后<code>dev_loss_tmo</code> 触发器, scsi设备被删除.</p>
<p> <code>multipath.conf</code>, 您可以设置 <code>dev_loss_tmo</code> 为<code>infinity</code>, 其值设置为 2,147,483,647 seconds, 或 68 years, 并且是 <code>dev_loss_tmo</code>最大值 .</p>
<p>在红帽企业版Linux 7中，如果不设置该<code>fast_io_fail_tmo</code>选项，<code>dev_loss_tmo</code>则上限为600秒。默认情况下，<code>fast_io_fail_tmo</code>如果<code>multipathd</code>服务正在运行，在Red Hat Enterprise Linux 7中设置为5秒; 否则，设置为<code>off</code>。</p>
</li>
<li><p><code>fast_io_fail_tmo</code>：指定在将链接标记为“不良”之前等待的秒数。一旦链接被标记为坏，现有的正在运行的I / O或其相应路径上的任何新I / O都会失败。</p>
<p>如果I / O处于阻塞队列中，则不会失败，直到<code>dev_loss_tmo</code>到期并且队列被解除阻塞。</p>
<p>如果<code>fast_io_fail_tmo</code>设置为任何值<code>off</code>，<code>dev_loss_tmo</code>则不封顶。如果<code>fast_io_fail_tmo</code>设置为<code>off</code>，则在将设备从系统中移除之前，不会发生I / O故障。如果<code>fast_io_fail_tmo</code>设置为一个数字，则当<code>fast_io_fail_tmo</code>超时触发时，I / O将立即失败。</p>
</li>
</ul>
<p>Host: <code>/sys/class/fc_host/host*H*/</code></p>
<ul>
<li><code>port_id</code></li>
<li><code>issue_lip</code>: 指示驱动程序重新发现远程端口。</li>
</ul>
<h3 id="本地光纤通道驱动程序和功能"><a href="#本地光纤通道驱动程序和功能" class="headerlink" title="本地光纤通道驱动程序和功能"></a>本地光纤通道驱动程序和功能</h3><p>红帽企业Linux 7附带下列本地光纤通道驱动程序：</p>
<ul>
<li><code>lpfc</code></li>
<li><code>qla2xxx</code></li>
<li><code>zfcp</code></li>
<li><code>bfa</code></li>
</ul>
<p> <strong>qla2xxx</strong>驱动程序启动器模式默认运行。要在Linux-IO上使用qla2xxx，请使用相应的<em>qlini_mode</em>模块参数启用光纤通道目标模式。</p>
<p>首先，确保已安装qla设备的固件包，如ql2200-固件或类似软件。</p>
<p>要启用目标模式，请将以下参数添加到<code>/usr/lib/modprobe.d/qla2xxx.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">options qla2xxx qlini_mode=disabled</span><br></pre></td></tr></table></figure>
<p>然后，使用该<code>dracut -f</code>命令重建初始ramdisk（<code>initrd</code>），然后重新引导系统以使更改生效。</p>
<p><strong>光纤通道API功能</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><code>lpfc</code></th>
<th><code>qla2xxx</code></th>
<th><code>zfcp</code></th>
<th><code>bfa</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Transport <code>port_id</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Transport <code>node_name</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Transport <code>port_name</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Remote Port <code>dev_loss_tmo</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Remote Port <code>fast_io_fail_tmo</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Host <code>port_id</code></td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Host <code>issue_lip</code></td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="通过以太网接口配置光纤通道"><a href="#通过以太网接口配置光纤通道" class="headerlink" title="通过以太网接口配置光纤通道"></a>通过以太网接口配置光纤通道</h2><p>设置和部署以太网光纤通道（FCoE）接口需要两个包：</p>
<ul>
<li><code>fcoe-utils</code></li>
<li><code>lldpad</code></li>
</ul>
<p>安装这些软件包后，请执行以下步骤以通过虚拟LAN（VLAN）启用FCoE：</p>
<p><strong>配置以太网接口以使用FCoE</strong></p>
<ol>
<li>要配置新的VLAN，请复制现有的网络脚本,  <code>/etc/fcoe/cfg-eth0</code>, a并将名称更改为支持FCoE的以太网设备。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /etc/fcoe/cfg-ethx  /etc/fcoe/cfg-ethX</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果您希望设备在启动时自动加载，  在相应的文件中进行设置  <code>ONBOOT=yes</code>  </p>
</li>
<li><p>通过运行以下命令来 启动数据中心桥接守护进程 (<code>dcbd</code>) :</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start lldpad</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于实现硬件DCBX客户端的网络接口，请跳过此步骤。</p>
<p>对于需要软件DCBX客户端的接口，通过运行以下命令在以太网接口上启用数据中心桥接：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dcbtool sc ethX dcb on</span></span><br></pre></td></tr></table></figure>
<p>   然后，运行以下命令在以太网接口上启用FCoE：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dcbtool sc ethX app:fcoe e:1</span></span><br></pre></td></tr></table></figure>
<p>   请注意，只有<code>dcbd</code>在以太网接口的设置没有改变的情况下，这些命令才有效。</p>
<ol>
<li>现在使用以下命令加载FCoE设备</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip link set dev ethX up</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用以下命令启动FCoE：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start fcoe</span></span><br></pre></td></tr></table></figure>
<p>   如果Fabric上的所有其他设置都正确，则FCoE设备即将出现。要查看已配置的FCoE设备，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fcoeadm -i</span></span><br></pre></td></tr></table></figure>
<p>在正确配置以太网接口以使用FCoE之后，Red Hat建议您设置FCoE并<code>lldpad</code>在启动时运行该服务。为此，请使用<strong>systemctl</strong>实用程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl enable lldpad</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl enable fcoe</span></span><br></pre></td></tr></table></figure>
<p>运行该<code># systemctl stop fcoe</code>命令会停止守护程序，但不会重置FCoE接口的配置。为此，请运行该<code># systemctl -s SIGHUP kill fcoe</code>命令。</p>
<p>从红帽企业版Linux 7开始，网络管理器可以查询和设置具有DCB功能的以太网接口的DCB设置。</p>
<h2 id="配置FCOE接口以在引导时自动挂载"><a href="#配置FCOE接口以在引导时自动挂载" class="headerlink" title="配置FCOE接口以在引导时自动挂载"></a>配置FCOE接口以在引导时自动挂载</h2><p>您可以通过<code>udev</code>规则<code>autofs</code>，和其他类似的方法安装新发现的磁盘。然而，有时候，特定的服务可能需要在启动时挂载FCoE磁盘。在这种情况下，应在服务运行后<em>立即</em>安装FCoE磁盘，<code>fcoe</code>并<em>在</em>启动需要FCoE磁盘的任何服务<em>之前</em>安装。</p>
<p>要将FCoE磁盘配置为在引导时自动挂载，请将适当的FCoE挂载代码添加到服务的启动脚本中<code>fcoe</code>。该<code>fcoe</code>启动脚本<code>/etc/init.d/fcoe</code>。</p>
<p>无论您使用的是简单格式的FCoE磁盘，LVM还是多路径设备节点，FCoE安装代码对于每个系统配置都是不同的。</p>
<p><strong>例25.2。FCoE安装代码</strong></p>
<p>以下是通过通配符指定安装文件系统的FCoE安装代码示例<code>/etc/fstab</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount_fcoe_disks_from_fstab()</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="built_in">local</span> timeout=20</span><br><span class="line">	    <span class="built_in">local</span> <span class="keyword">done</span>=1</span><br><span class="line">	    <span class="built_in">local</span> fcoe_disks=($(egrep <span class="string">'by-path\/fc-.*_netdev'</span> /etc/fstab | cut -d <span class="string">' '</span> -f1))</span><br><span class="line"></span><br><span class="line">	    <span class="built_in">test</span> -z <span class="variable">$fcoe_disks</span> &amp;&amp; <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line">	    <span class="built_in">echo</span> -n <span class="string">"Waiting for fcoe disks . "</span></span><br><span class="line">	    <span class="keyword">while</span> [ <span class="variable">$timeout</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">		<span class="keyword">for</span> disk <span class="keyword">in</span> <span class="variable">$&#123;fcoe_disks[*]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">if</span> ! <span class="built_in">test</span> -b <span class="variable">$disk</span>; <span class="keyword">then</span></span><br><span class="line">				<span class="keyword">done</span>=0</span><br><span class="line">				<span class="built_in">break</span></span><br><span class="line">			<span class="keyword">fi</span></span><br><span class="line">		<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">test</span> <span class="variable">$done</span> -eq 1 &amp;&amp; <span class="built_in">break</span>;</span><br><span class="line">		sleep 1</span><br><span class="line">		<span class="built_in">echo</span> -n <span class="string">". "</span></span><br><span class="line">		<span class="keyword">done</span>=1</span><br><span class="line">		<span class="built_in">let</span> timeout--</span><br><span class="line">	    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$timeout</span> -eq 0; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"timeout!"</span></span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"done!"</span></span><br><span class="line">	    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment"># mount any newly discovered disk</span></span><br><span class="line">	    mount -a 2&gt;/dev/null</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在服务脚本启动守护进程<em>之后</em>   <code>mount_fcoe_disks_from_fstab</code>函数应该被调用。  <code>fcoe</code> 脚本启动  <code>fcoemon</code> 守护进程之后. 这将挂载以下路径指定的FCoE磁盘 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-path/<span class="built_in">fc</span>-0xXX:0xXX /mnt/fcoe-disk1 ext3  defaults,_netdev    0 0</span><br><span class="line">/dev/disk/by-path/<span class="built_in">fc</span>-0xYY:0xYY /mnt/fcoe-disk2 ext3  defaults,_netdev    0 0</span><br></pre></td></tr></table></figure>
<p>与项<code>fc-</code>和<code>_netdev</code>子串启用<code>mount_fcoe_disks_from_fstab</code>功能，以确定FCoE的磁盘挂载项。</p>
<h2 id="ISCSI"><a href="#ISCSI" class="headerlink" title="ISCSI"></a>ISCSI</h2><p>本节介绍iSCSI API和<code>iscsiadm</code>实用程序。在使用该<code>iscsiadm</code>实用程序之前，<code>iscsi-initiator-utils</code>先运行安装软件包<code>yum install iscsi-initiator-utils</code>。</p>
<p>在红帽企业版Linux 7中，默认情况下iSCSI服务延迟启动。如果root不在iSCSI设备上，或者没有标有节点的节点，<code>node.startup = automatic</code>则在<code>iscsiadm</code>运行需要启动iscsid或iscsi内核模块的命令之前，iSCSI服务才会启动。例如，运行发现命令<code>iscsiadm -m discovery -t st -p ip:port</code>将导致iscsiadmin启动iSCSI服务。</p>
<p>要强制运行iscsid守护程序并加载iSCSI内核模块，请运行<code>service iscsid force-start</code>。</p>
<h3 id="iSCSI-API"><a href="#iSCSI-API" class="headerlink" title="iSCSI API"></a>iSCSI API</h3><p>要获取有关运行会话的信息，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session -P 3</span></span><br></pre></td></tr></table></figure>
<p>此命令显示会话/设备状态，会话ID（sid），一些协商参数以及可通过会话访问的SCSI设备。</p>
<p>对于较短的输出（例如，仅显示sid到节点的映射），请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session -P 0</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session</span></span><br></pre></td></tr></table></figure>
<p>这些命令以下列格式打印正在运行的会话列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">driver [sid] target_ip:port,target_portal_group_tag proper_target_name</span><br></pre></td></tr></table></figure>
<p><strong>iscsisadm -m session命令的输出</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session</span></span><br><span class="line"></span><br><span class="line">tcp [2] 10.15.84.19:3260,2 iqn.1992-08.com.netapp:sn.33615311</span><br><span class="line">tcp [3] 10.15.85.19:3260,3 iqn.1992-08.com.netapp:sn.33615311</span><br></pre></td></tr></table></figure>
<h2 id="持久命名"><a href="#持久命名" class="headerlink" title="持久命名"></a>持久命名</h2><p>红帽企业Linux提供了许多方法来识别存储设备。使用正确的选项识别每个设备时很重要，以避免无意中访问错误的设备，特别是在安装或重新格式化驱动器时</p>
<h3 id="主要和次要的存储设备"><a href="#主要和次要的存储设备" class="headerlink" title="主要和次要的存储设备"></a>主要和次要的存储设备</h3><p>由<code>sd</code>驱动程序管理的存储设备在内部由一系列主要设备编号及其相关次要编号进行标识。用于此目的的主要设备编号不在连续的范围内。每个存储设备都由一个主号码和一系列次号码来表示，这些号码用来标识设备中的整个设备或分区。分配给设备的主号码和次号码以及形式中的号码之间存在直接联系。只要驾驶员检测到新设备，就会分配可用的主号码和次号码范围。无论何时将设备从操作系统中移除，主要号码和次要号码范围都被释放以供以后再次使用。</p>
<p>主要和次要号码范围和相关<code>sd</code>名称在检测到时分配给每个设备。这意味着，<code>sd</code>如果设备检测顺序发生变化，则主号码和次号码范围以及相关联的名称之间的关联可能会发生变化。尽管在某些硬件配置（例如，使用内部SCSI控制器和磁盘的SCSI目标ID由其机箱内的物理位置分配）的情况下，这种情况并不常见。发生这种情况的例子如下：</p>
<ul>
<li>磁盘可能无法启动或响应SCSI控制器。这将导致它不被正常的设备探测器检测到。系统将无法访问磁盘，并且后续设备将具有其主要和次要编号范围，包括关联的<code>sd</code>名称向下移动。例如，如果<code>sdb</code>没有检测到通常被称为的磁盘，则通常被称为的磁盘<code>sdc</code>会显示为<code>sdb</code>。</li>
<li>SCSI控制器（主机总线适配器或HBA）可能无法初始化，导致连接到该HBA的所有磁盘不能被检测到。连接到随后探测到的HBA的任何磁盘将被分配不同的主号码范围和次号码范围，以及不同的关联<code>sd</code>名称。</li>
<li>如果系统中存在不同类型的HBA，驱动程序初始化的顺序可能会改变。这将导致连接到这些HBA的磁盘以不同的顺序被检测到。如果HBA移动到系统上不同的PCI插槽，也会发生这种情况。</li>
<li>例如，由于存储阵列或中断交换机断电，在探测存储设备时，通过光纤通道，iSCSI或FCoE适配器连接到系统的磁盘可能无法访问。当系统在电源故障后重新启动时，如果存储阵列比系统启动需要更长的时间才能联机，则可能会发生这种情况。虽然某些光纤通道驱动程序支持一种机制来指定永久SCSI目标ID到WWPN映射，但这不会导致主要和次要编号范围以及相关联的<code>sd</code>名称被保留，只会提供一致的SCSI目标ID编号。</li>
</ul>
<p>这些原因使得<code>sd</code>在引用诸如<code>/etc/fstab</code>文件中的设备时使用主要和次要号码范围或相关名称是不合需要的。可能会装入错误的设备并导致数据损坏。</p>
<p>然而，有时<code>sd</code>甚至在使用另一种机制时（例如，当设备报告错误时）仍然需要引用这些名称。这是因为Linux内核<code>sd</code>在关于设备的内核消息中使用了名称（还有SCSI主机/通道/目标/ LUN元组）。</p>
<h3 id="全球标识符（WWID）"><a href="#全球标识符（WWID）" class="headerlink" title="全球标识符（WWID）"></a>全球标识符（WWID）</h3><p>的<em>全球标识符</em>（WWID）可以可靠地识别设备中使用。这是一个持久的，与系统无关的ID，SCSI标准要求所有的SCSI设备。WWID标识符保证对于每个存储设备都是唯一的，并且独立于用于访问设备的路径。</p>
<p>此标识符可以通过发出SCSI查询获取<em>设备标识重要产品数据</em>（页面<code>0x83</code>）或设备<em>序列号</em>（页面<code>0x80</code>）来获得。从这些WWID到当前<code>/dev/sd</code>名称的映射可以在<code>/dev/disk/by-id/</code>目录中维护的符号链接中看到。</p>
<p>例如，具有页面<code>0x83</code>标识符的设备将具有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scsi-3600508b400105e210000900000490000 -&gt; ../../sda</span><br></pre></td></tr></table></figure>
<p>或者，具有页面<code>0x80</code>标识符的设备将具有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scsi-SSEAGATE_ST373453LW_3HW1RHM6 -&gt; ../../sda</span><br></pre></td></tr></table></figure>
<p>红帽企业版Linux会自动维护从该系统中基于WWID的设备名称到当前<code>/dev/sd</code>名称的正确映射。应用程序可以使用该<code>/dev/disk/by-id/</code>名称来引用磁盘上的数据，即使设备的路径发生更改，甚至在从不同系统访问设备时也是如此。</p>
<p>如果从系统到设备有多条路径，则<strong>DM多路径</strong>使用WWID来检测此<strong>路径</strong>。<strong>DM多路径</strong>然后在<code>/dev/mapper/wwid</code>目录中呈现单个“伪装置” ，例如<code>/dev/mapper/3600508b400105df70000e00000ac0000</code>。</p>
<p>命令<code>multipath -l</code>显示映射到非永久标识符：，名称和编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3600508b400105df70000e00000ac0000 dm-2 vendor,product </span><br><span class="line">[size=20G][features=1 queue_if_no_path][hwhandler=0][rw] </span><br><span class="line">\_ round-robin 0 [prio=0][active] </span><br><span class="line"> \_ 5:0:1:1 sdc 8:32  [active][undef] </span><br><span class="line"> \_ 6:0:1:1 sdg 8:96  [active][undef]</span><br><span class="line">\_ round-robin 0 [prio=0][enabled] </span><br><span class="line"> \_ 5:0:0:1 sdb 8:16  [active][undef] </span><br><span class="line"> \_ 6:0:0:1 sdf 8:80  [active][undef]</span><br></pre></td></tr></table></figure>
<p><strong>DM多路径会</strong>自动维护每个基于WWID的设备名称<code>/dev/sd</code>与系统上相应名称的正确映射。这些名称在路径更改中保持不变，并且在从不同系统访问设备时是一致的。</p>
<p>使用<strong>DM Multipath</strong><code>user_friendly_names</code>特性时，WWID被映射到表单的名称。 默认情况下，该映射在文件 <code>/etc/multipath/bindings</code>中维护. 只要该文件被保留，这些名称就是持久的。</p>
<p>除了系统提供的这些持久名称之外，您还可以使用<code>udev</code>规则来实现您自己的持久化名称，并将其映射到存储器的WWID。</p>
<h3 id="设备名称管理由udev机制-dev-disk-by"><a href="#设备名称管理由udev机制-dev-disk-by" class="headerlink" title="设备名称管理由udev机制/dev/disk/by-*"></a>设备名称管理由<code>udev</code>机制<code>/dev/disk/by-*</code></h3><p>该<code>udev</code>机制由三个主要组成部分组成：</p>
<ul>
<li><p>The kernel</p>
<p>生成添加，删除或更改设备时发送到用户空间的事件。</p>
</li>
<li><p>The <code>udevd</code> service</p>
<p>接收事件。</p>
</li>
<li><p>The <code>udev</code> rules</p>
<p>Specifies the action to take when the <code>udev</code> service receives the kernel events.指定<code>udev</code>服务收到内核事件时要执行的操作。</p>
</li>
</ul>
<p>这种机制用于Linux中的所有类型的设备，而不仅仅用于存储设备。对于存储设备，红帽企业版Linux包含的<code>udev</code>规则可以在<code>/dev/disk/</code>目录中创建符号链接，允许存储设备的内容，唯一标识符，序列号或用于访问设备的硬件路径。</p>
<ul>
<li><p><code>/dev/disk/by-label/</code></p>
<p>此目录中的条目提供了一个符号名称，该名称通过存储在设备上的内容（即数据）中的标签来引用存储设备。的<strong>BLKID</strong>实用程序用于从所述设备读取数据并确定一个名称（即，标记）的装置。例如：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-label/Boot</span><br></pre></td></tr></table></figure>
<p>该标签还可以用于<code>/etc/fstab</code>使用以下语法引用设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LABEL=Boot</span><br></pre></td></tr></table></figure>
<p><code>/dev/disk/by-uuid/</code></p>
<p>此目录中的条目提供了一个符号名称，该名称通过存储在设备上的内容（即数据）中的唯一标识符引用存储设备。的<strong>BLKID</strong>实用程序用于从设备读取数据，将获得的唯一标识符（即，UUID）的设备。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=3e6be9de-8139-11d1-9106-a43f08d823a6</span><br></pre></td></tr></table></figure>
<p><code>/dev/disk/by-id/</code></p>
<p>此目录中的条目提供了一个符号名称，该名称通过唯一标识符引用存储设备（与所有其他存储设备不同）。标识符是设备的属性，但不存储在设备上的内容（即数据）中。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05</span><br></pre></td></tr></table></figure>
<p>该ID是从设备的全球ID或设备序列号获得的。这些<code>/dev/disk/by-id/</code>条目还可以包括分区号。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-id/scsi-3600508e000000000ce506dc50ab0ad05-part1</span><br><span class="line">/dev/disk/by-id/wwn-0x600508e000000000ce506dc50ab0ad05-part1</span><br></pre></td></tr></table></figure>
<p><code>/dev/disk/by-path/</code></p>
<p>此目录中的条目提供了一个符号名称，该名称通过用于访问设备的硬件路径引用存储设备，从对PCI层次结构中存储控制器的引用开始，包括SCSI主机，通道，目标和LUN号和可选的分区号码。虽然这些名字比使用主要和次要的数字更可取<code>sd</code>名称时，必须谨慎使用以确保目标号码在光纤通道SAN环境中不发生更改（例如，通过使用持久性绑定），并且如果主机适配器移到其他位置，则更新名称的使用PCI插槽。此外，如果HBA无法探测，驱动程序以不同的顺序加载，或者系统上安装了新的HBA，SCSI主机号码可能会发生变化。旁路列表的一个例子是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0</span><br></pre></td></tr></table></figure>
<p>这些<code>/dev/disk/by-path/</code>条目还可以包括分区号，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/disk/by-path/pci-0000:03:00.0-scsi-0:1:0:0-part1</span><br></pre></td></tr></table></figure>
<h4 id="udev设备命名约定的局限性"><a href="#udev设备命名约定的局限性" class="headerlink" title="udev设备命名约定的局限性"></a><code>udev</code>设备命名约定的局限性</h4><p>以下是<code>udev</code>命名约定的一些限制。</p>
<ul>
<li>在执行查询时设备可能不可访问，因为该<code>udev</code>机制可能依赖于在<code>udev</code>处理<code>udev</code>事件的规则时查询存储设备的能力。当设备不在服务器机箱中时，这很可能发生在光纤通道，iSCSI或FCoE存储设备上。</li>
<li>内核也可能<code>udev</code>随时发送事件，导致规则被处理，<code>/dev/disk/by-*/</code>如果设备不可访问，可能导致链接被删除。</li>
<li>在<code>udev</code>事件发生时和处理时间之间可能存在一定的延迟，例如当检测到大量设备，并且用户空间<code>udevd</code>服务需要一些时间来处理每个设备的规则时。这可能会导致内核检测到设备和<code>/dev/disk/by-*/</code>名称可用之间的延迟。</li>
<li>诸如由规则调用的<strong>blkid之类的</strong>外部程序可能会在短时间内打开设备，使设备无法进入其他用途。</li>
</ul>
<h4 id="修改持久命名属性"><a href="#修改持久命名属性" class="headerlink" title="修改持久命名属性"></a>修改持久命名属性</h4><p>尽管<code>udev</code>命名属性是持久的，但是在系统重启时它们不会自行更改，有些也是可配置的。您可以为以下持久命名属性设置自定义值：</p>
<ul>
<li><code>UUID</code>：文件系统UUID</li>
<li><code>LABEL</code>：文件系统标签</li>
</ul>
<p>由于<code>UUID</code>和<code>LABEL</code>属性与文件系统有关，所以需要使用的工具取决于该分区上的文件系统。</p>
<ul>
<li>要更改<code>UUID</code>或<code>LABEL</code>XFS文件系统的属性，卸载文件系统，然后使用<strong>xfs_admin</strong>实用程序来更改属性：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># umount /dev/device</span></span><br><span class="line"><span class="comment"># xfs_admin [-U new_uuid] [-L new_label] /dev/device</span></span><br><span class="line"><span class="comment"># udevadm settle</span></span><br></pre></td></tr></table></figure>
<ul>
<li>要改变<code>UUID</code>或<code>LABEL</code>一个EXT4，ext3或ext2文件系统的属性，可以使用<strong>tune2fs</strong>实用程序：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune2fs [-U new_uuid] [-L new_label] /dev/device</span></span><br><span class="line"><span class="comment"># udevadm settle</span></span><br></pre></td></tr></table></figure>
<p>将<em>new_uuid</em>替换为您要设置的UUID; 例如<code>1cdfbc07-1c90-4984-b5ec-f61943f5ea50</code>。用标签替换<em>new_label</em> ; 例如<code>backup_data</code>。</p>
<p>更改<code>udev</code>属性发生在后台，可能需要很长时间。该<code>udevadm settle</code>命令将等待更改完全注册，这将确保您的下一个命令能够正确使用新的属性。</p>
<p>在创建新设备之后，您还应该使用该命令; 例如，在使用<strong>分开的</strong>工具创建具有自定义<code>PARTUUID</code>或<code>PARTLABEL</code>属性的分区之后，或者在创建新的文件系统之后。</p>
<h2 id="卸下存储设备"><a href="#卸下存储设备" class="headerlink" title="卸下存储设备"></a>卸下存储设备</h2><p>在删除对存储设备本身的访问之前，建议先从设备备份数据。之后，刷新I / O并删除所有操作系统对设备的引用。如果设备使用多路径，则对多路径“伪设备”和代表设备路径的每个标识符都执行此操作。如果只删除多路径设备的路径，其他路径将保留，则过程更简单，</p>
<p>当系统处于内存压力下时，不建议取出存储设备，因为I / O刷新将添加到负载。要确定内存压力的级别，运行命令<code>vmstat 1 100</code>; 如果出现以下情况，建议不要拆除设备</p>
<ul>
<li>空闲内存少于每100个10个以上采样总数的5％（该命令<code>free</code>也可用于显示总内存）。</li>
<li>交换处于活动状态（非零<code>si</code>和输出中的<code>so</code>列<code>vmstat</code>）。</li>
</ul>
<p>删除对设备的所有访问的一般过程如下所示：</p>
<ol>
<li><p>根据需要关闭设备的所有用户和备份设备数据。</p>
</li>
<li><p>使用<code>umount</code>卸载该安装的设备的文件系统。</p>
</li>
<li><p>使用<code>md</code>从任何LVM卷中移除设备。如果设备是LVM卷组的成员，则可能需要使用<code>pvmove</code>命令将数据从设备移出，然后使用<code>vgreduce</code>命令移除物理卷，<code>pvremove</code>从磁盘移除LVM元数据。</p>
</li>
<li><p>如果设备使用多路径，请运行<code>multipath -l</code>并记下设备的所有路径。之后，使用<code>multipath -f device</code>删除多路径设备。</p>
</li>
<li><p>运行 <code>blockdev --flushbufs device</code> 刷新任何未完成的I / O到设备的所有路径。 这对于原始设备来说尤为重要。</p>
</li>
<li><p>删除任何引用到设备的基于路径的名字一样<code>/dev/sd</code>，<code>/dev/disk/by-path</code>或者<code>major:minor</code> number,在应用程序，脚本，或在系统上的实用程序。这对确保未来添加的不同设备不会被误认为当前设备非常重要。</p>
</li>
<li><p>最后，从SCSI子系统中删除设备的每个路径。要做到这一点，使用命令在那里可能，例如。 <code>echo 1 &gt; /sys/block/device-name/device/delete</code> </p>
<p>此操作的另一个变体是：HBA号在哪里是HBA 上的通道，是SCSI目标ID，是LUN。</p>
<p><code>echo 1 &gt; /sys/class/scsi_device/h:c:t:l/device/delete</code>, .</p>
<p><strong>Note</strong></p>
<p>这些命令的旧形式, <code>echo &quot;scsi remove-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi</code>已被弃用。</p>
</li>
</ol>
<p>可以判断<code>device-name</code>，HBA数目，HBA信道，SCSI目标ID和LUN从各种命令，诸如设备 <code>lsscsi</code>, <code>scsi_id</code>, <code>multipath -l</code>, and <code>ls -l /dev/disk/by-</code>.</p>
<p>可以将设备从运行的系统中安全地移出。这样做不需要停止对其他设备的I/O。</p>
<p>其他过程，如物理移除设备，然后重新扫描SCSI总线，以使操作系统状态更新以反映更改。这会由于I / O超时而导致延迟，并且可能会意外删除设备。如果需要执行互连的重新扫描，则必须在I / O暂停时完成。</p>
<h2 id="删除存储设备的路径"><a href="#删除存储设备的路径" class="headerlink" title="删除存储设备的路径"></a>删除存储设备的路径</h2><p>如果要删除使用多路径的设备的路径（不影响设备的其他路径），则一般过程如下所示：</p>
<p><strong>删除存储设备的路径</strong></p>
<ol>
<li><p>删除该设备的基于路径名的任何引用，如<code>/dev/sd</code>或<code>/dev/disk/by-path</code>或<code>major:minor</code>数量，在应用程序，脚本，或在系统上的实用程序。这对确保未来添加的不同设备不会被误认为当前设备非常重要。</p>
</li>
<li><p>使用离线路径<code>echo offline &gt; /sys/block/sda/device/state</code>。</p>
<p>这将导致发送到此路径上的设备的任何后续I / O立即失败。<strong>设备映射器多路径</strong>将继续使用设备的剩余路径。</p>
</li>
<li><p>从SCSI子系统中删除路径。为了这样做，使用命令，其中可以是，例如。 <code>echo 1 &gt; /sys/block/*device-name*/device/delete``*device-name*``sde</code></p>
</li>
</ol>
<p>可以安全地从正在运行的系统中删除该路径。在此过程中不必停止I / O，因为<strong>设备映射器多路径</strong>将根据配置的路径分组和故障转移策略将I / O重新路由到其余路径。</p>
<p>其他程序，例如物理移除电缆，然后重新扫描SCSI总线以使操作系统状态更新以反映更改，不建议使用。这会由于I / O超时而导致延迟，并且可能会意外删除设备。如果需要执行互连的重新扫描，则必须在I / O暂停时完成。</p>
<h2 id="添加存储设备或路径"><a href="#添加存储设备或路径" class="headerlink" title="添加存储设备或路径"></a>添加存储设备或路径</h2><p>添加设备时，请注意，系统分配给新设备的基于路径的设备名称（例如，<code>/dev/sd</code>名称，<code>major:minor</code>编号和<code>/dev/disk/by-path</code>名称）可能以前已被移除的设备使用。因此，请确保已删除对基于路径的设备名称的所有旧引用。否则，新设备可能会被误认为旧设备。</p>
<p><strong>添加存储设备或路径</strong></p>
<ol>
<li><p>添加存储设备或路径的第一步是在物理上启用对新存储设备的访问或对现有设备的新路径。这是通过在光纤通道或iSCSI存储服务器上使用特定于供应商的命令完成的。这样做时，请注意将显示给主机的新存储的LUN值。如果存储服务器是光纤通道，请注意存储服务器的<em>全球通用节点名称</em>（WWNN），并确定存储服务器上的所有端口是否存在单个WWNN。如果不是这种情况，请记下将用于访问新LUN的每个端口的<em>全球端口名称</em>（WWPN）。</p>
</li>
<li><p>接下来，让操作系统知道新的存储设备或现有设备的路径。建议使用的命令是：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"c t l"</span> &gt;  /sys/class/scsi_host/hosth/scan</span><br></pre></td></tr></table></figure>
<p>   在前面的命令中，<em><code>h</code></em>是HBA号，<em><code>c</code></em>是HBA 上的通道，<em><code>t</code></em>是SCSI目标ID，<em><code>l</code></em>是LUN。</p>
<p>   此命令的较早形式<code>echo &quot;scsi add-single-device 0 0 0 0&quot; &gt; /proc/scsi/scsi</code>已被弃用。</p>
<pre><code>  1. 在某些光纤通道硬件中，在执行*循环初始化协议*（LIP）操作之前，RAID阵列上新创建的LUN可能对操作系统不可见。



  如果需要LIP，则需要在执行此操作时停止I / O。

  2. 如果在RAID阵列上添加了新的LUN，但仍未被操作系统配置，请使用`sg_luns`命令（sg3_utils包的一部分）确认阵列正在导出的LUN的列表。这将向`SCSI REPORT LUNS`RAID阵列发出命令并返回存在的LUN列表。
</code></pre><p>   对于实现单个WWNN对所有端口光纤通道存储服务器，您可以确定正确的<em><code>h</code></em>,<em><code>c</code></em>,和<em><code>t</code></em> 值 (即HBA数量，HBA通道和SCSI目标ID)，在<code>sysfs</code>中搜索WWNN .</p>
<p>   例如，如果存储服务器的WWNN是<code>0x5006016090203181</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep 5006016090203181 /sys/class/fc_transport/*/node_name</span><br></pre></td></tr></table></figure>
<p>   这应该显示类似于以下内容的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sys/class/fc_transport/target5:0:2/node_name:0x5006016090203181 </span><br><span class="line">/sys/class/fc_transport/target5:0:3/node_name:0x5006016090203181 </span><br><span class="line">/sys/class/fc_transport/target6:0:2/node_name:0x5006016090203181 </span><br><span class="line">/sys/class/fc_transport/target6:0:3/node_name:0x5006016090203181</span><br></pre></td></tr></table></figure>
<p>   这表示到此目标有四条光纤通道路由（两条单通道HBA，每条通向两个存储端口）。假设有一个LUN值<code>56</code>，那么下面的命令将配置第一个路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"0 2 56"</span> &gt;  /sys/class/scsi_host/host5/scan</span><br></pre></td></tr></table></figure>
<p>   这必须为新设备的每个路径完成。</p>
<p>   对于没有为所有端口实施单个WWNN的光纤通道存储服务器，可以通过搜索其中的每个WWPN来确定正确的HBA编号，HBA通道和SCSI目标ID.</p>
<p>   确定HBA号码，HBA通道和SCSI目标ID的另一种方法是引用已经在新设备的相同路径上配置的另一个设备。这可以通过各种命令，比如要做<code>lsscsi</code>，<code>scsi_id</code>，<code>multipath -l</code>，和<code>ls -l /dev/disk/by-</code>。如上所示，可以使用此信息以及新设备的LUN编号来探测和配置到新设备的路径。</p>
<ol>
<li>将所有SCSI路径添加到设备后，执行该<code>multipath</code>命令，并检查设备是否已正确配置。此时，可以将设备添加到<code>md</code>LVM <code>mkfs</code>，或者<code>mount</code>，例如。</li>
</ol>
<p>如果遵循上述步骤，则可以将设备安全地添加到正在运行的系统中。完成这个任务后，不需要停止对其他设备的I / O操作。当存储I / O正在进行时，不推荐其他涉及SCSI总线重新扫描（或重置）的过程，这会导致操作系统更新其状态以反映当前的设备连接。</p>
<h2 id="扫描存储互连"><a href="#扫描存储互连" class="headerlink" title="扫描存储互连"></a>扫描存储互连</h2><p>某些命令允许您重置，扫描或同时重置和扫描一个或多个互连，这可能会在一次操作中添加和删除多个设备。这种类型的扫描可能会造成干扰，因为在I / O操作超时的同时会造成延迟，并意外移除设备。红帽建议<em>仅在必要时</em>使用互连扫描。扫描存储互连时，请遵守以下限制：</p>
<ul>
<li>在执行该过程之前，受影响的互连上的所有I/O必须暂停并刷新，并在I/O恢复之前检查扫描结果。</li>
<li>与拆除设备一样，当系统处于内存压力下时，不建议进行互连扫描。要确定内存压力的级别，请运行该<code>vmstat 1 100</code>命令。如果空闲内存小于每100个10个以上采样的总内存的5％，则不建议进行互连扫描。另外，如果交换处于活动状态（非零<code>si</code>和输出中的<code>so</code>列），则不建议进行互连扫描<code>vmstat</code>。<code>free</code>命令还可以显示总内存。</li>
</ul>
<p>以下命令可用于扫描存储互连：</p>
<ul>
<li><p><code>echo &quot;1&quot; &gt; /sys/class/fc_host/host/issue_lip</code></p>
<p>此操作执行<em>循环初始化协议</em>（<em>LIP</em>），扫描互连，并使SCSI层更新以反映总线上当前的设备。从本质上讲，LIP是一个总线复位，并导致设备添加和删除。此过程对于在光纤通道互连上配置新的SCSI目标是必需的。</p>
<p>请注意，这<code>issue_lip</code>是一个异步操作。该命令可以在整个扫描完成之前完成。你必须监视，<code>/var/log/messages</code>以确定何时<code>issue_lip</code>完成。</p>
<p>的<code>lpfc</code>，<code>qla2xxx</code>和<code>bnx2fc</code>驱动程序的支持<code>issue_lip</code>。有关红帽企业版Linux中每个驱动程序支持的API功能的更多信息</p>
</li>
<li><p><code>/usr/bin/rescan-scsi-bus.sh</code></p>
<p>该<code>/usr/bin/rescan-scsi-bus.sh</code>脚本是在红帽企业Linux 5.4中引入的。默认情况下，此脚本扫描系统上的所有SCSI总线，并更新SCSI层以反映总线上的新设备。该脚本提供了额外的选项来允许设备移除和发行LIP。</p>
</li>
<li><p><code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/hosth/scan</code></p>
<p>在这种情况下，通道号，SCSI目标ID和LUN值将被通配符替换。标识符和通配符的任何组合都是允许的，所以您可以根据需要将命令设置为特定或广泛的。此过程添加LUN，但不删除它们。</p>
</li>
<li><p><code>modprobe --remove driver-name</code>, <code>modprobe driver-name</code></p>
<p>运行<code>modprobe --remove driver-name</code> 命令，然后执行命令<code>modprobe driver-name</code> 完全重新初始化驱动程序控制的所有互连的状态。尽管比较极端，但在某些情况下使用描述的命令可能是合适的。例如，可以使用这些命令以不同的模块参数值重新启动驱动程序。 </p>
</li>
</ul>
<h2 id="ISCSI发现配置"><a href="#ISCSI发现配置" class="headerlink" title="ISCSI发现配置"></a>ISCSI发现配置</h2><p>默认的iSCSI配置文件是<code>/etc/iscsi/iscsid.conf</code>。该文件包含<code>iscsid</code>和使用的iSCSI设置<code>iscsiadm</code>。</p>
<p>在发现目标期间，该<code>iscsiadm</code>工具使用其中的设置<code>/etc/iscsi/iscsid.conf</code>来创建两种类型的记录：</p>
<ul>
<li><p>节点记录 <code>/var/lib/iscsi/nodes</code></p>
<p>登录到目标时，<code>iscsiadm</code>使用此文件中的设置。</p>
</li>
<li><p>发现记录在 <code>/var/lib/iscsi/*discovery_type*</code></p>
<p>在对同一目的地执行发现时，<code>iscsiadm</code>使用此文件中的设置。</p>
</li>
</ul>
<p>在使用不同的发现设置之前，先删除当前的发现记录（即）。为此，请使用以下命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t discovery_type -p target_IP:port -o delete</span></span><br></pre></td></tr></table></figure>
<p>在这里，<em>discovery_type</em>可以是<code>sendtargets</code>，<code>isns</code>或<code>fw</code>。</p>
<p>有两种方法可以重新配置发现记录设置：</p>
<ul>
<li>编辑 <code>/etc/iscsi/iscsid.conf</code> 在执行发现之前直接. 发现设置使用前缀<code>discovery</code>; 要查看它们，请运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t discovery_type -p target_IP:port</span></span><br></pre></td></tr></table></figure>
<ul>
<li>或者，<code>iscsiadm</code>也可以用来直接更改发现记录设置，如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t discovery_type -p target_IP:port -o update -n setting -v %value</span></span><br></pre></td></tr></table></figure>
<h2 id="配置ISCSI卸载和接口绑定"><a href="#配置ISCSI卸载和接口绑定" class="headerlink" title="配置ISCSI卸载和接口绑定"></a>配置ISCSI卸载和接口绑定</h2><p>本章介绍如何设置iSCSI接口，以便在使用软件iSCSI时将会话绑定到NIC端口。还介绍如何设置支持卸载的网络设备的接口。</p>
<p>网络子系统可以配置为确定iSCSI接口应该用于绑定的路径/ NIC。例如，如果门户网站和网卡设置在不同的子网上，则不需要手动配置iSCSI接口进行绑定。</p>
<p>在尝试配置iSCSI接口进行绑定之前，请先运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping -I eth X  target_IP</span><br></pre></td></tr></table></figure>
<p>如果<code>ping</code>失败，那么您将无法将会话绑定到NIC。如果是这种情况，请首先检查网络设置。</p>
<h3 id="查看可用的iface配置"><a href="#查看可用的iface配置" class="headerlink" title="查看可用的iface配置"></a>查看可用的iface配置</h3><p>以下iSCSI启动器实施支持iSCSI卸载和接口绑定：</p>
<ul>
<li><p>软件iSCSI</p>
<p>此堆栈为<code>scsi_host</code>每个会话分配一个iSCSI主机实例（即），每个会话只有一个连接。作为结果，<code>/sys/class_scsi_host</code>、<code>/proc/scsi</code>会报告<code>scsi_host</code>你登录到每个连接/会话。 </p>
</li>
<li><p>卸载iSCSI</p>
<p>这个堆栈<code>scsi_host</code>为每个PCI设备分配一个。因此，主机总线适配器上的每个端口将显示为不同的PCI设备，<code>scsi_host</code>每个HBA端口都有不同的端口。</p>
</li>
</ul>
<p>要管理这两种类型的启动器实现，请<code>iscsiadm</code>使用该<code>iface</code>结构。使用此结构，<code>iface</code>必须为用于绑定会话的<code>/var/lib/iscsi/ifaces</code>每个HBA端口，软件iSCSI或网络设备（<code>ethX</code>）输入配置。 </p>
<p>要查看可用<code>iface</code>配置，请运行<code>iscsiadm -m iface</code>。这将显示<code>iface</code>以下格式的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iface_name  transport_name，hardware_address，ip_address，net_ifacename，initiator_name</span><br></pre></td></tr></table></figure>
<p>请参阅下表，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>设置</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iface_name</code></td>
<td><code>iface</code> 配置名称。</td>
</tr>
<tr>
<td><code>transport_name</code></td>
<td>设备名称</td>
</tr>
<tr>
<td><code>hardware_address</code></td>
<td>MAC 地址</td>
</tr>
<tr>
<td><code>ip_address</code></td>
<td>用于此端口的IP地址</td>
</tr>
<tr>
<td><code>net_iface_name</code></td>
<td>名称用于<code>vlan</code>软件iSCSI会话的别名绑定。对于iSCSI卸载，<code>net_iface_name</code>将是<code>&lt;empty&gt;</code>因为这个值在重新启动时不是持久的。</td>
</tr>
<tr>
<td><code>initiator_name</code></td>
<td>此设置用于覆盖<code>/etc/iscsi/initiatorname.iscsi</code>中定义的启动器的默认名称</td>
</tr>
</tbody>
</table>
</div>
<p><strong>iscsiadm -m iface命令的输出示例</strong></p>
<p>以下是<code>iscsiadm -m iface</code>命令的输出示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iface0 qla4xxx,00:c0:dd:08:63:e8,20.15.0.7,default,iqn.2005-06.com.redhat:madmax</span><br><span class="line">iface1 qla4xxx,00:c0:dd:08:63:ea,20.15.0.9,default,iqn.2005-06.com.redhat:madmax</span><br></pre></td></tr></table></figure>
<p>对于软件iSCSI，每个<code>iface</code>配置必须具有唯一的名称（少于65个字符）。该<code>iface_name</code>网络设备支持卸载出现在格式。</p>
<p><strong>iscsiadm -m iface使用Chelsio网卡输出</strong></p>
<p>例如，<code>iscsiadm -m iface</code>使用Chelsio网卡的系统上的示例输出可能显示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default tcp,&lt;empty&gt;,&lt;empty&gt;,&lt;empty&gt;,&lt;empty&gt;</span><br><span class="line">iser iser,&lt;empty&gt;,&lt;empty&gt;,&lt;empty&gt;,&lt;empty&gt;</span><br><span class="line">cxgb3i.00:07:43:05:97:07 cxgb3i,00:07:43:05:97:07,&lt;empty&gt;,&lt;empty&gt;,&lt;empty&gt;</span><br></pre></td></tr></table></figure>
<p>也可以以<code>iface</code>更友好的方式显示特定配置的设置。为此，请使用该选项。这将以以下格式显示设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iface.setting = value</span><br></pre></td></tr></table></figure>
<p><strong>使用ifaceChelsio融合网络适配器的设置</strong></p>
<p>使用前面的示例，<code>iface</code>相同的Chelsio融合网络适配器（即<code>iscsiadm -m iface -I cxgb3i.00:07:43:05:97:07</code>）的设置将显示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN RECORD 2.0-871</span></span><br><span class="line">iface.iscsi_ifacename = cxgb3i.00:07:43:05:97:07</span><br><span class="line">iface.net_ifacename = &lt;empty&gt;</span><br><span class="line">iface.ipaddress = &lt;empty&gt;</span><br><span class="line">iface.hwaddress = 00:07:43:05:97:07</span><br><span class="line">iface.transport_name = cxgb3i</span><br><span class="line">iface.initiatorname = &lt;empty&gt;</span><br><span class="line"><span class="comment"># END RECORD</span></span><br></pre></td></tr></table></figure>
<h3 id="为软件iSCSI配置iface"><a href="#为软件iSCSI配置iface" class="headerlink" title="为软件iSCSI配置iface"></a>为软件iSCSI配置iface</h3><p>如前所述，<code>iface</code>每个将用于绑定会话的网络对象都需要配置。</p>
<p>之前</p>
<p>要<code>iface</code>为软件iSCSI 创建配置，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m iface -I iface_name --op=new</span></span><br></pre></td></tr></table></figure>
<p>这将创建一个具有指定的新的<em>空</em> <code>iface</code>配置<code>*iface_name*</code>。如果现有<code>iface</code>配置已经有相同的<code>*iface_name*</code>，那么它将被一个新的空的覆盖。</p>
<p>要配置特定的<code>iface</code>配置设置，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m iface -I iface_name --op=update -n iface.setting -v hw_address</span></span><br></pre></td></tr></table></figure>
<p><strong>设置MAC地址iface0</strong></p>
<p>例如，要设置的MAC地址（<code>hardware_address</code>的）<code>iface0</code>到<code>00:0F:1F:92:6B:BF</code>，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m iface -I iface0 --op=update -n iface.hwaddress -v 00:0F:1F:92:6B:BF</span></span><br></pre></td></tr></table></figure>
<p>不要使用<code>default</code>或<code>iser</code>作为<code>iface</code>名称。这两个字符串都是<code>iscsiadm</code>为了向后兼容而使用的特殊值。任何手动创建的<code>iface</code>配置命名<code>default</code>或<code>iser</code>将禁用向后兼容性。</p>
<h3 id="为iSCSI卸载配置iface"><a href="#为iSCSI卸载配置iface" class="headerlink" title="为iSCSI卸载配置iface"></a>为iSCSI卸载配置iface</h3><p>默认情况下<code>iscsiadm</code>会<code>iface</code>为每个端口创建一个配置。要查看可用的<code>iface</code>配置，请在软件iSCSI中使用相同的命令，即<code>iscsiadm -m iface</code>。</p>
<p>在使用<code>iface</code>网卡进行iSCSI卸载之前，首先设置设备应使用的IP地址。对于使用<code>be2iscsi</code>驱动程序的设备，在BIOS设置屏幕中配置IP地址。对于所有其他设备，要配置使用的IP地址<code>iface</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m iface -I iface_name -o update -n iface.ipaddress -v target_IP</span></span><br></pre></td></tr></table></figure>
<p><strong>设置ifaceChelsio卡的IP地址</strong></p>
<p>例如，要将<code>iface</code>IP地址设置为<code>20.15.0.66</code>使用iface名称为cxgb3i.00:07:43:05:97:07的卡时，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m iface -I cxgb3i.00:07:43:05:97:07 -o update -n iface.ipaddress -v 20.15.0.66</span></span><br></pre></td></tr></table></figure>
<h3 id="将iface绑定-解除绑定到Portal"><a href="#将iface绑定-解除绑定到Portal" class="headerlink" title="将iface绑定/解除绑定到Portal"></a>将iface绑定/解除绑定到Portal</h3><p>每当<code>iscsiadm</code>用于扫描互连时，都会首先检查<code>iface.transport</code>每个<code>iface</code>配置的设置<code>/var/lib/iscsi/ifaces</code>。在<code>iscsiadm</code>随后实用程序将绑定发现的门户网站的任何<code>iface</code> 其<code>iface.transport</code>是<code>tcp</code>。</p>
<p>出于兼容性的原因，此行为已实施。要覆盖这个，使用指定哪个入口绑定到一个，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t st -p target_IP:port -I iface_name -P 1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，该<code>iscsiadm</code>实用程序不会自动将任何入口绑定到<code>iface</code>使用卸载的配置。这是因为这样的<code>iface</code>配置不会被<code>iface.transport</code>设置为<code>tcp</code>。因此，这些<code>iface</code>配置需要手动绑定到发现的门户。</p>
<p>也可以防止门户绑定到任何现有的<code>iface</code>。要做到这一点，使用<code>default</code>的<code>iface_name</code>，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t st -p IP:port -I default -P 1</span></span><br></pre></td></tr></table></figure>
<p>要删除目标之间的绑定<code>iface</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node -targetname proper_target_name -I iface0 --op=delete</span></span><br></pre></td></tr></table></figure>
<p>要删除特定的所有绑定<code>iface</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node -I iface_name --op=delete</span></span><br></pre></td></tr></table></figure>
<p>要删除特定门户的绑定（例如，对于Equalogic目标），请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node -p IP:port -I iface_name --op=delete</span></span><br></pre></td></tr></table></figure>
<p>如果没有<code>iface</code>定义任何配置<code>/var/lib/iscsi/iface</code>并且该<code>-I</code>选项未被使用，<code>iscsiadm</code>将允许网络子系统决定特定门户应该使用哪个设备。</p>
<h2 id="扫描ISCSI互连"><a href="#扫描ISCSI互连" class="headerlink" title="扫描ISCSI互连"></a>扫描ISCSI互连</h2><p>对于iSCSI，如果目标发送指示添加新存储的iSCSI异步事件，则扫描将自动完成。</p>
<p>但是，如果目标不发送iSCSI异步事件，则需要使用该<code>iscsiadm</code>实用程序手动扫描它们。然而，在这样做之前，您需要先检索正确<code>--targetname</code>的<code>--portal</code>值。如果您的设备型号仅支持每个目标的单个逻辑单元和门户，请使用<code>iscsiadm</code>向<code>sendtargets</code>主机发出命令，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m discovery -t sendtargets -p target_IP:port</span></span><br></pre></td></tr></table></figure>
<p>输出将以以下格式显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target_IP:port,target_portal_group_tag proper_target_name</span><br></pre></td></tr></table></figure>
<p><strong>使用iscsiadm发出一个sendtargets命令</strong></p>
<p>例如，在具有<code>proper_target_name</code>of <code>iqn.1992-08.com.netapp:sn.33615311</code>和<code>target_IP:port</code>of 的目标上<code>10.15.85.19:3260</code>，输出可能显示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.15.84.19:3260,2 iqn.1992-08.com.netapp:sn.33615311</span><br><span class="line">10.15.85.19:3260,3 iqn.1992-08.com.netapp:sn.33615311</span><br></pre></td></tr></table></figure>
<p>In this example, the target has two portals, each using <code>*target_ip:port*</code>s of <code>10.15.84.19:3260</code> and <code>10.15.85.19:3260</code>.</p>
<p>要查看哪个<code>iface</code>配置将用于每个会话，请添加该<code>-P 1</code>选项。此选项将以树格式打印会话信息，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Target: proper_target_name</span><br><span class="line">    Portal: target_IP:port,target_portal_group_tag</span><br><span class="line">       Iface Name: iface_name</span><br></pre></td></tr></table></figure>
<p><strong>查看iface配置</strong></p>
<p>例如，与<code>iscsiadm -m discovery -t sendtargets -p 10.15.85.19:3260 -P 1</code>，输出可能会显示为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Target: iqn.1992-08.com.netapp:sn.33615311</span><br><span class="line">    Portal: 10.15.84.19:3260,2</span><br><span class="line">       Iface Name: iface2</span><br><span class="line">    Portal: 10.15.85.19:3260,3</span><br><span class="line">       Iface Name: iface2</span><br></pre></td></tr></table></figure>
<p>这意味着目标<code>iqn.1992-08.com.netapp:sn.33615311</code>将<code>iface2</code>用作其<code>iface</code>配置。</p>
<p>对于某些设备模型，一个目标可能有多个逻辑单元和门户。在这种情况下，<code>sendtargets</code>首先向主机发出命令以在目标上找到新的门户。然后，使用以下命令重新扫描现有会话：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session --rescan</span></span><br></pre></td></tr></table></figure>
<p>您还可以通过指定会话的<code>SID</code>值重新扫描特定会话，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m session -r SID --rescan</span></span><br></pre></td></tr></table></figure>
<p>如果您的设备支持多个目标，则需要向<code>sendtargets</code>主机发出命令，以便为<em>每个</em>目标找到新的入口。重新扫描现有会话以使用该<code>--rescan</code>选项在现有会话上发现新的逻辑单元。</p>
<p><code>sendtargets</code>用于检索<code>--targetname</code>和<code>--portal</code>值 的命令会覆盖<code>/var/lib/iscsi/nodes</code>数据库的内容。然后使用中的设置重新填充此数据库<code>/etc/iscsi/iscsid.conf</code>。但是，如果会话当前已登录并正在使用，则不会发生这种情况。</p>
<p>要安全地添加新的目标/门户或删除旧的，分别使用<code>-o new</code>或<code>-o delete</code>选项。例如，要添加新的目标/门户而不覆盖<code>/var/lib/iscsi/nodes</code>，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m discovery -t st -p target_IP -o new</span><br></pre></td></tr></table></figure>
<p>要删除<code>/var/lib/iscsi/nodes</code>目标在发现过程中未显示的条目，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m discovery -t st -p target_IP -o delete</span><br></pre></td></tr></table></figure>
<p>您也可以同时执行这两个任务，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m discovery -t st -p target_IP -o delete -o new</span><br></pre></td></tr></table></figure>
<p>该<code>sendtargets</code>命令将产生以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip:port,target_portal_group_tag proper_target_name</span><br></pre></td></tr></table></figure>
<p><strong>sendtargets命令的输出</strong></p>
<p>例如，给定一个具有单个目标，逻辑单元和门户<code>equallogic-iscsi1</code>的设备<code>*target_name*</code>，其输出应与以下内容类似：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10.16.41.155:3260,0 iqn.2001-05.com.equallogic:6-8a0900-ac3fe0101-63aff113e344a4a2-dl585-03-1</span><br></pre></td></tr></table></figure>
<p>此时，您现在拥有手动扫描iSCSI设备所需的正确值<code>--targetname</code>和<code>--portal</code>值。为此，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm --mode node --targetname proper_target_name --portal ip:port,target_portal_group_tag \ --login</span></span><br></pre></td></tr></table></figure>
<p><strong>完整的iscsiadm命令</strong></p>
<p>使用我们前面的例子（<code>*proper_target_name*</code>是<code>equallogic-iscsi1</code>），完整的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm --mode node --targetname  \ iqn.2001-05.com.equallogic:6-8a0900-ac3fe0101-63aff113e344a4a2-dl585-03-1 	\ --portal 10.16.41.155:3260,0 --login[8]</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="登录到ISCSI目标"><a href="#登录到ISCSI目标" class="headerlink" title="登录到ISCSI目标"></a>登录到ISCSI目标</h2><p>必须运行iSCSI服务才能发现或登录目标。要启动iSCSI服务，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start iscsi</span></span><br></pre></td></tr></table></figure>
<p>执行此命令后，iSCSI <code>init</code>脚本将自动登录到<code>node.startup</code>设置配置为的目标<code>automatic</code>。这是<code>node.startup</code>所有目标的默认值。</p>
<p>要防止自动登录到目标，请设置<code>node.startup</code>为<code>manual</code>。为此，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node --targetname proper_target_name -p target_IP:port -o update -n node.startup -v manual</span></span><br></pre></td></tr></table></figure>
<p>删除整个记录也会阻止自动登录。要做到这一点，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node --targetname proper_target_name -p target_IP:port -o delete</span></span><br></pre></td></tr></table></figure>
<p>要从网络上的iSCSI设备自动安装文件系统，请<code>/etc/fstab</code>使用该<code>_netdev</code>选项为安装添加分区条目。例如，为了自动iSCSI设备安装<code>sdb</code>到<code>/mount/iscsi</code>启动过程中，下面的行添加到<code>/etc/fstab</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sdb /mnt/iscsi ext3 _netdev 0 0</span><br></pre></td></tr></table></figure>
<p>要手动登录到iSCSI目标，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node --targetname proper_target_name -p target_IP:port -l</span></span><br></pre></td></tr></table></figure>
<p>该<code>proper_target_name</code>和<code>target_IP:port</code>指全名和目标的IP地址/端口组合。</p>
<h2 id="RESIZING-调整在线逻辑单元的大小"><a href="#RESIZING-调整在线逻辑单元的大小" class="headerlink" title="RESIZING 调整在线逻辑单元的大小"></a>RESIZING 调整在线逻辑单元的大小</h2><p>在大多数情况下，完全调整在线<em>逻辑单元的</em>大小涉及两件事情：调整逻辑单元本身的大小，并在相应的多路径设备（如果在系统上启用多路径）中反映大小更改。</p>
<p>要调整联机逻辑单元的大小，请首先通过存储设备的阵列管理界面修改逻辑单元大小。这个过程与每个数组不同，因此，请查阅您的存储阵列供应商文档以获取更多信息。</p>
<p><strong>Note</strong></p>
<p>为了调整在线文件系统的大小，文件系统不能驻留在分区设备上。</p>
<h3 id="调整光纤通道逻辑单元的大小"><a href="#调整光纤通道逻辑单元的大小" class="headerlink" title="调整光纤通道逻辑单元的大小"></a>调整光纤通道逻辑单元的大小</h3><p>修改在线逻辑单元大小后，重新扫描逻辑单元以确保系统检测到更新的大小。要为光纤通道逻辑单元执行此操作，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /sys/block/sdX/device/rescan</span><br></pre></td></tr></table></figure>
<p>要在使用多路径的系统上重新扫描光纤通道逻辑单元，请为表示多路径逻辑单元的路径的每个sd设备（即<code>sd1</code>，<code>sd2</code>等等）执行上述命令。要确定哪些设备是多路径逻辑单元的路径，请使用<code>multipath -ll</code>; 然后找到匹配被调整大小的逻辑单元的条目。建议您参考每个条目的WWID，以便更容易地找到哪个匹配被调整大小的逻辑单元。</p>
<h3 id="调整iSCSI逻辑单元的大小"><a href="#调整iSCSI逻辑单元的大小" class="headerlink" title="调整iSCSI逻辑单元的大小"></a>调整iSCSI逻辑单元的大小</h3><p>修改在线逻辑单元大小后，重新扫描逻辑单元以确保系统检测到更新的大小。要为iSCSI设备执行此操作，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node --targetname target_name -R</span></span><br></pre></td></tr></table></figure>
<p>替换<code>*target_name*</code>为设备所在的目标的名称。</p>
<p>您也可以使用以下命令重新扫描iSCSI逻辑单元：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iscsiadm -m node -R -I interface</span></span><br></pre></td></tr></table></figure>
<p>替换<code>interface</code>为调整大小的逻辑单元的相应接口名称（例如<code>iface0</code>）。该命令执行两个操作：</p>
<ul>
<li><p>它以与命令相同的方式扫描新设备 </p>
<p><code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/*host*/scan</code> </p>
</li>
<li><p>它以与命令相同的方式重新扫描新的/修改的逻辑单元  <code>echo 1 &gt; /sys/block/sdX/device/rescan</code> 请注意，该命令与用于重新扫描光纤通道逻辑单元的命令相同。</p>
</li>
</ul>
<h3 id="更新多路径设备的大小"><a href="#更新多路径设备的大小" class="headerlink" title="更新多路径设备的大小"></a>更新多路径设备的大小</h3><p>如果系统启用了多路径，则还需要将逻辑单元大小的变化反映到逻辑单元的相应多路径设备（<em>在</em>调整逻辑单元大小<em>之后</em>）。这可以通过<code>multipathd</code>。为此，首先确保<code>multipathd</code>正在运行使用<code>service multipathd status</code>。一旦您验证了<code>multipathd</code>可操作性，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd -k "resize map multipath_device"</span></span><br></pre></td></tr></table></figure>
<p>该<code>multipath_device</code>变量是您的设备在相应的多路径条目<code>/dev/mapper</code>。根据系统上多路径的设置，<code>*multipath_device*</code>可以是以下两种格式之一：</p>
<ul>
<li><code>mpathX</code>，<code>X</code>您的设备的相应条目在哪里（例如<code>mpath0</code>）</li>
<li>WWID; 例如，<code>3600508b400105e210000900000490000</code></li>
</ul>
<p>要确定哪个多路径条目对应于您调整大小的逻辑单元，请运行<code>multipath -ll</code>。这将显示系统中所有现有多路径条目的列表，以及相应设备的主要和次要编号。</p>
<h3 id="改变在线逻辑单元的读-写状态"><a href="#改变在线逻辑单元的读-写状态" class="headerlink" title="改变在线逻辑单元的读/写状态"></a>改变在线逻辑单元的读/写状态</h3><p>某些存储设备为用户提供了将设备状态从读/写（R / W）更改为只读（RO）以及从RO更改为R / W的功能。这通常通过存储设备上的管理界面完成。进行更改时，操作系统不会自动更新设备状态视图。按照本章介绍的步骤使操作系统知道更改。</p>
<p>运行以下命令，将XYZ替换为所需的设备指示符，以确定操作系统当前的设备R / W状态视图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blockdev --getro /dev/sdXYZ</span></span><br></pre></td></tr></table></figure>
<p>以下命令也可用于红帽企业版Linux 7：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sdXYZ/ro 1 = read-only 0 = read-write</span></span><br></pre></td></tr></table></figure>
<p>使用多路径时，请参阅命令输出的第二行中的<em>ro</em>或<em>rw</em>字段<code>multipath -ll</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">36001438005deb4710000500000640000 dm-8 GZ,GZ500</span><br><span class="line">[size=20G][features=0][hwhandler=0][ro]</span><br><span class="line">\_ round-robin 0 [prio=200][active]</span><br><span class="line"> \_ 6:0:4:1  sdax 67:16  [active][ready]</span><br><span class="line"> \_ 6:0:5:1  sday 67:32  [active][ready]</span><br><span class="line">\_ round-robin 0 [prio=40][enabled]</span><br><span class="line"> \_ 6:0:6:1  sdaz 67:48  [active][ready]</span><br><span class="line"> \_ 6:0:7:1  sdba 67:64  [active][ready]</span><br></pre></td></tr></table></figure>
<p>要更改R/W状态，请使用以下步骤：</p>
<p><strong>改变R/W状态</strong></p>
<ol>
<li><p>要将设备从RO移到R / W，请参阅步骤2。</p>
<p>要将器件从R / W移至RO，确保不会再发出写操作。通过停止应用程序或通过使用适当的特定于应用程序的操作来执行此操作。</p>
<p>使用以下命令确保所有未完成的写入I / O完成：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blockdev --flushbufs /dev/device</span></span><br></pre></td></tr></table></figure>
<p>   用所需的代号替换<em>设备</em> ; 对于设备映射器多路径，这是您设备的条目<code>dev/mapper</code>。例如。 <code>/dev/mapper/mpath3</code></p>
<ol>
<li><p>使用存储设备的管理接口将逻辑单元的状态从R / W更改为RO，或将RO更改为R/W。这个过程对每个数组都不相同。查阅适用的存储阵列供应商文档以获取更多信</p>
</li>
<li><p>执行设备的重新扫描以更新设备的R / W状态的操作系统的视图。如果使用设备映射器多路径，请在发出告知多路径重新加载其设备映射的命令之前，对设备的每条路径执行此重新扫描。</p>
</li>
</ol>
<h4 id="重新扫描逻辑单元"><a href="#重新扫描逻辑单元" class="headerlink" title="重新扫描逻辑单元"></a>重新扫描逻辑单元</h4><p>在线逻辑单元的读/写状态”所述，修改了在线逻辑单元读/写状态之后，重新扫描逻辑单元以确保系统检测到更新状态命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /sys/block/sdX/device/rescan</span></span><br></pre></td></tr></table></figure>
<p>要在使用多路径的系统上重新扫描逻辑单元，请为表示多路径逻辑单元的路径的每个sd设备执行上述命令。例如，在sd1，sd2和所有其他sd设备上运行命令。要确定哪些设备是多路径单元的路径，请使用<code>multipath -11</code>，然后查找与要更改的逻辑单元相匹配的条目。</p>
<p><strong>使用multipath -11命令</strong></p>
<p>例如，<code>multipath -11</code>以上显示了WWID为36001438005deb4710000500000640000的LUN的路径。在这种情况下，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; /sys/block/sdax/device/rescan</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /sys/block/sday/device/rescan</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /sys/block/sdaz/device/rescan</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /sys/block/sdba/device/rescan</span></span><br></pre></td></tr></table></figure>
<h4 id="更新多路径设备的R-W状态"><a href="#更新多路径设备的R-W状态" class="headerlink" title="更新多路径设备的R/W状态"></a>更新多路径设备的R/W状态</h4><p>如果启用了多路径，则在重新扫描逻辑单元之后，其状态变化将需要反映在逻辑单元的相应多路径驱动器中。通过使用以下命令重新载入多路径设备映射来执行此操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipath -r</span></span><br></pre></td></tr></table></figure>
<p>该<code>multipath -11</code>命令可以用来确认更改。</p>
<h2 id="通过RESCAN-SCSI-BUS-SH添加-删除逻辑单元"><a href="#通过RESCAN-SCSI-BUS-SH添加-删除逻辑单元" class="headerlink" title="通过RESCAN-SCSI-BUS.SH添加/删除逻辑单元"></a>通过RESCAN-SCSI-BUS.SH添加/删除逻辑单元</h2><p>该<code>sg3_utils</code>软件包提供了<code>rescan-scsi-bus.sh</code>脚本，可以根据需要自动更新主机的逻辑单元配置（在设备添加到系统后）。该<code>rescan-scsi-bus.sh</code>脚本还可以<code>issue_lip</code>在支持的设备上执行。有关如何使用此脚本的更多信息，请参阅<code>rescan-scsi-bus.sh --help</code>。</p>
<p>要安装该<code>sg3_utils</code>软件包，请运行<code>yum install sg3_utils</code>。</p>
<h3 id="已知问题与rescan-scsi-bus-sh"><a href="#已知问题与rescan-scsi-bus-sh" class="headerlink" title="已知问题与rescan-scsi-bus.sh"></a>已知问题与rescan-scsi-bus.sh</h3><p>使用<code>rescan-scsi-bus.sh</code>脚本时，请注意以下已知问题：</p>
<ul>
<li>为了<code>rescan-scsi-bus.sh</code>正常工作，<code>LUN0</code>必须是第一个映射的逻辑单元。的<code>rescan-scsi-bus.sh</code>，如果它是仅可以检测第一映射逻辑单元<code>LUN0</code>。该<code>rescan-scsi-bus.sh</code>不会是能够扫描任何其他逻辑单元，除非它检测到，即使你使用的第一映射逻辑单元<code>--nooptscan</code>选项。</li>
<li><code>rescan-scsi-bus.sh</code>如果逻辑单元是第一次映射的， 竞态条件要求运行两次。在第一次扫描期间，<code>rescan-scsi-bus.sh</code>只增加<code>LUN0</code>; 在第二次扫描中添加所有其他逻辑单元。</li>
<li><code>rescan-scsi-bus.sh</code>当使用该<code>--remove</code>选项时 ，脚本中的错误错误地执行识别逻辑单元大小变化的功能。</li>
<li>该<code>rescan-scsi-bus.sh</code>脚本不识别ISCSI逻辑单元删除。</li>
</ul>
<h2 id="修改链路丢失行为"><a href="#修改链路丢失行为" class="headerlink" title="修改链路丢失行为"></a>修改链路丢失行为</h2><p>This section describes how to modify the link loss behavior of devices that use either Fibre Channel or iSCSI protocols.</p>
<h3 id="光纤通道-1"><a href="#光纤通道-1" class="headerlink" title="光纤通道"></a>光纤通道</h3><p>如果驱动程序实现传输<code>dev_loss_tmo</code>回调，则在检测到传输问题时，通过链接访问设备的尝试将被阻止。要验证设备是否被阻止，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /sys/block/device/device/state</span><br></pre></td></tr></table></figure>
<p><code>blocked</code>如果设备被阻塞， 该命令将返回。如果设备运行正常，该命令将返回<code>running</code>。</p>
<p><strong>确定远程端口的状态</strong></p>
<ol>
<li>要确定远程端口的状态，请运行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat</span><br><span class="line">/sys/class/fc_remote_port/rport-H:B:R/port_state</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>Blocked</code>当远程端口（以及通过它访问的设备）被阻塞时， 该命令将返回。如果远程端口正常运行，命令将返回<code>Online</code>。</p>
</li>
<li><p>如果问题在<code>dev_loss_tmo</code>几秒内不能解决，则rport和设备将被解除阻塞，并且该设备上运行的所有I/O（以及任何发送到该设备的新I/O）都将失败。</p>
</li>
</ol>
<p><strong>更改dev_loss_tmo</strong></p>
<ul>
<li>要更改该<code>dev_loss_tmo</code>值，<code>echo</code>请将所需的值更改为该文件。例如，要设置<code>dev_loss_tmo</code>为30秒，请运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 30 &gt;</span><br><span class="line">/sys/class/fc_remote_port/rport-H:B:R/dev_loss_tmo</span><br></pre></td></tr></table></figure>
<h3 id="iSCSI设置dm-multipath"><a href="#iSCSI设置dm-multipath" class="headerlink" title="iSCSI设置dm-multipath"></a>iSCSI设置<code>dm-multipath</code></h3><p>如果<code>dm-multipath</code>已实施，则建议将iSCSI定时器设置为立即将命令延迟到多路径层。要配置它，请将以下行嵌套<code>device</code>在<code>/etc/multipath.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">features		<span class="string">"1 queue_if_no_path"</span></span><br></pre></td></tr></table></figure>
<p>这确保了如果<code>dm-multipath</code>图层中的所有路径都失败，I / O错误将重试并排队。</p>
<p>您可能需要进一步调整iSCSI定时器，以更好地监控SAN的问题。您可以配置可用的iSCSI计时器是<em>NOP超时间隔/超时</em>和<code>replacement_timeout</code>，这在下面的章节中讨论。</p>
<h4 id="NOP输出间隔-超时"><a href="#NOP输出间隔-超时" class="headerlink" title="NOP输出间隔/超时"></a>NOP输出间隔/超时</h4><p>为了帮助监控SAN的问题，iSCSI层向每个目标发送一个NOP-Out请求。如果NOP-Out请求超时，则iSCSI层响应失败的任何运行命令，并指示SCSI层在可能的情况下重新执行这些命令。</p>
<p>在<code>dm-multipath</code>使用时，SCSI层将会使那些正在运行的命令失效，并将它们推迟到多路径层。多路径层然后在另一条路径上重试这些命令。如果<code>dm-multipath</code>是<em>没有</em>被使用，这些命令是完全失败之前重试五次。</p>
<p>NOP-Out请求之间的间隔默认为10秒。要调整它，请打开<code>/etc/iscsi/iscsid.conf</code>并编辑以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node.conn[0].timeo.noop_out_interval = [interval value]</span><br></pre></td></tr></table></figure>
<p>一旦设置，iSCSI层将每<em>[间隔值]</em>秒发送一个NOP-Out请求给每个目标。</p>
<p>默认情况下，NOP-Out请求在10秒内超时要调整它，请打开<code>/etc/iscsi/iscsid.conf</code>并编辑以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node.conn[0].timeo.noop_out_timeout = [timeout value]</span><br></pre></td></tr></table></figure>
<p>这会将iSCSI层设置为在<em>[超时值]</em>秒后超时一个NOP-Out请求。</p>
<h5 id="SCSI错误处理程序"><a href="#SCSI错误处理程序" class="headerlink" title="SCSI错误处理程序"></a>SCSI错误处理程序</h5><p>如果SCSI错误处理程序正在运行，当路径上的NOP-Out请求超时时，在路径上运行命令将不会立即失败。相反，这些命令将<em>在</em> <code>replacement_timeout</code>几秒钟<em>后</em>失败。</p>
<p>要验证SCSI错误处理程序是否正在运行，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃iscsiadm -m session -P 3</span><br></pre></td></tr></table></figure>
<h4 id="replacement-timeout"><a href="#replacement-timeout" class="headerlink" title="replacement_timeout"></a><code>replacement_timeout</code></h4><p><code>replacement_timeout</code>控制iSCSI层在发生任何命令失败之前应该等待超时路径/会话重新建立自己的时间。默认<code>replacement_timeout</code>值是120秒。</p>
<p>要进行调整<code>replacement_timeout</code>，请打开<code>/etc/iscsi/iscsid.conf</code>并编辑以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node.session.timeo.replacement_timeout = [replacement_timeout]</span><br></pre></td></tr></table></figure>
<p>通过配置较低的<code>replacement_timeout</code>I / O，当iSCSI层尝试重新建立失败的路径/会话时，I / O被快速发送到新的路径并执行（在NOP-Out超时的情况下）。如果所有路径都超时，那么多路径和设备映射器将根据设置在内部排队I / O <code>/etc/multipath.conf</code>而不是<code>/etc/iscsi/iscsid.conf</code>。</p>
<p><strong>重要</strong></p>
<p>无论您考虑的是故障转移速度还是安全性，建议的值<code>replacement_timeout</code>将取决于其他因素。这些因素包括网络，目标和系统工作负载。因此，建议您<code>replacements_timeout</code>在将其应用于任务关键型系统之前彻底测试任何新的配置。</p>
<h3 id="iSCSI根"><a href="#iSCSI根" class="headerlink" title="iSCSI根"></a>iSCSI根</h3><p>当直接通过iSCSI磁盘访问根分区时，应设置iSCSI定时器，以便iSCSI层尝试重新建立路径/会话有几次机会。另外，命令不应该快速重新排队到SCSI层。这与<code>dm-multipath</code>实施时应该做的是相反的。</p>
<p>首先，应禁用NOP输出。您可以通过将NOP-Out时间间隔和超时设置为零来完成此操作。要设置这个，打开<code>/etc/iscsi/iscsid.conf</code>并编辑如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node.conn [0] .timeo.noop_out_interval = 0</span><br><span class="line">node.conn [0] .timeo.noop_out_timeout = 0</span><br></pre></td></tr></table></figure>
<p>为此，<code>replacement_timeout</code>应该设置一个很高的数字。这将指示系统等待很长时间来重新建立路径/会话。要进行调整<code>replacement_timeout</code>，请打开<code>/etc/iscsi/iscsid.conf</code>并编辑以下行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node.session.timeo.replacement_timeout = replacement_timeout</span><br></pre></td></tr></table></figure>
<p>配置完成后<code>/etc/iscsi/iscsid.conf</code>，您必须重新发现受影响的存储。这将允许系统加载和使用任何新的值<code>/etc/iscsi/iscsid.conf</code>。</p>
<h4 id="配置特定会话超时"><a href="#配置特定会话超时" class="headerlink" title="配置特定会话超时"></a>配置特定会话超时</h4><p>您还可以为特定会话配置超时，并使其非持久（而不是使用<code>/etc/iscsi/iscsid.conf</code>）。为此，请运行以下命令（相应地替换变量）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃iscsiadm -m node -T target_name -p target_IP：port -o update -n node.session.timeo.replacement_timeout -v $ timeout_value</span><br></pre></td></tr></table></figure>
<h2 id="控制SCSI命令计时器和设备状态"><a href="#控制SCSI命令计时器和设备状态" class="headerlink" title="控制SCSI命令计时器和设备状态"></a>控制SCSI命令计时器和设备状态</h2><p>Linux SCSI层在每个命令上设置一个定时器。当此计时器到期时，SCSI层将使<em>主机总线适配器</em>（HBA）停顿并等待所有未完成的命令超时或完成。之后，SCSI层将激活驱动程序的错误处理程序。</p>
<p>当错误处理程序被触发时，它将按顺序尝试以下操作（直到成功执行）：</p>
<ol>
<li>中止命令。</li>
<li>重置设备。</li>
<li>重置总线。</li>
<li>重置主机。</li>
</ol>
<p>如果所有这些操作失败，设备将被设置为<code>offline</code>状态。发生这种情况时，该设备的所有I / O都将失败，直到问题得到纠正，并且用户将设备设置为<code>running</code>。</p>
<p>但是，如果设备使用光纤通道协议并且<code>rport</code>被阻止，则该过程是不同的。在这种情况下，驱动程序<code>rport</code>在激活错误处理程序之前等待几秒钟才能再次联机。这可以防止由于临时传输问题导致设备脱机。</p>
<h3 id="设备状态"><a href="#设备状态" class="headerlink" title="设备状态"></a>设备状态</h3><p>要显示设备的状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /sys/block/device-name/device/state</span><br></pre></td></tr></table></figure>
<p>要将设备设置为该<code>running</code>状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃<span class="built_in">echo</span> running&gt; /sys/block/device-name/device/state</span><br></pre></td></tr></table></figure>
<h3 id="命令计时器"><a href="#命令计时器" class="headerlink" title="命令计时器"></a>命令计时器</h3><p>要控制命令计时器，请修改文件： <code>/sys/block/device-name/device/timeout</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃<span class="built_in">echo</span> value &gt; /sys/block/device-name/device/timeout</span><br></pre></td></tr></table></figure>
<p><code>value</code>在命令中用您想要实现的超时值（以秒为单位） 替换。</p>
<h2 id="在线存储配置故障排除"><a href="#在线存储配置故障排除" class="headerlink" title="在线存储配置故障排除"></a>在线存储配置故障排除</h2><p>逻辑单元删除状态不会反映在主机上。</p>
<p>在配置的文件管理器上删除逻辑单元时，更改不会反映在主机上。在这种情况下，<code>lvm</code>命令将在<code>dm-multipath</code>使用时无限期挂起，因为逻辑单元现在已经<em>过时</em>。</p>
<p>要解决此问题，请执行以下步骤：</p>
<p><strong>在陈旧的逻辑单位工作</strong></p>
<ol>
<li><p>确定哪些<code>mpath</code>链接条目<code>/etc/lvm/cache/.cache</code>特定于陈旧的逻辑单元。为此，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l / dev / mpath | grep stale-logical-unit</span><br></pre></td></tr></table></figure>
<p><strong>确定特定的mpath链接条目</strong></p>
<p>例如，如果<code>stale-logical-unit</code>是3600d0230003414f30000203a7bc41a00，则可能会出现以下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 7 Aug 2 10:33 / 3600d0230003414f30000203a7bc41a00  - &gt; ../dm-4 lrwxrwxrwx </span><br><span class="line">1 root root 7 Aug 2 10:33 / 3600d0230003414f30000203a7bc41a00p1  - &gt; ../dm-5</span><br></pre></td></tr></table></figure>
<p>这意味着3600d0230003414f30000203a7bc41a00被映射到两个<code>mpath</code>链接：<code>dm-4</code>和<code>dm-5</code>。</p>
</li>
<li><p>接下来，打开<code>/etc/lvm/cache/.cache</code>。删除包含的所有行<code>*stale-logical-unit</code>和映射到的<code>mpath</code>链接<code>stale-logical-unit</code>。</p>
</li>
</ol>
<p><strong>删除相关的行</strong></p>
<p>使用上一步中的相同示例，需要删除的行是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ dev / dm-4</span><br><span class="line">/ dev / dm-5</span><br><span class="line">/ dev / mapper / 3600d0230003414f30000203a7bc41a00</span><br><span class="line">/ dev / mapper / 3600d0230003414f30000203a7bc41a00p1</span><br><span class="line">/ dev / mpath / 3600d0230003414f30000203a7bc41a00</span><br><span class="line">/ dev / mpath / 3600d0230003414f30000203a7bc41a00p1</span><br></pre></td></tr></table></figure>
<h2 id="使用EH-DEADLINE配置错误恢复的最长时间"><a href="#使用EH-DEADLINE配置错误恢复的最长时间" class="headerlink" title="使用EH_DEADLINE配置错误恢复的最长时间"></a>使用EH_DEADLINE配置错误恢复的最长时间</h2><p>在大多数情况下，您不需要启用<em>eh_deadline</em>参数。<em>eh_deadline</em>例如，如果光纤通道交换机和目标端口之间发生链路丢失，并且主机总线适配器（HBA）没有收到注册状态更改通知（RSCN），则在某些特定情况下使用该参数可能很有用。在这种情况下，I / O请求和错误恢复命令全部超时而不是遇到错误。<em>eh_deadline</em>在这个环境中设置恢复时间的上限，这使得可以通过多路径在另一条可用路径上重试失败的I / O。</p>
<p>但是，如果启用了RSCN，则HBA不会注册链路变为不可用，或者两者兼而有之<em>eh_deadline</em>，因为I / O和错误恢复命令立即失败，因此该功能不会提供额外的好处，从而允许多路径重试。</p>
<p>SCSI主机对象<em>eh_deadline</em>参数使您能够配置SCSI错误处理机制在停止和重置整个HBA之前尝试执行错误恢复的最长时间。</p>
<p>该值<em>eh_deadline</em>以秒为单位指定。默认设置是<code>off</code>禁用时间限制，并允许所有的错误恢复。除使用外<code>sysfs</code>，还可以使用<em>scsi_mod.eh_deadline</em>内核参数为所有SCSI HBA设置默认值。</p>
<p>请注意，<em>eh_deadline</em>到期时，HBA将重置，从而影响该HBA上的所有目标路径，而不仅仅是失败的路径。因此，如果某些冗余路径由于其他原因而不可用，则可能会发生I / O错误。<em>eh_deadline</em>仅当您在所有目标上具有完全冗余的多路径配置时才启用。</p>
<h2 id="设备映射器多路径和虚拟存储"><a href="#设备映射器多路径和虚拟存储" class="headerlink" title="设备映射器多路径和虚拟存储"></a>设备映射器多路径和虚拟存储</h2><h3 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h3><p>红帽企业版Linux 7支持以下用于虚拟存储的文件系统/在线存储方法：</p>
<ul>
<li>光纤通道</li>
<li>iSCSI的</li>
<li>NFS</li>
<li>GFS2</li>
</ul>
<p>红帽企业版Linux 7中的虚拟化<code>libvirt</code>用于管理虚拟实例。该<code>libvirt</code>实用程序使用<em>存储池</em>的概念来管理虚拟客户的存储。存储池是可以分成更小卷或直接分配给来宾的存储。存储池的卷可以分配给虚拟客户端。有两类存储池可用：</p>
<p>本地存储池</p>
<p>本地存储涵盖直接连接到主机的存储设备，文件或目录。本地存储包括本地目录，直接连接的磁盘和LVM卷组。</p>
<p>联网（共享）存储池</p>
<p>网络存储涵盖了使用标准协议通过网络共享的存储设备。它包括使用光纤通道，iSCSI，NFS，GFS2和SCSI RDMA协议的共享存储设备，并且需要在主机之间迁移访客虚拟化来宾。</p>
<h3 id="DM-多路径"><a href="#DM-多路径" class="headerlink" title="DM-多路径"></a>DM-多路径</h3><p>设备映射器多路径（DM-Multipath）功能可让您将服务器节点和存储阵列之间的多个I / O路径配置到一个设备中。这些I / O路径是物理SAN连接，可以包含单独的电缆，交换机和控制器。多路径聚合I / O路径，创建一个由聚合路径组成的新设备。</p>
<p>DM-Multipath主要用于以下原因：</p>
<ul>
<li><p>冗余</p>
<p>DM-Multipath可以在主动/被动配置中提供故障转移。在主动/被动配置中，只有一半的路径在任何时候用于I / O。如果I / O路径的任何元素（电缆，交换机或控制器）发生故障，DM-Multipath将切换到备用路径。</p>
</li>
<li><p>改进的性能</p>
<p>可以在主动/主动模式下配置DM-Multipath，其中I / O以循环方式分布在路径上。在一些配置中，DM-Multipath可以检测I / O路径上的负载并动态地重新平衡负载。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux存储管理</title>
    <url>/2017/12/30/Linux/storage/LocalStorage/</url>
    <content><![CDATA[<h1 id="安装期间的存储注意事项"><a href="#安装期间的存储注意事项" class="headerlink" title="安装期间的存储注意事项"></a>安装期间的存储注意事项</h1><p>许多存储设备和文件系统设置只能在安装时进行配置。其他设置（如文件系统类型）只能在不需要重新格式化的情况下进行修改。因此，在安装红帽企业版Linux 7之前，谨慎的规划您的存储配置。<br><a id="more"></a></p>
<h2 id="特别注意事项"><a href="#特别注意事项" class="headerlink" title="特别注意事项"></a>特别注意事项</h2><p>列举了特定存储配置需要考虑的几个问题和因素。</p>
<h3 id="单独分区为-home-opt-usr-local"><a href="#单独分区为-home-opt-usr-local" class="headerlink" title="单独分区为 /home, /opt, /usr/local"></a>单独分区为 /home, /opt, /usr/local</h3><p>If it is likely that you will upgrade your system in the future, place <code>/home</code>, <code>/opt</code>, and <code>/usr/local</code> on a separate device. This will allow you to reformat the devices/file systems containing the operating system while preserving your user and application data.</p>
<h3 id="IBM-System-Z-上的-DASD和zFCP设备"><a href="#IBM-System-Z-上的-DASD和zFCP设备" class="headerlink" title="IBM System Z 上的 DASD和zFCP设备"></a>IBM System Z 上的 DASD和zFCP设备</h3><p>在IBM System Z平台上, DASD 和 zFCP 设备通过 <em>Channel Command Word</em> (CCW) 机制进行配置. CCW路径必须显式添加到系统中，然后才能联机。 对于DASD设备， 这只是意味着列出设备号码（或设备号码范围）， <code>DASD=</code> 参数在引导命令行或CMS配置文件中。</p>
<p>对于zFCP设备，必须列出设备号， <em>逻辑单元号</em> (LUN), and <em>全球端口名</em> (WWPN). 一旦zFCP设备被初始化，它被映射到CCW路径。 The <code>FCP_x=</code> 启动命令行（或在CMS配置文件）上线，您可以指定该信息的安装程序。</p>
<h3 id="使用LUKS加密块设备"><a href="#使用LUKS加密块设备" class="headerlink" title="使用LUKS加密块设备"></a>使用LUKS加密块设备</h3><p>使用LUKS /格式化块设备进行加密<code>dm-crypt</code>将会破坏该设备上的任何现有格式。因此，在新系统的存储配置作为安装过程的一部分被激活之前，您应该决定要加密哪些设备（如果有的话）。</p>
<h3 id="陈旧的BIOS-RAID元数据"><a href="#陈旧的BIOS-RAID元数据" class="headerlink" title="陈旧的BIOS RAID元数据"></a>陈旧的BIOS RAID元数据</h3><p>从配置为固件RAID的系统移动磁盘<em>而不</em>从磁盘中移除RAID元数据可能会阻止<strong>Anaconda</strong>正确检测磁盘。</p>
<p>从磁盘删除/删除RAID元数据可能会破坏任何存储的数据。红帽建议您在继续之前备份您的数据。</p>
<p>要从磁盘删除RAID元数据，请使用以下命令：</p>
<p><code>dmraid -r -E /*device*/</code></p>
<h3 id="iSCSI检测和配置"><a href="#iSCSI检测和配置" class="headerlink" title="iSCSI检测和配置"></a>iSCSI检测和配置</h3><p>对于iSCSI驱动器的即插即用检测，请将其配置在具有iBFT启动功能的<em>网络接口卡</em>（NIC）的固件中。在安装过程中支持iSCSI目标的CHAP身份验证。但是，安装期间不支持iSNS发现。</p>
<h3 id="FCoE检测和配置"><a href="#FCoE检测和配置" class="headerlink" title="FCoE检测和配置"></a>FCoE检测和配置</h3><p>对于<em>以太网光纤通道</em>（FCoE）驱动器的即插即用检测，请在具有EDD引导功能的NIC的固件中对其进行配置。</p>
<h3 id="DASD"><a href="#DASD" class="headerlink" title="DASD"></a>DASD</h3><p><em>直接访问存储设备</em>（DASD）不能在安装过程中添加/配置。这些设备在CMS配置文件中指定。</p>
<h3 id="块设备启用DIF-DIX"><a href="#块设备启用DIF-DIX" class="headerlink" title="块设备启用DIF/DIX"></a>块设备启用DIF/DIX</h3><p>DIF/DIX 是某些SCSI主机总线适配器和块设备提供的硬件校验和功能. 启用 DIF/DIX 时, 如果块设备用作通用块设备，则会发生错误。 缓冲的 I/O 或 <code>mmap(2)</code>-基于 I/O 将无法可靠地工作，因为在缓冲写入路径中没有互锁，以防止在计算了 DIF/DIX 校验和之后缓冲的数据被覆盖。</p>
<p>这将导致 I/O 稍后失败并出现校验和错误。这个问题对所有块设备（或基于文件系统）缓冲的 I/O 或 <code>mmap(2)</code> I/O, 都很常见，所以不可能解决这些由覆盖造成的错误。</p>
<p>因此，启用了 DIF/DIX 的块设备只能与使用的应用程序一起使用 <code>O_DIRECT</code>. 这样的应用程序应该使用原始块设备。或者，只要在文件系统中只发出 <code>O_DIRECT</code> I/O . 在启用了DIF/DIX的块设备上使用XFS文件系统也是安全的。XFS是唯一一个在执行某些分配操作时不会回退到缓冲I/O的文件系统。</p>
<p>在计算完 DIF/DIX 校验和之后，确保I/O数据不会改变的责任始终在于应用程序，因此只有为 <code>O_DIRECT</code> I/O 和 DIF/DIX 硬件设计的应用程序才能使用 DIF/DIX.</p>
<h1 id="文件系统检查"><a href="#文件系统检查" class="headerlink" title="文件系统检查"></a>文件系统检查</h1><p>可以使用文件系统特定的用户空间工具检查文件系统的一致性，并可以选择修复。这些工具通常被称为<code>fsck</code>工具，其中<code>fsck</code>是缩短版本的<em>文件系统检查</em>。</p>
<p><strong>注意</strong></p>
<p>文件系统不一致可能由于各种原因而发生，包括但不限于硬件错误，存储管理错误和软件错误。</p>
<p>这些文件系统检查程序只保证整个文件系统的元数据一致性; 他们没有意识到文件系统中包含的实际数据，而不是数据恢复工具。</p>
<p>在现代元数据记录文件系统变得普遍之前，系统崩溃或断电时都需要进行文件系统检查。这是因为文件系统更新可能被中断，导致状态不一致。因此，文件系统检查通常<code>/etc/fstab</code>在引导时列出的每个文件系统上运行。对于日志文件系统，这通常是非常短的操作，因为文件系统的元数据日志记录即使在崩溃之后也能确保一致性。</p>
<p>但是，即使对于日志记录文件系统，有时甚至可能发生文件系统不一致或损坏。发生这种情况时，必须使用文件系统检查程序修复文件系统。以下内容将提供执行此过程时的最佳实践和其他有用信息。</p>
<p>除非计算机无法启动，文件系统非常大或者文件系统位于远程存储中，否则Red Hat不建议使用此功能。通过将/etc/fstab中的第六个字段设置为0，可以在启动时禁用文件系统检查。</p>
<h2 id="fsck最佳实践"><a href="#fsck最佳实践" class="headerlink" title="fsck最佳实践"></a>fsck最佳实践</h2><p>一般来说，运行文件系统检查和修复工具可以自动修复至少一些找到的不一致之处。在某些情况下，严重损坏的索引节点或目录如果无法修复，可能会被丢弃。文件系统的重大更改可能会发生。为确保不会永久性发生意想不到的变化，请执行以下预防措施：</p>
<ul>
<li><p>演习</p>
<p>大多数文件系统检查程序有一个操作模式，可以检查文件系统，但不会修复文件系统。在这种模式下，检查器将打印它找到的任何错误和应该采取的操作，而不实际修改文件系统。</p>
<p>一致性检查的后续阶段可能会打印额外的错误，因为它发现了不一致的情况，如果在修复模式下运行，它们在早期阶段就会被修复。</p>
</li>
<li><p>首先在文件系统映像上运行</p>
<p>大多数文件系统都支持创建<em>元数据映像</em>，这是一个只包含元数据的文件系统的稀疏副本。由于文件系统检查程序仅对元数据进行操作，因此可以使用此映像执行实际文件系统修复的空运行，以评估实际进行的更改。如果更改是可接受的，则修复可以在文件系统上执行。</p>
<p>严重损坏的文件系统可能会导致元数据映像创建出现问题。</p>
</li>
<li><p>保存文件系统映像以进行支持调查</p>
<p>修复前的文件系统元数据映像通常可以用于支持调查，如果有可能是由于软件错误引起的。修复前图像中存在的腐败模式可能有助于根源分析。</p>
</li>
<li><p>仅在卸载的文件系统上运行</p>
<p>文件系统的修复只能在未安装的文件系统上运行。该工具必须能够唯一访问文件系统，否则可能会导致进一步的损坏。大多数文件系统工具在修复模式下强制执行此要求，尽管某些文件系统仅支持在已安装的文件系统上进行只检查模式。如果在已安装的文件系统上运行只检查模式，则可能会发现在卸载的文件系统上运行时不会发现的虚假错误。</p>
</li>
<li><p>磁盘错误</p>
<p>文件系统检查工具不能修复硬件问题。如果修复成功，文件系统必须完全可读写。如果文件系统由于硬件错误而损坏，则必须首先将文件系统移动到合适的磁盘上，例如使用 <code>dd(8)</code> 实用程序.</p>
</li>
</ul>
<h2 id="FSCK的文件系统特定信息"><a href="#FSCK的文件系统特定信息" class="headerlink" title="FSCK的文件系统特定信息"></a>FSCK的文件系统特定信息</h2><h3 id="ext2-ext3-和-ext4"><a href="#ext2-ext3-和-ext4" class="headerlink" title="ext2, ext3, 和 ext4"></a>ext2, ext3, 和 ext4</h3><p>所有这些文件系统都使用 <code>e2fsck</code> 二进制来执行文件系统检查和修复. 文件名 <code>fsck.ext2</code>, <code>fsck.ext3</code>, 和 <code>fsck.ext4</code> 都硬链接到这个相同的二进制文件. 这些二进制文件在启动时自动运行，其行为根据被检查的文件系统和文件系统的状态而不同。</p>
<p>对ext2（不是元数据日志文件系统）和ext4文件系统（不带日志）调用完整的文件系统检查和修复.</p>
<p>对于具有元数据日记功能的ext3和ext4文件系统，将在用户空间中重播日志，并退出二进制文件。这是默认操作，因为日志重播确保崩溃后的文件系统一致</p>
<p>如果这些文件系统在挂载时遇到元数据不一致的情况，他们会将这个事实记录在文件系统超级块中。 如果 <code>e2fsck</code> 发现文件系统标有这样的错误 <code>e2fsck</code> 将在重播日志（如果存在）后执行完整检查。</p>
<p><code>e2fsck</code> 如果没有指定<code>-p</code>选项 ，则可以在运行期间询问用户输入。   <code>-p</code>项告诉 <code>e2fsck</code> 自动执行所有可能安全完成的修理。如果需要用户干预， <code>e2fsck</code> 将在其输出中指示未固定的问题，并在退出代码中反映此状态。</p>
<p>常用的 <code>e2fsck</code> 运行时选项包括：</p>
<ul>
<li><p><code>-n</code></p>
<p>无修改模式。只检查操作。</p>
</li>
<li><p><code>-b</code> superblock</p>
<p>如果主要的损坏，指定一个备用的suprerblock的块号。</p>
</li>
<li><p><code>-f</code></p>
<p>即使超级块没有记录错误，也强制进行全面检查。</p>
</li>
<li><p><code>-j</code> journal-dev</p>
<p>指定外部日志设备（如果有）。</p>
</li>
<li><p><code>-p</code></p>
<p>在没有用户输入的情况下自动修复或“修改”文件系统。</p>
</li>
<li><p><code>-y</code></p>
<p>对所有问题都回答“是”。</p>
<p><code>e2fsck</code>所有选项都在 <code>e2fsck(8)</code> 手册页中。</p>
</li>
</ul>
<p><code>e2fsck</code> 运行时 执行以下五个基本阶段：</p>
<ol>
<li>Inode, block,和大小检查。</li>
<li>目录结构检查。</li>
<li>目录连接检查。</li>
<li>引用计数检查。</li>
<li><p>小组汇总信息检查。</p>
<p><code>e2image(8)</code> 在修复之前， 该实用程序可用于创建元数据映像以用于诊断或测试目的。  <code>-r</code> 选项应该用于测试目的，以创建一个与文件系统本身相同大小的稀疏文件。 <code>e2fsck</code> 然后可以直接对结果文件进行操作。 如果要将图像归档或提供用于诊断，应指定<code>-Q</code>选项  ，这创建了一个适合传输的更紧凑的文件格式。</p>
</li>
</ol>
<h3 id="XFS"><a href="#XFS" class="headerlink" title="XFS"></a>XFS</h3><p>在启动时不会自动执行修复。要启动文件系统检查或修复，使用 <code>xfs_repair</code> 工具。</p>
<p><strong>注意</strong></p>
<p>尽管xfsprogs包中有一个二进制文件 <code>fsck.xfs</code> ，但它只是为了满足在启动时查找二进制文件 <code>fsck.*filesystem*</code>的初始化脚本 . <code>fsck.xfs</code> 立即退出，退出代码为0.</p>
<p>另一件需要注意的是旧的xfsprogs包包含一个 <code>xfs_check</code> 工具。这个工具非常慢，对于大型文件系统来说效果不好。因此, 它已被弃用，推荐使用xfs_repair -n`.</p>
<p> <code>xfs_repair</code> 操作，文件系统上必须是干净的日志， 如果文件系统没有完全卸载, 在使用 <code>xfs_repair</code>之前应该挂载和卸载. 如果日志损坏且无法重播, 可以使用 <code>-L</code> 选项将日志归零.</p>
<p><strong>重要</strong></p>
<p> <code>-L</code> 选项 只有在日志无法重播的情况下才能使用. 该选项会丢弃日志中的所有元数据更新，并将导致进一步的不一致.</p>
<p>可以在演习运行 <code>xfs_repair</code> , 运行check-only模式通过 <code>-n</code> 选项. 不会对文件系统进行更改。</p>
<p><code>xfs_repair</code> 需要很少的选项。常用的选项包括:</p>
<ul>
<li><p><code>-n</code></p>
<p>没有修改模式。只检查操作。</p>
</li>
<li><p><code>-L</code></p>
<p>零元数据日志。只有在日志不能用mount重放时才使用。</p>
</li>
<li><p><code>-m</code> maxmem</p>
<p>将运行期间使用的内存限制为 maxmem MB. 可以指定0来获得所需最小内存的粗略估计。</p>
</li>
<li><p><code>-l</code> logdev</p>
<p>指定外部日志设备（如果存在）。</p>
<p><code>xfs_repair</code> 的所有选项都在 <code>xfs_repair(8)</code> 手册页中指定.</p>
</li>
</ul>
<p><code>xfs_repair</code> 运行时 执行以下八个基本阶段:</p>
<ol>
<li>Inode 和 inode 块映射 (寻址) 检查.</li>
<li>Inode 分配映射检查.</li>
<li>Inode 大小检查.</li>
<li>目录检查.</li>
<li>路径名检查.</li>
<li>链接计数检查.</li>
<li>Freemap检查.</li>
<li>超级块检查.</li>
</ol>
<p><code>xfs_repair</code> 不是交互的. 所有的操作都是在没有用户输入的情况下自动执行的.</p>
<p>如果希望在修复之前创建元数据映像以用于诊断或测试目的，可以使用<code>xfs_metadump(8)</code> 和 <code>xfs_mdrestore(8)</code> 。</p>
<h4 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h4><p> <code>btrfsck</code> 工具用于检查和修复btrfs文件系统。此工具仍处于早期开发阶段，可能无法检测或修复所有类型的文件系统损坏。</p>
<p>默认情况下, <code>btrfsck</code> 不对文件系统进行更改; 也就是说，它默认运行只检查模式。如果需要修复，必须指定 <code>--repair</code> 选项。</p>
<p> <code>btrfsck</code>运行时 执行以下三个基本阶段 :</p>
<ol>
<li>范围检查。</li>
<li>文件系统根检查。</li>
<li>根引用计数检查。</li>
</ol>
<p>在修复之前<code>btrfs-image(8)</code> 可用于创建元数据映像以用于诊断或测试目的。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>使用 <strong>parted</strong> 程序，您可以：</p>
<ul>
<li>查看现有的分区表。</li>
<li>改变现有分区的大小。</li>
<li>从可用空间或其他硬盘添加分区。</li>
</ul>
<p>Parted软件包默认安装在Red Hat Enterprise Linux 7上. 启动 <strong>parted</strong>, 以root身份登录 ，在shell下运行 <code>parted */dev/sda*</code> </p>
<p>其中 <em>/dev/sda</em> 是要配置的驱动器设备名称。</p>
<h2 id="在正在使用的设备上操作分区"><a href="#在正在使用的设备上操作分区" class="headerlink" title="在正在使用的设备上操作分区"></a>在正在使用的设备上操作分区</h2><p>对于不使用的设备，不能使用设备上的分区进行挂载，也不能使能设备的交换空间。</p>
<p>如果要删除或调整分区的大小，则不得使用该分区所在的设备。</p>
<p>在正在使用的设备上创建新分区是可能的，但不推荐使用。</p>
<h2 id="修改分区表"><a href="#修改分区表" class="headerlink" title="修改分区表"></a>修改分区表</h2><p>通常不建议在同一磁盘上的另一个分区正在使用的同时修改分区表，因为内核无法重新读取分区表。因此，更改不适用于正在运行的系统。在描述的情况下，重新启动系统，或使用以下命令使系统注册新的或修改的分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># partx --update --nr partition-number disk</span></span><br></pre></td></tr></table></figure>
<p>修改当前正在使用的磁盘的最简单方法是，如果无法卸载磁盘上的分区（例如在系统磁盘的情况下），则以救援模式引导系统。当提示安装文件系统时，请选择<strong>跳过</strong>。</p>
<p>如果驱动器不包含任何正在使用的分区，也就是没有使用或锁定文件系统的系统进程被卸载，则可以使用<code>umount</code>命令卸载分区，并使用<code>swapoff</code>命令关闭硬盘上的所有交换空间。</p>
<p>不要使用<strong>parted</strong>实用程序来创建文件系统。改用<strong>mkfs</strong>工具。</p>
<p><strong>parted Commands</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check</code> <em><code>minor-num</code></em></td>
<td>执行文件系统的简单检查</td>
</tr>
<tr>
<td><code>cp</code> <em><code>from to</code></em></td>
<td>从一个分区复制文件系统到另一个分区; <em>从</em>和<em>到</em>是分区的次要数字</td>
</tr>
<tr>
<td><code>help</code></td>
<td>显示可用命令的列表</td>
</tr>
<tr>
<td><code>mklabel</code> <em><code>label</code></em></td>
<td>为分区表创建一个磁盘标签</td>
</tr>
<tr>
<td><code>mkfs</code> <em><code>minor-num</code></em> <em><code>file-system-type</code></em></td>
<td>创建一个文件系统类型的<em>文件系统</em></td>
</tr>
<tr>
<td><code>mkpart</code> <em><code>part-type</code></em> [<em><code>fs-type</code></em>] <em><code>start-mb**end-mb</code></em></td>
<td>创建一个分区而不创建新的文件系统</td>
</tr>
<tr>
<td><code>mkpartfs</code> <em><code>part-type</code></em> <em><code>fs-type</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>创建一个分区并创建指定的文件系统</td>
</tr>
<tr>
<td><code>move</code> <em><code>minor-num</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>移动分区</td>
</tr>
<tr>
<td><code>name</code> <em><code>minor-num</code></em> <em><code>name</code></em></td>
<td>只为Mac和PC98磁盘标签命名分区</td>
</tr>
<tr>
<td><code>print</code></td>
<td>显示分区表</td>
</tr>
<tr>
<td><code>quit</code></td>
<td>退出 <strong>parted</strong></td>
</tr>
<tr>
<td><code>rescue</code> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>从<em>start-mb</em>到<em>end-mb</em>挽救一个丢失的分区</td>
</tr>
<tr>
<td><code>resize</code> <em><code>minor-num</code></em> <em><code>start-mb</code></em> <em><code>end-mb</code></em></td>
<td>调整分区从<em>start-mb</em>到<em>end-mb的大小</em></td>
</tr>
<tr>
<td><code>rm</code> <em><code>minor-num</code></em></td>
<td>删除分区</td>
</tr>
<tr>
<td><code>select</code> <em><code>device</code></em></td>
<td>选择一个不同的设备进行配置</td>
</tr>
<tr>
<td><code>set</code> <em><code>minor-num</code></em> <em><code>flag</code></em> <em><code>state</code></em></td>
<td>在分区上设置标志; <em>状态</em>是打开还是关闭</td>
</tr>
<tr>
<td><code>toggle</code> [<em><code>NUMBER</code></em> [<em><code>FLAG</code></em>]</td>
<td>在<em>NUMBER</em>分区上切换<em>FLAG</em>的状态</td>
</tr>
<tr>
<td><code>unit</code> <em><code>UNIT</code></em></td>
<td>将默认单位设置为<em>UNIT</em></td>
</tr>
</tbody>
</table>
</div>
<h2 id="查看分区表"><a href="#查看分区表" class="headerlink" title="查看分区表"></a>查看分区表</h2><p>启动parted, 使用 <code>print</code> 命令来查看分区表。出现类似如下的表格：</p>
<p><strong>分区表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Model: ATA ST3160812AS (scsi)</span><br><span class="line">Disk /dev/sda: 160GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line"></span><br><span class="line">Number  Start   End    Size    Type      File system  Flags</span><br><span class="line"> 1      32.3kB  107MB  107MB   primary   ext3         boot</span><br><span class="line"> 2      107MB   105GB  105GB   primary   ext3</span><br><span class="line"> 3      105GB   107GB  2147MB  primary   linux-swap</span><br><span class="line"> 4      107GB   160GB  52.9GB  extended		      root</span><br><span class="line"> 5      107GB   133GB  26.2GB  logical   ext3</span><br><span class="line"> 6      133GB   133GB  107MB   logical   ext3</span><br><span class="line"> 7      133GB   160GB  26.6GB  logical                lvm</span><br></pre></td></tr></table></figure>
<p>第一行包含磁盘类型，制造商，型号和接口，第二行显示磁盘标签类型。第四行下面的剩余输出显示分区表。</p>
<p>在分区表中, <em>次要</em>号码是分区 <code>number</code>. 例如，次号为1的分区对应于 <code>/dev/sda1</code>.  <code>Start</code> 和 <code>End</code> 值以MB为单位。 有效的 <code>Type</code> 是元数据, free（空闲）, primary（主）, extended（扩展）, or logical（逻辑）.  <code>Filesystem</code> 是文件系统的类型，其可以是任何以下的：</p>
<ul>
<li>ext2</li>
<li>ext3</li>
<li>fat16</li>
<li>fat32</li>
<li>hfs</li>
<li>jfs</li>
<li>linux-swap</li>
<li>ntfs</li>
<li>reiserfs</li>
<li>hp-ufs</li>
<li>sun-ufs</li>
<li>xfs</li>
</ul>
<p>如果某个<code>Filesystem</code>设备没有显示任何值，则表示其文件系统类型未知。</p>
<p><strong>标志</strong>列列出了分区被设置的标志。可用的标志有 boot, root, swap, hidden, raid, lvm, or lba.</p>
<p>要选择不同的设备而不必重新启动<code>parted</code>，请使用<code>select</code>命令后跟设备名称（例如<code>/dev/sda</code>）。这样做可以让您查看或配置设备的分区表。</p>
<h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><p>==不要尝试在正在使用的设备上创建分区。==</p>
<p><strong>创建分区</strong></p>
<ol>
<li><p>在创建分区之前，启动进入救援模式（或卸载设备上的任何分区，并关闭设备上的交换空间）。</p>
</li>
<li><p>开始<code>parted</code>，在哪里创建分区的设备： <code>/dev/sda</code></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># parted /dev/sda</span></span><br></pre></td></tr></table></figure>
<ol>
<li>查看当前分区表以确定是否有足够的可用空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print</span></span><br></pre></td></tr></table></figure>
<p>如果没有足够的可用空间，则可以调整现有分区的大小。</p>
<h3 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h3><p>从分区表中，确定新分区的起点和终点以及它应该是什么分区类型。设备上只能有四个主分区（没有扩展分区）。如果您需要四个以上的分区，则扩展中可以有三个主分区，一个扩展分区和多个逻辑分区。</p>
<p>例如，要创建一个ext3文件系统从1024兆字节到2048兆字节的硬盘上的主分区，请键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkpart primary 1024 2048</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果使用该<code>mkpartfs</code>命令，则在创建分区后创建文件系统。但是，<code>parted</code>不支持创建ext3文件系统。因此，如果您希望创建一个ext3文件系统，请按照稍后所述使用<code>mkpart</code>和创建文件系统<code>mkfs</code>。</p>
<p>按<strong>Enter键后</strong>，所做的更改就会开始，因此在执行命令之前先查看命令。</p>
<p>创建分区后，使用该<code>print</code>命令确认它在正确的分区类型，文件系统类型和大小的分区表中。还要记住新分区的次要号码，以便您可以在其上标记任何文件系统。您还应该查看<code>cat /proc/partitions</code>关闭后的输出，以确保内核识别新分区。</p>
<p>分区分区的最大数量将为128.尽管<em>GUID分区表</em>（GPT）规范允许通过增加为分区表保留的区域来增加分区，但分区使用的常见做法是将其限制为足够的区域用于128个分区。</p>
<h3 id="格式化和标记分区"><a href="#格式化和标记分区" class="headerlink" title="格式化和标记分区"></a>格式化和标记分区</h3><p>要格式化和标记分区，请使用以下过程：</p>
<p><strong>格式化和标记分区</strong></p>
<ol>
<li>该分区没有文件系统。要创建<code>ext4</code>文件系统，请使用：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 /dev/sda6</span></span><br></pre></td></tr></table></figure>
<p>   <strong>警告</strong></p>
<p>   格式化分区将永久销毁分区上当前存在的任何数据。</p>
<ol>
<li><p>接下来，给分区上的文件系统一个标签。例如，如果新分区上的文件系统是<code>/dev/sda6</code>并且要标记它<code>/work</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># e2label /dev/sda6 /work</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>默认情况下，安装程序使用分区的挂载点作为标签来确保标签是唯一的。你可以使用任何你想要的标签。</p>
<p>之后，以root身份创建一个安装点（例如<code>/work</code>）。</p>
<h4 id="添加-etc-fstab"><a href="#添加-etc-fstab" class="headerlink" title="添加/etc/fstab"></a>添加<code>/etc/fstab</code></h4><p>以root <code>/etc/fstab</code>身份，使用分区的UUID 编辑文件以包含新的分区。使用该命令<code>blkid -o list</code>可以获得分区UUID的完整列表，也可以<code>blkid device</code>查看各个设备的详细信息。</p>
<p>第一列应该包含<code>UUID=</code>文件系统的UUID。第二列应包含新分区的挂载点，下一列应为文件系统类型（例如，ext3或swap）。如果您需要更多关于格式的信息，请使用该命令阅读手册页<code>man fstab</code>。</p>
<p>如果第四列是该字<code>defaults</code>，则在引导时挂载分区。要挂载分区而不重新启动，请以超级用户身份键入以下命令：</p>
<p><code>mount /work</code></p>
<h2 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h2><p>==不要尝试删除正在使用的设备上的分区。==</p>
<p><strong>删除分区</strong></p>
<ol>
<li><p>在删除分区之前，启动进入救援模式（或卸载设备上的任何分区，并关闭设备上的交换空间）.</p>
</li>
<li><p>启动 <code>parted</code>, 删除sda设备上的分区。</p>
</li>
</ol>
<p>​```bash</p>
<h1 id="parted-dev-sda"><a href="#parted-dev-sda" class="headerlink" title="parted /dev/sda"></a>parted /dev/sda</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 查看当前分区表以确定要删除的分区的次号码：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">   # print</span><br></pre></td></tr></table></figure>
<ol>
<li>用命令<code>rm</code>删除分区 . 例如，要删除次编号为3的分区：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm 3</span></span><br></pre></td></tr></table></figure>
<p>   按<strong>Enter键</strong>，所做的更改就会开始，因此在提交之前先查看命令。</p>
<ol>
<li>删除分区后，使用 <code>print</code> 命令确认它已从分区表中删除。您还应该查看输出<code>/proc/partitions</code>以确保内核知道分区已被删除。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/partitions</span></span><br></pre></td></tr></table></figure>
<ol>
<li>最后一步是从<code>/etc/fstab</code>文件中删除它。找到声明已删除分区的行，并将其从文件中删除。</li>
</ol>
<h2 id="设置分区类型"><a href="#设置分区类型" class="headerlink" title="设置分区类型"></a>设置分区类型</h2><p>分区类型，不要与文件系统类型混淆，很少被运行的系统使用。但是，分区类型对即时生成器很重要，例如<code>systemd-gpt-auto-generator</code>使用分区类型来自动识别和挂载设备。</p>
<p>您可以启动该<code>fdisk</code>实用程序并使用该<code>t</code>命令来设置分区类型。以下示例显示如何将第一个分区的分区类型更改为0x83，在Linux上是default：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/sdc</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Partition <span class="built_in">type</span> (<span class="built_in">type</span> L to list all types): 83</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux LVM'</span> to <span class="string">'Linux'</span>.</span><br></pre></td></tr></table></figure>
<p><code>parted</code> 程序通过尝试将分区类型映射到“标志”来提供对分区类型的一些控制，这对最终用户不方便。该<code>parted</code>实用程序只能处理某些分区类型，例如LVM或RAID。例如，要删除第一个分区的lvm标志<code>parted</code>，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parted</span><br><span class="line"><span class="comment"># parted /dev/sdc 'set 1 lvm off'</span></span><br></pre></td></tr></table></figure>
<h2 id="使用FDISK调整分区大小"><a href="#使用FDISK调整分区大小" class="headerlink" title="使用FDISK调整分区大小"></a>使用FDISK调整分区大小</h2><p><code>fdisk</code>实用程序允许您创建和操作GPT，MBR，Sun，SGI和BSD分区表。在具有GUID分区表（GPT）的磁盘上，<code>parted</code>建议使用该实用程序，因为<code>fdisk</code>GPT支持处于试验阶段。</p>
<p>在调整分区大小之前，<em>备份</em>存储在文件系统<em>上</em>的数据并测试过程，因为使用的唯一方法是更改分区大小，方法<code>fdisk</code>是删除并重新创建分区。</p>
<p><strong>重要</strong></p>
<p>您正在调整大小的分区必须是特定磁盘上的最后一个分区。</p>
<p>红帽只支持扩展和调整LVM分区的大小。</p>
<p><strong>调整分区大小</strong></p>
<p>以下程序仅供参考。要使用<code>fdisk</code>以下命令调整分区大小：</p>
<ol>
<li>卸载设备:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># umount /dev/vda</span></span><br></pre></td></tr></table></figure>
<ol>
<li>运行 <code>fdisk *disk_name*</code>. 例如:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fdisk /dev/vda</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them. Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>):</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>p</code> 选项确定要删除的分区的行号。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p</span><br><span class="line">Disk /dev/vda: 16.1 GB, 16106127360 bytes, 31457280 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x0006d09a</span><br><span class="line"></span><br><span class="line">Device    Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/vda2         1026048    31457279    15215616   8e  Linux LVM</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用 <code>d</code> 选项删除分区. 如果有多个可用的分区，<code>fdisk</code>则会提示您提供一个要删除的分区的编号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line">Partition 2 is deleted</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>使用 <code>n</code> 选项创建分区并按照提示进行操作。留出足够的空间用于将来调整大小.  <code>fdisk</code> 默认行为 (输入 <code>Enter</code>) 是使用设备上的所有空间. 您可以按扇区指定分区的末尾, 也可以使用 <code>+*&lt;size&gt;**&lt;suffix&gt;*</code>, 例如 +500M, 或者 +10G.</p>
<p>如果您不想使用全部可用空间，则Red Hat建议使用可读大小的规范<code>fdisk</code>，将分区的末尾与物理扇区对齐。如果通过提供确切的数字（扇区）来指定大小，<code>fdisk</code>则不会对齐分区的末尾。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): *Enter*</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (2-4, default 2): *Enter*</span><br><span class="line">First sector (1026048-31457279, default 1026048): *Enter*</span><br><span class="line">Using default value 1026048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (1026048-31457279, default 31457279): +500M</span><br><span class="line">Partition 2 of <span class="built_in">type</span> Linux and of size 500 MiB is <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将分区类型设置为LVM:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1,2, default 2): *Enter*     </span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果确定所做的更改是正确的 请使用<code>w</code>选项编写更改 , 因为错误可能会导致所选分区不稳定。</p>
</li>
<li><p>运行 <code>e2fsck</code> 在设备上 运行以检查一致性:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e2fsck /dev/vda</span><br><span class="line">e2fsck 1.41.12 (17-May-2010)</span><br><span class="line">Pass 1:Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2:Checking directory structure</span><br><span class="line">Pass 3:Checking directory connectivity</span><br><span class="line">Pass 4:Checking reference counts</span><br><span class="line">Pass 5:Checking group summary information</span><br><span class="line">ext4-1:11/131072 files (0.0% non-contiguous),27050/524128 blocks</span><br></pre></td></tr></table></figure>
<ol>
<li>挂载设备:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/vda</span><br></pre></td></tr></table></figure>
<h1 id="使用快照程序创建和维护快照"><a href="#使用快照程序创建和维护快照" class="headerlink" title="使用快照程序创建和维护快照"></a>使用快照程序创建和维护快照</h1><p>快照卷是目标卷的时间点副本，它提供了将文件系统恢复到早期状态的方法。Snapper是一个命令行工具，用于为Btrfs和精简配置的LVM文件系统创建和维护快照。</p>
<h2 id="创建初始快照程序配置"><a href="#创建初始快照程序配置" class="headerlink" title="创建初始快照程序配置"></a>创建初始快照程序配置</h2><p>Snapper需要为其运行的每个卷设置独立的配置文件。您必须手动设置配置文件。默认情况下，只有root用户才能执行snapper命令。</p>
<p>Red Hat建议在Red Hat Enterprise Linux 7上使用带有Snapper的ext4文件系统。只有在监视池中的可用空间量时，才能在lvm-thin卷上使用XFS文件系统，以防止出现空间不足的问题导致失败。</p>
<p>请注意，Btrfs工具和文件系统是作为技术预览提供的，这使得它们不适用于生产系统。</p>
<p>虽然可以允许用户或根以外的组使用某些命令鲷鱼，红帽建议您不要<em>不</em>提升的权限添加到非特权否则用户或组。这样的配置绕过SELinux，可能会造成安全风险。红帽建议您与安全团队一起审核这些功能，并考虑使用<code>sudo</code>基础架构。</p>
<p><strong>创建快照程序配置文件</strong></p>
<ol>
<li><p>创建或选择:</p>
<ul>
<li>一个配置了红帽支持文件系统的精简配置逻辑卷，或者</li>
<li>Btrfs子卷.</li>
</ul>
</li>
<li><p>安装文件系统.</p>
</li>
<li><p>创建定义这个卷的配置文件.</p>
<p>对于 LVM2:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create-config -f "lvm(fs_type)" /mount-point</span></span><br></pre></td></tr></table></figure>
<p>   对于 Btrfs:</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create-config -f btrfs /mount-point</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-c</code> <em><code>config_name</code></em> 选项指定配置文件的名称.</li>
<li><code>create-config</code> 选项告诉 snapper创建一个配置文件.</li>
<li><code>-f</code> <em><code>file_system</code></em> 选项告诉 snapper 所使用的文件系统；如果省略将尝试检测文件系统</li>
<li><p><em><code>/mount-point</code></em> 是安装子卷或精简配置的LVM2文件系统的位置</p>
<p>例如，要创建<code>lvm_config</code>在具有ext4文件系统的LVM2子卷上调用的配置文件（安装在）<code>/lvm_mount</code>，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create-config -f "lvm(ext4)" /lvm_mount</span></span><br></pre></td></tr></table></figure>
<p>或者，要创建名为的配置文件<code>btrfs_config</code>，请在挂载的Btrfs子卷上<code>/btrfs_mount</code>使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c btrfs_config create-config -f btrfs /btrfs_mount</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置文件存储在<code>/etc/snapper/configs/</code>目录中。</p>
<h2 id="创建快照程序快照"><a href="#创建快照程序快照" class="headerlink" title="创建快照程序快照"></a>创建快照程序快照</h2><p>Snapper可以创建以下类型的快照：</p>
<ul>
<li><p>快照前</p>
<p>预先快照作为发布后快照的起点。两者紧密联系，旨在跟踪两点之间的文件系统修改。必须在发布快照之前创建预先快照。</p>
</li>
<li><p>张贴快照</p>
<p>后快照被用作快照的终点。快照结合前后快照定义了一个比较范围。默认情况下，每个新的快照程序卷都被配置为在成功创建相关的快照后创建背景比较。</p>
</li>
<li><p>单一快照</p>
<p>单个快照是在特定时刻创建的独立快照。这些可以用来跟踪修改的时间线，并有一个普遍的观点返回到稍后。</p>
</li>
</ul>
<h3 id="创建前置和后置快照对"><a href="#创建前置和后置快照对" class="headerlink" title="创建前置和后置快照对"></a>创建前置和后置快照对</h3><h4 id="使用Snapper创建前期快照"><a href="#使用Snapper创建前期快照" class="headerlink" title="使用Snapper创建前期快照"></a>使用Snapper创建前期快照</h4><p>要创建预览快照，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create -t pre</span></span><br></pre></td></tr></table></figure>
<p> <code>-c *config_name*</code> 选项根据指定配置文件中的规范创建快照。</p>
<p><code>create -t</code> 选项指定要创建的快照类型。接受条目 <code>pre</code>, <code>post</code>, 或 <code>single</code>.</p>
<p>例如, ，使用<code>lvm_config</code> 配置文件创建一个快照前，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c SnapperExample create -t pre -p</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p> <code>-p</code> 选项将打印创建的快照的编号，并且是可选的。</p>
<h4 id="使用Snapper创建帖子快照"><a href="#使用Snapper创建帖子快照" class="headerlink" title="使用Snapper创建帖子快照"></a>使用Snapper创建帖子快照</h4><p><strong>创建一个快照</strong></p>
<ol>
<li><p>确定快照编号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name list</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   例如，要显示使用配置文件创建的快照列表<code>lvm_config</code>, 请使用以下命令：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config list</span></span><br><span class="line">Type   | <span class="comment"># | Pre # | Date              | User | Cleanup  | Description | Userdata</span></span><br><span class="line">-------+---+-------+-------------------+------+----------+-------------+---------</span><br><span class="line">single | 0 |       |                   | root |          | current     |</span><br><span class="line">pre    | 1 |       | Mon 06&lt;...&gt;       | root |          |             |</span><br></pre></td></tr></table></figure>
<p>   上面的输出显示前快照是编号1。</p>
<ol>
<li>创建链接到先前创建的预先快照的后快照：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file create -t post --pre-num pre_snapshot_number</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t post</code> 选项指定创建快照类型.</li>
<li><p><code>--pre-num</code> 选项指定相应的预先快照.</p>
<p>例如，要使用 <code>lvm_config</code> 配置文件创建后期快照并将其链接到预先快照编号1，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create -t post --pre-num 1 -p</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>-p</code> 选项将打印创建的快照的编号，并且是可选的。</p>
</li>
</ul>
<ol>
<li><p>快照1和快照2现在已创建并配对。验证这个<code>list</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config list</span></span><br><span class="line">Type   | <span class="comment"># | Pre # | Date              | User | Cleanup  | Description | Userdata</span></span><br><span class="line">-------+---+-------+-------------------+------+----------+-------------+---------</span><br><span class="line">single | 0 |       |                   | root |          | current     |</span><br><span class="line">pre    | 1 |       | Mon 06&lt;...&gt;       | root |          |             |</span><br><span class="line">post   | 2 | 1     | Mon 06&lt;...&gt;       | root |          |             |</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="在快照前后包装一个命令"><a href="#在快照前后包装一个命令" class="headerlink" title="在快照前后包装一个命令"></a>在快照前后包装一个命令</h4><p> 您也可以在快照之前和之后包装一个命令，这在测试时很有用。这是以下步骤的快捷方式：</p>
<ol>
<li>运行<code>snapper create pre snapshot</code>命令。</li>
<li>运行命令或命令列表来执行可能影响文件系统内容的操作。</li>
<li>运行<code>snapper create post snapshot</code>命令。</li>
</ol>
<p><strong>在快照前后包装一个命令</strong></p>
<ol>
<li>在前后快照中包装命令:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create --command "command_to_be_tracked"</span></span><br></pre></td></tr></table></figure>
<p>例如，要跟踪 <code>/lvm_mount/hello_file</code> 文件的创建:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create --command "echo Hello &gt; /lvm_mount/hello_file"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>要验证这一点，请使用 <code>status</code> 命令:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file status first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>例如，要跟踪第一步中所做的更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config status 3..4</span></span><br><span class="line">+..... /lvm_mount/hello_file</span><br></pre></td></tr></table></figure>
<p>如果需要， 使用<code>list</code>命令验证快照的编号。</p>
<p>请注意，不能保证上述示例中的命令是快照捕获的唯一内容。Snapper还记录系统修改的任何内容，而不仅仅是用户修改的内容。</p>
<h3 id="创建单个快照程序快照"><a href="#创建单个快照程序快照" class="headerlink" title="创建单个快照程序快照"></a>创建单个快照程序快照</h3><p>创建单个快照快照与创建快照前或快照后类似，只有create <code>-t</code>选项指定single。单个快照用于创建一个单一的快照，而不会与任何其他快照相关联。但是，如果您有兴趣直接创建LVM2精简卷的快照，而无需自动生成比较或列出附加信息，则红帽建议使用系统存储管理器而不是Snapper来实现此目的，</p>
<p>要创建单个快照，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name create -t single</span></span><br></pre></td></tr></table></figure>
<p>例如，以下命令使用<code>lvm_config</code>配置文件创建单个快照。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config create -t single</span></span><br></pre></td></tr></table></figure>
<p>虽然单个快照并非专为跟踪变化，您可以使用<code>snapper diff</code>，<code>xadiff</code>和<code>status</code>命令任何两个快照进行比较.</p>
<h3 id="配置快照程序以获取自动快照"><a href="#配置快照程序以获取自动快照" class="headerlink" title="配置快照程序以获取自动快照"></a>配置快照程序以获取自动快照</h3><p>拍摄自动快照是Snapper的主要功能之一。默认情况下，当为Snapper配置卷时，Snapper将开始每小时拍摄卷的快照。</p>
<p>在默认配置下，Snapper保留：</p>
<ul>
<li>每小时10张快照，最终每小时快照保存为“每日”快照。</li>
<li>10个每日快照，并且一个月的最终每日快照被保存为“每月”快照。</li>
<li>每月10次快照，最终每月快照保存为“年度”快照。</li>
<li>每年10个快照。</li>
</ul>
<p>请注意，Snapper默认保持不超过50个快照。但是，Snapper会默认保留不到1800秒前创建的所有快照。</p>
<p>默认配置在<code>/etc/snapper/config-templates/default</code>文件中指定。使用该<code>snapper create-config</code>命令创建配置时，将根据默认配置设置任何未指定的值。您可以编辑文件中任何定义的卷的配置。 <code>/etc/snapper/configs/*config_name*</code></p>
<h2 id="跟踪SNAPPER快照之间的更改"><a href="#跟踪SNAPPER快照之间的更改" class="headerlink" title="跟踪SNAPPER快照之间的更改"></a>跟踪SNAPPER快照之间的更改</h2><p>使用 <code>status</code>, <code>diff</code>, 和 <code>xadiff</code> 指令跟踪快照之间的子卷所做的更改：</p>
<ul>
<li><p>status</p>
<p><code>status</code> 命令显示在两个快照之间创建，修改或删除的文件和目录的列表，这是两个快照之间更改的完整列表。您可以使用此命令来获取更改的概述，而不会有过多的细节。</p>
</li>
<li><p>diff</p>
<p>如果至少检测到一个修改，则 <code>diff</code> 命令显示从 <code>status</code> 命令接收到的两个快照之间的已修改文件和目录的差异。</p>
</li>
<li><p>xadiff</p>
<p> <code>xadiff</code> 命令比较文件或目录的扩展属性在两个快照之间的变化。</p>
</li>
</ul>
<h3 id="比较变更与status命令"><a href="#比较变更与status命令" class="headerlink" title="比较变更与status命令"></a>比较变更与<code>status</code>命令</h3><p> <code>status</code> 命令显示在两个快照之间创建，修改或删除的文件和目录的列表。</p>
<p>要显示两个快照之间的文件状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_file status first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要，使用 <code>list</code> 命令确定快照编号。</p>
<p>例如，以下命令使用配置文件<code>lvm_config</code>显示快照1和2之间所做的更改 .</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snapper -c lvm_config status 1..2</span><br><span class="line">tp.... /lvm_mount/dir1</span><br><span class="line">-..... /lvm_mount/dir1/file_a</span><br><span class="line">c.ug.. /lvm_mount/file2</span><br><span class="line">+..... /lvm_mount/file3</span><br><span class="line">....x. /lvm_mount/file4</span><br><span class="line">cp..xa /lvm_mount/file5</span><br></pre></td></tr></table></figure>
<p>在输出的第一部分中以字母的形式读取字母和圆点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+..... /lvm_mount/file3</span><br><span class="line">||||||</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>列1指示文件（目录条目）类型的任何修改。可能的值是：</p>
<p><strong>Column 1</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>什么也没有变.</td>
</tr>
<tr>
<td>+</td>
<td>创建文件.</td>
</tr>
<tr>
<td>-</td>
<td>文件已删除.</td>
</tr>
<tr>
<td>c</td>
<td>内容已更改.</td>
</tr>
<tr>
<td>t</td>
<td>目录条目的类型已更改。例如，以前的符号链接已经更改为具有相同文件名的常规文件.</td>
</tr>
</tbody>
</table>
</div>
<p>列2指示文件权限的任何更改。可能的值是：</p>
<p><strong>Column 2</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有权限更改.</td>
</tr>
<tr>
<td>p</td>
<td>权限已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>第3列表示用户所有权的任何变化。可能的值是：</p>
<p><strong>Column 3</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有用户所有权更改.</td>
</tr>
<tr>
<td>u</td>
<td>用户所有权已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>第4列表示组所有权的任何变化。可能的值是：</p>
<p><strong>Column 4</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有组的所有权改变.</td>
</tr>
<tr>
<td>g</td>
<td>集体所有权已经改变.</td>
</tr>
</tbody>
</table>
</div>
<p>列5指示扩展属性中的任何更改。可能的值是：</p>
<p><strong>Column 5</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有扩展的属性改变.</td>
</tr>
<tr>
<td>x</td>
<td>扩展属性已更改.</td>
</tr>
</tbody>
</table>
</div>
<p>列6指示访问控制列表（ACL）中的任何更改。可能的值是：</p>
<p><strong>Column 6</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>没有ACL改变。</td>
</tr>
<tr>
<td>a</td>
<td>ACL被修改。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="比较变更与diff命令"><a href="#比较变更与diff命令" class="headerlink" title="比较变更与diff命令"></a>比较变更与<code>diff</code>命令</h3><p><code>diff</code> 命令显示两个快照之间修改的文件和目录的更改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name diff first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要 ,使用<code>list</code> 命令确定快照的编号。</p>
<p>例如，要比较使用<code>lvm_config</code>配置文件创建的快照1和快照2之间的文件更改，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config diff 1..2</span></span><br><span class="line">--- /lvm_mount/.snapshots/13/snapshot/file4	19&lt;...&gt;</span><br><span class="line">+++ /lvm_mount/.snapshots/14/snapshot/file4	20&lt;...&gt;</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+words</span><br></pre></td></tr></table></figure>
<p>上面的输出显示<code>file4</code>已被修改为将“单词”添加到文件中。</p>
<h3 id="比较变更与xadiff命令"><a href="#比较变更与xadiff命令" class="headerlink" title="比较变更与xadiff命令"></a>比较变更与<code>xadiff</code>命令</h3><p> <code>xadiff</code> 命令比较文件或目录的扩展属性在两个快照之间的变化情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name xadiff first_snapshot_number..second_snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>如果需要， 使用<code>list</code>命令确定快照的编号。 </p>
<p>例如，要显示使用<code>lvm_config</code>配置文件创建的快照号码1和快照号码2之间的<code>xadiff</code>输出，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c lvm_config xadiff 1..2</span></span><br></pre></td></tr></table></figure>
<h2 id="反转快照之间的更改"><a href="#反转快照之间的更改" class="headerlink" title="反转快照之间的更改"></a>反转快照之间的更改</h2><p>要反转两个现有Snapper快照之间所做的更改，请使用<code>undochange</code>以下格式的命令，其中<code>1</code>第一个快照<code>2</code>是第二个快照：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">snapper -c config_name undochange 1..2</span><br></pre></td></tr></table></figure>
<p><strong>Important</strong></p>
<p>使用 <code>undochange</code> 命令不会将Snapper卷恢复到其原始状态，也不会提供数据一致性。发生在指定范围之外的任何文件修改（例如，在快照2之后）将在恢复之后保持不变，例如，恢复到快照1的状态。例如，如果<code>undochange</code>运行以撤消创建用户，则拥有的任何文件由用户仍然可以保持。</p>
<p>在创建快照时也没有确保文件一致性的机制，所以当使用<code>undochange</code>命令时，任何已经存在的不一致都可以传回快照。</p>
<p>不要使用 Snapper <code>undochange</code> 命令 在根文件系统中, 否则可能会导致失败。</p>
<p>下图演示了该<code>undochange</code>命令的工作原理：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/J3Ke3j2Iid.png?imageslim" alt="mark"></p>
<p><strong>快照状态随着时间的推移</strong></p>
<p>该图显示了<code>snapshot_1</code>创建，<code>file_a</code>创建和<code>file_b</code>删除的时间点。<code>Snapshot_2</code>然后创建，然后<code>file_a</code>编辑和<code>file_c</code>创建。这是现在系统的当前状态。目前的系统有一个编辑版本<code>file_a</code>，不<code>file_b</code>，和一个新创建的<code>file_c</code>。</p>
<p>当<code>undochange</code>调用该命令时，Snapper将生成第一个列出的快照和第二个快照之间的已修改文件的列表。在该图中，如果使用该<code>snapper -c SnapperExample undochange 1..2</code>命令，Snapper将创建一个修改文件列表（即已创建<code>file_a</code>;将<code>file_b</code>被删除）并将其应用于当前系统。因此：</p>
<ul>
<li>目前的系统将不会有<code>file_a</code>，因为它创建时还<code>snapshot_1</code>没有创建。</li>
<li><code>file_b</code>将存在，从<code>snapshot_1</code>当前系统复制而来。</li>
<li><code>file_c</code> 将会存在，因为它的创造超出了规定的时间。</li>
</ul>
<p>请注意，如果<code>file_b</code>和<code>file_c</code>冲突，系统可能会损坏。</p>
<p>您也可以使用该<code>snapper -c SnapperExample undochange 2..1</code>命令。在这种情况下，当前的系统会用<code>file_a</code>从中复制的一个版本替换编辑后的版本，而这个编辑版本是在创建<code>snapshot_1</code>之后取消该文件的编辑<code>snapshot_2</code>。</p>
<p><strong>使用挂载和卸载命令来反转更改</strong></p>
<p><code>undochange</code>命令并不总是恢复修改的最佳方式. 使用<code>status</code>和<code>diff</code>命令，您可以做出合格的决定, and use the <code>mount</code> and <code>unmount</code> 而不是 Snapper. 在 <code>mount</code> and <code>unmount</code> 命令仅在您要装载快照并独立于Snapper工作流程浏览其内容时才有用。</p>
<p>如果需要，该<code>mount</code>命令将在安装之前激活相应的LVM Snapper快照。例如，使用<code>mount</code>和<code>unmount</code>命令（例如，有兴趣加载快照并手动提取几个文件的旧版本）。要手动还原文件，请将其从装入的快照复制到当前文件系统</p>
<p>system. The current file system, snapshot 0, is the live file system created in <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-snapper#p-creating-a-snapper-configuration-file" target="_blank" rel="noopener">Procedure 14.1, “Creating a Snapper Configuration File”</a>. Copy the files to the subtree of the original /mount-point.</p>
<p>使用 <code>mount</code> and <code>unmount</code> 命令显式的客户端请求 文件</p>
<p> <code>/etc/snapper/configs/*config_name*</code> 包含  ALLOW_USERS= and ALLOW_GROUPS= variables 您可以在其中添加用户和组.  然后<code>snapperd</code> ，允许您为添加的用户和组执行安装操作</p>
<h2 id="删除快照程序快照"><a href="#删除快照程序快照" class="headerlink" title="删除快照程序快照"></a>删除快照程序快照</h2><p>删除快照：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># snapper -c config_name delete snapshot_number</span></span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>list</code> 命令来验证快照是否已成功删除。</p>
<h1 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h1><p>Linux中的<em>交换空间</em>在物理内存（RAM）数量已满时使用。如果系统需要更多的内存资源并且RAM已满，则内存中的不活动页面将移至交换空间。虽然交换空间可以帮助具有少量RAM的机器，但不应该被视为更多RAM的替代品。交换空间位于硬盘上，其访问时间比物理内存慢。交换空间可以是专用交换分区（推荐），交换文件或交换分区和交换文件的组合。需要注意的是<em>增加了Btrfs</em>并<em>没有</em>支持的交换空间。</p>
<p>过去几年，交换空间的建议数量随着系统内存量的增加而线性增加。但是，现代系统通常包含数百GB的RAM。因此，建议的交换空间被视为系统内存工作负载的函数，而不是系统内存。</p>
<p>交换分区的推荐大小，具体取决于系统中RAM的数量，以及是否需要足够的内存供系统休眠。建议的交换分区大小在安装过程中自动建立。但是，要允许休眠，您需要在自定义分区阶段编辑交换空间。</p>
<p>建议在系统低内存（1 GB以下）尤其重要。未能在这些系统上分配足够的交换空间可能会导致问题，如不稳定甚至导致安装的系统无法启动。</p>
<p><strong>推荐的系统交换空间</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统中的RAM数量</th>
<th>建议交换空间</th>
<th>如果允许休眠，建议使用交换空间</th>
</tr>
</thead>
<tbody>
<tr>
<td>⩽ 2 GB</td>
<td>RAM的2倍</td>
<td>RAM数量的3倍</td>
</tr>
<tr>
<td>&gt; 2 GB – 8 GB</td>
<td>等于RAM的数量</td>
<td>RAM的2倍</td>
</tr>
<tr>
<td>&gt; 8 GB – 64 GB</td>
<td>至少4 GB</td>
<td>RAM的1.5倍</td>
</tr>
<tr>
<td>&gt; 64 GB</td>
<td>至少4 GB</td>
<td>不建议休眠</td>
</tr>
</tbody>
</table>
</div>
<p>列出的每个范围的边界处（例如具有2 GB，8 GB或64 GB系统RAM的系统），可以选择交换空间和休眠支持。如果您的系统资源允许，增加交换空间可能会导致更好的性能。对于超过140个逻辑处理器或超过3 TB RAM的系统，建议至少100 GB的交换空间。</p>
<p>请注意，通过多个存储设备分配交换空间也会提高交换空间性能，特别是在具有快速驱动器，控制器和接口的系统上。</p>
<p>分配为交换空间的文件系统和LVM2卷在修改时<em>不应</em>使用。如果系统进程或内核正在使用交换空间，则任何修改交换的尝试都将失败。使用<code>free</code>和<code>cat /proc/swaps</code>命令来验证多少和交换在哪里使用。</p>
<p>您应修改交换空间，而系统在引导<code>rescue</code>模式下,当提示安装文件系统时，请选择<strong>跳过</strong>。</p>
<h2 id="添加交换空间"><a href="#添加交换空间" class="headerlink" title="添加交换空间"></a>添加交换空间</h2><p>有时需要在安装后添加更多的交换空间。例如，您可以将系统中的RAM数量从1 GB升级到2 GB，但只有2 GB的交换空间。如果执行内存密集型操作或运行需要大量内存的应用程序，则将交换空间量增加到4 GB可能会有所帮助。</p>
<p>您有三种选择：创建新的交换分区，创建新的交换文件或在现有的LVM2逻辑卷上扩展交换。建议您扩展现有的逻辑卷。</p>
<h3 id="在LVM2逻辑卷上扩展交换"><a href="#在LVM2逻辑卷上扩展交换" class="headerlink" title="在LVM2逻辑卷上扩展交换"></a>在LVM2逻辑卷上扩展交换</h3><p>默认情况下，红帽企业版Linux 7在安装过程中使用所有可用的空间。如果系统出现这种情况，则必须先将新的物理卷添加到交换空间使用的卷组中。</p>
<p>向交换空间的卷组添加额外的存储之后，现在可以扩展它。为此，请执行以下步骤（假定<code>/dev/VolGroup00/LogVol01</code>是要扩展2 GB的卷）：</p>
<p><strong>在LVM2逻辑卷上扩展交换</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将LVM2逻辑卷调整大小2 GB：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvresize /dev/VolGroup00/LogVol01 -L +2G</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<p>要测试逻辑卷是否成功扩展，请使用 <code>cat /proc/swaps</code> 或<code>free</code> 检查交换空间。</p>
<h3 id="为交换创建一个LVM2逻辑卷"><a href="#为交换创建一个LVM2逻辑卷" class="headerlink" title="为交换创建一个LVM2逻辑卷"></a>为交换创建一个LVM2逻辑卷</h3><p>要添加交换卷组（假设<code>/dev/VolGroup00/LogVol02</code>是要添加的交换卷）：</p>
<ol>
<li>创建大小为2 GB的LVM2逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvcreate VolGroup00 -n LogVol02 -L 2G</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将以下条目添加到 <code>/etc/fstab</code> 文件中：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /dev/VolGroup00/LogVol02 swap swap defaults 0 0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<p>要测试逻辑卷是否成功创建，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="创建一个交换文件"><a href="#创建一个交换文件" class="headerlink" title="创建一个交换文件"></a>创建一个交换文件</h3><p>要添加交换文件：</p>
<p><strong>添加一个交换文件</strong></p>
<ol>
<li><p>以兆字节确定新的交换文件的大小并乘以1024来确定块的数量。例如，一个64 MB交换文件的块大小是65536。</p>
</li>
<li><p>在shell中，输入以下命令，<code>count</code>并等于所需的块大小：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dd if=/dev/zero of=/swapfile bs=1024 count=65536</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用以下命令设置交换文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkswap /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li>更改交换文件的安全性，使其不是世界上可读的。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 0600 /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li>要在启动时立即启用交换文件，但不能自动启用：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapon /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>要在引导时启用它，请编辑<code>/etc/fstab</code>以包含以下条目：</p>
<p><code>/swapfile swap swap defaults 0 0</code></p>
<p>系统下次启动时，将启用新的交换文件。</p>
</li>
</ol>
<p>要测试新的交换文件是否成功创建，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h2 id="删除交换空间"><a href="#删除交换空间" class="headerlink" title="删除交换空间"></a>删除交换空间</h2><p>有时在安装之后可以谨慎的减少交换空间。例如，假设您将系统中的RAM数量从1 GB降级到512 MB，但仍有2 GB的交换空间仍在分配。将交换空间量减少到1 GB可能是有利的，因为较大的2 GB可能会浪费磁盘空间。</p>
<p>您有三种选择：删除用于交换的整个LVM2逻辑卷，删除交换文件或减少现有LVM2逻辑卷上的交换空间。</p>
<h3 id="减少LVM2逻辑卷上的交换"><a href="#减少LVM2逻辑卷上的交换" class="headerlink" title="减少LVM2逻辑卷上的交换"></a>减少LVM2逻辑卷上的交换</h3><p>减少LVM2交换逻辑卷（假定<code>/dev/VolGroup00/LogVol01</code>是要减少的卷）：</p>
<p><strong>减少LVM2交换逻辑卷</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将LVM2逻辑卷减少512 MB：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvreduce /dev/VolGroup00/LogVol01 -L -512M</span></span><br></pre></td></tr></table></figure>
<ol>
<li>格式化新的交换空间：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkswap /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启用扩展逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapon -v /dev/VolGroup00/LogVol01</span></span><br></pre></td></tr></table></figure>
<p>要测试交换的逻辑卷大小是否成功减少，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="删除交换的LVM2逻辑卷"><a href="#删除交换的LVM2逻辑卷" class="headerlink" title="删除交换的LVM2逻辑卷"></a>删除交换的LVM2逻辑卷</h3><p>要除去交换卷组（假设<code>/dev/VolGroup00/LogVol02</code>是要除去的交换卷）：</p>
<p><strong>删除交换卷组</strong></p>
<ol>
<li>禁用相关逻辑卷的交换：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>删除大小为512 MB的LVM2逻辑卷：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lvremove /dev/VolGroup00/LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>从<code>/etc/fstab</code>文件中删除以下条目：</p>
<p><code>/dev/VolGroup00/LogVol02 swap swap defaults 0 0</code></p>
</li>
</ol>
<p>要测试逻辑卷大小是否已成功删除，请使用<code>cat /proc/swaps</code>或<code>free</code>检查交换空间。</p>
<h3 id="删除交换文件"><a href="#删除交换文件" class="headerlink" title="删除交换文件"></a>删除交换文件</h3><p><strong>删除交换文件</strong></p>
<ol>
<li>在shell提示下，执行以下命令来禁用交换文件（其中<code>/swapfile</code>是交换文件）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># swapoff -v /swapfile</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>从<code>/etc/fstab</code>文件中删除它的条目。</p>
</li>
<li><p>删除实际的文件：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rm /swapfile</span></span><br></pre></td></tr></table></figure>
<h2 id="移动交换空间"><a href="#移动交换空间" class="headerlink" title="移动交换空间"></a>移动交换空间</h2><p>要将交换空间从一个位置移动到另一个位置，请执行删除交换空间的步骤，然后按照添加交换空间的步骤进行操作。</p>
<h2 id="SSM后端"><a href="#SSM后端" class="headerlink" title="SSM后端"></a>SSM后端</h2><p>SSM使用<code>ssmlib/main.py</code>符合设备，池和卷抽象的核心抽象层，忽略底层技术的细节。后端可以被注册在<code>ssmlib/main.py</code>处理特定的存储技术方法，如<code>create</code>，<code>snapshot</code>或到<code>remove</code>卷和池。</p>
<p>SSM已经有多个后端注册。以下部分将提供关于它们的基本信息以及如何处理池，卷，快照和设备的定义。</p>
<h3 id="Btrfs后端"><a href="#Btrfs后端" class="headerlink" title="Btrfs后端"></a>Btrfs后端</h3><p><strong>注意</strong></p>
<p>Btrfs在红帽企业版Linux 7中作为技术预览功能提供，但自从红帽企业版Linux 7.4发行版以来已经被弃用了。它将在未来的红帽企业Linux主要版本中被删除。</p>
<p>Btrfs是一个具有许多高级功能的文件系统，在SSM中用作卷管理后端。可以使用Btrfs后端创建池，卷和快照。</p>
<h4 id="Btrfs池"><a href="#Btrfs池" class="headerlink" title="Btrfs池"></a>Btrfs池</h4><p>Btrfs文件系统本身就是池。可以通过添加更多设备来扩展，也可以通过删除设备来缩小。创建Btrfs池时，SSM将创建一个Btrfs文件系统。这意味着每个新的Btrfs池都有一个与池相同的卷，如果不删除整个池，则不能删除该卷。默认的Btrfs池名称是<code>btrfs_pool</code>。</p>
<p>池的名称用作文件系统标签。如果系统中已经存在一个没有标签的Btrfs文件系统，则Btrfs池将以格式生成一个内部使用的名称 <code>btrfs_device_base_name</code></p>
<h4 id="Btrfs卷"><a href="#Btrfs卷" class="headerlink" title="Btrfs卷"></a>Btrfs卷</h4><p>在池中的第一个卷之后创建的卷与子卷相同。如果未安装Btrfs文件系统以创建子卷，SSM将临时安装Btrfs文件系统。</p>
<p>卷的名称用作Btrfs文件系统中的子卷路径。例如，一个子卷显示为<code>/dev/lvm_pool/lvol001</code>。该路径中的每个对象都必须存在才能创建卷。卷也可以用它的挂载点来引用。</p>
<h4 id="Btrfs快照"><a href="#Btrfs快照" class="headerlink" title="Btrfs快照"></a>Btrfs快照</h4><p>可以使用SSM在系统中的任何Btrfs卷上拍摄快照。请注意，Btrfs不会区分子卷和快照。虽然这意味着SSM无法识别Btrfs快照目标，但它会尝试识别特殊的名称格式。如果创建快照时指定的名称执行了特定的模式，则快照将不会被识别，而是被列为常规Btrfs卷。</p>
<h4 id="Btrfs设备"><a href="#Btrfs设备" class="headerlink" title="Btrfs设备"></a>Btrfs设备</h4><p>Btrfs不需要创建任何特殊的设备。</p>
<h3 id="LVM后端"><a href="#LVM后端" class="headerlink" title="LVM后端"></a>LVM后端</h3><p>可以使用LVM创建池，卷和快照。以下定义来自LVM的观点。</p>
<h4 id="LVM池"><a href="#LVM池" class="headerlink" title="LVM池"></a>LVM池</h4><p>LVM池与LVM卷组相同。这意味着可以在LVM池外创建分组设备和新逻辑卷。默认的LVM池名称是<code>lvm_pool</code>。</p>
<h4 id="LVM卷"><a href="#LVM卷" class="headerlink" title="LVM卷"></a>LVM卷</h4><p>LVM卷与普通逻辑卷相同。</p>
<h4 id="LVM快照"><a href="#LVM快照" class="headerlink" title="LVM快照"></a>LVM快照</h4><p>当从LVM卷创建快照时，会创建一个新<code>snapshot</code>卷，然后可以像处理其他任何LVM卷一样处理该卷。与Btrfs不同的是，LVM能够区分常规卷的快照，因此不需要快照名称来匹配特定的模式。</p>
<h4 id="LVM设备"><a href="#LVM设备" class="headerlink" title="LVM设备"></a>LVM设备</h4><p>SSM使得需要在对用户透明的物理设备上创建LVM后端。</p>
<h3 id="Crypt-后端"><a href="#Crypt-后端" class="headerlink" title="Crypt 后端"></a>Crypt 后端</h3><p>SSM中的隐藏后端使用<code>cryptsetup</code>并<code>dm-crypt target</code>管理加密卷。加密后端可用作常规后端，用于在常规块设备（或其他卷（如LVM或MD卷）上）上创建加密卷，或者在一个步骤中创建加密的LVM卷。</p>
<p>只有卷可以用隐藏后端创建; 不支持共享，不需要特殊的设备。</p>
<p>以下几节从crypt的角度定义了卷和快照。</p>
<h4 id="地穴容积"><a href="#地穴容积" class="headerlink" title="地穴容积"></a>地穴容积</h4><p><code>dm-crypt</code>加密 卷由未加密的形式创建并代表原始加密设备上的数据。它不支持RAID或任何设备连接。</p>
<p>支持两种模式或扩展：luks和plain。Luks默认使用。有关扩展的更多信息，请参阅<code>man cryptsetup</code>。</p>
<h4 id="Crypt-快照"><a href="#Crypt-快照" class="headerlink" title="Crypt 快照"></a>Crypt 快照</h4><p>虽然crypt后端不支持快照，但如果在LVM卷上创建加密卷，则卷本身可以被快照。快照可以通过使用打开<code>cryptsetup</code>。</p>
<h3 id="多个设备（MD）后端"><a href="#多个设备（MD）后端" class="headerlink" title="多个设备（MD）后端"></a>多个设备（MD）后端</h3><p>MD后端目前仅限于收集有关系统中MD卷的信息。</p>
<h2 id="常见的SSM任务"><a href="#常见的SSM任务" class="headerlink" title="常见的SSM任务"></a>常见的SSM任务</h2><p>以下部分将介绍基本用例，介绍如何安装SSM，然后显示有关所有检测到的设备，池和卷的信息。接下来，将使用两个卷和一个XFS文件系统创建一个池。然后将检查文件系统的一致性，然后卷的大小将会增加。然后创建一个快照。最后其中一卷将被删除。</p>
<h3 id="安装-SSM"><a href="#安装-SSM" class="headerlink" title="安装 SSM"></a>安装 SSM</h3><p>要安装SSM，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install system-storage-manager</span></span><br></pre></td></tr></table></figure>
<p>只有在安装了支持包的情况下，才会启用多个后端：</p>
<ul>
<li>LVM后端需要<code>lvm2</code>包。</li>
<li>Btrfs后端需要<code>btrfs-progs</code>包。</li>
<li>Crypt后端需要<code>device-mapper</code>和<code>cryptsetup</code>包装。</li>
</ul>
<h3 id="显示有关所有检测到的设备的信息"><a href="#显示有关所有检测到的设备的信息" class="headerlink" title="显示有关所有检测到的设备的信息"></a>显示有关所有检测到的设备的信息</h3><p>使用该<code>list</code>命令显示有关所有检测到的设备，池，卷和快照的信息。运行<code>ssm list</code>没有选项将显示以下输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">Device        Free      Used      Total  Pool  Mount point</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">/dev/sda                        2.00 GB        PARTITIONED</span><br><span class="line">/dev/sda1                      47.83 MB        /<span class="built_in">test</span></span><br><span class="line">/dev/vda                       15.00 GB        PARTITIONED</span><br><span class="line">/dev/vda1                     500.00 MB        /boot</span><br><span class="line">/dev/vda2  0.00 KB  14.51 GB   14.51 GB  rhel</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">------------------------------------------------</span><br><span class="line">Pool  Type  Devices     Free      Used     Total</span><br><span class="line">------------------------------------------------</span><br><span class="line">rhel  lvm   1        0.00 KB  14.51 GB  14.51 GB</span><br><span class="line">------------------------------------------------</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">Volume          Pool  Volume size  FS     FS size       Free  Type    Mount point</span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root  rhel     13.53 GB  xfs   13.52 GB    9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap  rhel   1000.00 MB                             linear</span><br><span class="line">/dev/sda1                47.83 MB  xfs   44.50 MB   44.41 MB  part    /<span class="built_in">test</span></span><br><span class="line">/dev/vda1               500.00 MB  xfs  496.67 MB  403.56 MB  part    /boot</span><br><span class="line">---------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>通过使用参数来指定显示内容，可以进一步缩小显示范围。可用的选项列表可以通过<code>ssm list --help</code>命令找到。</p>
<p>根据给出的参数，SSM可能不会显示所有内容。</p>
<ul>
<li>运行<code>devices</code>或<code>dev</code>参数将省略一些设备。例如，CDRoms和DM / MD设备被故意隐藏，因为它们被列为卷。</li>
<li>某些后端不支持快照，无法区分快照和常规卷。<code>snapshot</code>在其中一个后端运行参数将导致SSM尝试识别卷名以识别快照。如果SSM正则表达式与快照模式不匹配，则不会识别快照。</li>
<li>除了主Btrfs卷（文件系统本身）外，任何未安装的Btrfs卷都不会显示.</li>
</ul>
<h3 id="创建新池，逻辑卷和文件系统"><a href="#创建新池，逻辑卷和文件系统" class="headerlink" title="创建新池，逻辑卷和文件系统"></a>创建新池，逻辑卷和文件系统</h3><p>在本节中，将使用默认名称创建一个新池。它将具有1G 的设备<code>/dev/vdb</code>和<code>/dev/vdc</code>逻辑卷以及XFS文件系统。</p>
<p>创建这个场景的命令是<code>ssm create --fs xfs -s 1G /dev/vdb /dev/vdc</code>。使用以下选项：</p>
<ul>
<li><code>--fs</code> 选项指定所需的文件系统类型。当前支持的文件系统类型是：<ul>
<li>ext3</li>
<li>ext4</li>
<li>xfs</li>
<li>btrfs</li>
</ul>
</li>
<li>所述<code>-s</code>指定逻辑卷的大小。定义单位支持以下后缀<ul>
<li><code>K</code> or <code>k</code>  千字节</li>
<li><code>M</code> or <code>m</code>  兆字节</li>
<li><code>G</code> or <code>g</code>  千兆字节</li>
<li><code>T</code> or <code>t</code>  TB</li>
<li><code>P</code> or <code>p</code>  PB</li>
<li><code>E</code> or <code>e</code>  EB字节</li>
</ul>
</li>
<li>这两个列出的设备，<code>/dev/vdb</code>并且<code>/dev/vdc</code>，是我希望创建的两个设备。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm create --fs xfs -s 1G /dev/vdb /dev/vdc</span></span><br><span class="line">  Physical volume <span class="string">"/dev/vdb"</span> successfully created</span><br><span class="line">  Physical volume <span class="string">"/dev/vdc"</span> successfully created</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully created</span><br><span class="line">  Logical volume <span class="string">"lvol001"</span> created</span><br></pre></td></tr></table></figure>
<p>还有其他两个 <code>ssm command</code> 可能有用的选项. 第一个是 <code>-p</code><em><code>pool</code></em> . 这指定了要在其上创建卷的池。如果还不存在，那么SSM将创建它. 在上面的例子中这被省略了，导致SSM使用默认名称 <code>lvm_pool</code>. 但是，要使用特定的名称来适应任何现有的命名约定，应该使用该选项 <code>-p</code> .</p>
<p>第二个有用的选项是 <code>-n</code> <em><code>name</code></em>. 这将命名新创建的逻辑卷. 与之一样 <code>-p</code>, 为了使用特定的名称来适应现有的命名约定，这是必要的。</p>
<p>以下是这两个选项的一个例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># ssm create --fs xfs -p new_pool -n XFS_Volume /dev/vdd</span></span><br><span class="line">  Volume group <span class="string">"new_pool"</span> successfully created</span><br><span class="line">  Logical volume <span class="string">"XFS_Volume"</span> created</span><br></pre></td></tr></table></figure>
<p>现在SSM已经创建了两个物理卷，一个池和一个逻辑卷，只需要一个命令。</p>
<h4 id="检查文件系统的一致性"><a href="#检查文件系统的一致性" class="headerlink" title="检查文件系统的一致性"></a>检查文件系统的一致性</h4><p> <code>ssm check</code> 命令检查卷上的文件系统一致性。可以指定多个卷来检查。如果卷上没有文件系统，则该卷将被跳过。</p>
<p>要检查卷中的所有设备<code>lvol001</code>，请运行。 <code>ssm check /dev/lvm_pool/lvol001</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm check /dev/lvm_pool/lvol001</span></span><br><span class="line">Checking xfs file system on <span class="string">'/dev/mapper/lvm_pool-lvol001'</span>.</span><br><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal <span class="built_in">log</span></span><br><span class="line">        - scan filesystem freespace and inode maps...</span><br><span class="line">        - found root inode chunk</span><br><span class="line">Phase 3 - <span class="keyword">for</span> each AG...</span><br><span class="line">        - scan (but don<span class="string">'t clear) agi unlinked lists...</span></span><br><span class="line"><span class="string">        - process known inodes and perform inode discovery...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - agno = 4</span></span><br><span class="line"><span class="string">        - agno = 5</span></span><br><span class="line"><span class="string">        - agno = 6</span></span><br><span class="line"><span class="string">        - process newly discovered inodes...</span></span><br><span class="line"><span class="string">Phase 4 - check for duplicate blocks...</span></span><br><span class="line"><span class="string">        - setting up duplicate extent list...</span></span><br><span class="line"><span class="string">        - check for inodes claiming duplicate blocks...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - agno = 4</span></span><br><span class="line"><span class="string">        - agno = 5</span></span><br><span class="line"><span class="string">        - agno = 6</span></span><br><span class="line"><span class="string">No modify flag set, skipping phase 5</span></span><br><span class="line"><span class="string">Phase 6 - check inode connectivity...</span></span><br><span class="line"><span class="string">        - traversing filesystem ...</span></span><br><span class="line"><span class="string">        - traversal finished ...</span></span><br><span class="line"><span class="string">        - moving disconnected inodes to lost+found ...</span></span><br><span class="line"><span class="string">Phase 7 - verify link counts...</span></span><br><span class="line"><span class="string">No modify flag set, skipping filesystem flush and exiting.</span></span><br></pre></td></tr></table></figure>
<h3 id="增加卷的大小"><a href="#增加卷的大小" class="headerlink" title="增加卷的大小"></a>增加卷的大小</h3><p><code>ssm resize</code> 命令将更改指定的卷和文件系统的大小。如果没有文件系统，那么只有卷本身将被调整大小。</p>
<p>对于这个例子， 我们目前有一个逻辑卷 <code>/dev/vdb</code> , 900MB 命令为 <code>lvol001</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">Device          Free       Used      Total  Pool      Mount point</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">/dev/vda                          15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                        500.00 MB            /boot</span><br><span class="line">/dev/vda2    0.00 KB   14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb   120.00 MB  900.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc                           1.00 GB</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">Pool      Type  Devices       Free       Used       Total</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   1        120.00 MB  900.00 MB  1020.00 MB</span><br><span class="line">rhel      lvm   1          0.00 KB   14.51 GB    14.51 GB</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS     FS size       Free  Type    Mount point</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs   13.52 GB    9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                             linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool    900.00 MB  xfs  896.67 MB  896.54 MB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs  496.67 MB  403.56 MB  part    /boot</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>逻辑卷需要增加500MB。要做到这一点，我们需要添加一个额外的设备到池中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm resize -s +500M /dev/lvm_pool/lvol001 /dev/vdc</span></span><br><span class="line">  Physical volume <span class="string">"/dev/vdc"</span> successfully created</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully extended</span><br><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal <span class="built_in">log</span></span><br><span class="line">        - scan filesystem freespace and inode maps...</span><br><span class="line">        - found root inode chunk</span><br><span class="line">Phase 3 - <span class="keyword">for</span> each AG...</span><br><span class="line">        - scan (but don<span class="string">'t clear) agi unlinked lists...</span></span><br><span class="line"><span class="string">        - process known inodes and perform inode discovery...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">        - process newly discovered inodes...</span></span><br><span class="line"><span class="string">Phase 4 - check for duplicate blocks...</span></span><br><span class="line"><span class="string">        - setting up duplicate extent list...</span></span><br><span class="line"><span class="string">        - check for inodes claiming duplicate blocks...</span></span><br><span class="line"><span class="string">        - agno = 0</span></span><br><span class="line"><span class="string">        - agno = 1</span></span><br><span class="line"><span class="string">        - agno = 2</span></span><br><span class="line"><span class="string">        - agno = 3</span></span><br><span class="line"><span class="string">No modify flag set, skipping phase 5</span></span><br><span class="line"><span class="string">Phase 6 - check inode connectivity...</span></span><br><span class="line"><span class="string">        - traversing filesystem ...</span></span><br><span class="line"><span class="string">        - traversal finished ...</span></span><br><span class="line"><span class="string">        - moving disconnected inodes to lost+found ...</span></span><br><span class="line"><span class="string">Phase 7 - verify link counts...</span></span><br><span class="line"><span class="string">No modify flag set, skipping filesystem flush and exiting.</span></span><br><span class="line"><span class="string">  Extending logical volume lvol001 to 1.37 GiB</span></span><br><span class="line"><span class="string">  Logical volume lvol001 successfully resized</span></span><br><span class="line"><span class="string">meta-data=/dev/mapper/lvm_pool-lvol001 isize=256    agcount=4, agsize=57600 blks</span></span><br><span class="line"><span class="string">         =                       sectsz=512   attr=2, projid32bit=1</span></span><br><span class="line"><span class="string">         =                       crc=0</span></span><br><span class="line"><span class="string">data     =                       bsize=4096   blocks=230400, imaxpct=25</span></span><br><span class="line"><span class="string">         =                       sunit=0      swidth=0 blks</span></span><br><span class="line"><span class="string">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span></span><br><span class="line"><span class="string">log      =internal               bsize=4096   blocks=853, version=2</span></span><br><span class="line"><span class="string">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span></span><br><span class="line"><span class="string">realtime =none                   extsz=4096   blocks=0, rtextents=0</span></span><br><span class="line"><span class="string">data blocks changed from 230400 to 358400</span></span><br></pre></td></tr></table></figure>
<p>SSM在设备上运行检查，然后按指定的数量扩展音量。这可以通过<code>ssm list</code>命令来验证.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Device          Free        Used      Total  Pool      Mount point</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">/dev/vda                           15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                         500.00 MB            /boot</span><br><span class="line">/dev/vda2    0.00 KB    14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb     0.00 KB  1020.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc   640.00 MB   380.00 MB    1.00 GB  lvm_pool</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">------------------------------------------------------</span><br><span class="line">Pool      Type  Devices       Free      Used     Total</span><br><span class="line">------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   2        640.00 MB   1.37 GB   1.99 GB</span><br><span class="line">rhel      lvm   1          0.00 KB  14.51 GB  14.51 GB</span><br><span class="line">------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS      FS size        Free  Type    Mount point</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs    13.52 GB     9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                               linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool      1.37 GB  xfs     1.36 GB     1.36 GB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs   496.67 MB   403.56 MB  part    /boot</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>只能降低LVM卷的大小; 其他卷类型不支持。这是通过使用一个<code>-</code>而不是一个<code>+</code>。例如，要将LVM卷的大小减小50M，该命令将是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~]<span class="comment"># ssm resize -s-50M /dev/lvm_pool/lvol002</span></span><br><span class="line">  Rounding size to boundary between physical extents: 972.00 MiB</span><br><span class="line">  WARNING: Reducing active logical volume to 972.00 MiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce lvol002? [y/n]: y</span><br><span class="line">  Reducing logical volume lvol002 to 972.00 MiB</span><br><span class="line">  Logical volume lvol002 successfully resized</span><br></pre></td></tr></table></figure>
<p>没有<code>+</code>或者<code>-</code>，被视为绝对的。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>要获取现有卷的快照，请使用该<code>ssm snapshot</code>命令。</p>
<p>如果后端卷所属的卷不支持快照，则该操作将失败。</p>
<p>要创建快照<code>lvol001</code>，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm snapshot /dev/lvm_pool/lvol001</span></span><br><span class="line">  Logical volume <span class="string">"snap20150519T130900"</span> created</span><br></pre></td></tr></table></figure>
<p>要验证这一点，使用<code>ssm list</code>，并注意额外的快照部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm list</span></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">Device        Free        Used      Total  Pool      Mount point</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">/dev/vda                         15.00 GB            PARTITIONED</span><br><span class="line">/dev/vda1                       500.00 MB            /boot</span><br><span class="line">/dev/vda2  0.00 KB    14.51 GB   14.51 GB  rhel</span><br><span class="line">/dev/vdb   0.00 KB  1020.00 MB    1.00 GB  lvm_pool</span><br><span class="line">/dev/vdc                          1.00 GB</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">Pool      Type  Devices     Free        Used       Total</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">lvm_pool  lvm   1        0.00 KB  1020.00 MB  1020.00 MB</span><br><span class="line">rhel      lvm   1        0.00 KB    14.51 GB    14.51 GB</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">Volume                 Pool      Volume size  FS      FS size        Free  Type    Mount point</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">/dev/rhel/root         rhel         13.53 GB  xfs    13.52 GB     9.64 GB  linear  /</span><br><span class="line">/dev/rhel/swap         rhel       1000.00 MB                               linear</span><br><span class="line">/dev/lvm_pool/lvol001  lvm_pool    900.00 MB  xfs   896.67 MB   896.54 MB  linear</span><br><span class="line">/dev/vda1                          500.00 MB  xfs   496.67 MB   403.56 MB  part    /boot</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">Snapshot                           Origin   Pool      Volume size     Size  Type</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">/dev/lvm_pool/snap20150519T130900  lvol001  lvm_pool    120.00 MB  0.00 KB  linear</span><br><span class="line">----------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="删除一个项目"><a href="#删除一个项目" class="headerlink" title="删除一个项目"></a>删除一个项目</h3><p>该<code>ssm remove</code>用于删除的项目，或者是设备，游泳池或体积。</p>
<p>如果某个设备在移除时正在被池使用，则会失败。这可以被迫使用<code>-f</code>参数。</p>
<p>如果在卸下卷时安装，则会失败。与设备不同，它不能被强制使用<code>-f</code>。</p>
<p>要删除其中的<code>lvm_pool</code>所有内容，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssm remove lvm_pool</span></span><br><span class="line">Do you really want to remove volume group <span class="string">"lvm_pool"</span> containing 2 logical volumes? [y/n]: y</span><br><span class="line">Do you really want to remove active logical volume snap20150519T130900? [y/n]: y</span><br><span class="line">  Logical volume <span class="string">"snap20150519T130900"</span> successfully removed</span><br><span class="line">Do you really want to remove active logical volume lvol001? [y/n]: y</span><br><span class="line">  Logical volume <span class="string">"lvol001"</span> successfully removed</span><br><span class="line">  Volume group <span class="string">"lvm_pool"</span> successfully removed</span><br></pre></td></tr></table></figure>
<h1 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h1><p>磁盘空间可以通过在用户占用太多磁盘空间或分区变满之前实现提醒系统管理员的磁盘配额来限制。</p>
<p>可以为个人用户和用户组配置磁盘配额。这使得可以与分配给用户工作的项目的空间（假设项目被赋予它们自己的组）分开管理分配给用户特定文件（例如电子邮件）的空间。</p>
<p>另外，可以设置配额，不仅可以控制所使用的磁盘块数量，还可以控制inode数量（包含UNIX文件系统中的文件信息的数据结构）。由于inode用于包含与文件相关的信息，因此可以控制可以创建的文件的数量。</p>
<p>将<code>quota</code>必须安装RPM来实现磁盘配额。</p>
<h2 id="配置磁盘配额"><a href="#配置磁盘配额" class="headerlink" title="配置磁盘配额"></a>配置磁盘配额</h2><p>要实施磁盘配额，请使用以下步骤：</p>
<ol>
<li>通过修改<code>/etc/fstab</code>文件来启用每个文件系统的配额。</li>
<li>重新安装文件系统。</li>
<li>创建配额数据库文件并生成磁盘使用情况表。</li>
<li>分配配额策略。</li>
</ol>
<p>以下各节将详细讨论这些步骤。</p>
<h3 id="启用配额"><a href="#启用配额" class="headerlink" title="启用配额"></a>启用配额</h3><p>以root身份使用文本编辑器编辑<code>/etc/fstab</code>文件。</p>
<p><strong>编辑/etc/fstab</strong></p>
<p>例如，要使用文本编辑器，<code>vim</code>键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/fstab</span></span><br></pre></td></tr></table></figure>
<p>添加<code>usrquota</code>和 <code>/</code> 或<code>grpquota</code>选项到需要配额的文件系统：</p>
<p><strong>添加配额</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/VolGroup00/LogVol00 /         ext3    defaults        1 1 </span><br><span class="line">LABEL=/boot              /boot     ext3    defaults        1 2 </span><br><span class="line">none                     /dev/pts  devpts  gid=5,mode=620  0 0 </span><br><span class="line">none                     /dev/shm  tmpfs   defaults        0 0 </span><br><span class="line">none                     /proc     proc    defaults        0 0 </span><br><span class="line">none                     /sys      sysfs   defaults        0 0 </span><br><span class="line">/dev/VolGroup00/LogVol02 /home     ext3    defaults,usrquota,grpquota  1 2 </span><br><span class="line">/dev/VolGroup00/LogVol01 swap      swap    defaults        0 0 . . .</span><br></pre></td></tr></table></figure>
<p>在本例中，<code>/home</code>文件系统同时启用了用户和组配额。</p>
<p>以下示例假定<code>/home</code>在安装红帽企业版Linux期间创建了单独的分区。root（<code>/</code>）分区可用于在<code>/etc/fstab</code>文件中设置配额策略。</p>
<h3 id="重新挂载文件系统"><a href="#重新挂载文件系统" class="headerlink" title="重新挂载文件系统"></a>重新挂载文件系统</h3><p>在添加<code>usrquota</code>和/或<code>grpquota</code>选项后，重新装入其<code>fstab</code>条目已被修改的每个文件系统。如果文件系统未被任何进程使用，请使用以下方法之一：</p>
<ul>
<li>发出<code>umount</code>命令后再执行该<code>mount</code>命令以重新挂载文件系统。请参阅<code>man</code>这两个页面<code>umount</code>以及<code>mount</code>有关安装和卸载各种文件系统类型的特定语法。</li>
<li><code>mount -o remount</code> <em><code>file-system</code></em> 命令 (其中 <em><code>file-system</code></em> 是文件系统的名称) 来挂载文件系统. 例如, 要重新挂载 <code>/home</code> 文件系统, 要使用命令 <code>mount -o remount /home</code>.</li>
</ul>
<p>如果文件系统当前正在使用，则重新安装文件系统的最简单方法是重新引导系统。</p>
<h3 id="创建配额数据库文件"><a href="#创建配额数据库文件" class="headerlink" title="创建配额数据库文件"></a>创建配额数据库文件</h3><p>在每个启用配额的文件系统重新安装后，运行该<code>quotacheck</code>命令。</p>
<p>该<code>quotacheck</code>命令检查启用配额的文件系统，并构建每个文件系统当前磁盘使用情况的表。该表然后用于更新操作系统的磁盘使用情况的副本。另外，文件系统的磁盘配额文件也被更新。</p>
<p>该<code>quotacheck</code>命令对XFS没有影响，因为磁盘使用情况在安装时自动完成。<code>xfs_quota(8)</code>有关更多信息，请参阅手册页。</p>
<p>要在文件系统上创建配额文件(<code>aquota.user</code> 和 <code>aquota.group</code>) , 使用  <code>quotacheck</code> <code>-c</code>。</p>
<p><strong>创建配额文件</strong></p>
<p>例如，如果为 <code>/home</code> 文件系统启用了用户和组配额, 请在<code>/home</code>目录中创建文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quotacheck -cug /home</span></span><br></pre></td></tr></table></figure>
<p> <code>-c</code> 项指定应为每个启用了配额的文件系统创建配额文件, <code>-u</code> o选项指定检查用户配额, <code>-g</code> 选项指定检查组配额。</p>
<p>如果没有指定 <code>-u</code> 或 <code>-g</code> 选项，则只创建用户配额文件。 如果仅指定 <code>-g</code> ，则只创建组配额文件。</p>
<p>创建文件后，运行以下命令以生成启用了配额的每个文件系统的当前磁盘使用情况表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quotacheck -avug</span></span><br></pre></td></tr></table></figure>
<p>使用的选项如下：</p>
<ul>
<li><p>a</p>
<p>检查所有配额启用的本地安装的文件系统</p>
</li>
<li><p>v</p>
<p>随着配额检查的进行，显示详细的状态信息</p>
</li>
<li><p>u</p>
<p>检查用户磁盘配额信息</p>
</li>
<li><p>g</p>
<p>检查组磁盘配额信息</p>
<p><code>quotacheck</code> 运行完毕后, 对应于启用配额（用户和/或组）被填充以用于每个启用了配额的本地安装的文件系统，例如数据配额文件 <code>/home</code>.</p>
</li>
</ul>
<h3 id="为每个用户分配配额"><a href="#为每个用户分配配额" class="headerlink" title="为每个用户分配配额"></a>为每个用户分配配额</h3><p>最后一步是用<code>edquota</code>命令分配磁盘配额。</p>
<p>要为用户配置配额，请以root用户身份在shell提示符下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edquota username</span></span><br></pre></td></tr></table></figure>
<p>为需要配额的每个用户执行此步骤。例如， 如果 <code>/etc/fstab</code> 为 <code>/home</code> 分区启用了配额  (<code>/dev/VolGroup00/LogVol02</code>在下面的示例中) 并且执行<code>edquota testuser</code>命令 ,则以下内容将显示在配置为系统默认值的编辑器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> user testuser (uid 501):   </span><br><span class="line">Filesystem                blocks     soft     hard    inodes   soft   hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440436        0        0     37418      0      0</span><br></pre></td></tr></table></figure>
<p>由<code>EDITOR</code>环境变量定义的文本编辑器被使用<code>edquota</code>。要更改编辑器，请将文件中的<code>EDITOR</code>环境变量设置为所选<code>~/.bash_profile</code>编辑器的完整路径。</p>
<p>第一列是启用了配额的文件系统的名称。第二列显示用户当前使用的块数。接下来的两列用于为文件系统上的用户设置软硬限制。该<code>inodes</code>列显示用户当前使用了多少个inode。最后两列用于设置文件系统上用户的软硬节点限制。</p>
<p>硬块限制是用户或组可以使用的绝对最大磁盘空间量。达到此限制后，不能使用其他磁盘空间。</p>
<p>软块限制定义了可以使用的最大磁盘空间量。但是，与硬限制不同，软限制可以超过一定的时间。那个时候被称为<em>宽限期</em>。宽限期可以用秒，分，小时，天，星期或月来表示。</p>
<p>如果任何值被设置为0，则不设置该限制。在文本编辑器中，更改所需的限制。</p>
<p><strong>更改所需限制</strong></p>
<p>例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> user testuser (uid 501):   </span><br><span class="line">Filesystem                blocks     soft     hard   inodes   soft   hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440436   500000   550000    37418      0      0</span><br></pre></td></tr></table></figure>
<p>要验证是否已设置用户的配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quota username</span></span><br><span class="line">Disk quotas <span class="keyword">for</span> user username (uid 501): </span><br><span class="line">   Filesystem  blocks   quota   <span class="built_in">limit</span>   grace   files   quota   <span class="built_in">limit</span>   grace</span><br><span class="line">     /dev/sdb    1000*   1000    1000               0       0       0</span><br></pre></td></tr></table></figure>
<h2 id="为每组分配配额"><a href="#为每组分配配额" class="headerlink" title="为每组分配配额"></a>为每组分配配额</h2><p>配额也可以按组分配。例如，要为组设置组配额<code>devel</code>（该组必须在设置组配额之前存在），请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edquota -g devel</span></span><br></pre></td></tr></table></figure>
<p>该命令在文本编辑器中显示组的现有配额：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Disk quotas <span class="keyword">for</span> group devel (gid 505):   </span><br><span class="line">Filesystem                blocks    soft     hard    inodes    soft    hard   </span><br><span class="line">/dev/VolGroup00/LogVol02  440400       0        0     37418       0       0</span><br></pre></td></tr></table></figure>
<p>修改限制，然后保存文件。</p>
<p>要验证组配额是否已设置，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quota -g devel</span></span><br></pre></td></tr></table></figure>
<h3 id="设置软极限的宽限期"><a href="#设置软极限的宽限期" class="headerlink" title="设置软极限的宽限期"></a>设置软极限的宽限期</h3><p>如果给定的配额具有软限制，则可以使用以下命令编辑宽限期（即，可以超过软限制的时间量）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edquota -t</span></span><br></pre></td></tr></table></figure>
<p>此命令适用于用户或组的inode或块的配额。</p>
<p>当其他<code>edquota</code>命令对特定用户或组执行配额操作时，该<code>-t</code>选项将在启用配额的每个文件系统上运行。</p>
<h2 id="管理磁盘配额"><a href="#管理磁盘配额" class="headerlink" title="管理磁盘配额"></a>管理磁盘配额</h2><p>如果实施配额，他们需要一些维护 - 主要是看配额是否超出，并确保配额是准确的形式。</p>
<p>当然，如果用户反复超出配额或一直达到软限制，系统管理员可以根据他们的用户类型以及磁盘空间的多少来影响他们的工作。管理员可以帮助用户确定如何使用更少的磁盘空间或增加用户的磁盘配额。</p>
<h3 id="启用和禁用"><a href="#启用和禁用" class="headerlink" title="启用和禁用"></a>启用和禁用</h3><p>可以禁用配额而不将其设置为0.要关闭所有用户和组配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quotaoff -vaug</span></span><br></pre></td></tr></table></figure>
<p>如果没有指定<code>-u</code>或<code>-g</code>选项， 则只有用户配额被禁用。如果仅<code>-g</code>指定，则仅禁用组配额。当<code>-v</code>命令执行时，交换机会导致详细的状态信息显示。</p>
<p>要再次启用配额，请使用<code>quotaon</code>具有相同选项的命令。</p>
<p>例如，要为所有文件系统启用用户和组配额，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quotaon -vaug</span></span><br></pre></td></tr></table></figure>
<p>要为特定文件系统启用配额<code>/home</code>，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># quotaon -vug /home</span></span><br></pre></td></tr></table></figure>
<p>如果没有指定<code>-u</code>或<code>-g</code>选项，则只启用用户配额。如果仅<code>-g</code>指定，则只启用组配额。</p>
<p><code>quotaon</code>XFS并不总是需要 该命令，因为它在安装时自动执行</p>
<h3 id="报告磁盘配额"><a href="#报告磁盘配额" class="headerlink" title="报告磁盘配额"></a>报告磁盘配额</h3><p>创建磁盘使用情况报告需要运行该<code>repquota</code>实用程序。</p>
<p><strong>repquota命令的输出</strong></p>
<p>例如，该命令<code>repquota /home</code>产生这个输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*** Report <span class="keyword">for</span> user quotas on device /dev/mapper/VolGroup00-LogVol02 </span><br><span class="line">Block grace time: 7days; Inode grace time: 7days</span><br><span class="line">			Block limits			File limits		</span><br><span class="line">User		used	soft	hard	grace	used	soft	hard	grace </span><br><span class="line">---------------------------------------------------------------------- </span><br><span class="line">root      --      36       0       0              4     0     0 </span><br><span class="line">kristin   --     540       0       0            125     0     0 </span><br><span class="line">testuser  --  440400  500000  550000          37418     0     0</span><br></pre></td></tr></table></figure>
<p>要查看所有（可选<code>-a</code>）启用配额的文件系统的磁盘使用情况报告，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repquota -a</span></span><br></pre></td></tr></table></figure>
<p>报告很容易阅读，应该解释几点。在<code>--</code>每个用户之后显示是一个快速的方法来确定块或i节点限制是否已经被超过。如果超出软限制，<code>+</code>则会出现a 代替相应的代码<code>-</code>; 第一个<code>-</code>表示块限制，第二个表示inode限制。</p>
<p>该<code>grace</code>栏目是空白正常。如果软限制已超出，则该列包含的时间规格等于宽限期内剩余的时间量。如果宽限期已经过期，则<code>none</code>出现在其位置上。</p>
<h3 id="保持配额准确"><a href="#保持配额准确" class="headerlink" title="保持配额准确"></a>保持配额准确</h3><p>当文件系统无法完全卸载（例如，由于系统崩溃），则需要运行<code>quotacheck</code>。但是，<code>quotacheck</code>即使系统没有崩溃，也可以定期运行。定期运行的安全方法<code>quotacheck</code>包括：</p>
<p>确保在下次重新启动时运行quotacheck</p>
<p>以root用户身份，将一个shell脚本放到<code>/etc/cron.daily/</code>或<code>/etc/cron.weekly/</code>目录中 - 或者使用<code>crontab -e</code>包含该<code>touch /forcequotacheck</code>命令的命令来安排一个shell脚本。这将<code>forcequotacheck</code>在根目录中创建一个空文件，系统启动脚本将在启动时查找该文件。如果找到，则运行init脚本<code>quotacheck</code>。之后，init脚本删除<code>/forcequotacheck</code>文件; 因此，调度此文件定期创建，以<code>cron</code>确保<code>quotacheck</code>在下次重新启动时运行。</p>
<p>Refer to <code>man cron</code> for more information about configuring <code>cron</code>.</p>
<p>在单用户模式下运行quotacheck</p>
<p>另一种安全运行的方法<code>quotacheck</code>是将系统引导到单用户模式，以防止配额文件中数据损坏的可能性并运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ quotaoff -vug /file_system</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ quotacheck -vug /file_system</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ quotaon -vug /file_system</span><br></pre></td></tr></table></figure>
<p>在正在运行的系统上运行quotacheck</p>
<p>如果有必要，可以<code>quotacheck</code>在没有用户登录的时间在机器上运行，因此在被检查的文件系统上没有打开的文件。运行命令; 如果无法将给定的<em>file_system</em>重新挂载为只读，则此命令将失败。请注意，在检查之后，文件系统将被重新读写。 <code>quotacheck -vug*file_system*``quotacheck</code>**</p>
<p><strong>警告</strong></p>
<p><code>quotacheck</code>由于配额文件损坏的可能性，建议不要使用挂载的读写方式 运行实时文件系统。</p>
<h2 id="磁盘配额参考"><a href="#磁盘配额参考" class="headerlink" title="磁盘配额参考"></a>磁盘配额参考</h2><p>有关磁盘配额的更多信息，请参阅</p>
<ul>
<li><code>quotacheck</code></li>
<li><code>edquota</code></li>
<li><code>repquota</code></li>
<li><code>quota</code></li>
<li><code>quotaon</code></li>
<li><code>quotaoff</code></li>
</ul>
<h1 id="独立磁盘冗余阵列（RAID）"><a href="#独立磁盘冗余阵列（RAID）" class="headerlink" title="独立磁盘冗余阵列（RAID）"></a>独立磁盘冗余阵列（RAID）</h1><p>RAID背后的基本思想是将多个小型，廉价的磁盘驱动器组合成一个阵列，以实现一个大而昂贵的驱动器无法实现的性能或冗余目标。该驱动器阵列在计算机上显示为单个逻辑存储单元或驱动器。</p>
<p>RAID允许信息分布在多个磁盘上。RAID使用诸如<em>磁盘分条</em>（RAID 0级），<em>磁盘镜像</em>（RAID 1）和<em>带有奇偶校验</em>（RAID Level 5）的<em>磁盘分条等技术</em>来实现冗余，更低的延迟，增加的带宽以及最大限度地从硬盘崩溃中恢复的能力。</p>
<p>RAID通过将数据分解成一致大小的块（通常为256K或512k，尽管其他值是可接受的）来将数据分布到阵列中的每个驱动器上。然后根据所使用的RAID级别将每个块写入RAID阵列中的硬盘驱动器。当数据被读取时，这个过程被颠倒过来，给出这样的错觉：阵列中的多个驱动器实际上是一个大驱动器。</p>
<p>系统管理员和其他管理大量数据的人员将从使用RAID技术中受益。部署RAID的主要原因包括：</p>
<ul>
<li>提高速度</li>
<li>使用单个虚拟磁盘提高存储容量</li>
<li>最大限度减少磁盘故障造成的数据丢失</li>
</ul>
<h2 id="RAID类型"><a href="#RAID类型" class="headerlink" title="RAID类型"></a>RAID类型</h2><p>有三种可能的RAID方法：固件RAID，硬件RAID和软件RAID。</p>
<h3 id="固件RAID"><a href="#固件RAID" class="headerlink" title="固件RAID"></a>固件RAID</h3><p><em>固件RAID</em>（也称为ATARAID）是一种软件RAID，可以使用基于固件的菜单对RAID集进行配置。这种类型的RAID所使用的固件也会挂接到BIOS中，允许您从RAID设置中进行引导。不同的供应商使用不同的磁盘元数据格式来标记RAID组成员。Intel Matrix RAID是固件RAID系统的一个很好的例子。</p>
<h3 id="硬件RAID"><a href="#硬件RAID" class="headerlink" title="硬件RAID"></a>硬件RAID</h3><p>基于硬件的阵列独立于主机管理RAID子系统。它为主机提供每个RAID阵列的单个磁盘。</p>
<p>硬件RAID设备可以在系统的内部或外部，内部设备通常由专用控制器卡组成，该卡对操作系统透明地处理RAID任务，并且通常通过SCSI，光纤通道，iSCSI等连接到系统的外部设备。 InfiniBand或其他高速网络互连，并向系统呈现逻辑卷。</p>
<p>RAID控制卡的功能类似于操作系统的SCSI控制器，并处理所有实际的驱动器通信。用户将驱动器插入RAID控制器（就像普通的SCSI控制器一样），然后将它们添加到RAID控制器配置中。操作系统将无法区分。</p>
<h3 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h3><p>软件RAID实现内核磁盘（块设备）代码中的各种RAID级别。它提供了最便宜的解决方案，因为不需要昂贵的磁盘控制器卡或热插拔机箱</p>
<p>软件RAID也适用于更便宜的IDE磁盘以及SCSI磁盘。有了如今更快的CPU，软件RAID通常也比硬件RAID更好。</p>
<p>Linux内核包含一个<em>多磁盘</em>（MD）驱动程序，使RAID解决方案完全独立于硬件。基于软件的阵列的性能取决于服务器的CPU性能和负载。</p>
<p>以下是Linux软件RAID堆栈的一些主要特性：</p>
<ul>
<li>多线程设计</li>
<li>Linux机器之间的阵列可移植性，无需重建</li>
<li>使用空闲系统资源的背景阵列重建</li>
<li>支持热插拔驱动器</li>
<li>自动CPU检测，以利用某些CPU功能，如流SIMD支持</li>
<li>自动更正阵列中磁盘上的坏扇区</li>
<li>定期对RAID数据进行一致性检查，以确保阵列的健康</li>
<li>通过电子邮件警报主动监控阵列，将其发送到重要事件的指定电子邮件地址</li>
<li>写意图位图通过允许内核精确地知道磁盘的哪些部分需要重新同步而不必重新同步整个阵列，从而大大提高了重新同步事件的速度</li>
<li>重新同步点校验，以便在重新同步期间重新启动计算机时，在启动时，重新同步将会停止，并且不会重新开始</li>
<li>安装后更改数组参数的功能。例如，当您添加新磁盘时，可以将4磁盘RAID5阵列增长为5磁盘RAID5阵列。这种增长操作是实时完成的，不需要您在新阵列上重新安装。</li>
</ul>
<hr>
<h2 id="RAID级别和线性支持"><a href="#RAID级别和线性支持" class="headerlink" title="RAID级别和线性支持"></a>RAID级别和线性支持</h2><p>RAID支持各种配置，包括级别0,1,4,5,6,10和线性。这些RAID类型定义如下：</p>
<ul>
<li><p>0级</p>
<p>RAID级别0通常称为“分条”，是一种面向性能的分条数据映射技术。这意味着写入阵列的数据被分解为条带并写入阵列的成员磁盘，从而以较低的固有成本实现高I / O性能，但不提供冗余。许多RAID级别0的实现将只将成员设备上的数据分条到阵列中最小的设备的大小。这意味着，如果您有多个尺寸略有不同的设备，则每个设备都将被视为与最小驱动器的尺寸相同。因此，0级阵列的公共存储容量等于硬件RAID中最小成员磁盘的容量，或软件RAID中最小成员分区的容量乘以阵列中磁盘或分区的数量。</p>
</li>
<li><p>1级</p>
<p>RAID级别1（或“镜像”）的使用时间比任何其他形式的RAID都要长。级别1通过将相同的数据写入阵列的每个成员磁盘来提供冗余，在每个磁盘上留下“镜像”副本。由于其简单和高水平的数据可用性，镜像依然流行。级别1使用两个或更多磁盘运行，并提供非常好的数据可靠性，并提高读取密集型应用程序的性能，但成本相对较高。级别1阵列的存储容量等于硬件RAID中最小镜像硬盘的容量或软件RAID中最小镜像分区的容量。在所有RAID类型中，1级冗余是最高的可能性，阵列只能在单个磁盘上运行。</p>
</li>
<li><p>4级</p>
<p>级别4使用奇偶校验集中在单个磁盘驱动器上来保护数据。由于专用奇偶校验磁盘代表了对RAID阵列的所有写入事务的固有瓶颈，因此级别4很少没有附带的技术（如回写缓存）使用，或者在系统管理员有意用此设计软件RAID设备的特定情况下记住瓶颈（例如，一旦阵列填充数据，将会有几乎没有写入事务的数组）。RAID级别4很少使用，因此在Anaconda中不可用。但是，如果真的需要，可以由用户手动创建。硬件RAID级别4的存储容量等于最小成员分区的容量乘以分区数<em>减一</em>。RAID级别4阵列的性能总是不对称的，这意味着读取将优于写入。这是因为在产生奇偶校验时，写入操作会消耗额外的CPU和主存储器带宽，并且在将实际数据写入磁盘时也消耗额外的总线带宽，因为您不仅正在写入数据，而且正在写入奇偶校验。除非阵列处于降级状态，否则只需要读取数据而不是奇偶校验。因此，在正常操作条件下，读取操作产生的驱动器和计算机总线上的流量减少了相同的数据传输量。</p>
</li>
<li><p>5级</p>
<p>这是最常见的RAID类型。通过在阵列的所有成员磁盘驱动器中分配奇偶校验，RAID级别5消除了级别4固有的写入瓶颈。唯一的性能瓶颈是奇偶校验计算过程本身。随着现代CPU和软件RAID，这通常不是一个瓶颈，因为现代的CPU可以非常快速地产生奇偶校验。但是，如果软件RAID5阵列中的成员设备数量足够多，以至于所有设备的汇总数据传输总速度足够高，则此瓶颈可能开始起作用。与第4级一样，第5级的表现也是不对称的，读取效果明显优于写入。RAID级别5的存储容量的计算方式与级别4相同。</p>
</li>
<li><p>6级</p>
<p>当数据冗余和保存（而不是性能）是最重要的问题时，这是RAID的普通级别，但是级别1的空间低效率是不可接受的。级别6使用复杂的奇偶校验方案能够从阵列中任何两个驱动器的丢失中恢复。这种复杂的奇偶校验方案在软件RAID设备上造成了显着更高的CPU负担，并且在写入事务期间也增加了负担。因此，6级在性能上比4级和5级更为不对称。除了必须从额外奇偶校验存储空间的设备计数中减去2个设备（而不是1个）之外，RAID级别6阵列的总容量的计算与RAID级别5和4相似。</p>
</li>
<li><p>10级</p>
<p>此RAID级别尝试将级别0的性能优势与级别1的冗余相结合。它还有助于减轻2级以上设备在1级阵列中浪费的部分空间。通过级别10，可以创建一个3驱动器阵列，每个数据只能存储2个副本，然后允许整个阵列大小为最小器件大小的1.5倍，而不是等于最小值设备（就像3设备，1级阵列一样）。创建10级阵列时可用的选项数量（以及为特定用例选择正确选项的复杂性）使安装过程中创建不切实际。可以使用命令行<code>mdadm</code>工具手动创建一个。有关选项及其各自性能折衷的详细信息，请参阅<code>man md</code>。</p>
</li>
<li><p>线性RAID</p>
<p>线性RAID是一个简单的驱动器分组来创建一个更大的虚拟驱动器。在线性RAID中，块是从一个成员驱动器中顺序分配的，只有当第一个完全填满时才会进入下一个驱动器。这个分组没有提供性能优势，因为任何I / O操作都不太可能在成员驱动器之间进行分割。线性RAID也不提供冗余，实际上降低了可靠性 - 如果任何一个成员驱动器发生故障，整个阵列将无法使用。容量是所有成员磁盘的总和。</p>
</li>
</ul>
<h2 id="LINUX-RAID子系统"><a href="#LINUX-RAID子系统" class="headerlink" title="LINUX RAID子系统"></a>LINUX RAID子系统</h2><p>Linux中的RAID由以下子系统组成：</p>
<h3 id="Linux硬件RAID控制器驱动程序"><a href="#Linux硬件RAID控制器驱动程序" class="headerlink" title="Linux硬件RAID控制器驱动程序"></a>Linux硬件RAID控制器驱动程序</h3><p>硬件RAID控制器在Linux中没有特定的RAID子系统。由于他们使用特殊的RAID芯片组，硬件RAID控制器带有自己的驱动程序; 这些驱动程序允许系统将RAID设置检测为常规磁盘。</p>
<h4 id="mdraid"><a href="#mdraid" class="headerlink" title="mdraid"></a>mdraid</h4><p>该<code>mdraid</code>子系统被设计为Linux的软件RAID解决方案; 它也是Linux下软件RAID的首选解决方案。该子系统使用其自己的元数据格式，通常称为本地<code>mdraid</code>元数据。</p>
<p><code>mdraid</code>还支持其他元数据格式，称为外部元数据。红帽企业Linux 7使用<code>mdraid</code>外部元数据来访问ISW / IMSM（英特尔固件RAID）集。<code>mdraid</code>套件通过<code>mdadm</code>电力公司进行配置和控制。</p>
<h4 id="dmraid的"><a href="#dmraid的" class="headerlink" title="dmraid的"></a>dmraid的</h4><p><em>设备映射程序RAID</em>或<code>dmraid</code>指设备映射程序内核代码，它提供了将磁盘组合成RAID组的机制。相同的内核代码不提供任何RAID配置机制。</p>
<p><code>dmraid</code>完全在用户空间中配置，使得支持各种磁盘上的元数据格式变得容易。因此，<code>dmraid</code>用于各种固件RAID实现。<code>dmraid</code>也支持英特尔固件RAID，尽管红帽企业Linux 7使用<code>mdraid</code>英特尔固件RAID集。</p>
<h2 id="ANACONDA安装程序中的RAID支持"><a href="#ANACONDA安装程序中的RAID支持" class="headerlink" title="ANACONDA安装程序中的RAID支持"></a>ANACONDA安装程序中的RAID支持</h2><p>该<strong>Anaconda</strong>安装程序会自动检测系统中的任何硬件和固件的RAID集，使其可用于安装。<strong>Anaconda</strong>还支持使用软件RAID <code>mdraid</code>，并可以识别现有的<code>mdraid</code>设置。</p>
<p><strong>Anaconda</strong>提供了用于在安装期间创建RAID集的实用程序; 但是，这些实用程序只允许分区（而不是整个磁盘）成为新集的成员。要将整个磁盘用于集合，只需在整个磁盘上创建一个分区，然后将该分区用作RAID集成员。</p>
<p>当根文件系统使用RAID集时，<strong>Anaconda</strong>会在启动加载程序配置中添加特殊的内核命令行选项，告诉<code>initrd</code>在搜索根文件系统之前要激活哪个RAID集。</p>
<h2 id="安装后将根磁盘转换为RAID1"><a href="#安装后将根磁盘转换为RAID1" class="headerlink" title="安装后将根磁盘转换为RAID1"></a>安装后将根磁盘转换为RAID1</h2><p>在PowerPC（PPC）体系结构上，执行以下附加步骤：</p>
<ol>
<li>将PowerPC参考平台（PReP）引导分区的内容复制<code>/dev/sda1</code>到<code>/dev/sdb1</code>：</li>
</ol>
<ol>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dd if&#x3D;&#x2F;dev&#x2F;sda1 of&#x3D;&#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新两个磁盘上第一个分区上的准备和启动标志：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ parted /dev/sda <span class="built_in">set</span> 1 prep on</span><br><span class="line">$ parted /dev/sda <span class="built_in">set</span> 1 boot on</span><br><span class="line"></span><br><span class="line">$ parted /dev/sdb <span class="built_in">set</span> 1 prep on</span><br><span class="line">$ parted /dev/sdb <span class="built_in">set</span> 1 boot on</span><br></pre></td></tr></table></figure>
<p>请注意，<code>grub2-install /dev/sda</code> 在PowerPC机器上运行该命令不起作用，并返回一个错误，但是系统按预期方式启动。</p>
<h2 id="配置RAID集"><a href="#配置RAID集" class="headerlink" title="配置RAID集"></a>配置RAID集</h2><p>大多数RAID组在创建时都会配置，通常通过固件菜单或安装程序进行配置。在某些情况下，您可能需要在安装系统后创建或修改RAID集，最好不必重新启动机器并进入固件菜单。</p>
<p>某些硬件RAID控制器允许您即时配置RAID集，甚至可以在添加额外的磁盘后定义全新的集。这需要使用驱动程序特定的实用程序，因为没有标准的API。有关这方面的信息，请参阅您的硬件RAID控制器的驱动程序文档。</p>
<h2 id="mdadm的"><a href="#mdadm的" class="headerlink" title="mdadm的"></a>mdadm的</h2><p>该<code>mdadm</code>命令行工具来管理Linux软件RAID，即<code>mdraid</code>。有关不同<code>mdadm</code>模式和选项的信息，请参阅<code>man mdadm</code>。该<code>man</code>页面还包含常用操作的有用示例，如创建，监视和组装软件RAID阵列。</p>
<h2 id="dmraid的-1"><a href="#dmraid的-1" class="headerlink" title="dmraid的"></a>dmraid的</h2><p>顾名思义，<code>dmraid</code>用于管理设备映射器RAID集。该<code>dmraid</code>工具使用多个元数据格式处理程序查找ATARAID设备，每个处理程序支持各种格式。有关支持的格式的完整列表，请运行<code>dmraid -l</code>。</p>
<h2 id="创建高级RAID设备"><a href="#创建高级RAID设备" class="headerlink" title="创建高级RAID设备"></a>创建高级RAID设备</h2><p>在某些情况下，您可能希望将操作系统安装在安装完成后无法创建的阵列上。通常，这意味着<code>/boot</code>在一个复杂的RAID设备上设置或根文件系统阵列; 在这种情况下，您可能需要使用<strong>Anaconda</strong>不支持的数组选项。要解决此问题，请执行以下步骤：</p>
<p><strong>创建高级RAID设备</strong></p>
<ol>
<li>像平常一样插入安装盘。</li>
<li>在初始启动过程中，请选择“ <strong>救援模式”，</strong>而不是“ <strong>安装”</strong>或“ <strong>升级”</strong>。当系统完全进入<em>Rescue模式时</em>，用户将会看到一个命令行终端。</li>
<li>从此终端上，使用<code>parted</code>在目标硬盘驱动器上创建RAID分区。然后，使用<code>mdadm</code>任何和所有可用的设置和选项，从这些分区手动创建RAID阵列。</li>
<li>一旦创建了数组，您也可以选择在数组上创建文件系统。</li>
<li>重新启动计算机，这次选择<strong>安装</strong>或<strong>升级</strong>以正常安装。当<strong>Anaconda</strong>搜索系统中的磁盘时，它将找到预先存在的RAID设备。</li>
<li>当询问如何使用系统中的磁盘时，请选择“ <strong>自定义布局”</strong>，然后单击“ <strong>下一步”</strong>。在设备列表中，将列出预先存在的MD RAID设备。</li>
<li>选择一个RAID设备，单击<strong>编辑</strong>并配置其安装点和（可选）它应该使用的文件系统的类型（如果您以前没有创建），然后单击<strong>完成</strong>。<strong>Anaconda</strong>将执行安装到这个预先存在的RAID设备，保留您在<em>救援模式下</em>创建它时选择的自定义选项。</li>
</ol>
<p><strong>注意</strong></p>
<p>安装程序 的有限<em>救援模式</em>不包括<code>man</code>页面。无论是<code>man mdadm</code>和<code>man md</code>包含用于创建自定义RAID阵列的有用信息，并且可能需要在整个解决方法。因此，可以访问带有这些<code>man</code>页面的机器，或者在启动进入<em>救援模式</em>并创建自定义阵列之前将其打印出来。</p>
<h2 id="使用MOUNT命令"><a href="#使用MOUNT命令" class="headerlink" title="使用MOUNT命令"></a>使用MOUNT命令</h2><p>在Linux，UNIX和类似操作系统上，可以将不同分区和可移动设备（例如CD，DVD或USB闪存驱动器）上的文件系统附加到目录树中的某个点（<em>装入点</em>），然后分离再次。要附加或分离文件系统，请分别使用<code>mount</code>或<code>umount</code>命令。本章介绍这些命令的基本用法，以及一些高级主题，如移动挂载点或创建共享子树。</p>
<h3 id="列出当前已安装的文件系统"><a href="#列出当前已安装的文件系统" class="headerlink" title="列出当前已安装的文件系统"></a>列出当前已安装的文件系统</h3><p>要显示所有当前连接的文件系统，<code>mount</code>不带其他参数运行该命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>该命令显示已知挂载点的列表。每行提供有关设备名称，文件系统类型，安装目录以及相关安装选项的重要信息，格式如下：</p>
<blockquote>
<p><em>device</em> on <em>directory</em> type <em>type</em> (<em>options</em>)</p>
</blockquote>
<p>The <code>findmnt</code> u工具允许用户以树状形式列出已安装的文件系统, 要显示所有当前连接的文件系统，<code>findmnt</code>不带其他参数运行该命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">findmnt</span><br></pre></td></tr></table></figure>
<h3 id="指定文件系统类型"><a href="#指定文件系统类型" class="headerlink" title="指定文件系统类型"></a>指定文件系统类型</h3><p>缺省情况下，输出<code>mount</code>命令包括各种虚拟文件系统，如<code>sysfs</code>和<code>tmpfs</code>。要仅显示具有特定文件系统类型的设备，请<code>-t</code>在命令行上提供该选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p>同样，要使用该<code>findmnt</code>命令仅显示具有特定文件系统类型的设备，请键入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">findmnt -t <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
<p><strong>列出当前已安装的ext4文件系统</strong></p>
<p>通常情况下，这两个<code>/</code>和<code>/boot</code>分区格式化使用<code>ext4</code>。要仅显示使用此文件系统的安装点，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mount -t ext4</span><br><span class="line">/dev/sda2 on / <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br></pre></td></tr></table></figure>
<p>要使用该<code>findmnt</code>命令列出此类安装点，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ findmnt -t ext4</span><br><span class="line">TARGET SOURCE    FSTYPE OPTIONS</span><br><span class="line">/      /dev/sda2 ext4   rw,realtime,seclabel,barrier=1,data=ordered</span><br><span class="line">/boot  /dev/sda1 ext4   rw,realtime,seclabel,barrier=1,data=ordered</span><br></pre></td></tr></table></figure>
<h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><p>要附加某个文件系统，请使用<code>mount</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [option…] device directory</span><br></pre></td></tr></table></figure>
<p><em>设备</em>可以通过以下方式识别：</p>
<ul>
<li><em>块设备</em> 的完整路径：例如，<code>/dev/sda3</code></li>
<li>一个<em>通用唯一标识符</em>（UUID）：例如，<code>UUID=34795a28-ca6d-4fd8-a347-73671d0c19cb</code></li>
<li>一个<em>卷标</em>：例如，<code>LABEL=home</code></li>
</ul>
<p>请注意，挂载文件系统时，不能访问<em>目录</em>的原始内容。</p>
<p>Linux不阻止用户将文件系统挂载到已连接文件系统的目录。要确定一个特定的目录是否作为挂载点，运行<code>findmnt</code>该目录作为参数的实用程序并验证退出代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">findmnt directory; <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>如果没有文件系统连接到目录，则上述命令返回<code>1</code>。</p>
<p>如果运行<code>mount</code>命令时没有提供所有必需信息（即没有设备名称，目标目录或文件系统类型），则<code>mount</code>读取<code>/etc/fstab</code>文件的内容以检查是否列出了给定的文件系统。该<code>/etc/fstab</code>文件包含设备名称的列表以及所选文件系统设置为要装入的目录以及文件系统类型和装入选项。因此，在安装指定的文件系统时<code>/etc/fstab</code>，可以选择以下选项之一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [option…] directory</span><br><span class="line">mount [option…] device</span><br></pre></td></tr></table></figure>
<p>请注意，除非命令运行为<code>root</code>，否则安装文件系统需要权限。</p>
<p><strong>注意</strong></p>
<p>要确定UUID并且（如果设备使用它）特定设备的标签，请使用<code>blkid</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid device</span><br></pre></td></tr></table></figure>
<p>例如，要显示有关的信息<code>/dev/sda3</code>，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blkid /dev/sda3</span></span><br><span class="line">/dev/sda3: LABEL=<span class="string">"home"</span> UUID=<span class="string">"34795a28-ca6d-4fd8-a347-73671d0c19cb"</span> TYPE=<span class="string">"ext3"</span></span><br></pre></td></tr></table></figure>
<h4 id="指定文件系统类型-1"><a href="#指定文件系统类型-1" class="headerlink" title="指定文件系统类型"></a>指定文件系统类型</h4><p>在大多数情况下，<code>mount</code>自动检测文件系统。但是，某些文件系统（例如<code>NFS</code>（网络文件系统）或<code>CIFS</code>（通用Internet文件系统））无法识别，需要手动指定。要指定文件系统类型，请使用<code>mount</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t <span class="built_in">type</span> device directory</span><br></pre></td></tr></table></figure>
<p><strong>通用文件系统类型</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ext2</code></td>
<td><code>ext2</code>文件系统。</td>
</tr>
<tr>
<td><code>ext3</code></td>
<td><code>ext3</code>文件系统。</td>
</tr>
<tr>
<td><code>ext4</code></td>
<td><code>ext4</code>文件系统。</td>
</tr>
<tr>
<td><code>btrfs</code></td>
<td><code>btrfs</code>文件系统。</td>
</tr>
<tr>
<td><code>xfs</code></td>
<td><code>xfs</code>文件系统。</td>
</tr>
<tr>
<td><code>iso9660</code></td>
<td><code>ISO 9660</code>文件系统。它通常被光学媒体使用，通常是CD。</td>
</tr>
<tr>
<td><code>jfs</code></td>
<td><code>JFS</code>由IBM创建的文件系统。</td>
</tr>
<tr>
<td><code>nfs</code></td>
<td><code>NFS</code>文件系统。它通常用于通过网络访问文件。</td>
</tr>
<tr>
<td><code>nfs4</code></td>
<td><code>NFSv4</code>文件系统。它通常用于通过网络访问文件。</td>
</tr>
<tr>
<td><code>ntfs</code></td>
<td><code>NTFS</code>文件系统。它通常用于运行Windows操作系统的机器上。</td>
</tr>
<tr>
<td><code>udf</code></td>
<td><code>UDF</code>文件系统。它通常用于光学媒体，通常是DVD。</td>
</tr>
<tr>
<td><code>vfat</code></td>
<td><code>FAT</code>文件系统。它通常用于运行Windows操作系统的机器，以及某些数字媒体，如USB闪存驱动器或软盘。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>挂载USB闪存驱动器</strong></p>
<p>较旧的USB闪存驱动器通常使用FAT文件系统。假设这样的驱动器使用该<code>/dev/sdc1</code>设备并且该<code>/media/flashdisk/</code>目录存在，请通过在shell提示符处键入以下命令将其挂载到此目录<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -t vfat /dev/sdc1 /media/flashdisk</span></span><br></pre></td></tr></table></figure>
<h3 id="指定挂载选项"><a href="#指定挂载选项" class="headerlink" title="指定挂载选项"></a>指定挂载选项</h3><p>要指定其他挂载选项，请使用以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -o options device directory</span><br></pre></td></tr></table></figure>
<p>提供多个选项时，不要在逗号后面插入空格，否则<code>mount</code>会错误地将空格后面的值解释为附加参数</p>
<p><strong>常见的安装选项</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async</code></td>
<td>允许在文件系统上进行异步输入/输出操作。</td>
</tr>
<tr>
<td><code>auto</code></td>
<td>允许使用该<code>mount -a</code>命令自动安装文件系统。</td>
</tr>
<tr>
<td><code>defaults</code></td>
<td>提供一个别名<code>async,auto,dev,exec,nouser,rw,suid</code>。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td>允许在特定文件系统上执行二进制文件。</td>
</tr>
<tr>
<td><code>loop</code></td>
<td>将图像作为循环设备装入。</td>
</tr>
<tr>
<td><code>noauto</code></td>
<td>默认行为禁止使用该<code>mount -a</code>命令自动安装文件系统。</td>
</tr>
<tr>
<td><code>noexec</code></td>
<td>不允许在特定文件系统上执行二进制文件。</td>
</tr>
<tr>
<td><code>nouser</code></td>
<td>不允许普通用户（即非<code>root</code>）挂载和卸载文件系统。</td>
</tr>
<tr>
<td><code>remount</code></td>
<td>重新装入文件系统，以防已安装。</td>
</tr>
<tr>
<td><code>ro</code></td>
<td>将文件系统安装为只读。</td>
</tr>
<tr>
<td><code>rw</code></td>
<td>安装文件系统进行读取和写入。</td>
</tr>
<tr>
<td><code>user</code></td>
<td>允许普通用户（即非<code>root</code>）挂载和卸载文件系统。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>挂载 ISO 镜像</strong></p>
<p>可以使用循环设备挂载ISO映像（或通常的磁盘映像）。假设Fedora 14安装光盘的ISO映像存在于当前工作目录中，并且该<code>/media/cdrom/</code>目录存在，请通过运行以下命令将映像挂载到此目录<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o ro,loop Fedora-14-x86_64-Live-Desktop.iso /media/cdrom</span></span><br></pre></td></tr></table></figure>
<p>请注意，ISO 9660设计为只读文件系统。</p>
<h3 id="共享挂载"><a href="#共享挂载" class="headerlink" title="共享挂载"></a>共享挂载</h3><p>偶尔，某些系统管理任务需要从目录树中的多个位置（例如，在准备chroot环境时）访问同一个文件系统。这是可能的，并且Linux允许您根据需要将相同的文件系统安装到多个目录。另外，该<code>mount</code>命令实现了<code>--bind</code>提供复制特定坐骑的方法的选项。其用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --<span class="built_in">bind</span> old_directory new_directory</span><br></pre></td></tr></table></figure>
<p>尽管此命令允许用户从两个位置访问文件系统，但它不适用于原始目录中安装的文件系统。要包括这些安装，请输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --rbind old_directory new_directory</span><br></pre></td></tr></table></figure>
<p>另外，为了提供尽可能大的灵活性，红帽企业版Linux 7实现了被称为<em>共享子树</em>的功能。该功能允许使用以下四种安装类型：</p>
<p><strong>共享挂载</strong></p>
<p>共享挂载允许创建给定挂载点的精确副本。当挂载点被标记为共享挂载时，原始挂载点内的任何挂载都会反映在其中，反之亦然。要将安装点的类型更改为共享安装，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-shared mount_point</span><br></pre></td></tr></table></figure>
<p>或者，要更改所选安装点和其下的所有安装点的安装类型，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-rshared mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建共享安装点</strong></p>
<p>其他文件系统通常挂载在两个位置：<code>/media/</code>可移动介质的<code>/mnt/</code>目录以及临时挂载的文件系统的目录。通过使用共享挂载，可以使这两个目录共享相同的内容。为此<code>root</code>，将<code>/media/</code>目录标记为共享：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /media</span></span><br><span class="line"><span class="comment"># mount --make-shared /media</span></span><br></pre></td></tr></table></figure>
<p>然后<code>/mnt/</code>使用以下命令创建它的重复项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount --<span class="built_in">bind</span> /media /mnt</span><br></pre></td></tr></table></figure>
<p>现在可以验证在一个挂载<code>/media/</code>也出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/cdrom /media/cdrom</span></span><br><span class="line"><span class="comment"># ls /media/cdrom</span></span><br><span class="line">EFI  GPL  isolinux  LiveOS</span><br><span class="line"><span class="comment"># ls /mnt/cdrom</span></span><br><span class="line">EFI  GPL  isolinux  LiveOS</span><br></pre></td></tr></table></figure>
<p>同样，也可以验证安装在<code>/mnt/</code>目录中的任何文件系统是否被反映<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/sdc1 /mnt/flashdisk</span></span><br><span class="line"><span class="comment"># ls /media/flashdisk</span></span><br><span class="line">en-US  publican.cfg</span><br><span class="line"><span class="comment"># ls /mnt/flashdisk</span></span><br><span class="line">en-US  publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>从属挂载</strong></p>
<p>从属安装允许创建给定挂载点的有限副本。当挂载点被标记为从属挂载时，原始挂载点内的任何挂载都会反映到挂载点中，但挂载挂载中的挂载不会反映在其原始映像中。要将挂载点的类型更改为从属安装，请在shell提示下键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-slave mount_point</span><br></pre></td></tr></table></figure>
<p>或者，也可以通过输入以下命令来更改所选安装点及其下的所有挂载点的挂载类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-rslave mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个从站挂载点</strong></p>
<p>这个例子展示了如何让<code>/media/</code>目录的内容也出现在目录中<code>/mnt/</code>，但是没有在<code>/mnt/</code>目录中的任何坐标被反映到<code>/media/</code>。因为<code>root</code>，首先将该<code>/media/</code>目录标记为共享：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /media</span><br><span class="line">＃mount --make-shared /media</span><br></pre></td></tr></table></figure>
<p>然后创建它的副本<code>/mnt/</code>，但将其标记为“slave”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /mnt</span><br><span class="line">＃mount --make-slave /mnt</span><br></pre></td></tr></table></figure>
<p>现在验证一个挂载<code>/media/</code>也出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/cdrom /media/cdrom</span><br><span class="line">ls /media/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS〜</span><br><span class="line">ls /mnt/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS</span><br></pre></td></tr></table></figure>
<p>还要验证<code>/mnt/</code>目录中装载的文件系统没有被反映到<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount /dev/sdc1 /mnt/flashdisk</span><br><span class="line">＃ls /media/flashdisk</span><br><span class="line">＃ls /mnt/flashdisk</span><br><span class="line">en-US publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>私有挂载</strong></p>
<p>私有挂载是挂载的默认类型，与共享或从属挂载不同，它不接收或转发任何传播事件。要明确地将安装点标记为私有安装，请在shell提示符处输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-private mount_point</span><br></pre></td></tr></table></figure>
<p>或者，可以更改所选安装点的装载类型及其下的所有装入点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-rprivate mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个私有安装点</strong></p>
<p>假定共享挂载点先前是通过使用以下命令创建的<code>root</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount --<span class="built_in">bind</span> /media /media</span><br><span class="line">＃mount --make-shared /media</span><br><span class="line">＃mount --<span class="built_in">bind</span> /media /mnt</span><br></pre></td></tr></table></figure>
<p>要将该<code>/mnt/</code>目录标记为私有，请输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount --make-private /mnt</span><br></pre></td></tr></table></figure>
<p>现在可以确认没有内的坐骑<code>/media/</code>出现在<code>/mnt/</code>。例如，如果CD-ROM驱动器包含非空媒体并且该<code>/media/cdrom/</code>目录存在，请运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount /dev/cdrom /media/cdrom</span><br><span class="line"> ls /media/cdrom</span><br><span class="line">＃EFI GPL isolinux LiveOS〜</span><br><span class="line">＃ls /mnt/cdrom</span><br><span class="line">＃</span><br></pre></td></tr></table></figure>
<p>也可以验证安装在<code>/mnt/</code>目录中的文件系统没有被反映<code>/media/</code>。例如，如果<code>/dev/sdc1</code>插入了使用该设备的非空USB闪存驱动器并且该<code>/mnt/flashdisk/</code>目录存在，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount /dev/sdc1 /mnt/flashdisk</span><br><span class="line">＃ls /media/flashdisk</span><br><span class="line">＃ls /mnt/flashdisk</span><br><span class="line">en-US publican.cfg</span><br></pre></td></tr></table></figure>
<p><strong>不可绑定的挂载点</strong></p>
<p>为了防止给定的挂载点被复制，使用一个不可绑定的挂载点。要将安装点的类型更改为不可绑定安装，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-unbindable mount_point</span><br></pre></td></tr></table></figure>
<p>或者，可以更改所选安装点的装载类型及其下的所有装入点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --make-runbindable mount_point</span><br></pre></td></tr></table></figure>
<p><strong>创建一个不可绑定的挂载点</strong></p>
<p>要防止<code>/media/</code>共享目录<code>root</code>，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /media</span></span><br><span class="line"><span class="comment"># mount --make-unbindable /media</span></span><br></pre></td></tr></table></figure>
<p>这样，任何后续尝试重复此挂载将失败并出现错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount --bind /media /mnt</span></span><br><span class="line">mount: wrong fs <span class="built_in">type</span>, bad option, bad superblock on /media,</span><br><span class="line">missing codepage or helper program, or other error</span><br><span class="line">In some cases useful info is found <span class="keyword">in</span> syslog - try</span><br><span class="line">dmesg | tail  or so</span><br></pre></td></tr></table></figure>
<h3 id="移动一个挂载点"><a href="#移动一个挂载点" class="headerlink" title="移动一个挂载点"></a>移动一个挂载点</h3><p>要更改安装文件系统的目录，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount --move old_directory new_directory</span><br></pre></td></tr></table></figure>
<p><strong>移动现有的NFS挂载点</strong></p>
<p>一个NFS存储包含用户目录，并已被挂载<code>/mnt/userdirs/</code>。作为<code>root</code>，<code>/home</code>通过使用以下命令移动此安装点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount --move /mnt/userdirs /home</span><br></pre></td></tr></table></figure>
<p>要验证装入点已被移动，请列出两个目录的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ls /mnt/userdirs</span><br><span class="line"> ls /home</span><br><span class="line">jill joe</span><br></pre></td></tr></table></figure>
<h3 id="设置只读权限root"><a href="#设置只读权限root" class="headerlink" title="设置只读权限root"></a>设置只读权限<code>root</code></h3><p>有时，您需要以只读权限安装根文件系统。示例用例包括增强安全性或在系统意外断电后确保数据完整性。</p>
<h4 id="配置root为在引导时使用只读权限进行挂载"><a href="#配置root为在引导时使用只读权限进行挂载" class="headerlink" title="配置root为在引导时使用只读权限进行挂载"></a>配置<code>root</code>为在引导时使用只读权限进行挂载</h4><ol>
<li>在<code>/etc/sysconfig/readonly-root</code> 文件中, 更改 <code>READONLY</code> 为<code>yes</code>:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set to 'yes' to mount the system file systems read-only.</span></span><br><span class="line">READONLY=yes</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<ol>
<li>在 <code>/etc/fstab</code>文件的根条目(<code>/</code>)中将缺省值 <code>defaults</code> 更改为 <code>ro</code> ：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/mapper/luks-c376919e... / ext4 ro,x-systemd.device-timeout=0 1 1</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>/etc/default/grub</code>中，添加<code>ro</code> 到文件中的 <code>GRUB_CMDLINE_LINUX</code> 指令 并确保它不包含 <code>rw</code>:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"crashkernel=auto rd.lvm.lv=rhel/root rd.lvm.lv=rhel/swap rhgb quiet ro"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>重新创建 GRUB2 配置文件:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果需要在<code>tmpfs</code>文件系统中添加要以写入权限挂载的文件和目录，请在该<code>/etc/rwtab.d/</code>目录中创建一个文本文件，并将配置置于该文件中。例如，要<code>/etc/example/file</code>使用写入权限进行挂载，请将以下行添加到文件中：<code>/etc/rwtab.d/</code><em><code>example</code></em></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">files /etc/example/file</span><br></pre></td></tr></table></figure>
<p>对文件和目录所做的更改<code>tmpfs</code>不会保留在各个引导程序中.</p>
<ol>
<li>重启操作系统</li>
</ol>
<h3 id="root立即重新挂载"><a href="#root立即重新挂载" class="headerlink" title="root立即重新挂载"></a><code>root</code>立即重新挂载</h3><p>如果root（<code>/</code>）在系统引导时以只读权限挂载，则可以使用写入权限重新挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount -o remount,rw /</span><br></pre></td></tr></table></figure>
<p>要<code>/</code>使用只读权限重新装入，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o remount,ro /</span></span><br></pre></td></tr></table></figure>
<p>这个命令装载<em>整个</em> <code>/</code>只读权限。更好的方法是通过将某些文件和目录复制到RAM中来保留写入权限</p>
<h3 id="保留写权限的文件和目录"><a href="#保留写权限的文件和目录" class="headerlink" title="保留写权限的文件和目录"></a>保留写权限的文件和目录</h3><p>为了使系统正常工作，某些文件和目录需要保留写权限。root在只读模式下，它们被安装在<code>tmpfs</code>临时文件系统的RAM中。从<code>/etc/rwtab</code>文件读取这些文件和目录的默认设置，其中包含：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dirs</span>	/var/cache/man</span><br><span class="line"><span class="built_in">dirs</span>	/var/gdm</span><br><span class="line">[output truncated]</span><br><span class="line">empty	/tmp</span><br><span class="line">empty	/var/cache/foomatic</span><br><span class="line">[output truncated]</span><br><span class="line">files	/etc/adjtime</span><br><span class="line">files	/etc/ntp.conf</span><br><span class="line">[output truncated]</span><br></pre></td></tr></table></figure>
<p><code>/etc/rwtab</code>文件中的 条目遵循以下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">how the file or directory is copied to tmpfs       	path to the file or directory</span><br></pre></td></tr></table></figure>
<p>文件或目录可以通过<code>tmpfs</code>三种方式复制，因此有三种类型的条目：</p>
<ul>
<li><code>empty</code> <em><code>path</code></em>: 空的路径被复制到 <code>tmpfs</code>. 例如: <code>empty /tmp</code></li>
<li><code>dirs</code> <em><code>path</code></em>: 目录树被复制到 <code>tmpfs</code>, 为空. 例如: <code>dirs /var/run</code></li>
<li><code>files</code> <em><code>path</code></em>: 文件或目录被 <code>tmpfs</code> 完整复制. 例如: <code>files /etc/resolv.conf</code></li>
</ul>
<p>添加自定义路径时适用相同的格式<code>/etc/rwtab.d/</code>。</p>
<h2 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h2><p>要分离先前安装的文件系统，请使用以下任一种<code>umount</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount directory</span><br><span class="line">umount device</span><br></pre></td></tr></table></figure>
<p>当一个文件系统正在使用（例如，当一个进程正在读取这个文件系统上的一个文件，或者当它被内核使用的时候），运行这个<code>umount</code>命令将会失败并报错。要确定哪些进程正在访问文件系统，请使用<code>fuser</code>以下形式的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fuser -m directory</span><br></pre></td></tr></table></figure>
<p>例如，要列出正在访问挂载到<code>/media/cdrom/</code>目录的文件系统的进程，请键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fuser -m /media/cdrom</span><br><span class="line">/media/cdrom:         1793  2013  2022  2435 10532c 10672c</span><br></pre></td></tr></table></figure>
<p><strong> 卸载CD</strong></p>
<p>要卸载先前安装到该<code>/media/cdrom/</code>目录的CD，请在shell提示符处键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ umount /media/cdrom</span><br></pre></td></tr></table></figure>
<h1 id="VOLUME-KEY函数"><a href="#VOLUME-KEY函数" class="headerlink" title="VOLUME_KEY函数"></a>VOLUME_KEY函数</h1><p>volume_key 函数提供了两个工具， libvolume_key and <code>volume_key</code>. libvolume_key 是一个用于处理存储卷加密密钥并将其与卷分开存储的库。<code>volume_key</code>是一个相关的命令行工具，用于提取密钥和密码以恢复对加密硬盘的访问。</p>
<p>当主要用户忘记密钥和密码，员工突然离职后，或者在硬件或软件故障破坏加密卷的标题后提取数据时，这一点很有用。在公司设置中，IT帮助台可以<code>volume_key</code>在将计算机交付给最终用户之前用于备份加密密钥。</p>
<p>目前<code>volume_key</code>只支持LUKS卷加密格式。</p>
<h2 id="volume-key-命令"><a href="#volume-key-命令" class="headerlink" title="volume_key` 命令"></a>volume_key` 命令</h2><p> <code>volume_key</code> 格式是:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key [OPTION]... OPERAND</span><br></pre></td></tr></table></figure>
<p><code>volume_key</code>通过指定以下选项之一来确定 操作数和操作模式:</p>
<ul>
<li><p><code>--save</code></p>
<p>该命令期望操作数<em>卷</em> [ <em>包</em> ]。如果提供了<em>数据包，</em><code>volume_key</code>则会从中提取密钥和密码。如果没有提供<em>数据包</em>，<code>volume_key</code>则会从<em>卷中</em>提取密钥和密码，在必要时提示用户。这些密钥和密码将被存储在一个或多个输出数据包中。</p>
</li>
<li><p><code>--restore</code></p>
<p>该命令期望操作数<em>卷数据包</em>。然后，它会打开<em>音量</em>，并使用密钥和密码短语中的<em>数据包</em>，使<em>音量</em>再次访问，提示用户在必要时，例如允许用户输入新的密码，例如。</p>
</li>
<li><p><code>--setup-volume</code></p>
<p>该命令期望操作数 <em>volume packet name</em>. 然后打开 <em>volume</em> 并使用  <em>packet</em> t中的密钥和密码设置 <em>volume</em> 来解密数据 ，<em>name</em>.<em>Name</em> 是 dm-crypt volume的名称. 此操作是解密卷可用例如  <code>/dev/mapper/*name*</code>.此操作不会通过添加新的密码来永久性更改 <em>volume</em>  for example. 用户可以访问和修改解密卷，修改过程中的劵.</p>
</li>
<li><p><code>--reencrypt</code>, <code>--secrets</code>, and <code>--dump</code></p>
<p>这三个命令使用不同的输出方法执行类似的功能。他们每个都需要操作数<em>数据包</em>，每个都打开<em>数据包</em>，在必要时解密<em>数据包</em>。<code>--reencrypt</code>然后将信息存储在一个或多个新的输出分组中。<code>--secrets</code>输出<em>包中</em>包含的密钥和密码短语。<code>--dump</code>输出<em>数据包</em>的内容，尽管默认情况下不输出密钥和密码。这可以通过追加<code>--with-secrets</code>命令来改变。也可以通过使用<code>--unencrypted</code>命令转储数据包的未加密部分（如果有的话）。这不需要任何密码或私钥访问。</p>
</li>
</ul>
<p>每个这些可以附加以下选项：</p>
<ul>
<li><p><code>-o</code>, <code>--output</code> <em><code>packet</code></em></p>
<p>该命令将默认密钥或密码写入<em>数据包</em>。默认密钥或密码短语取决于音量格式。确保它不可能过期，并允许<code>--restore</code>恢复对卷的访问。</p>
</li>
<li><p><code>--output-format</code> <em><code>format</code></em></p>
<p>此命令对所有输出数据包使用指定的<em>格式</em>。目前，<em>格式</em>可以是以下之一：</p>
<ul>
<li><code>asymmetric</code>：使用CMS来加密整个数据包，并且需要一个证书</li>
<li><code>asymmetric_wrap_secret_only</code>：只包装秘密，或密钥和密码，并且需要证书</li>
<li><code>passphrase</code>：使用GPG加密整个数据包，并需要密码</li>
</ul>
</li>
<li><p><code>--create-random-passphrase</code> <em><code>packet</code></em></p>
<p>此命令会生成一个随机的字母数字密码，将其添加到<em>音量</em>（不影响其他密码），然后将此随机密码存储到<em>数据包中</em>。</p>
</li>
</ul>
<h2 id="使用VOLUME-KEY作为个人用户"><a href="#使用VOLUME-KEY作为个人用户" class="headerlink" title="使用VOLUME_KEY作为个人用户"></a>使用VOLUME_KEY作为个人用户</h2><p>作为个人用户，<code>volume_key</code>可以使用以下过程来保存加密密钥。</p>
<p>对于这个文件中的所有例子, <em><code>/path/to/volume</code></em>  是一个LUKS设备, 而不是其中包含的纯文本设备. <code>blkid -s</code> <em><code>type /path/to/volume</code></em> 应该报告 <em><code>type</code></em> <code>`=&quot;crypto_LUKS&quot;</code>.</p>
<p><strong>使用独立volume_key</strong></p>
<ol>
<li>运行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --save /path/to/volume -o escrow-packet</span><br></pre></td></tr></table></figure>
<p>   随后会出现提示，要求托管数据包密码来保护密钥。</p>
<ol>
<li>保存生成的<code>escrow-packet</code>文件，确保密码不会被遗忘。</li>
</ol>
<p>如果忘记密码短语，请使用保存的托管数据包恢复对数据的访问。</p>
<p><strong>使用托管数据包恢复对数据的访问</strong></p>
<ol>
<li><p>在<code>volume_key</code>可以运行的环境中启动系统，并且托管数据包可用（例如救援模式）。</p>
</li>
<li><p>运行：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --restore /path/to/volume escrow-packet</span><br></pre></td></tr></table></figure>
<p>在创建托管数据包时使用的托管数据包密码以及卷的新密码会显示提示。</p>
<ol>
<li>使用所选密码安装音量。</li>
</ol>
<p>要释放加密卷的LUKS标头中的密码槽，请使用该命令删除旧的，被遗忘的密码<code>cryptsetup luksKillSlot</code>。</p>
<h2 id="在较大的组织中使用VOLUME-KEY"><a href="#在较大的组织中使用VOLUME-KEY" class="headerlink" title="在较大的组织中使用VOLUME_KEY"></a>在较大的组织中使用VOLUME_KEY</h2><p>在一个更大的组织中，使用每个系统管理员都知道的单个密码并且为每个系统记录一个单独的密码是不切实际的和安全的风险。为了解决这个问题，<code>volume_key</code>可以使用非对称加密技术来减少知道在任何计算机上访问加密数据所需的密码的人数。</p>
<p>本节将介绍在保存加密密钥，如何保存加密密钥，恢复对卷的访问以及设置紧急密码之前所需的准备步骤。</p>
<h3 id="准备保存加密密钥"><a href="#准备保存加密密钥" class="headerlink" title="准备保存加密密钥"></a>准备保存加密密钥</h3><p>为了开始保存加密密钥，需要做一些准备。</p>
<p><strong>准备</strong></p>
<ol>
<li><p>创建一个X509证书/私人对.</p>
</li>
<li><p>指定值得信任的可信用户不要危及私钥。这些用户将能够解密托管数据包。</p>
</li>
<li><p>选择将使用哪些系统来解密托管数据包。在这些系统上，建立一个包含私钥的NSS数据库。</p>
<p>如果私钥没有在NSS数据库中创建，请按照下列步骤操作：</p>
<ul>
<li><p>将证书和私钥存储在一个<code>PKCS#12</code>文件中。</p>
</li>
<li><p>运行:</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certutil -d /the/nss/directory -N</span><br></pre></td></tr></table></figure>
<p>此时可以选择NSS数据库密码。每个NSS数据库可以有不同的密码，因此如果每个用户使用一个单独的NSS数据库，指定的用户不需要共享一个密码。</p>
<ul>
<li>运行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pk12util -d /the/nss/directory -i the-pkcs12-file</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将证书分发给任何安装系统或在现有系统上保存密钥的人员。</p>
</li>
<li><p>对于保存的专用密钥，请准备存储空间，以便通过机器和音量来查找。例如，这可以是一个简单的目录，每个机器有一个子目录，也可以是用于其他系统管理任务的数据库。</p>
</li>
</ol>
<h4 id="保存加密密钥"><a href="#保存加密密钥" class="headerlink" title="保存加密密钥"></a>保存加密密钥</h4><p>完成所需的准备工作后，现在可以使用以下步骤保存加密密钥。</p>
<p><strong>保存加密秘钥</strong></p>
<ol>
<li>运行:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --save /path/to/volume -c /path/to/cert escrow-packet</span><br></pre></td></tr></table></figure>
<ol>
<li>将生成的<code>escrow-packet</code>文件保存在准备好的存储中，将其与系统和卷相关联.</li>
</ol>
<p>这些步骤可以手动执行，或者作为系统安装的一部分编写脚本。</p>
<h3 id="恢复对卷的访问"><a href="#恢复对卷的访问" class="headerlink" title="恢复对卷的访问"></a>恢复对卷的访问</h3><p>加密密钥保存后，可以根据需要将访问权恢复到驱动程序。</p>
<p><strong>恢复对卷的访问</strong></p>
<ol>
<li><p>从数据包存储器获取卷的托管数据包，并将其发送给指定用户之一进行解密。</p>
</li>
<li><p>指定的用户运行：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --reencrypt -d /the/nss/directory escrow-packet-in -o escrow-packet-out</span><br></pre></td></tr></table></figure>
<p>   提供NSS数据库密码后，指定用户选择密码进行加密<code>escrow-packet-out</code>。该密码可以每次都不同，只有在密钥从指定用户移动到目标系统时才能保护密码。</p>
<ol>
<li><p><code>escrow-packet-out</code>从指定的用户 获取文件和密码。</p>
</li>
<li><p>在可运行的环境中启动目标系统，<code>volume_key</code>并使<code>escrow-packet-out</code>文件可用，例如在救援模式下。</p>
</li>
<li><p>运行:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --restore /path/to/volume escrow-packet-out</span><br></pre></td></tr></table></figure>
<p>将出现提示，指定用户选择的数据包密码以及该卷的新密码。</p>
<ol>
<li>使用所选的卷密码安装卷。</li>
</ol>
<p>例如，可以使用 <code>cryptsetup luksKillSlot</code>删除忘记的旧密码, 以释放加密卷的LUKS标头中的密码插槽。这是用命令完成的。<code>cryptsetup luksKillSlot</code> <em><code>device key-slot</code></em>.</p>
<h3 id="设置紧急密码"><a href="#设置紧急密码" class="headerlink" title="设置紧急密码"></a>设置紧急密码</h3><p>在某些情况下（如出差旅行），系统管理员直接与受影响的系统协作是不切实际的，但用户仍然需要访问其数据。在这种情况下，<code>volume_key</code>可以使用密码和加密密钥。</p>
<p>在系统安装过程中，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --save /path/to/volume -c /path/to/ert --create-random-passphrase passphrase-packet</span><br></pre></td></tr></table></figure>
<p>这将生成一个随机密码，将其添加到指定的卷，并将其存储到<em><code>passphrase-packet</code></em> 。也可以将选项<code>--create-random-passphrase</code>和<code>-o</code>选项组合在一起生成两个数据包。</p>
<p>如果用户忘记了密码，指定的用户运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">volume_key --secrets -d /your/nss/directory passphrase-packet</span><br></pre></td></tr></table></figure>
<p>这显示了随机密码。将此密码提供给最终用户。</p>
<h1 id="固态硬盘部署指南"><a href="#固态硬盘部署指南" class="headerlink" title="固态硬盘部署指南"></a>固态硬盘部署指南</h1><p><em>固态硬盘</em>（SSD）是使用NAND闪存芯片来持久存储数据的存储设备。这使得它们与上一代磁盘存储器不同，磁盘存储旋转磁盘中的数据。在SSD中，整个逻辑块地址（LBA）范围内的数据访问时间不变; 而使用旋转媒体的较旧的磁盘，跨越大地址范围的访问模式会招致成本。因此，SSD设备具有更好的延迟和吞吐量。</p>
<p>随着使用块的数量接近磁盘容量，性能下降。供应商对性能的影响程度差异很大。但是，所有设备都会经历一些降级。</p>
<p>为了解决退化问题，主机系统（例如，Linux内核）可以使用丢弃请求来通知存储器给定范围的块不再被使用。SSD可以使用这些信息来释放内部空间，使用空闲块进行磨损平衡。只有当存储广告支持存储协议（不管是ATA还是SCSI）时才会发放丢弃。丢弃请求使用特定于存储协议协商的丢弃命令发布到存储装置（<code>TRIM</code>用于ATA命令，和<code>WRITE SAME</code>与<code>UNMAP</code>一组，或<code>UNMAP</code>用于SCSI命令）。</p>
<p><code>discard</code>当满足以下两点时， 启用支持是最有用的：</p>
<ul>
<li>文件系统上的可用空间仍然可用。</li>
<li>底层存储设备上的大多数逻辑块已被写入。</li>
</ul>
<p>并非市场上所有的固态器件都有<code>discard</code>支持。要确定您的固态设备是否<code>discard</code>支持，请检查<code>/sys/block/sda/queue/discard_granularity</code>。</p>
<h2 id="部署注意事项"><a href="#部署注意事项" class="headerlink" title="部署注意事项"></a>部署注意事项</h2><p>由于SSD的内部布局和操作，最好在内部<em>擦除块边界</em>上对器件进行分区。如果SSD导出拓扑信息，红帽企业版Linux 7中的分区工具会选择合理的默认值。</p>
<p>然而，如果该设备不会<em>不</em>导出拓扑信息，红帽建议的第一个分区在1MB边界创建。</p>
<p>逻辑卷管理器（LVM），设备映射程序（DM）目标以及LVM使用支持丢弃的MD（软件RAID）目标。唯一不支持丢弃的DM目标是dm-snapshot，dm-crypt和dm-raid45。在Red Hat Enterprise Linux 6.1中添加了对dm-mirror的支持，从7.0开始，MD支持丢弃。</p>
<p>如果SSD不能<code>discard</code>正确处理，则在SSD上使用RAID级别5会导致性能低下。您可以在<code>raid456.conf</code>文件中或在GRUB2配置中设置放弃。有关说明，请参阅以下过程。</p>
<p><strong>在raid456.conf中设置放弃</strong></p>
<p>该<em>devices_handle_discard_safely</em>模块参数的设定中的<code>raid456</code>模块。要在<code>raid456.conf</code>文件中启用丢弃：</p>
<ol>
<li>确认您的硬件支持丢弃：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/disk-name/queue/discard_zeroes_data</span></span><br></pre></td></tr></table></figure>
<p>如果返回值是<code>1</code>，则支持丢弃。如果命令返回<code>0</code>，则RAID代码必须将磁盘清零，这需要更多的时间。</p>
<ol>
<li>创建该<code>/etc/modprobe.d/raid456.conf</code>文件，并包含以下行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">options raid456 devices_handle_discard_safely = Y</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用该<code>dracut -f</code>命令重建初始ramdisk（<code>initrd</code>）。</p>
</li>
<li><p>重新启动系统以使更改生效。</p>
</li>
</ol>
<p><strong>在GRUB2配置中设置放弃</strong></p>
<p>该<em>devices_handle_discard_safely</em>模块参数的设定中的<code>raid456</code>模块。要在GRUB2配置中启用丢弃，请执行以下操作：</p>
<ol>
<li>确认您的硬件支持丢弃：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/disk-name/queue/discard_zeroes_data</span></span><br></pre></td></tr></table></figure>
<p>   如果返回值是<code>1</code>，则支持丢弃。如果命令返回<code>0</code>，则RAID代码必须将磁盘清零，这需要更多的时间。</p>
<ol>
<li>将以下行添加到<code>/etc/default/grub</code>文件中：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">raid456.devices_handle_discard_safely = Y</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在具有BIOS固件的系统和具有UEFI的系统上，GRUB2配置文件的位置不同。使用以下命令之一重新创建GRUB2配置文件。</p>
<ul>
<li>在具有BIOS固件的系统上，使用：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在具有UEFI固件的系统上，使用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</span></span><br></pre></td></tr></table></figure>
<ol>
<li>重新启动系统以使更改生效。</li>
</ol>
<p><strong>注意</strong></p>
<p>在红帽企业版Linux 7中，只有ext4和XFS文件系统完全支持丢弃。</p>
<p>在Red Hat Enterprise Linux 6.3及更早版本中，只有ext4文件系统完全支持丢弃。从红帽企业版Linux 6.4开始，ext4和XFS文件系统完全支持丢弃。要在设备上启用丢弃命令，请使用<code>discard</code>该<code>mount</code>命令的选项。例如，安装<code>/dev/sda2</code>到<code>/mnt</code>与丢弃启用，使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -t ext4 -o discard /dev/sda2 /mnt</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，ext4不会发出<code>discard</code>命令，主要是避免可能无法正确执行丢弃的设备上的问题。Linux <code>swap</code>代码发出<code>discard</code>命令丢弃启用设备，并没有选项来控制这种行为。</p>
<h1 id="写障碍"><a href="#写障碍" class="headerlink" title="写障碍"></a>写障碍</h1><p>一个<em>写屏障</em>是用来确保文件系统元数据被正确地写入，并下令永久存储内核机制，即使与性写高速缓存存储设备断电。启用了写入屏障的文件系统还确保通过传输的数据<code>fsync()</code>在整个功率损耗期间保持不变。</p>
<p>启用写入障碍会对某些应用程序造成显着的性能损失。特别是，<code>fsync()</code>大量使用或者创建和删除很多小文件的应用程序可能运行速度要慢得多。</p>
<h2 id="写障碍的重要性"><a href="#写障碍的重要性" class="headerlink" title="写障碍的重要性"></a>写障碍的重要性</h2><p>文件系统非常谨慎地安全地更新元数据，确保一致性。已记录的文件系统将元数据更新绑定到事务中，并按以下方式将其发送到永久存储：</p>
<ol>
<li>首先，文件系统将事务主体发送给存储设备。</li>
<li>然后，文件系统发送一个提交块。</li>
<li>如果将事务及其相应的提交块写入磁盘，则文件系统假定事务将在任何电源故障之后存活。</li>
</ol>
<p>但是，对于具有额外缓存的存储设备，断电期间的文件系统完整性会变得更加复杂。存储目标设备（如本地S-ATA或SAS驱动器）的写入缓存范围可以从32MB到64MB（使用现代驱动器）。硬件RAID控制器通常包含内部写入缓存。而且，高端阵列（如NetApp，IBM，Hitachi和EMC等）也拥有大量缓存。</p>
<p>当数据处于缓存时，具有写入缓存的存储设备将I / O报告为“完成”; 如果缓存失去能力，它也会丢失数据。更糟糕的是，当缓存取消暂存到永久性存储时，它可能会更改原始的元数据排序。发生这种情况时，提交块可能存在于磁盘上，而没有完整的关联事务。结果，日志可能会在断电恢复期间将这些未初始化的事务块重放到文件系统中; 这将导致数据不一致和腐败。</p>
<h2 id="如何写障碍的工作"><a href="#如何写障碍的工作" class="headerlink" title="如何写障碍的工作"></a>如何写障碍的工作</h2><p>写入障碍在Linux内核中通过在I / O之前和之后的存储写入缓存刷新来实现，这对<em>订单来说至关重要</em>。事务写入后，刷新存储缓存，写入提交块，并重新刷新缓存。这确保：</p>
<ul>
<li>该磁盘包含所有的数据。</li>
<li>没有重新排序发生。</li>
</ul>
<p>启用屏障后，<code>fsync()</code>调用也将发出存储缓存刷新。这可以确保文件数据在磁盘上保留，即使在<code>fsync()</code>返回后不久也会发生掉电。</p>
<h2 id="启用-禁用写障碍"><a href="#启用-禁用写障碍" class="headerlink" title="启用/禁用写障碍"></a>启用/禁用写障碍</h2><p>为了降低掉电时数据损坏的风险，一些存储设备使用电池供电的写缓存。通常，高端阵列和一些硬件控制器使用电池供电的写入缓存。但是，由于内核不可见缓存的波动性，红帽企业版Linux 7默认在所有支持的日志文件系统上启用了写障碍。</p>
<p><strong>注意</strong></p>
<p>写高速缓存旨在提高I / O性能。但是，启用写屏障意味着不断刷新这些缓存，这会显着降低性能。</p>
<p>对于具有非易失性，电池支持的写入缓存和禁止写入缓存的设备，可以使用<code>-o nobarrier</code>选项在安装时安全地禁用写入屏障<code>mount</code>。但是，有些设备不支持写入屏障; 这些设备将记录一条错误消息<code>/var/log/messages</code></p>
<p><strong>为每个文件系统写入屏障错误消息</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件系统</th>
<th>错误信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXT3 / EXT4</td>
<td><code>JBD: barrier-based sync failed on *device* - disabling barriers</code></td>
</tr>
<tr>
<td>XFS</td>
<td><code>Filesystem *device* - Disabling barriers, trial barrier write failed</code></td>
</tr>
<tr>
<td>BTRFS</td>
<td><code>btrfs: disabling barriers on dev *device*</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="写入障碍注意事项"><a href="#写入障碍注意事项" class="headerlink" title="写入障碍注意事项"></a>写入障碍注意事项</h2><p>一些系统配置不需要写入屏障来保护数据。在大多数情况下，其他方法比写障碍更好，因为写障碍会导致显着的性能损失。</p>
<h3 id="禁用写入缓存"><a href="#禁用写入缓存" class="headerlink" title="禁用写入缓存"></a>禁用写入缓存</h3><p>避免数据完整性问题的一种方法是确保写入缓存在电源故障时不会丢失数据。如果可能的话，配置这个的最好方法是简单地禁用写缓存。在具有一个或多个SATA驱动器的简单服务器或台式机（不包括本地SATA控制器Intel AHCI部分）上，可以使用以下<code>hdparm</code>命令禁用目标SATA驱动器上的写入缓存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃hdparm -W0 / device /</span><br></pre></td></tr></table></figure>
<h3 id="电池支持的写入缓存"><a href="#电池支持的写入缓存" class="headerlink" title="电池支持的写入缓存"></a>电池支持的写入缓存</h3><p>只要系统使用硬件RAID控制器和带有电池供电的写缓存，写屏障也是不必要的。如果系统配备了这样的控制器，并且如果其组件驱动器禁止了写入缓存，则控制器将宣告自己为直写式缓存; 这将通知内核写入缓存数据将在掉电时存活。</p>
<p>大多数控制器使用特定于供应商的工具来查询和操作目标驱动器。例如，LSI Megaraid SAS控制器使用电池支持的写入缓存; 这种类型的控制器需要该<code>MegaCli64</code>工具来管理目标驱动器。要显示LSI Megaraid SAS所有后端驱动器的状态，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃MegaCli64 -LDGetProp -DskCache -LAll -aALL</span><br></pre></td></tr></table></figure>
<p>要禁用LSI Megaraid SAS所有后端驱动器的写缓存，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃MegaCli64 -LDSetProp -DisDskCache -Lall -aALL</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>硬件RAID卡在系统运行时为电池充电。如果系统长时间关闭电源，电池将会失去充电功能，在电源出现故障时，储存的数据会变得易受攻击。</p>
<h3 id="高端数组"><a href="#高端数组" class="headerlink" title="高端数组"></a>高端数组</h3><p>高端阵列在发生电源故障时有多种保护数据的方式。因此，不需要验证外部RAID存储器中的内部驱动器的状态。</p>
<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>NFS客户端不需要启用写入障碍，因为数据完整性是由NFS服务器端处理的。因此，应该配置NFS服务器以确保在整个电力损失期间（无论是通过编写屏障还是通过其他方式）数据持久化。</p>
<h1 id="存储I-O对齐和大小"><a href="#存储I-O对齐和大小" class="headerlink" title="存储I/O对齐和大小"></a>存储I/O对齐和大小</h1><p>最近对SCSI和ATA标准的增强允许存储设备指示其首选（并且在某些情况下是所需的）<em>I/O对齐</em>和<em>I/O大小</em>。此信息对于较新的磁盘驱动器特别有用，可将物理扇区大小从512字节增加到4k字节。此信息对于RAID设备也可能是有益的，其中块大小和条带大小可能会影响性能。</p>
<p>在Linux I/O栈已经增强处理供应商提供的 I/O 对齐和 I/O 大小信息, 从而允许存储管理工具 (<code>parted</code>, <code>lvm</code>, <code>mkfs.*</code>, 等等) 以优化数据放置和访问。如果传统设备不能导出I / O对齐和大小数据，那么红帽企业版Linux 7中的存储管理工具将在4k（或2的更大幂）边界上保守地对齐I / O。这将确保4k扇区设备即使没有指示任何所需的/首选的I / O对齐和尺寸，也能正常工作.</p>
<p>红帽企业版Linux 7的IO调度程序已更改。默认IO调度程序现在是<em>截止日期</em>，SATA驱动器除外。CFQ是SATA驱动器的默认IO调度程序。为了更快速的存储，截止日期优于CFQ，并且在使用时可以提高性能，而不需要特殊的调整。</p>
<p>如果某些磁盘（例如SAS旋转磁盘）的默认值不正确，则将IO调度程序更改为CFQ。这个实例将取决于工作量。</p>
<h2 id="存储访问参数"><a href="#存储访问参数" class="headerlink" title="存储访问参数"></a>存储访问参数</h2><p>操作系统使用以下信息来确定I/O对齐和大小：</p>
<ul>
<li><p>physical_block_size</p>
<p>设备可以运行的最小的内部单元</p>
</li>
<li><p>logical_block_size</p>
<p>用于外部寻址设备上的某个位置</p>
</li>
<li><p>alignment_offset</p>
<p>Linux块设备(partition/MD/LVM device)开始的字节数与基础物理对齐偏移量</p>
</li>
<li><p>minimum_io_size</p>
<p>该设备的首选最小单位为随机I/O</p>
</li>
<li><p>optimal_io_size</p>
<p>该设备的流式 I/O的首选单位</p>
</li>
</ul>
<p>例如，某些4K扇区设备可能会在<code>physical_block_size</code>内部使用4K，但会<code>logical_block_size</code>向Linux发布更细粒度的512字节。这种差异引起了I/O错位的可能性。为了解决这个问题，红帽企业Linux 7 I/O堆栈将尝试启动自然对齐的边界上的所有数据区域（<code>physical_block_size</code>），如果块设备的开始偏离底层物理，确保它占到任何alignment_offset对准。</p>
<p>存储供应商还可以提供有关设备的随机 *I/O 和流 I/O (<code>minimum_io_size</code>) 的首选最小单位的 I/O (<code>optimal_io_size</code>) . 例如, <code>minimum_io_size</code> 和 <code>optimal_io_size</code> 可能分别对应于RAID设备的块大小和条带大小.</p>
<h2 id="用户空间访问"><a href="#用户空间访问" class="headerlink" title="用户空间访问"></a>用户空间访问</h2><p>始终注意使用正确对齐和大小的I/O。这对于直接I/O访问尤为重要。直接I/O应该在一个<code>logical_block_size</code>边界上对齐，并在多个边界上对齐<code>logical_block_size</code>。</p>
<p>对于原生4K设备（即<code>logical_block_size</code>是4K），应用程序执行多个设备的直接I/O现在至关重要<code>logical_block_size</code>。这意味着应用程序将会失败，原生4k设备执行512字节对齐的I/O而不是4k对齐的I/O。</p>
<p>为避免这种情况，应用程序应该查询设备的I/O参数，以确保使用正确的I/O对齐和大小。如前所述，I/O参数通过两个<code>sysfs</code>和块设备<code>ioctl</code>接口公开。</p>
<p>有关更多详细信息，请参阅<code>man libblkid</code>。该<code>man</code>页面由<code>libblkid-devel</code>软件包提供。</p>
<h3 id="sysfs-Interface"><a href="#sysfs-Interface" class="headerlink" title="sysfs Interface"></a>sysfs Interface</h3><ul>
<li><p>/sys/block/<em><code>disk</code></em>/alignment_offset</p>
<p>或者</p>
<p>/sys/block/<em><code>disk</code></em><code>/</code><em><code>partition</code></em> /alignment_offset</p>
<p>​</p>
<p>文件位置取决于磁盘是物理磁盘（是本地磁盘，本地RAID还是多路径LUN）还是虚拟磁盘。第一个文件位置适用于物理磁盘，而第二个文件位置适用于虚拟磁盘。这是因为virtio-blk将始终报告分区的对齐值。物理磁盘可能会或可能不会报告对齐值。</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/physical_block_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/logical_block_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/minimum_io_size</p>
</li>
<li><p>/sys/block/<code>*disk*</code>/queue/optimal_io_size</p>
</li>
</ul>
<p>内核仍将<code>sysfs</code>为不提供I / O参数信息的“传统”设备导出这些属性，例如：</p>
<p><strong>sysfs Interface</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alignment_offset:    0</span><br><span class="line">physical_block_size: 512</span><br><span class="line">logical_block_size:  512</span><br><span class="line">minimum_io_size:     512</span><br><span class="line">optimal_io_size:     0</span><br></pre></td></tr></table></figure>
<h2 id="Block-Device-ioctls块设备ioctls"><a href="#Block-Device-ioctls块设备ioctls" class="headerlink" title="Block Device ioctls块设备ioctls"></a>Block Device ioctls块设备ioctls</h2><ul>
<li><code>BLKALIGNOFF</code>: <code>alignment_offset</code></li>
<li><code>BLKPBSZGET</code>: <code>physical_block_size</code></li>
<li><code>BLKSSZGET</code>: <code>logical_block_size</code></li>
<li><code>BLKIOMIN</code>: <code>minimum_io_size</code></li>
<li><code>BLKIOOPT</code>: <code>optimal_io_size</code></li>
</ul>
<h2 id="I-O标准"><a href="#I-O标准" class="headerlink" title="I/O标准"></a>I/O标准</h2><p>本节介绍ATA和SCSI设备使用的I/O标准。</p>
<h3 id="ATA"><a href="#ATA" class="headerlink" title="ATA"></a>ATA</h3><p>ATA设备必须通过<code>IDENTIFY DEVICE</code>命令报告适当的信息。ATA设备只报告I / O参数<code>physical_block_size</code>，<code>logical_block_size</code>和<code>alignment_offset</code>。额外的I / O提示超出了ATA命令集的范围。</p>
<h3 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h3><p>红帽企业版Linux 7中的I / O参数支持至少需要<em>版本3</em>的<em>SCSI主命令</em>（SPC-3）协议。内核只会发送一个<em>扩展查询</em>（可以访问该<code>BLOCK LIMITS VPD</code>页面），并<code>READ CAPACITY(16)</code>命令那些声称符合SPC-3的设备。</p>
<p>该<code>READ CAPACITY(16)</code>命令提供块大小和对齐偏移：</p>
<ul>
<li><code>LOGICAL BLOCK LENGTH IN BYTES</code> 被用来派生 <code>/sys/block/*disk*/queue/physical_block_size</code></li>
<li><code>LOGICAL BLOCKS PER PHYSICAL BLOCK EXPONENT</code> 被用来派生 <code>/sys/block/*disk*/queue/logical_block_size</code></li>
<li><code>LOWEST ALIGNED LOGICAL BLOCK ADDRESS</code> 用来派生：<ul>
<li><code>/sys/block/*disk*/alignment_offset</code></li>
<li><code>/sys/block/*disk*/*partition*/alignment_offset</code></li>
</ul>
</li>
</ul>
<p>该<code>BLOCK LIMITS VPD</code>页面（<code>0xb0</code>）提供了I/O提示。它也使用<code>OPTIMAL TRANSFER LENGTH GRANULARITY</code>并<code>OPTIMAL TRANSFER LENGTH</code>导出：</p>
<ul>
<li><code>/sys/block/*disk*/queue/minimum_io_size</code></li>
<li><code>/sys/block/*disk*/queue/optimal_io_size</code></li>
</ul>
<p>该<code>sg3_utils</code>软件包提供了<code>sg_inq</code>可用于访问该<code>BLOCK LIMITS VPD</code>页面的实用程序。为此，请运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sg_inq -p 0xb0 disk</span></span><br></pre></td></tr></table></figure>
<h2 id="堆叠I-O参数"><a href="#堆叠I-O参数" class="headerlink" title="堆叠I/O参数"></a>堆叠I/O参数</h2><p>Linux I/O堆栈的所有层都被设计为将各种I/O参数传播到堆栈中。当一个图层消耗一个属性或聚合很多设备时，该图层必须公开适当的I/O参数，以便上层设备或工具在转换后可以准确查看存储。一些实际的例子是：</p>
<ul>
<li>I/O堆栈中只有一层应该调整为非零值<code>alignment_offset</code>; 一旦相应地调整一层，它将输出一个<code>alignment_offset</code>零的设备。</li>
<li>使用LVM创建的条纹设备映射（DM）设备必须导出<code>minimum_io_size</code>并<code>optimal_io_size</code>相对于所述条纹计数（盘数）和用户提供的块大小。</li>
</ul>
<p>在红帽企业版Linux 7中，Device Mapper和Software Raid（MD）设备驱动程序可以用来任意组合具有不同I / O参数的设备。内核的块层将尝试合理地组合各个设备的I / O参数。内核不会阻止组合异构设备; 但是，请注意与此相关的风险。</p>
<p>例如，一个512字节的设备和一个4K设备可以组合成一个逻辑DM设备，其具有<code>logical_block_size</code>4K的。分布在这种混合设备上的文件系统假设4K将被原子写入，但实际上，当发送到512字节的设备时，它将跨越8个逻辑块地址。<code>logical_block_size</code>如果系统崩溃，则使用4K 更高级DM设备可能会增加对512字节设备的部分写入的可能性。</p>
<p>如果组合多个设备的I/O参数导致冲突，则块层可以发出设备容易受到部分写入和/或未对准的警告。</p>
<h2 id="逻辑卷管理器"><a href="#逻辑卷管理器" class="headerlink" title="逻辑卷管理器"></a>逻辑卷管理器</h2><p>LVM提供用于管理内核DM设备的用户空间工具。LVM将移动数据区的开始（给定的DM设备将使用）来说明<code>alignment_offset</code>与由LVM管理的任何设备相关的非零值。这意味着逻辑卷将正确对齐（<code>alignment_offset=0</code>）。</p>
<p>默认情况下，LVM将调整为任何<code>alignment_offset</code>，但是可以通过设置<code>data_alignment_offset_detection</code>为<code>0</code>in 来禁用此行为<code>/etc/lvm/lvm.conf</code>。不建议禁用此功能。</p>
<p>LVM还将检测设备的I/O提示。设备数据区域的开始将是sysfs中的一个倍数<code>minimum_io_size</code>或<code>optimal_io_size</code>暴露的数量。LVM将使用<code>minimum_io_size</code>if <code>optimal_io_size</code>是未定义的（即<code>0</code>）。</p>
<p>默认情况下，LVM将自动确定这些I/O提示，但是可以通过设置<code>data_alignment_detection</code>为<code>0</code>in 来禁用此行为<code>/etc/lvm/lvm.conf</code>。不建议禁用此功能。</p>
<h2 id="分区和文件系统工具"><a href="#分区和文件系统工具" class="headerlink" title="分区和文件系统工具"></a>分区和文件系统工具</h2><p>本节介绍不同的分区和文件系统管理工具如何与设备的I/O参数进行交互。</p>
<h3 id="util-linux-ng的libblkid和fdisk"><a href="#util-linux-ng的libblkid和fdisk" class="headerlink" title="util-linux-ng的libblkid和fdisk"></a>util-linux-ng的libblkid和fdisk</h3><p>在<code>libblkid</code>设置有库<code>util-linux-ng</code>包包括一个编程API来访问设备的I/O参数。<code>libblkid</code>允许应用程序（尤其是使用Direct I/O的应用程序）正确调整I/O请求的大小。在<code>fdisk</code>从公用<code>util-linux-ng</code>的用途<code>libblkid</code>来确定用于所有分区的最佳放置的设备的I/O参数。该<code>fdisk</code>实用程序将对齐1MB边界上的所有分区。</p>
<h2 id="分开和libparted"><a href="#分开和libparted" class="headerlink" title="分开和libparted"></a>分开和libparted</h2><p>该<code>libparted</code>库<code>parted</code>也使用I/O参数API <code>libblkid</code>。红帽企业Linux 7安装程序（<strong>Anaconda</strong>）使用<code>libparted</code>，这意味着由安装程序创建的所有分区或<code>parted</code>将被正确对齐。对于似乎不提供I/O参数的设备上创建的所有分区，默认对齐将为1MB。</p>
<p>启发式<code>parted</code>使用如下：</p>
<ul>
<li><p>始终使用报告<code>alignment_offset</code>作为第一个主分区启动的偏移量。</p>
</li>
<li><p>如果<code>optimal_io_size</code>定义（即不是<code>0</code>），则对齐<code>optimal_io_size</code>边界上的所有分区。</p>
</li>
<li><p>如果<code>optimal_io_size</code>是未定义的（即<code>0</code>），<code>alignment_offset</code>是<code>0</code>和<code>minimum_io_size</code>是2的幂，使用默认1MB对准。</p>
<p>对于那些看似不提供I / O提示的“传统”设备来说，这是最好的办法。因此，默认情况下，所有分区将在1MB边界上对齐。</p>
<hr>
<p>红帽企业版Linux 7无法区分不提供I/O提示的设备，以及使用<code>alignment_offset=0</code>和提供此功能的设备<code>optimal_io_size=0</code>。这样的设备可能是一个单一的SAS 4K设备; 因此，在磁盘启动时，最坏的情况是1MB的空间丢失。</p>
</li>
</ul>
<h3 id="文件系统工具"><a href="#文件系统工具" class="headerlink" title="文件系统工具"></a>文件系统工具</h3><p>不同的 <code>mkfs.*filesystem*</code>实用程序也被增强以消耗设备的I/O参数. 这些实用程序将不允许将文件系统格式化为使用<code>logical_block_size</code>小于底层存储设备的块大小 </p>
<p>除了 <code>mkfs.gfs2</code>, 所有 <code>mkfs.*filesystem*</code> 实用程序还使用  I/O 提示布局相对于<code>minimum_io_size</code> 磁盘上的数据结构和数据区<code>optimal_io_size</code> 和底层存储设备 ,这使得文件系统可以针对各种RAID（条纹）布局进行最佳格式化。</p>
<h1 id="远程无盘系统"><a href="#远程无盘系统" class="headerlink" title="远程无盘系统"></a>远程无盘系统</h1><p>要设置通过PXE引导的基本远程无盘系统，需要以下软件包：</p>
<ul>
<li><p><code>tftp-server</code></p>
</li>
<li><p><code>xinetd</code></p>
</li>
<li><p><code>dhcp</code></p>
</li>
<li><p><code>syslinux</code></p>
</li>
<li><p><code>dracut-network</code></p>
<p><strong>注意</strong></p>
<p>安装<code>dracut-network</code>包后，将以下行添加到<code>/etc/dracut.conf</code>：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_dracutmodules+=<span class="string">"nfs"</span></span><br></pre></td></tr></table></figure>
<p>远程无盘系统启动需要<code>tftp</code>服务（由提供<code>tftp-server</code>）和DHCP服务（由提供<code>dhcp</code>）。该<code>tftp</code>服务用于<code>initrd</code>通过PXE加载程序检索内核映像并通过网络进行检索。</p>
<p>SELinux仅支持NFSv4.2。要使用SELinux，必须<code>/etc/sysconfig/nfs</code>通过添加以下行来显式启用NFS ：</p>
<p><code>RPCNFSDARGS=&quot;-V 4.2&quot;</code></p>
<p>然后,在<code>/var/lib/tftpboot/pxelinux.cfg/default</code>, 更改 <code>root=nfs:server-ip:/exported/root/directory</code>为 <code>root=nfs:server-ip:/exported/root/directory,vers=4.2</code>.</p>
<p>最后，重新启动NFS服务器。</p>
<p>以下各节概述了在网络环境中部署远程无盘系统的必要步骤。</p>
<p>些RPM软件包已经开始使用文件功能（比如<code>setcap</code>和<code>getcap</code>）。但是，NFS目前不支持这些，所以试图安装或更新任何使用文件功能的软件包将会失败。</p>
<h2 id="为无盘客户机配置tftp服务"><a href="#为无盘客户机配置tftp服务" class="headerlink" title="为无盘客户机配置tftp服务"></a>为无盘客户机配置tftp服务</h2><p>该<code>tftp</code>服务默认是禁用的。要启用它并允许通过网络启动PXE，请将该<code>Disabled</code>选项设置<code>/etc/xinetd.d/tftp</code>为<code>no</code>。要进行配置<code>tftp</code>，请执行以下步骤：</p>
<p><strong>配置<code>tftp</code></strong></p>
<ol>
<li><p><code>tftp</code>根目录 (<code>chroot</code>) 位于 <code>/var/lib/tftpboot</code>. 复制 <code>/usr/share/syslinux/pxelinux.0</code>到<code>/var/lib/tftpboot/</code>, 例如:</p>
<p><code>cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/</code></p>
</li>
<li><p>在tftp根目录下创建目录 <code>pxelinux.cfg</code> :</p>
<p><code>mkdir -p /var/lib/tftpboot/pxelinux.cfg/</code></p>
</li>
</ol>
<p>还需要正确配置防火墙规则以允许<code>tftp</code>通信; 作为<code>tftp</code>对TCP封装器的支持，你可以配置主机对<code>tftp</code>via的访问<code>/etc/hosts.allow</code></p>
<h2 id="为无盘客户机配置DHCP"><a href="#为无盘客户机配置DHCP" class="headerlink" title="为无盘客户机配置DHCP"></a>为无盘客户机配置DHCP</h2><p>配置好<code>tftp</code>服务器后，需要在同一台主机上设置DHCP服务。有关如何设置DHCP服务器的说明，请参阅“Red Hat Enterprise Linux 7 <em>部署指南”</em>。另外，您应该在DHCP服务器上启用PXE引导; 为此，请将以下配置添加到<code>/etc/dhcp/dhcp.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">allow booting;</span><br><span class="line">allow bootp;</span><br><span class="line">class <span class="string">"pxeclients"</span> &#123;</span><br><span class="line">   match <span class="keyword">if</span> substring(option vendor-class-identifier, 0, 9) = <span class="string">"PXEClient"</span>;</span><br><span class="line">   next-server server-ip;</span><br><span class="line">   filename <span class="string">"pxelinux.0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换<code>*server-ip*</code>为<code>tftp</code>DHCP服务所在主机的IP地址。现在，<code>tftp</code>配置了DHCP，剩下的就是配置NFS和导出的文件系统。</p>
<h2 id="为无盘客户机配置导出的文件系统"><a href="#为无盘客户机配置导出的文件系统" class="headerlink" title="为无盘客户机配置导出的文件系统"></a>为无盘客户机配置导出的文件系统</h2><p>导出文件系统的根目录（由网络中的无盘客户机使用）通过NFS共享。配置NFS服务以将其添加到根目录<code>/etc/exports</code></p>
<p>为了适应完全无盘的客户端，根目录应该包含完整的红帽企业Linux安装。您可以通过以下方式将其与正在运行的系统<code>rsync</code>同步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃rsync -a -e ssh --exclude =<span class="string">'/ proc / *'</span>--exclude =<span class="string">'/ sys / *'</span> hostname.com：/ / exported / root / directory</span><br></pre></td></tr></table></figure>
<p>替换为要<em><code>hostname.com</code></em>与之同步的正在运行的系统的主机名<code>rsync</code>。<em><code>/exported/root/directory</code></em>是导出文件系统的路径。</p>
<p>另外，您还可以使用<code>yum</code>与<code>--installroot</code>选项来安装Red Hat Enterprise Linux的特定位置。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum groupinstall Base --installroot=/exported/root/directory --releasever=/</span><br></pre></td></tr></table></figure>
<p>要导出的文件系统在无盘客户机可以使用之前，仍然需要进一步配置。为此，请执行以下步骤：</p>
<p><strong>配置文件系统</strong></p>
<ol>
<li>配置导出的文件系统<code>/etc/fstab</code>包含（至少）以下配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">none		/tmp		tmpfs	defaults	0 0</span><br><span class="line">tmpfs		/dev/shm	tmpfs	defaults	0 0</span><br><span class="line">sysfs		/sys		sysfs	defaults	0 0</span><br><span class="line">proc		/proc		proc 	defaults	0 0</span><br></pre></td></tr></table></figure>
<ol>
<li><p>选择无盘客户机应该使用的内核 (<code>vmlinuz-*kernel-version*</code>) 并将其复制到</p>
<p><code>tftp</code>启动目录:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /boot/vmlinuz-kernel-version /var/lib/tftpboot/</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建 <code>initrd</code> (即, <code>initramfs-kernel-version.img</code>) 与网络支持:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dracut initramfs-kernel-version.img kernel-version</span></span><br></pre></td></tr></table></figure>
<ol>
<li>initrd的文件权限需要更改为600或<code>pxelinux.0</code>引导加载程序将失败，并出现“文件未找到”错误。使用以下命令执行此操作:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod go-r initramfs-kernel-version.img</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>将结果复制到引导目录中<code>initramfs-kernel-version.img到</code> tftp启动目录.</p>
</li>
<li><p>编辑默认的启动配置以使用<code>initrd</code>里面的内核<code>/var/lib/tftpboot</code>。此配置应该指示无盘客户机的root用户将导出的文件系统（<code>/exported/root/directory</code>）挂载为读写。为此，请<code>/var/lib/tftpboot/pxelinux.cfg/default</code>使用以下配置：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default rhel7</span><br><span class="line"></span><br><span class="line">label rhel7</span><br><span class="line">  kernel vmlinuz-kernel-version</span><br><span class="line">  append initrd=initramfs-kernel-version.img root=nfs:server-ip:/exported/root/directory rw</span><br></pre></td></tr></table></figure>
<p>   替换 <code>server-ip</code> 为<code>tftp</code> and DHCP 服务器地址.</p>
<p>NFS共享现在已准备好导出到无盘客户端。这些客户端可以通过PXE通过网络启动。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统管理</title>
    <url>/2017/12/10/Linux/storage/filesystem/</url>
    <content><![CDATA[<p>文件系统部分提供了有关文件系统结构和维护，Btrfs技术预览以及Red Hat完全支持的文件系统的信息:: ext3, ext4, GFS2, XFS, NFS, and FS-Cache.</p>
<p><strong>Note</strong></p>
<p>Btrfs is available as a Technology Preview feature in Red Hat Enterprise Linux 7 but has been deprecated since the Red Hat Enterprise Linux 7.4 release. It will be removed in a future major release of Red Hat Enterprise Linux.</p>
<p>XFS is the default file system in Red Hat Enterprise Linux 7 and Red Hat, and Red Hat recommends you to use XFS unless you have a strong reason to use another file system.<br><a id="more"></a></p>
<h1 id="文件系统的结构和维护"><a href="#文件系统的结构和维护" class="headerlink" title="文件系统的结构和维护"></a>文件系统的结构和维护</h1><p>文件系统结构是操作系统中最基本的组织结构。操作系统与用户，应用程序和安全模型的交互方式几乎总是取决于操作系统如何组织存储设备上的文件。提供通用的文件系统结构，确保用户和程序可以访问和写入文件。</p>
<p>文件系统将文件分解成两个逻辑类别：</p>
<ul>
<li>共享 vs.非共享</li>
<li>变量 vs. 静态文件</li>
</ul>
<p><em>可共享</em> 文件 可以在本地访问，也可以由远程主机访问; <em>非共享</em> 文件只可本地使用。<em>变量</em>文件, 例如文档, 可随时更改; 如果没有系统管理员的操作； <em>静态</em> 文件,  (例如二进制文件),不会更改。</p>
<p>以这种方式分类文件有助于将每个文件的功能与分配给保存它们的目录的权限相关联。操作系统及其用户如何与文件进行交互，可以确定放置文件的目录，该目录是以只读还是读/写权限挂载，以及每个用户对该文件的访问级别。这个组织的最高层至关重要; 可以限制对底层目录的访问，否则如果从顶层向下访问规则不遵守严格的结构，则可能会出现安全问题。</p>
<h2 id="文件系统层次结构标准（FHS）概述"><a href="#文件系统层次结构标准（FHS）概述" class="headerlink" title="文件系统层次结构标准（FHS）概述"></a>文件系统层次结构标准（FHS）概述</h2><p>Linux 使用  <em>文件系统层次结构标准</em> (<em>FHS</em>) 文件系统结构, 它定义了许多文件类型和目录的名称，位置和权限.</p>
<p>FHS文档是对任何符合FHS的文件系统的权威参考，但该标准留下了许多未定义或可扩展的区域。本节概述了标准未涉及的文件系统部分的标准和描述。</p>
<p>FHS合规性的两个最重要的要素是:</p>
<ul>
<li>与其他符合FHS的系统兼容</li>
<li>能够将 <code>/usr/</code> 分区挂载为只读. 这是特别重要的, 因为 <code>/usr/</code> 包含通用的可执行文件，不应该被用户改变. 此外, 由于 <code>/usr/</code> 它是以只读方式挂载的, 因此它应该可以从CD-ROM驱动器或另一台机器通过只读NFS安装进行安装.</li>
</ul>
<h3 id="FHS-组织"><a href="#FHS-组织" class="headerlink" title="FHS 组织"></a>FHS 组织</h3><p>这里提到的目录和文件是由FHS文件指定的一小部分。有关最全面的信息，请参阅最新的FHS文档。</p>
<p><strong>Note</strong></p>
<p>可用的目录取决于任何给定系统上安装的内容。下面的列表只是可能发现的一个例子。</p>
<p>收集文件系统信息</p>
<p> <code>df</code> 命令报告系统的磁盘空间使用情况。其输出看起来类似于以下内容:</p>
<p><strong>df Command Output</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">                       11675568   6272120   4810348  57% / /dev/sda1</span><br><span class="line">	                 100691      9281     86211  10% /boot</span><br><span class="line">none                     322856         0    322856   0% /dev/shm</span><br></pre></td></tr></table></figure>
<p>默认情况下, <code>df</code> 以1千字节块显示分区大小，以千字节为单位显示已用和可用磁盘空间量。要查看以兆字节和千兆字节为单位的信息，请使用该命令,  <code>df -h</code>.  <code>-h</code> argument stands for “human-readable” format. 输出<code>df -h</code> 看起来类似于以下内容:</p>
<p><strong>df -h Command Output</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">                        12G  6.0G  4.6G  57% / /dev/sda1</span><br><span class="line">			99M  9.1M   85M  10% /boot </span><br><span class="line">none 			316M     0  316M   0% /dev/shm</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong></p>
<p>在上面的例子中，挂载的分区 <code>/dev/shm</code>表示系统的虚拟内存文件系统.</p>
<p><code>du</code> 命令显示目录中文件使用的估计空间量，显示每个子目录的磁盘使用情况。输出中的最后一行 <code>du</code> 显示目录的总磁盘使用情况; 仅以可读的格式查看目录的总磁盘使用情况，请使用 <code>du -hs</code>. 有关更多选项，请参阅 <code>man du</code>.</p>
<p>要以图形格式查看系统的分区和磁盘空间使用情况，请通过单击 <strong>System Monitor</strong> by clicking on <strong>Applications</strong> → <strong>System Tools</strong> → <strong>System Monitor</strong> 或使用命令来使用 <code>gnome-system-monitor</code>. 选择 <strong>File Systems</strong> 选项卡查看系统的分区。</p>
<h4 id="boot-目录"><a href="#boot-目录" class="headerlink" title="/boot/ 目录"></a><code>/boot/</code> 目录</h4><p>The <code>/boot/</code> 目录包含启动系统所需的静态文件，例如Linux内核。这些文件对系统正常启动是必不可少的。</p>
<p><strong>Warning</strong></p>
<p>不要删除 <code>/boot/</code> 目录。这样做会导致系统无法启动。</p>
<h4 id="dev-目录"><a href="#dev-目录" class="headerlink" title="/dev/ 目录"></a><code>/dev/</code> 目录</h4><p><code>/dev/</code>目录包含代表以下设备类型的设备节点：</p>
<ul>
<li>连接到系统的设备;</li>
<li>内核提供的虚拟设备。</li>
</ul>
<p>这些设备节点对系统正常运行至关重要.  <code>udevd</code> 守护进程根据需要创建和删除在设备节点<code>/dev/</code>.</p>
<p> <code>/dev/</code> 目录和子目录中的 设备被定义为任一 <em>character</em> (仅提供输入和输出的串行流，例如鼠标或键盘) 或者 <em>block</em>(可随机访问，如硬盘驱动器或软盘驱动). 如果安装了GNOME或KDE，则在连接（例如使用USB）或插入（如CD或DVD驱动器）时会自动检测到某些存储设备，并显示一个弹出窗口，显示内容。.</p>
<p><strong> <code>/dev/</code>目录中的文件的示例</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">File</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/dev/hda</td>
<td style="text-align:center">主IDE通道上的主设备.</td>
</tr>
<tr>
<td style="text-align:center">/dev/hdb</td>
<td style="text-align:center">主要IDE通道上的从属设备.</td>
</tr>
<tr>
<td style="text-align:center">/dev/tty0</td>
<td style="text-align:center">第一个虚拟控制台.</td>
</tr>
<tr>
<td style="text-align:center">/dev/tty1</td>
<td style="text-align:center">第二个虚拟控制台.</td>
</tr>
<tr>
<td style="text-align:center">/dev/sda</td>
<td style="text-align:center">主SCSI或SATA通道上的第一个设备.</td>
</tr>
<tr>
<td style="text-align:center">/dev/lp0</td>
<td style="text-align:center">第一个并行端口.</td>
</tr>
</tbody>
</table>
</div>
<p>有效的块设备可以是两种类型的条目之一：</p>
<ul>
<li><p>映射的设备</p>
<p>卷组中的逻辑卷，例如, <code>/dev/mapper/VolGroup00-LogVol02</code>.</p>
</li>
<li><p>一个静态设备</p>
<p>例如，传统的存储卷，其中sdb是存储设备名称，X是分区号 。<code>/dev/*sdb**X*</code>,  <code>/dev/sdb*X*</code> 也可以是<code>/dev/disk/by-id/*WWID*</code>,或<code>/dev/disk/by-uuid/*UUID*</code>.</p>
</li>
</ul>
<h4 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc/ 目录"></a><code>/etc/</code> 目录</h4><p><code>/etc/</code>目录保留给机器本地的配置文件。 它不应该包含二进制文件; 任何二进制文件应该移动到 <code>/usr/bin/</code> 或 <code>/usr/sbin/</code>.</p>
<p>例如,  <code>/etc/skel/</code> 目录存储 用户文件”框架” , 用于在首次创建用户时填充主目录。 应用程序还将其配置文件存储在此目录中，并在执行时引用它们. The <code>/etc/exports</code>文件控制哪些文件系统导出到远程主机。</p>
<h4 id="mnt-目录"><a href="#mnt-目录" class="headerlink" title="/mnt/ 目录"></a><code>/mnt/</code> 目录</h4><p>The <code>/mnt/</code> 目录保留用于临时挂载的文件系统， 如NFS文件系统挂载. 对于所有可移动存储介质, 请使用 <code>/media/</code> 目录. 自动检测到的可移动媒体将被安装在 <code>/media</code> 目录中。.</p>
<p><strong>重要</strong></p>
<p> <code>/mnt</code> 目录不能被安装程序使用.</p>
<h4 id="opt-目录"><a href="#opt-目录" class="headerlink" title="/opt/ 目录"></a><code>/opt/</code> 目录</h4><p> <code>/opt/</code>目录通常保留给不属于默认安装的软件和附加软件包. 安装程序包以 <code>/opt/</code> 创建名称的目录, 例如, <code>/opt/*packagename*/</code>. 在大多数情况下, 这样的包遵循可预测的子目录结构; 大多数存储他们的二进制文件和他们的页面中 <code>/opt/*packagename*/bin/</code> and 他们的 <code>man</code> 手册在 <code>/opt/*packagename*/man/</code>中.</p>
<h4 id="proc-目录"><a href="#proc-目录" class="headerlink" title="/proc/ 目录"></a><code>/proc/</code> 目录</h4><p> <code>/proc/</code> 目录包含从内核中提取信息或向其发送信息的特殊文件. 这些信息的例子包括系统内存，CPU信息和硬件配置. </p>
<h4 id="srv-目录"><a href="#srv-目录" class="headerlink" title="/srv/ 目录"></a><code>/srv/</code> 目录</h4><p> <code>/srv/</code> 目录 包含由Linux系统提供的特定于站点的数据， 该目录为用户提供特定服务, 例如 （FTP, WWW, or CVS.）的数据文件的位置 ，只与特定用户有关的数据应该放在 <code>/home/</code>目录中.</p>
<h4 id="sys-目录"><a href="#sys-目录" class="headerlink" title="/sys/ 目录"></a><code>/sys/</code> 目录</h4><p><code>/sys/</code> 目录利用 <code>sysfs</code> 特定于内核的新虚拟文件系统。 随着对内核中热插拔硬件设备的支持的增加, <code>/sys/</code> 目录包含类似于所持有的信息 <code>/proc/</code>, 但显示特定于热插拔设备的设备信息的分层视图.</p>
<h4 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr/ 目录"></a><code>/usr/</code> 目录</h4><p><code>/usr/</code> 目录适用于可以在多台计算机上共享的文件.  <code>/usr/</code>目录通常在自己的分区上，并以只读方式挂载. 至少, <code>/usr/</code>应包含以下子目录：</p>
<ul>
<li><p><code>/usr/bin</code></p>
<p>该目录用于二进制文件.</p>
</li>
<li><p><code>/usr/etc</code></p>
<p>该目录用于系统范围的配置文件.</p>
</li>
<li><p><code>/usr/games</code></p>
<p>这个目录存储游戏.</p>
</li>
<li><p><code>/usr/include</code></p>
<p>该目录用于  C 头文件.</p>
</li>
<li><p><code>/usr/kerberos</code></p>
<p>此目录用于与Kerberos相关的二进制文件和文件。</p>
</li>
<li><p><code>/usr/lib</code></p>
<p>这个目录用于不被shell脚本或用户直接使用的目标文件和库.从RHEL7开始,  <code>/lib/</code> 目录已经被合并 <code>/usr/lib</code>. 现在还包含在执行的二进制文件所需的库 <code>/usr/bin/</code> 和 <code>/usr/sbin/</code>. 这些共享库图像用于引导系统或在根文件系统中执行命令.</p>
</li>
<li><p><code>/usr/libexec</code></p>
<p>该目录包含由其他程序调用的小型帮助程序.</p>
</li>
<li><p><code>/usr/sbin</code></p>
<p>从RHEL7开始, <code>/sbin</code> 已经转移到 <code>/usr/sbin</code>. 这意味着它包含所有系统管理二进制文件，包括引导，恢复，恢复或修复系统所必需的二进制文件。二进制文件<code>/usr/sbin/</code> 需要root权限才能使用.</p>
</li>
<li><p><code>/usr/share</code></p>
<p>该目录存储不是特定于体系结构的文件.</p>
</li>
<li><p><code>/usr/src</code></p>
<p>这个目录存储源代码.</p>
</li>
<li><p><code>/usr/tmp</code> 链接到 <code>/var/tmp</code></p>
<p>该目录存储临时文件.</p>
</li>
</ul>
<p><code>/usr/</code> 目录 还应该包含一个 <code>/local/</code> 子目录. 根据 FHS, 系统管理员在本地安装软件时使用此子目录, 并且在系统更新期间应该安全地被覆盖.  <code>/usr/local</code> 目录具有类似的结构 <code>/usr/</code>, 并包含以下子目录 :</p>
<ul>
<li><code>/usr/local/bin</code></li>
<li><code>/usr/local/etc</code></li>
<li><code>/usr/local/games</code></li>
<li><code>/usr/local/include</code></li>
<li><code>/usr/local/lib</code></li>
<li><code>/usr/local/libexec</code></li>
<li><code>/usr/local/sbin</code></li>
<li><code>/usr/local/share</code></li>
<li><code>/usr/local/src</code></li>
</ul>
<p>红帽企业Linux的使用 <code>/usr/local/</code>与FHS略有不同. FHS指出 <code>/usr/local/</code> 应该用来存储应该保持安全的系统软件升级的软件. 由于<strong>RPM Package Manager</strong> 可以安全地执行软件升级，因此不需要通过存储文件来保护<code>/usr/local/</code>的文件 </p>
<p>相反, 红帽企业Linux使用 <code>/usr/local/</code> 本地软件. 例如, 如果 <code>/usr/</code> 目录 是从远程主机挂载为只读NFS共享的,则仍然可以在 <code>/usr/local/</code> 目录下安装程序包或程序.</p>
<h4 id="var-目录"><a href="#var-目录" class="headerlink" title="/var/ 目录"></a><code>/var/</code> 目录</h4><p>由于FHS 要求Linux以只读方式挂载<code>/usr/</code> , 因此任何编写日志文件或需要的目录 <code>spool/</code> 或 <code>lock/</code> 目录都应将其写入 <code>/var/</code> 目录. FHS<code>/var/</code> 用于可变数据, 包含卷目录和文件,记录数据，瞬态和临时文件.</p>
<p>以下是目录中的一些<code>/var/</code> 目录:</p>
<ul>
<li><code>/var/account/</code></li>
<li><code>/var/arpwatch/</code></li>
<li><code>/var/cache/</code></li>
<li><code>/var/crash/</code></li>
<li><code>/var/db/</code></li>
<li><code>/var/empty/</code></li>
<li><code>/var/ftp/</code></li>
<li><code>/var/gdm/</code></li>
<li><code>/var/kerberos/</code></li>
<li><code>/var/lib/</code></li>
<li><code>/var/local/</code></li>
<li><code>/var/lock/</code></li>
<li><code>/var/log/</code></li>
<li><code>/var/mail</code> linked to <code>/var/spool/mail/</code></li>
<li><code>/var/mailman/</code></li>
<li><code>/var/named/</code></li>
<li><code>/var/nis/</code></li>
<li><code>/var/opt/</code></li>
<li><code>/var/preserve/</code></li>
<li><code>/var/run/</code></li>
<li><code>/var/spool/</code></li>
<li><code>/var/tmp/</code></li>
<li><code>/var/tux/</code></li>
<li><code>/var/www/</code></li>
<li><code>/var/yp/</code></li>
</ul>
<p><strong>重要</strong></p>
<p><code>/var/run/media/*user*</code>包含用作可移动介质（如USB存储介质，DVD，CD-ROM和Zip磁盘）的挂载点的子目录 请注意，以前，<code>/media/</code> 目录用于此。</p>
<p>系统日志文件, 如 <code>messages</code> and <code>lastlog</code>, 进入 <code>/var/log/</code> 目录. <code>/var/lib/rpm/</code>目录包含 RPM 系统数据库. 锁定文件在 <code>/var/lock/</code>目录, 通常在使用该文件的程序的目录中. <code>/var/spool/</code> 目录具有存储某些程序的数据文件的子目录。这些子目录包括:</p>
<ul>
<li><code>/var/spool/at/</code></li>
<li><code>/var/spool/clientmqueue/</code></li>
<li><code>/var/spool/cron/</code></li>
<li><code>/var/spool/cups/</code></li>
<li><code>/var/spool/exim/</code></li>
<li><code>/var/spool/lpd/</code></li>
<li><code>/var/spool/mail/</code></li>
<li><code>/var/spool/mailman/</code></li>
<li><code>/var/spool/mqueue/</code></li>
<li><code>/var/spool/news/</code></li>
<li><code>/var/spool/postfix/</code></li>
<li><code>/var/spool/repackage/</code></li>
<li><code>/var/spool/rwho/</code></li>
<li><code>/var/spool/samba/</code></li>
<li><code>/var/spool/squid/</code></li>
<li><code>/var/spool/squirrelmail/</code></li>
<li><code>/var/spool/up2date/</code></li>
<li><code>/var/spool/uucp/</code></li>
<li><code>/var/spool/uucppublic/</code></li>
<li><code>/var/spool/vbox/</code></li>
</ul>
<h2 id="特殊的红帽企业Linux文件位置"><a href="#特殊的红帽企业Linux文件位置" class="headerlink" title="特殊的红帽企业Linux文件位置"></a>特殊的红帽企业Linux文件位置</h2><p>红帽企业Linux稍微扩展了FHS结构以适应特殊文件.</p>
<p>大多数与RPM相关的文件都保存在 <code>/var/lib/rpm/</code> 目录中. 有关RPM的更多信息，请参阅 <code>man rpm</code>.</p>
<p><code>/var/cache/yum/</code> 目录包含 <strong>Package Updater</strong>, 使用的文件. 包括系统的RPM头信息。这个位置也可以用来临时存储下载的RPMs，同时更新系统。</p>
<p>红帽企业Linux特定的另一个位置是<code>/etc/sysconfig/</code> 目录. 这个目录存储了各种配置信息。许多在启动时运行的脚本都使用这个目录中的文件.</p>
<h3 id="proc-虚拟文件系统"><a href="#proc-虚拟文件系统" class="headerlink" title="/proc 虚拟文件系统"></a>/proc 虚拟文件系统</h3><p>与大多数文件系统不同, <code>/proc</code> 它不包含文本或二进制文件,相反，它包含 <em>virtual files</em>; 如此, <code>/proc</code> 通常被称为虚拟文件系统. 这些虚拟文件的大小通常是零字节，即使它们包含大量的信息。</p>
<p><code>/proc</code>文件系统不用于存储. 其主要目的是为硬件，内存，运行进程和其他系统组件提供一个基于文件的界面。通过查看相应的 <code>/proc</code> file. 可以在许多系统组件上检索实时信息。其中的一些文件 <code>/proc</code> 也可以被用户和应用程序操作来配置内核.</p>
<p>以下 <code>/proc</code> 文件与管理和监视系统存储相关:</p>
<ul>
<li><p>/proc/devices</p>
<p>显示当前配置的各种字符和块设备.</p>
</li>
<li><p>/proc/filesystems</p>
<p>列出内核当前支持的所有文件系统类型.</p>
</li>
<li><p>/proc/mdstat</p>
<p>包含系统上多磁盘或RAID配置的最新信息（如果存在）.</p>
</li>
<li><p>/proc/mounts</p>
<p>列出系统当前使用的所有挂载.</p>
</li>
<li><p>/proc/partitions</p>
<p>包含分区块分配信息.</p>
</li>
</ul>
<h3 id="Discard-Unused-Blocks"><a href="#Discard-Unused-Blocks" class="headerlink" title="Discard Unused Blocks"></a>Discard Unused Blocks</h3><p>批量丢弃和联机丢弃操作是挂载文件系统的功能，丢弃文件系统未使用的块。它们对于固态驱动器和精简配置存储都很有用.</p>
<ul>
<li><em>批处理丢弃操作</em> 由用户通过 <code>fstrim</code>命令显式地运行. 该命令放弃文件系统中符合用户标准的所有未使用的块.</li>
<li><em>在线丢弃操作</em> 是在挂载时指定的, 可以将 <code>-o discard</code>选项作为 <code>mount</code> 命令的一部分，也可以使用文件中的 <code>discard</code> 选项在 <code>/etc/fstab</code> 文件中. 他们在没有用户干预的情况下实时运行。在线丢弃操作只丢弃正在使用的空闲块.</li>
</ul>
<p>Both operation types are supported for use with ext4 file systems as of Red Hat Enterprise Linux 6.2 and later and with XFS file systems since Red Hat Enterprise Linux 6.4. Also, the block device underlying the file system must support physical discard operations. Physical discard operations are supported if the value stored in the <code>/sys/block/*device*/queue/discard_max_bytes</code> file is not zero.</p>
<p>Red Hat recommends batch discard operations unless the system’s workload is such that batch discard is not feasible, or online discard operations are necessary to maintain performance.</p>
<h1 id="XFS-文件系统"><a href="#XFS-文件系统" class="headerlink" title="XFS 文件系统"></a>XFS 文件系统</h1><p>XFS是一个高度可扩展的高性能文件系统，最初是在Silicon Graphics，Inc.设计的。XFS是Red Hat Enterprise Linux 7的默认文件系统.</p>
<ul>
<li><p>主要特点</p>
<p>XFS 支持 <em>元数据日志记录</em>, 这有助于更快的崩溃恢复。XFS文件系统也可以在安装和激活时进行碎片整理和放大。另外，红帽企业版Linux 7支持特定于XFS的备份和恢复实用程序。</p>
</li>
<li><p>分配功能</p>
<p>XFS 具有以下分配方案:</p>
<ul>
<li>Extent-based allocation</li>
<li>Stripe-aware allocation policies</li>
<li>Delayed allocation</li>
<li>Space pre-allocation</li>
</ul>
<p>延迟分配和其他性能优化会以与ext4相同的方式影响XFS。也就是说，除非程序 <code>fsync()</code> 后发出调用，否则程序对XFS文件系统的写入不能保证在磁盘上.</p>
</li>
</ul>
<p>其他 XFS 功能</p>
<p>XFS文件系统还支持以下内容:</p>
<ul>
<li><p><em>扩展属性</em> (<code>xattr</code>)</p>
<p>这允许系统为每个文件关联几个附加的名称/值对。它是默认启用的.</p>
</li>
<li><p><em>配额日记</em></p>
<p>这样可以避免在崩溃后需要进行冗长的配额一致性检查.</p>
</li>
<li><p><em>项目/目录配额</em></p>
<p>这允许在目录树上进行配额限制.</p>
</li>
<li><p><em>秒时间戳</em></p>
<p>这允许时间戳到秒.</p>
</li>
</ul>
<p>默认<code>atime</code>行为是 <code>relatime</code></p>
<p><code>Relatime</code>对于XFS默认是打开的。相比之下，它几乎没有任何开销 <code>noatime</code> 同时仍然保持理智的 <code>atime</code> 值.</p>
<h2 id="创建一个XFS文件系统"><a href="#创建一个XFS文件系统" class="headerlink" title="创建一个XFS文件系统"></a>创建一个XFS文件系统</h2><p>创建一个XFS文件系统, 使用 <code>mkfs.xfs /dev/*device*</code> 命令. 一般来说，默认选项是常用的最佳选择.</p>
<p>在 <code>mkfs.xfs</code> 包含现有文件系统的块设备上使用时， 使用 <code>-f</code>选项强制覆盖该文件系统.</p>
<p><strong>  mkfs.xfs Command Output</strong></p>
<p>以下是<code>mkfs.xfs</code>命令的输出示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meta-data=/dev/device            isize=256    agcount=4, agsize=3277258 blks</span><br><span class="line">=                       sectsz=512   attr=2</span><br><span class="line">data     =                       bsize=4096   blocks=13109032, imaxpct=25</span><br><span class="line">=                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=6400, version=2</span><br><span class="line">=                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>A在创建XFS文件系统之后，其大小不能减小. 但是，使用 <code>xfs_growfs</code>命令仍然可以扩大.</p>
<p>对于条带块设备（例如RAID5阵列），可以在创建文件系统时指定条带几何。使用适当的条带几何可以极大地提高XFS文件系统的性能.</p>
<p>在LVM或MD卷上创建文件系统时, <code>mkfs.xfs</code> 选择最佳几何体。在某些将几何信息导出到操作系统的硬件RAID上，这也可能是正确的.</p>
<p>如果设备导出条带几何信息, <code>mkfs</code> (for ext3, ext4, and xfs) 将自动使用此几何。如果条纹几何体没有被mkfs检测到，并且即使存储器实际上具有条纹几何体，也可以使用以下选项在mkfs时间手动指定它:</p>
<ul>
<li><p>su=<em>value</em></p>
<p>指定条带单位或RAID块大小. The <code>*value*</code> m必须以字节为单位指定, 具有可选的 <code>k</code>, <code>m</code>, 或 <code>g</code> 后缀.</p>
</li>
<li><p>sw=<em>value</em></p>
<p>指定RAID设备中的数据磁盘数量，或条带中的条带单元数量.</p>
</li>
</ul>
<p>The following example specifies a chunk size of 64k on a RAID device containing 4 stripe units:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.xfs -d su=64k,sw=4 /dev/device</span></span><br></pre></td></tr></table></figure>
<h2 id="挂载-XFS-文件系统"><a href="#挂载-XFS-文件系统" class="headerlink" title="挂载  XFS 文件系统"></a>挂载  XFS 文件系统</h2><p>以下示例在包含4个条带单元的RAID设备上指定64k的块大小:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<p>红帽企业版Linux 7的默认值是inode64.</p>
<p><strong>注意</strong></p>
<p>与mke2fs不同，mkfs.xfs不使用配置文件; 它们都在命令行中指定.</p>
<h2 id="Write-Barriers"><a href="#Write-Barriers" class="headerlink" title="Write Barriers"></a>Write Barriers</h2><p>默认情况下, XFS 使用 write barriers 来确保文件系统完整性，即使启用了写入缓存的设备断电时也是如此。对于没有写入缓存的设备，或使用电池支持写入缓存的设备，请使用以下 <code>nobarrier</code> 选项禁用Write Barriers:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o nobarrier /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<h3 id="Direct-Access-技术预览"><a href="#Direct-Access-技术预览" class="headerlink" title="Direct Access 技术预览"></a>Direct Access 技术预览</h3><p>从红帽企业版Linux 7.3开始, <code>Direct Access</code> (DAX) 作为ext4和XFS文件系统上的技术预览版提供了应用程序将持久内存直接映射到其地址空间的方法。要使用DAX，系统必须具有某种形式的持久性内存，通常以一个或多个非易失性双列直插式内存模块（NVDIMM）的形式提供，并且必须在NVDIMM上创建支持DAX的文件系统（ S）。此外，文件系统必须使用 <code>dax</code> 挂载选项进行安装。然后， <code>mmap</code> 挂载在dax上的文件系统上的一个文件将导致存储直接映射到应用程序的地址空间.</p>
<h2 id="XFS配额管理"><a href="#XFS配额管理" class="headerlink" title="XFS配额管理"></a>XFS配额管理</h2><p>XFS配额子系统管理磁盘空间 (blocks) 和文件 (inode) 使用的限制. XFS配额控制或报告这些项目在用户，组或目录或项目级别上的使用情况。另请注意，尽管用户，组和项目配额是独立启用的，但组和项目配额是互斥的.</p>
<p>在按目录或按项目进行管理时，XFS管理与特定项目关联的目录层次结构的磁盘使用情况。在这样做的过程中，XFS认可项目之间的跨组织“组”边界。这提供了比为用户或组管理配额时可用的控制级别更广的级别.</p>
<p>XFS配额在安装时启用，具有特定的挂载选项。每个安装选项也可以指定为 <code>noenforce</code>; 这将允许使用报告而不强制任何限制。有效的配额挂载选项是:</p>
<ul>
<li><code>uquota</code>/<code>uqnoenforce</code> - 用户配额</li>
<li><code>gquota</code>/<code>gqnoenforce</code> - 组配额</li>
<li><code>pquota</code>/<code>pqnoenforce</code> - 项目配额</li>
</ul>
<p>一旦启用配额 <code>xfs_quota</code> 工具可用于设置限制并报告磁盘使用情况。默认情况下, <code>xfs_quota</code> 以交互方式运行，并处于基本模式。基本模式子命令只是报告使用情况，并可供所有用户使用。基本的 <code>xfs_quota</code> 子命令包括:</p>
<ul>
<li><p>quota <em>username/userID</em></p>
<p>显示给定 <code>*username*</code>或数字的用法和限制 <code>*userID*</code></p>
</li>
<li><p>df</p>
<p>显示块和inode的空闲和使用计数.</p>
</li>
</ul>
<p>相比之下, <code>xfs_quota</code> 也有一个专家模式。该模式的子命令允许实际配置限制，并且仅对具有提升特权的用户可用。要交互使用专家模式子命令，请运行 <code>xfs_quota -x</code>. 专家模式子命令包括:</p>
<ul>
<li><p>report <em>/path</em></p>
<p>报告特定文件系统的配额信息.</p>
</li>
<li><p>limit</p>
<p>修改配额限制.</p>
</li>
</ul>
<p>有关基本或专家模式的子命令的完整列表，请使用子命令<code>help</code>.</p>
<p>所有子命令也可以使用该 <code>-c</code>选项直接从命令行运行，也可以使用 <code>-x</code> 专家子命令.</p>
<p><strong>显示样本配额报告</strong></p>
<p>例如，要显示 <code>/home</code> (on <code>/dev/blockdevice</code>), 的示例配额报告，请使用该命令 <code>xfs_quota -x -c &#39;report -h&#39; /home</code>. 这将显示类似于以下内容的输出:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">User quota on /home (/dev/blockdevice)</span><br><span class="line">Blocks              </span><br><span class="line">User ID      Used   Soft   Hard Warn/Grace   </span><br><span class="line">---------- --------------------------------- </span><br><span class="line">root            0      0      0  00 [------]</span><br><span class="line">testuser   103.4G      0      0  00 [------]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要为用户 <code>john</code> (其主目录是 <code>/home/john</code>), 分别设置500和700的软硬节点数限制，请使用以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_quota -x -c 'limit isoft=500 ihard=700 john' /home/</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，传递 <em>mount_point</em> 这是挂载的xfs文件系统.</p>
<p>默认情况下，<code>limit</code> 子命令将目标识别为用户。在配置组的限制时，使用 <code>-g</code> 如上例）。同样, use <code>-p</code> 用于项目.</p>
<p>软和硬块限制也可以使用 <code>bsoft</code> 或<code>bhard</code>代替<code>isoft</code> 或<code>ihard</code>.</p>
<p><strong>设置一个软和硬块限制</strong></p>
<p>例如，要分别为 <code>accounting</code> 在 <code>/target/path</code>文 件系统上设置1000m和1200m的软硬件块限制:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_quota -x -c 'limit -g bsoft=1000m bhard=1200m accounting' /target/path</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>命令 <code>bsoft</code> and <code>bhard</code> 字节计数.</p>
<p><strong>重要</strong></p>
<p>虽然在设置配额时，实时块 (<code>rtbhard</code>/<code>rtbsoft</code>) 被描述<code>man xfs_quota</code> 为有效单位, 但此版本中未启用实时子卷。因此， <code>rtbhard</code> and <code>rtbsoft</code> 选项是不适用的.</p>
<h2 id="设置项目限制"><a href="#设置项目限制" class="headerlink" title="设置项目限制"></a>设置项目限制</h2><p>在为项目控制的目录配置限制之前，先将它们添加到<code>/etc/projects</code>。可以添加项目名称<code>/etc/projectid</code>以将项目ID映射到项目名称。项目添加完成后<code>/etc/projects</code>，使用以下命令初始化项目目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_quota -x -c 'project -s projectname' project_path</span></span><br></pre></td></tr></table></figure>
<p>初始化目录的项目的配额然后可以配置，：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_quota -x -c 'limit -p bsoft=1000m bhard=1200m projectname'</span></span><br></pre></td></tr></table></figure>
<p>通用配额配置工具（quota，repquota，和edquota例如）也可以用于操纵XFS配额。但是，这些工具不能用于XFS项目配额。</p>
<p><strong>重要</strong></p>
<p>红帽推荐使用<code>xfs_quota</code> 和其他所有可用的工具。</p>
<p>有关设置XFS配额的更多信息, 请参阅 <code>man xfs_quota</code>, <code>man projid(5)</code>,和<code>man projects(5)</code>.</p>
<h2 id="增加XFS文件系统的大小"><a href="#增加XFS文件系统的大小" class="headerlink" title="增加XFS文件系统的大小"></a>增加XFS文件系统的大小</h2><p>使用以下 <code>xfs_growfs</code> 命令挂载XFS文件系统:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_growfs /mount/point -D size</span></span><br></pre></td></tr></table></figure>
<p> <code>-D *size*</code>选项使文件系统增长到指定的<code>*size*</code> (以文件系统块表示). 如果没有选项 <code>-D *size*</code> 选项， <code>xfs_growfs</code> 则会将文件系统增大到设备支持的最大大小.</p>
<p>在生成XFS文件系统之前 <code>-D *size*</code>, 请确保基础块设备具有适当的大小以便稍后保存文件系统. 为受影响的块设备使用适当的调整大小的方法.</p>
<p><strong>注意</strong></p>
<p>虽然XFS文件系统可以在挂载时进行扩容，但是它们的大小根本无法缩小.</p>
<h2 id="修复XFS文件系统"><a href="#修复XFS文件系统" class="headerlink" title="修复XFS文件系统"></a>修复XFS文件系统</h2><p>要修复XFS文件系统，请使用 <code>xfs_repair</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_repair /dev/device</span></span><br></pre></td></tr></table></figure>
<p> <code>xfs_repair</code> 用程序具有高度的可扩展性，能够有效地修复具有多个inode的超大型文件系统。与其他Linux文件系统不同, <code>xfs_repair</code> 即使在XFS文件系统未完全卸载的情况下，也不会在启动时运行, 在不清洁的情况下，<code>xfs_repair</code> 只需在安装时重播日志，确保一致的文件系统。</p>
<p><strong>警告</strong></p>
<p> <code>xfs_repair</code>实用程序无法修复具有脏日志的XFS文件系统。要清除日志，请挂载和卸载XFS文件系统。如果日志损坏且无法重播，请使用-L选项（“强制日志清零”）清除日志，即。请注意，这可能会导致进一步的损坏或数据丢失。, <code>xfs_repair -L */dev/device*</code>. 这可能会导致进一步的损坏或数据丢失.</p>
<h2 id="暂停XFS文件系统"><a href="#暂停XFS文件系统" class="headerlink" title="暂停XFS文件系统"></a>暂停XFS文件系统</h2><p>要暂停或恢复对文件系统的写入活动, 请使用 <code>xfs_freeze</code>. 暂停写入活动允许基于硬件的设备快照以一致的状态捕获文件系统.</p>
<p><strong>注意</strong></p>
<p><code>xfs_freeze</code>实用程序由 <code>xfsprogs</code> 程序包提供, 仅在x86_64上可用.</p>
<p>要暂停（即冻结）XFS文件系统，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_freeze -f /mount/point</span></span><br></pre></td></tr></table></figure>
<p>要解冻XFS文件系统，请使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfs_freeze -u /mount/point</span></span><br></pre></td></tr></table></figure>
<p>在创建LVM快照时，不需要先使用 <code>xfs_freeze</code> 挂起文件系统。相反，LVM管理工具将在拍摄快照之前自动挂起XFS文件系统.</p>
<h2 id="XFS文件系统的备份和恢复"><a href="#XFS文件系统的备份和恢复" class="headerlink" title="XFS文件系统的备份和恢复"></a>XFS文件系统的备份和恢复</h2><p>XFS文件系统备份和恢复涉及两个实用程序: <code>xfsdump</code> 和 <code>xfsrestore</code>.<br>要备份或转储XFS文件系统，请使用 <code>xfsdump</code> 实用程序. 红帽企业版Linux 7支持备份到磁带驱动器或常规文件映像，并允许将多个转储写入同一个磁带.  <code>xfsdump</code> 实用程序实用程序还允许转储跨越多个磁带，但只能将一个转储写入常规文件。此外.<code>xfsdump</code> 支持增量备份，并且可以使用大小，子树或inode标志从备份中排除文件以对其进行过滤.</p>
<p>为了支持增量备份, <code>xfsdump</code> 使用 <em>dump levels</em> 来确定特定转储相对于的基本转储.  <code>-l</code> 选项指定转储级别 (<em>0-9</em>). 要执行完整备份，请在文件系统上执行 <em>level 0</em> 转储 (<code>*/path/to/filesystem*</code>), 例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsdump -l 0 -f /dev/device /path/to/filesystem</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p> <code>-f</code> 选项指定备份的目标.例如, <code>/dev/st0</code>目标通常用于磁带驱动器. 一个 <code>xfsdump</code> 目标可以是磁带机, 常规文件，或远程磁带设备.</p>
<p>相比之下，增量备份只会转储自上次<em>第0级</em>转储以来发生更改的文件。1 <em>级</em>转储是完全转储后的第一个增量转储; 下一次增量转储将是<em>级别2</em>，依此类推，最大值为<em>9级</em>。因此，要执行到磁带驱动器的<em>1级</em>转储：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsdump -l 1 -f /dev/st0 /path/to/filesystem</span></span><br></pre></td></tr></table></figure>
<p>相反，该<code>xfsrestore</code>实用程序还原由生成的转储文件系统<code>xfsdump</code>。该<code>xfsrestore</code>实用程序有两种模式：默认<em>简单</em>模式和<em>累积</em>模式。特定转储由<em>会话标识</em>或<em>会话标签标识</em>。因此，恢复转储需要相应的会话ID或标签。要显示所有转储（包括完整和增量）的会话ID和标签，请使用以下<code>-I</code>选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsrestore -I</span></span><br></pre></td></tr></table></figure>
<p>这将提供类似于以下的输出:</p>
<p><strong>会话ID和所有转储的标签</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file system 0:</span><br><span class="line">fs id:		45e9af35-efd2-4244-87bc-4762e476cbab</span><br><span class="line">session 0:</span><br><span class="line">mount point:	bear-05:/mnt/<span class="built_in">test</span></span><br><span class="line">device:		bear-05:/dev/sdb2</span><br><span class="line">time:		Fri Feb 26 16:55:21 2010</span><br><span class="line">session label:	<span class="string">"my_dump_session_label"</span></span><br><span class="line">session id:	b74a3586-e52e-4a4a-8775-c3334fa8ea2c</span><br><span class="line">level:		0</span><br><span class="line">resumed:	NO</span><br><span class="line">subtree:	NO</span><br><span class="line">streams:	1</span><br><span class="line">stream 0:</span><br><span class="line">pathname:	/mnt/test2/backup</span><br><span class="line">start:		ino 0 offset 0</span><br><span class="line">end:		ino 1 offset 0</span><br><span class="line">interrupted:	NO</span><br><span class="line">media files:	1</span><br><span class="line">media file 0:</span><br><span class="line">mfile index:	0</span><br><span class="line">mfile <span class="built_in">type</span>:	data</span><br><span class="line">mfile size:	21016</span><br><span class="line">mfile start:	ino 0 offset 0</span><br><span class="line">mfile end:	ino 1 offset 0</span><br><span class="line">media label:	<span class="string">"my_dump_media_label"</span></span><br><span class="line">media id:	4a518062-2a8f-4f17-81fd-bb1eb2e3cb4f</span><br><span class="line">xfsrestore: Restore Status: SUCCESS</span><br></pre></td></tr></table></figure>
<h2 id="简单模式-xfsrestore"><a href="#简单模式-xfsrestore" class="headerlink" title="简单模式 xfsrestore"></a>简单模式 <code>xfsrestore</code></h2><p>在 <em>simple</em> mode 允许用户从恢复整个文件系统 <em>level 0</em> 转储. 在识别 <em>level 0</em> 转储会话 ID (<code>*session-ID*</code>), 之后完全恢复为 <code>*/path/to/destination*</code> 使用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsrestore -f /dev/st0 -S session-ID /path/to/destination</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>该<code>-f</code>选项指定转储的位置，而<code>-S</code>or <code>-L</code>选项指定要恢复的特定转储。该<code>-S</code>选项用于指定会话标识，而该<code>-L</code>选项用于会话标签。该<code>-I</code>选项显示每个转储的会话标签和ID</p>
<h2 id="累计模式-xfsrestore"><a href="#累计模式-xfsrestore" class="headerlink" title="累计模式 xfsrestore"></a>累计模式 <code>xfsrestore</code></h2><p>The <em>累计</em> 模式 <code>xfsrestore</code> 允许文件系统恢复来自一个特定的增量备份，例如 <em>level 1</em> to <em>level 9</em>. 要从增量备份还原文件系统，只需添加 <code>-r</code> 选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsrestore -f /dev/st0 -S session-ID -r /path/to/destination</span></span><br></pre></td></tr></table></figure>
<h2 id="交互式操作"><a href="#交互式操作" class="headerlink" title="交互式操作"></a>交互式操作</h2><p><code>xfsrestore</code> 实用程序还允许从转储中提取，添加或删除特定文件. 使用<code>xfsrestore</code> 交互使用, 使用<code>-i</code> 选项, 如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xfsrestore -f /dev/st0 -i /destination/directory</span></span><br></pre></td></tr></table></figure>
<p> <code>xfsrestore</code> 完成读取指定的设备 后，交互式对话将开始。在这次对话可用的命令包括 <code>cd</code>, <code>ls</code>, <code>add</code>, <code>delete</code>, and <code>extract</code>; 要获得完整的命令列表，请使用 <code>help</code>.</p>
<h2 id="从磁带恢复备份时的信息性消息"><a href="#从磁带恢复备份时的信息性消息" class="headerlink" title="从磁带恢复备份时的信息性消息"></a>从磁带恢复备份时的信息性消息</h2><p>从具有多个文件系统备份的磁带恢复备份时,  <code>xfsrestore</code> 实用程序可能会发出消息。这些消息通知您 <code>xfsrestore</code> 在按顺序检查磁带上的每个备份时是否找到请求的备份的匹配。例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xfsrestore: preparing drive</span><br><span class="line">xfsrestore: examining media file 0</span><br><span class="line">xfsrestore: inventory session uuid (8590224e-3c93-469c-a311-fc8f23029b2a) does not match the media header<span class="string">'s session uuid (7eda9f86-f1e9-4dfd-b1d4-c50467912408)</span></span><br><span class="line"><span class="string">xfsrestore: examining media file 1</span></span><br><span class="line"><span class="string">xfsrestore: inventory session uuid (8590224e-3c93-469c-a311-fc8f23029b2a) does not match the media header'</span>s session uuid (7eda9f86-f1e9-4dfd-b1d4-c50467912408)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>信息性消息一直出现，直到找到匹配的备份.</p>
<p>有关转储和恢复XFS文件系统的更多信息，请参阅,  <code>man xfsdump</code>和 <code>man xfsrestore</code>.</p>
<h2 id="配置错误行为"><a href="#配置错误行为" class="headerlink" title="配置错误行为"></a>配置错误行为</h2><p>在 I/O操作过程中发生错误时 , XFS驱动程序采用以下两种方式之一进行响应:</p>
<ul>
<li>继续重试，直到:<ul>
<li>I/O操作成功，或者</li>
<li>超出I/O 操作重试计数或时间限制.</li>
</ul>
</li>
<li>考虑永久性的错误并暂停系统.</li>
</ul>
<p>XFS目前认识到以下错误情况，您可以专门配置所需的行为:</p>
<ul>
<li><code>EIO</code>:尝试写入设备时出错</li>
<li><code>ENOSPC</code>: 设备上没有剩余空间</li>
<li><code>ENODEV</code>: 设备找不到</li>
</ul>
<p>所有其他可能的错误条件（没有定义特定的处理程序）共享一个全局配置.</p>
<p>您可以设置XFS认为错误永久的条件，包括最大重试次数和最长时间（以秒为单位）。当满足任何一个条件时，XFS将停止重试.</p>
<p>无论是否有其他配置，还可以选择在卸载文件系统时立即取消重试。这使得卸载操作即使在持续错误的情况下也能成功.</p>
<h3 id="特定和未定义条件的配置文件"><a href="#特定和未定义条件的配置文件" class="headerlink" title="特定和未定义条件的配置文件"></a>特定和未定义条件的配置文件</h3><p>控制错误行为的配置文件位于<code>/sys/fs/xfs/device/error/</code>目录.</p>
<p>该目录包含每个特定错误条件的子目录：<code>/sys/fs/xfs/*device*/error/metadata/</code></p>
<ul>
<li><code>/sys/fs/xfs/*device*/error/metadata/EIO/</code> 为 <code>EIO</code> 错误情况</li>
<li><code>/sys/fs/xfs/*device*/error/metadata/ENODEV/</code>为 <code>ENODEV</code> 错误情况</li>
<li><code>/sys/fs/xfs/*device*/error/metadata/ENOSPC/</code>为 <code>ENOSPC</code> 错误情况</li>
</ul>
<p>每一个 都包含以下配置文件’:</p>
<ul>
<li><code>/sys/fs/xfs/*device*/error/metadata/*condition*/max_retries</code>: 控制XFS重试操作的最大次数.</li>
<li><code>/sys/fs/xfs/*device*/error/metadata/*condition*/retry_timeout_seconds</code>: XFS将停止重试操作的时间限制（以秒为单位）</li>
</ul>
<p>所有其他可能出现的错误情况，除了上一节中描述的情况之外，在这些文件中共享一个通用配置:</p>
<ul>
<li><code>/sys/fs/xfs/*device*/error/default/max_retries</code>: 控制最大重试次数</li>
<li><code>/sys/fs/xfs/*device*/error/default/retry_timeout_seconds</code>: 控制重试的时间限制</li>
</ul>
<h3 id="设置特定和未定义条件的文件系统行为"><a href="#设置特定和未定义条件的文件系统行为" class="headerlink" title="设置特定和未定义条件的文件系统行为"></a>设置特定和未定义条件的文件系统行为</h3><p>要设置最大重试次数，请将所需的编号写入 <code>max_retries</code> 文件中.</p>
<ul>
<li>对于特定的条件:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo value &gt; /sys/fs/xfs/device/error/metadata/condition/max_retries</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于未定义的条件:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo value &gt; /sys/fs/xfs/device/error/default/max_retries</span></span><br></pre></td></tr></table></figure>
<p>值是1到int的最大可能值之间的一个数字，即C有符号整数类型。这是64位Linux上的2147483647。</p>
<p>要设置时间限制，请将所需的秒数写入 <code>retry_timeout_seconds</code>文件.</p>
<ul>
<li>对于特定的条件:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo value &gt; /sys/fs/xfs/device/error/metadata/condition/retry_timeout_seconds</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于未定义的条件:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo value &gt; /sys/fs/xfs/device/error/default/retry_timeout_seconds</span></span><br></pre></td></tr></table></figure>
<p><em>value</em> 是 <code>-1</code> 和 <code>86400</code>中的数字, 这是一天中的秒数.</p>
<p>在 <code>max_retries</code> 和<code>retry_timeout_seconds</code> 选项中, <code>-1</code> 意味着永远重试， <code>0</code> 立即停止.</p>
<p><em>device</em> 设备的名称, 如 <code>/dev/</code> 目录中所示; 例如, <code>sda</code>.</p>
<p><strong>注意</strong></p>
<p>每个错误条件的默认行为取决于错误上下文。有些错误，比如 <code>ENODEV</code>, 被认为是致命的，无法恢复，不管重试次数如何，所以它们的默认值是 <code>0</code>.</p>
<h3 id="设置卸载行为"><a href="#设置卸载行为" class="headerlink" title="设置卸载行为"></a>设置卸载行为</h3><p>如果 <code>fail_at_unmount</code> 设置了该选项，则文件系统将在卸载过程中覆盖所有其他错误配置，并立即在不重试I / O操作的情况下提升文件系统。这使得卸载操作即使在持续错误的情况下也能成功.</p>
<p>设置卸载行为:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> value &gt; /sys/fs/xfs/device/error/fail_at_unmount</span><br></pre></td></tr></table></figure>
<p><em>value</em> 的值 <code>1</code>或<code>0</code>:</p>
<ul>
<li><code>1</code> 意味着如果发现错误，立即取消重试.</li>
<li><code>0</code>意味着尊重 <code>max_retries</code> 和 <code>retry_timeout_seconds</code>的选择.</li>
</ul>
<p><em>device</em>是设备的名称, 如 <code>/dev/</code>目录中所示; 例如, <code>sda</code>.</p>
<p><strong>重要</strong></p>
<p><code>fail_at_unmount</code>在尝试卸载文件系统之前，必须根据需要设置 该选项。卸载操作启动后，配置文件和目录可能不可用.</p>
<h2 id="其他XFS文件系统实用程序"><a href="#其他XFS文件系统实用程序" class="headerlink" title="其他XFS文件系统实用程序"></a>其他XFS文件系统实用程序</h2><p>红帽企业Linux 7还提供了其他用于管理XFS文件系统的实用程序:</p>
<ul>
<li><p>xfs_fsr</p>
<p>用于对挂载的XFS文件系统进行碎片整理。在没有参数的情况下调用时, <code>xfs_fsr</code> 对所有已挂载的XFS文件系统中的所有常规文件进行碎片整理。此实用程序还允许用户在指定的时间暂停碎片整理，并在以后停止的地方恢复.</p>
<p>另外, <code>xfs_fsr</code> 还允许只对一个文件进行碎片整理, 如 <code>xfs_fsr*/path/to/file*</code>. 红帽建议不要定期对整个文件系统进行碎片整理，因为XFS默认避免碎片。系统范围的碎片整理可能会导致自由空间碎片的副作用.</p>
</li>
<li><p>xfs_bmap</p>
<p>打印XFS文件系统中文件使用的磁盘块映射。该映射列出了指定文件使用的每个范围，以及文件中没有对应块（即孔）的区域.</p>
</li>
<li><p>xfs_info</p>
<p>打印XFS文件系统信息.</p>
</li>
<li><p>xfs_admin</p>
<p>更改XFS文件系统的参. <code>xfs_admin</code> ，实用程序只能修改未安装的设备或文件系统的参数.</p>
</li>
<li><p>xfs_copy</p>
<p>将整个XFS文件系统的内容并行复制到一个或多个目标.</p>
</li>
</ul>
<p>以下实用程序在调试和分析XFS文件系统时也很有用:</p>
<ul>
<li><p>xfs_metadump</p>
<p>将XFS文件系统元数据复制到文件。红帽只支持使用<code>xfs_metadump</code>实用程序来复制未安装的文件系统或只读安装的文件系统; 否则，生成的转储可能被损坏或不一致.</p>
</li>
<li><p>xfs_mdrestore</p>
<p>将XFS metadump映像 (使用生成的 <code>xfs_metadump</code>) 恢复到文件系统映像.</p>
</li>
<li><p>xfs_db</p>
<p>调试XFS文件系统.</p>
</li>
</ul>
<p>有关这些实用程序的更多信息，请参阅各自的 <code>man</code> 页面.</p>
<h3 id="从-XFS迁移到EXT4"><a href="#从-XFS迁移到EXT4" class="headerlink" title="从 XFS迁移到EXT4"></a>从 XFS迁移到EXT4</h3><p>从红帽企业Linux 7.0开始，XFS是默认的文件系统，而不是ext4。本节重点介绍使用或管理XFS文件系统时的差异.</p>
<p>红帽企业版Linux 7中仍然完全支持ext4文件系统，可以在安装时进行选择。虽然可以从ext4迁移到XFS，但并不是必需的.</p>
<h3 id="Ext3-4-与XFS的区别"><a href="#Ext3-4-与XFS的区别" class="headerlink" title="Ext3/4 与XFS的区别"></a>Ext3/4 与XFS的区别</h3><ul>
<li><p>文件系统修复</p>
<p>Ext3 / 4 <code>e2fsck</code>在启动时在用户空间运行，以根据需要恢复日志。相比之下，XFS在挂载时在内核空间执行日志恢复。提供了一个<code>fsck.xfs</code>shell脚本，但没有执行任何有用的操作，因为它只是满足initscript要求。</p>
<p>当请求XFS文件系统修复或检查时，请使用该<code>xfs_repair</code>命令。使用该<code>-n</code>选项进行只读检查。</p>
<p>该<code>xfs_repair</code>命令不会在具有脏日志的文件系统上运行。要修复这样的文件系统<code>mount</code>，<code>unmount</code>必须首先执行重播日志。如果日志损坏且无法重播，则<code>-L</code>可以使用该选项在日志中将其清零</p>
</li>
<li><p>元数据错误行为</p>
<p>遇到元数据错误时，ext3/4文件系统具有可配置的行为，默认情况下只是继续。当XFS遇到不可恢复的元数据错误时，将关闭文件系统并返回<code>EFSCORRUPTED</code>错误。系统日志将包含所遇到的错误的详细信息，<code>xfs_repair</code>如果有必要，将建议运行。</p>
</li>
<li><p>配额</p>
<p>XFS配额不是可重新安装的选项。<code>-o quota</code>必须在初始安装中指定该选项才能使配额生效。</p>
<p>尽管配额包中的标准工具可以执行基本的配额管理任务（诸如<strong>setquota</strong>和<strong>repquota</strong>之<strong>类的</strong>工具），但<strong>xfs_quota</strong>工具可用于特定于XFS的功能，例如“项目配额管理”。</p>
<p>该<code>quotacheck</code>命令对XFS文件系统没有影响。第一次配额会计开启XFS在<code>quotacheck</code>内部自动执行。因为XFS配额元数据是头等级的日志元数据对象，所以配额系统将始终保持一致，直到手动关闭配额为止</p>
</li>
<li><p>调整文件系统大小</p>
<p>XFS文件系统没有实用程序来缩小文件系统。XFS文件系统可以通过<code>xfs_growfs</code>命令在线增长</p>
</li>
<li><p>Inode numbers</p>
<p>对于文件系统大于1 TB（256字节inode）或大于2 TB（512字节inode）的文件系统，XFS索引节点数可能会超过2^32。如此大的inode编号会导致32位统计调用失败，并返回EOVERFLOW值。使用默认的红帽企业版Linux 7配置时可能会出现上述问题：不带有四个分配组的条带。自定义配置（例如文件系统扩展或更改XFS文件系统参数）可能会导致不同的行为.</p>
<p>应用程序通常会正确处理这种更大的inode编号 如果需要，使用<code>-o inode32</code>参数来挂载XFS文件系统，以实施低于2 ^ 32的索引节点号。请注意，使用<code>inode32</code>不会影响已用64位数分配的inode</p>
</li>
<li><p>预分配</p>
<p>当文件被写入时， XFS使用<em>推测预分配</em>来分配经过EOF的块。这避免了由于NFS服务器上的并发流式写入工作负载而导致的文件碎片。默认情况下，这个预分配随着文件的大小而增加，并在“du”输出中显而易见。如果具有推测预分配的文件在五分钟内未被弄脏，则预分配将被丢弃。如果inode在该时间之前从高速缓存中循环，那么当inode被回收时，预分配将被丢弃。</p>
<p>如果由于预测性预分配而导致ENOSPC过早出现问题，则可以使用挂载选项来指定固定的预分配量。 <code>-o allocsize=*amount*</code></p>
</li>
<li><p>碎片相关的工具</p>
<p>由于启发式和行为（如延迟分配和推测预分配），碎片在XFS文件系统中很少成为一个重要问题。但是，存在用于测量文件系统碎片以及碎片整理文件系统的工具。他们的使用是不鼓励的。</p>
<p>该<code>xfs_db frag</code>命令会尝试将所有文件系统分配提取到单个碎片编号中，以百分比表示。命令的输出需要大量的专业知识来理解其含义。例如，75％的碎片因子意味着每个文件只有平均4个范围。出于这个原因，xfs_db的frag的输出不被认为是有用的，并且推荐对所有碎片问题进行更仔细的分析.</p>
<p>ext3 、ext4与 XFS的命令比较</p>
</li>
</ul>
<p>下表将ext3和ext4中使用的常用命令与特定于XFS的对应项进行了比较。.</p>
<p><strong>ext3 、ext4与 XFS的命令比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>任务</th>
<th>ext3/4</th>
<th>XFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建一个文件系统</td>
<td><code>mkfs.ext4</code> or <code>mkfs.ext3</code></td>
<td><code>mkfs.xfs</code></td>
</tr>
<tr>
<td>文件系统检查</td>
<td><code>e2fsck</code></td>
<td><code>xfs_repair</code></td>
</tr>
<tr>
<td>调整文件系统的大小</td>
<td><code>resize2fs</code></td>
<td><code>xfs_growfs</code></td>
</tr>
<tr>
<td>保存文件系统的图像</td>
<td><code>e2image</code></td>
<td><code>xfs_metadump</code> and <code>xfs_mdrestore</code></td>
</tr>
<tr>
<td>标记或调整文件系统</td>
<td><code>tune2fs</code></td>
<td><code>xfs_admin</code></td>
</tr>
<tr>
<td>备份文件系统</td>
<td><code>dump</code> and <code>restore</code></td>
<td><code>xfsdump</code> and <code>xfsrestore</code></td>
</tr>
</tbody>
</table>
</div>
<p>下表列出了在XFS文件系统上运行的通用工具，但XFS版本具有更多特定的功能，因此建议使用这些工具.</p>
<p><strong>用于ext4 和 XFS的工具</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Task</th>
<th>ext4</th>
<th>XFS</th>
</tr>
</thead>
<tbody>
<tr>
<td>定额</td>
<td><code>quota</code></td>
<td><code>xfs_quota</code></td>
</tr>
<tr>
<td>文件映射</td>
<td><code>filefrag</code></td>
<td><code>xfs_bmap</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="EXT3文件系统"><a href="#EXT3文件系统" class="headerlink" title="EXT3文件系统"></a>EXT3文件系统</h1><p>ext3文件系统本质上是ext2文件系统的增强版本。这些改进提供了以下优点:</p>
<ul>
<li><p>可用性</p>
<p>在发生意外的电源故障或系统崩溃（也称为<em>不清洁的系统关闭</em>）之后，必须通过<code>e2fsck</code>程序检查机器上每个安装的ext2文件系统的一致性。这是一个耗时的过程，可以显着延迟系统启动时间，特别是对于包含大量文件的大卷而言。在此期间，卷上的任何数据都无法访问。</p>
<p>可以<code>fsck -n</code>在一个活的文件系统上运行。但是，如果遇到部分写入的元数据，则不会做出任何更改并可能导致误导结果。</p>
<p>如果在堆栈中使用LVM，则另一个选择是取得文件系统的LVM快照并<code>fsck</code>在其上运行。</p>
<p>最后，可以选择以只读方式重新挂载文件系统。所有挂起的元数据更新（和写入）然后在重新装入之前强制到磁盘。这确保文件系统处于一致的状态，只要没有以前的损坏。现在可以运行了<code>fsck -n</code>。</p>
<p>ext3文件系统提供的日志功能意味着在系统不正常关闭后，不再需要这种文件系统检查。使用ext3进行一致性检查的唯一时间是在某些罕见的硬件故障情况下，例如硬盘故障。系统不正常关闭后恢复ext3文件系统的时间不取决于文件系统的大小或文件的数量; 相反，这取决于用来保持一致性的<em>日志</em>的大小。根据硬件的速度，默认的日志大小需要大约一秒的恢复时间.</p>
</li>
<li><p>数据的完整性</p>
<p>ext3文件系统防止发生不洁系统关闭时丢失数据完整性。ext3文件系统允许您选择数据收到的保护类型和级别。关于文件系统的状态，ext3卷默认配置为保持高水平的数据一致性.</p>
</li>
<li><p>速度</p>
<p>尽管多次写入一些数据，ext3在大多数情况下比ext2具有更高的吞吐量，因为ext3的日志优化了硬盘驱动器的磁头运动。您可以从三种日志模式中进行选择以优化速度，但是如果系统出现故障，则意味着在数据完整性方面进行权衡.</p>
</li>
</ul>
<ul>
<li><p>轻松过渡</p>
<p>从ext2迁移到ext3非常容易，并且无需重新格式化即可从强大的日志文件系统中获益。有关如何执行此任务的更多信息。</p>
</li>
</ul>
<h2 id="创建-Ext3-文件系统"><a href="#创建-Ext3-文件系统" class="headerlink" title="创建 Ext3 文件系统"></a>创建 Ext3 文件系统</h2><p>安装之后，有时需要创建一个新的ext3文件系统。例如，如果将新的磁盘驱动器添加到系统中，则可能需要对驱动器进行分区并使用ext3文件系统.</p>
<p>  创建一个ext3文件系统的步骤如下:</p>
<p><strong>创建一个ext3文件系统</strong></p>
<p>1.使用<code>mkfs.ext3</code>格式化分区ext3文件系统或LVM卷 .</p>
<ol>
<li>使用 <code>e2label</code>标签文件系统.</li>
</ol>
<p>也可以为文件系统设置特定的UUID。要在创建文件系统时指定UUID，请使用以下<code>-U</code>选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext3 -U UUID /dev/device</span></span><br></pre></td></tr></table></figure>
<p>将<em>UUID</em>替换为您要设置的UUID ,例如<code>7cd65de3-e0be-41d9-b66d-96d749c02da7</code>。将设备替换为<code>ext3</code>件系统以添加UUID：例如<code>sda8</code></p>
<h2 id="转换为EXT3文件系统"><a href="#转换为EXT3文件系统" class="headerlink" title="转换为EXT3文件系统"></a>转换为EXT3文件系统</h2><p><code>tune2fs</code> 命令将 <code>ext2</code> 文件系统转换为 <code>ext3</code>.</p>
<p><strong>注意</strong></p>
<p>要将ext2转换为ext3 ,请始终使用该<code>e2fsck</code> 实用程序在使用前后检查文件系统 <code>tune2fs</code>. 在尝试将ext2转换为ext3之前, 备份所有文件系统以防发生任何错误.</p>
<p>另外，Red Hat建议创建一个新的ext3文件系统并将数据迁移到它，而不是从ext2转换为ext3.</p>
<p>要将 <code>ext2</code> 文件系统转换为 <code>ext3</code>,请以root用户身份登录，然后在终端中键入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune2fs -j block_device</span></span><br></pre></td></tr></table></figure>
<p><em>block_device</em> 包含要转换的ext2文件系统.</p>
<p> <code>df</code> 命令以显示已安装的文件系统.</p>
<h2 id="恢复到EXT2文件系统"><a href="#恢复到EXT2文件系统" class="headerlink" title="恢复到EXT2文件系统"></a>恢复到EXT2文件系统</h2><p>为了恢复到ext2文件系统，请使用以下步骤.</p>
<p>为简单起见，本节中的示例命令对块设备使用以下值:</p>
<p><code>/dev/mapper/VolGroup00-LogVol02</code></p>
<p><strong>从ext3恢复到ext2</strong></p>
<ol>
<li>以root身份登录并键入以下命令卸载分区:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># umount /dev/mapper/VolGroup00-LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>通过输入以下命令将文件系统类型更改为ext2:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tune2fs -O ^has_journal /dev/mapper/VolGroup00-LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>输入以下命令来检查分区是否有错误:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># e2fsck -y /dev/mapper/VolGroup00-LogVol02</span></span><br></pre></td></tr></table></figure>
<ol>
<li>然后通过键入以下命令再次将分区挂载为ext2文件系统:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -t ext2 /dev/mapper/VolGroup00-LogVol02 /mount/point</span></span><br></pre></td></tr></table></figure>
<p>   在上述命令中, 将 <em>/mount/point</em> 替换为分区的挂载点.</p>
<p>   <strong>注意</strong></p>
<p>   如果 <code>.journal</code>文件存在于分区的根目录下，请将其删除.</p>
<p>要将分区永久更改为 ext2, 请记住更新该 <code>/etc/fstab</code> 文件, 则将在引导后恢复.</p>
<h1 id="EXT4文件系统"><a href="#EXT4文件系统" class="headerlink" title="EXT4文件系统"></a>EXT4文件系统</h1><p>ext4文件系统是ext3文件系统的可扩展扩展。使用红帽企业版Linux 7，它可以支持最大单个文件大小为16 TB，文件系统最大支持50 TB，而红帽企业版Linux 6仅支持高达16 TB的文件系统。它也支持无限数量的子目录（ext3文件系统最多只支持32,000个），但是一旦链接数量超过了65,000，它将重置为1，不再增加。bigalloc功能目前不支持.</p>
<p><strong>注意</strong></p>
<p>和ext3一样，一个ext4卷必须被卸载才能执行<code>fsck</code>.</p>
<ul>
<li><p>主要特点</p>
<p>Ext4使用扩展（与ext2和ext3使用的传统块映射方案相反），这可以提高使用大型文件时的性能，并减少大型文件的元数据开销。此外，ext4还会相应地标记未分配的块组和inode表段，这样可以在文件系统检查过程中跳过它们。这使得文件系统检查更快，随着文件系统规模的扩大，这种检查变得更加有利</p>
</li>
<li><p>分配功能</p>
<p>ext4文件系统具有以下分配方案：<br>持续的预分配<br>延迟分配<br>多块分配<br>条纹感知分配<br>由于延迟分配和其他性能优化，ext4将文件写入磁盘的行为与ext3不同。在ext4中，当程序写入文件系统时，除非程序<code>fsync()</code>发起调用，否则不能保证在磁盘上</p>
</li>
</ul>
<p>默认情况下，即使没有，ext3也会立即强制新建文件到磁盘<br><code>fsync()</code>。这种行为隐藏了一些程序中没有<code>fsync()</code>用来确保写入数据在磁盘上的错误。另一方面，ext4文件系统通常会等待几秒钟才能写出对磁盘的更改，从而允许它对写入进行组合和重新排序以获得比ext3更好的磁盘性能.</p>
<p>与ext3不同，ext4文件系统在事务提交时不强制数据到磁盘。因此，将缓冲的写入刷新到磁盘需要更长的时间。与任何文件系统一样，使用数据完整性调用<code>fsync()</code>来确保将数据写入永久存储.</p>
<ul>
<li><p>其他Ext4功能</p>
<p>ext4文件系统还支持以下内容:<br>扩展属性（xattr） - 这允许系统为每个文件关联几个附加的名称和值对。<br>配额日志 - 这可避免在崩溃后需要进行冗长的配额一致性检查。</p>
</li>
</ul>
<h2 id="创建一个Ext4文件系统"><a href="#创建一个Ext4文件系统" class="headerlink" title="创建一个Ext4文件系统"></a>创建一个Ext4文件系统</h2><p>要创建一个ext4文件系统，请使用<code>mkfs.ext4</code> 命令。一般来说，默认选项对于大多数使用情况是最佳的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 /dev/device</span></span><br></pre></td></tr></table></figure>
<p>以下是此命令的输出示例，它显示了生成的文件系统几何图形和特征:</p>
<p><strong>mkfs.ext4 Command Output</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)d</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">245280 inodes, 979456 blocks</span><br><span class="line">48972 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=1006632960</span><br><span class="line">30 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8176 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line"> 32768, 98304, 163840, 229376, 294912, 819200, 884736</span><br><span class="line"></span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (16384 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>对于条带块设备（例如RAID5阵列），可以在创建文件系统时指定条带几何。使用适当的条纹几何形状极大地提高了ext4文件系统的性能.</p>
<p>  在LVM或MD卷上创建文件系统时, <code>mkfs.ext4</code> 选择最佳几何体。在将几何信息输出到操作系统的某些硬件RAID上，这也可能是正确的.</p>
<p>要指定条状结构,使用<code>-E</code> ,<code>mkfs.ext4</code>（即，扩展文件系统选项）具有以下子选项</p>
<ul>
<li><p>stride=<em>value</em></p>
<p>指定RAID块大小.</p>
</li>
<li><p>stripe-width=<em>value</em></p>
<p>指定RAID设备中的数据磁盘数量，或条带中的条带单元数量.</p>
</li>
</ul>
<p>对于这两个子选项, <code>*value*</code> 必须在文件系统块单位中指定. 例如，要在4k块文件系统上创建一个带有64k步长（即16 x 4096）的文件系统，请使用以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext4 -E stride=16,stripe-width=64 /dev/device</span></span><br></pre></td></tr></table></figure>
<p><strong>重要</strong></p>
<p>可以使用 <code>tune2fs</code> 在ext3文件系统上开启某些ext4功能. 但是,  <code>tune2fs</code> 以这种方式使用还没有经过充分的测试，因此在红帽企业版Linux 7中不支持。因此，红帽无法保证通过使用转换或挂载的ext3文件系统的一致性能和可预测的行为 <code>tune2fs</code>.</p>
<p>It is also possible to set a specific UUID for a file system. To specify a UUID when creating a file system, use the <code>-U</code> option:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkfs.ext4 -U UUID &#x2F;dev&#x2F;device</span><br></pre></td></tr></table></figure>
<p>将<em>UUID</em>替换为您要设置的UUID,例如 <code>7cd65de3-e0be-41d9-b66d-96d749c02da7</code>. 将<em>设备</em>替换为 ext4文件系统以添加UUID：例如, <code>sda8</code>.</p>
<h2 id="挂载EXT4文件系统"><a href="#挂载EXT4文件系统" class="headerlink" title="挂载EXT4文件系统"></a>挂载EXT4文件系统</h2><p>一个ext4文件系统可以挂载，没有额外的选项。例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<p>ext4文件系统也支持多个挂载选项来影响行为。例如，<code>acl</code>参数启用访问控制列表，而<code>user_xattr</code>参数启用用户扩展属性。要启用这两个选项，请使用它们各自的参数<code>-o</code>，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o acl,user_xattr /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<p>和ext3一样，<code>data_err=abort</code>如果在文件数据中发生错误，该选项可以用来中止日志.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o data_err=abort /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<p>该<code>tune2fs</code>实用程序还允许管理员在文件系统超级块中设置默认挂载选项。有关这方面的更多信息，请参阅<code>man tune2fs</code>.</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>默认情况下，ext4使用写入屏障来确保文件系统完整性，即使启用写入缓存的设备断电也是如此。对于没有写入缓存的设备或使用电池供电的写入缓存，请使用<code>nobarrier</code>选项禁用屏障，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount -o nobarrier /dev/device /mount/point</span></span><br></pre></td></tr></table></figure>
<h2 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h2><p>从红帽企业版Linux 7.3开始，<code>Direct Access</code>（DAX）作为ext4和XFS文件系统上的技术预览版提供了应用程序将持久内存直接映射到其地址空间的方法。要使用DAX，系统必须具有某种形式的持久性内存，通常以一个或多个非易失性双列直插式内存模块（NVDIMM）的形式提供，并且必须在NVDIMM上创建支持DAX的文件系统（ S）。此外，文件系统必须使用<code>dax</code>安装选项进行安装。然后，<code>mmap</code>安装在dax上的文件系统上的一个文件将导致存储直接映射到应用程序的地址空间.</p>
<h2 id="调整EXT4文件系统的大小"><a href="#调整EXT4文件系统的大小" class="headerlink" title="调整EXT4文件系统的大小"></a>调整EXT4文件系统的大小</h2><p>在扩展ext4文件系统之前，请确保底层的块设备具有适当的大小以便稍后保存文件系统。为受影响的块设备使用适当的调整大小的方法.</p>
<p>ext4文件系统可以在使用以下<code>resize2fs</code>命令挂载时扩展:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resize2fs /mount/device size</span></span><br></pre></td></tr></table></figure>
<p>该<code>resize2fs</code>命令还可以减小<em>未挂载的</em> ext4文件系统的大小:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resize2fs /dev/device size</span></span><br></pre></td></tr></table></figure>
<p>在调整ext4文件系统<code>resize2fs</code>的大小时，实用程序将以文件系统块大小为单位读取大小，除非使用了指定特定单元的后缀。以下后缀表示特定单位:</p>
<ul>
<li><code>s</code> —  512字节的扇区</li>
<li><code>K</code> — 千字节</li>
<li><code>M</code> — 兆字节</li>
<li><code>G</code> — 千兆字节</li>
</ul>
<p><strong>注意</strong></p>
<p>size参数在扩展时是可选的（通常是冗余的）。所述<code>resize2fs</code>自动膨胀以填充所述容器的所有可用空间，通常是一个逻辑卷或分区。</p>
<p>有关调整ext4文件系统大小的更多信息，请参阅 <code>man resize2fs</code>.</p>
<h2 id="备份-ext2-3-4-文件系统"><a href="#备份-ext2-3-4-文件系统" class="headerlink" title="备份 ext2/3/4 文件系统"></a>备份 ext2/3/4 文件系统</h2><p><strong>备份 ext2/3/4 **</strong>文件系统备份的一个例子**</p>
<ol>
<li>在尝试进行任何类型的恢复操作之前，必须备份所有数据。数据备份应该定期进行。除了数据之外，还有应该保存的配置信息，包括<code>/etc/fstab</code>和输出<code>fdisk -l</code>。运行sosreport/sysreport将会捕获这些信息，强烈推荐</li>
<li>.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/fstab</span></span><br><span class="line">LABEL=/            /               ext3    defaults        1 1</span><br><span class="line">LABEL=/boot1       /boot           ext3    defaults        1 2</span><br><span class="line">LABEL=/data        /data           ext3    defaults        0 0</span><br><span class="line">tmpfs              /dev/shm        tmpfs   defaults        0 0</span><br><span class="line">devpts             /dev/pts        devpts  gid=5,mode=620  0 0</span><br><span class="line">sysfs              /sys            sysfs   defaults        0 0</span><br><span class="line">proc               /proc           proc    defaults        0 0</span><br><span class="line">LABEL=SWAP-sda5    swap            swap    defaults        0 0</span><br><span class="line">/dev/sda6          /backup-files   ext3    defaults        0 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># fdisk -l</span></span><br><span class="line">   Device Boot    Start      End    Blocks      Id  System</span><br><span class="line">/dev/sda1 *           1       13    104391      83  Linux</span><br><span class="line">/dev/sda2            14      1925   15358140    83  Linux</span><br><span class="line">/dev/sda3          1926      3200   10241437+   83  Linux</span><br><span class="line">/dev/sda4          3201      4864   13366080    5   Extended</span><br><span class="line">/dev/sda5          3201      3391   1534176     82  Linux swap / Solaris</span><br><span class="line">/dev/sda6          3392      4864   11831841    83  Linux</span><br></pre></td></tr></table></figure>
<p>   在这个例子中，我们将使用<code>/dev/sda6</code>分区来保存备份文件，我们假设它<code>/dev/sda6</code>被挂载<code>/backup-files</code>.</p>
<ol>
<li>如果要备份的分区是操作系统分区，请将系统启动到单用户模式。正常的数据分区不需要这一步.</li>
<li>使用<code>dump</code>备份分区的内容:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dump -0uf /backup-files/sda1.dump /dev/sda1</span></span><br><span class="line"><span class="comment"># dump -0uf /backup-files/sda2.dump /dev/sda2</span></span><br><span class="line"><span class="comment"># dump -0uf /backup-files/sda3.dump /dev/sda3</span></span><br></pre></td></tr></table></figure>
<p>   <strong>注意</strong></p>
<p>   如果系统已经运行了很长时间，建议<code>e2fsck</code>在备份之前在分区上运行.</p>
<p>   <strong>重要</strong></p>
<p>   备份操作系统分区时，必须卸载该分区。</p>
<p>尽管挂载时可以备份普通数据分区，但建议尽可能将其卸载。尝试备份安装的数据分区的结果可能是不可预知的。</p>
<p>如果您需要备份使用的挂载文件系统<code>dump</code>，请在文件系统不负载较重的情况下进行备份。备份时文件系统上发生的活动越多，备份损坏的风险就越高。</p>
<p>   如果你想做远程备份，你可以同时使用ssh或者配置非密码登录:</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dump -0u -f - /dev/sda1 | ssh root@remoteserver.example.com dd of=/tmp/sda1.dump</span></span><br></pre></td></tr></table></figure>
<p>   <strong>注意</strong></p>
<p>   如果使用标准重定向，该<code>-f</code>选项必须单独传递。</p>
<h2 id="恢复ext2-3-4-文件系统"><a href="#恢复ext2-3-4-文件系统" class="headerlink" title="恢复ext2/3/4 文件系统"></a>恢复ext2/3/4 文件系统</h2><p><strong> ext2/3/4 </strong>文件系统恢复示例<em>**</em></p>
<ol>
<li><p>如果您要还原操作系统分区，请将系统引导至Rescue Mode（救援模式）。普通数据分区不需要这一步。</p>
</li>
<li><p>使用  <code>fdisk</code> 命令重建sda1/sda2/sda3/sda4/sda5 by using the.</p>
<p><strong>注意</strong></p>
<p>如有必要，创建分区以包含还原的文件系统。新的分区必须足够大以包含还原的数据。开始和结束数字是正确的。这些是分区的起始和结束扇区号。</p>
</li>
<li><p>使用 <code>mkfs</code> 命令, 格式化目标分区，如下所示.</p>
<p><strong>重要</strong></p>
<p>不要格式化 <code>/dev/sda6</code>  因为它保存了备份文件.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.ext3 /dev/sda1</span></span><br><span class="line"><span class="comment"># mkfs.ext3 /dev/sda2</span></span><br><span class="line"><span class="comment"># mkfs.ext3 /dev/sda3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果创建新的分区，重新标记所有分区，以便它们匹配 <code>fstab</code>文件. 如果没有重新创建分区，则不需要执行此步骤.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># e2label /dev/sda1 /boot1</span></span><br><span class="line"><span class="comment"># e2label /dev/sda2 /</span></span><br><span class="line"><span class="comment"># e2label /dev/sda3 /data</span></span><br><span class="line"><span class="comment"># mkswap -L SWAP-sda5 /dev/sda5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>准备工作目录.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /mnt/sda1</span></span><br><span class="line"><span class="comment"># mount -t ext3 /dev/sda1 /mnt/sda1</span></span><br><span class="line"><span class="comment"># mkdir /mnt/sda2</span></span><br><span class="line"><span class="comment"># mount -t ext3 /dev/sda2 /mnt/sda2</span></span><br><span class="line"><span class="comment"># mkdir /mnt/sda3</span></span><br><span class="line"><span class="comment"># mount -t ext3 /dev/sda3 /mnt/sda3</span></span><br><span class="line"><span class="comment"># mkdir /backup-files</span></span><br><span class="line"><span class="comment"># mount -t ext3 /dev/sda6 /backup-files</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复数据.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /mnt/sda1</span></span><br><span class="line"><span class="comment"># restore -rf /backup-files/sda1.dump</span></span><br><span class="line"><span class="comment"># cd /mnt/sda2</span></span><br><span class="line"><span class="comment"># restore -rf /backup-files/sda2.dump</span></span><br><span class="line"><span class="comment"># cd /mnt/sda3</span></span><br><span class="line"><span class="comment"># restore -rf /backup-files/sda3.dump</span></span><br></pre></td></tr></table></figure>
<p>如果要从远程主机进行还原或从远程主机上的备份文件进行还原，则可以使用ssh或rsh。您将需要为以下示例配置无密码登录:</p>
<p>登录到10.0.0.87，并从本地sda1.dump文件恢复sda1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh 10.0.0.87 "cd /mnt/sda1 &amp;&amp; cat /backup-files/sda1.dump | restore -rf -"</span></span><br></pre></td></tr></table></figure>
<p>登录到10.0.0.87，并从远程10.66.0.124 sda1.dump文件恢复sda1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh 10.0.0.87 "cd /mnt/sda1 &amp;&amp; RSH=/usr/bin/ssh restore -r -f 10.66.0.124:/tmp/sda1.dump"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Reboot.</p>
</li>
</ol>
<h2 id="其他EXT4文件系统工具"><a href="#其他EXT4文件系统工具" class="headerlink" title="其他EXT4文件系统工具"></a>其他EXT4文件系统工具</h2><p>红帽企业版Linux 7还提供了用于管理ext4文件系统的其他实用程序:</p>
<ul>
<li><p>e2fsck</p>
<p>用于修复ext4文件系统。这个工具比ext3更有效地检查和修复ext4文件系统，这要归功于ext4磁盘结构的更新.</p>
</li>
<li><p>e2label</p>
<p>更改ext4文件系统上的标签。这个工具也适用于ext2和ext3文件系统.</p>
</li>
<li><p>quota</p>
<p>控制和报告ext4文件系统上用户和组的磁盘空间（块）和文件（inode）使用情况.</p>
</li>
<li><p>fsfreeze</p>
<p>要暂停对文件系统的访问，请使用该命令将其冻结并解冻。这会暂停对文件系统的访问，并在磁盘上创建一个稳定的映像。 <code># fsfreeze -f *mount-point*``# fsfreeze -u *mount-point*</code>.</p>
<p>​</p>
</li>
</ul>
<p>该<code>tune2fs</code>实用程序还可以调整ext2，ext3和ext4文件系统的可配置文件系统参数。另外，以下工具在调试和分析ext4文件系统时也很有用：:</p>
<ul>
<li><p>debugfs</p>
<p>调试ext2，ext3或ext4文件系统.</p>
</li>
<li><p>e2image</p>
<p>调试ext2，ext3或ext4文件系统.</p>
</li>
</ul>
<p>有关这些实用程序的更多信息，请参阅各自的<code>man</code>页面.</p>
<h1 id="BTRFS（技术预览）"><a href="#BTRFS（技术预览）" class="headerlink" title="BTRFS（技术预览）"></a>BTRFS（技术预览）</h1><p><strong>注意</strong></p>
<p>Btrfs在红帽企业版Linux 7中作为技术预览功能提供，但自从红帽企业版Linux 7.4发行版以来已经被弃用了。它将在未来的红帽企业Linux主要版本中被删除.</p>
<p>Btrfs是下一代Linux文件系统，提供先进的管理，可靠性和可扩展性功能。它在提供快照，压缩和集成设备管理方面是独一无二的。</p>
<h2 id="创建一个btrfs文件系统"><a href="#创建一个btrfs文件系统" class="headerlink" title="创建一个btrfs文件系统"></a>创建一个btrfs文件系统</h2><p>为了建立一个基本的btrfs文件系统，使用下面的命令:</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs /dev/device</span></span><br></pre></td></tr></table></figure>
<h2 id="挂载一个BTRFS文件系统"><a href="#挂载一个BTRFS文件系统" class="headerlink" title="挂载一个BTRFS文件系统"></a>挂载一个BTRFS文件系统</h2><p>要在btrfs文件系统中安装任何设备，请使用以下命令:</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/device /mount-point</span></span><br></pre></td></tr></table></figure>
<p>其他有用的安装选项包括:</p>
<ul>
<li><p>device=/<em>dev</em>/<em>name</em></p>
<p>将此选项附加到mount命令会告诉btrfs为指定的设备扫描btrfs卷。这用于确保挂载将成功，因为尝试挂载不是btrfs的设备将导致挂载失败。</p>
</li>
<li><p>max_inline=<em>number</em></p>
<p>使用此选项可设置可用于在元数据B树叶中内联数据的最大空间量（以字节为单位）。默认是8192字节。对于4k页面，由于需要适合叶子的附加头文件，它被限制为3900字节</p>
</li>
<li><p>alloc_start=<em>number</em></p>
<p>使用此选项可以设置磁盘分配的起始位置。</p>
</li>
<li><p>thread_pool=<em>number</em></p>
<p>使用此选项分配分配的工作线程数。</p>
</li>
<li><p>discard</p>
<p>使用此选项可以释放释放块上的TRIM。</p>
</li>
<li><p>noacl</p>
<p>使用此选项禁用ACL的使用。</p>
</li>
<li><p>space_cache</p>
<p>使用此选项将可用空间数据存储在磁盘上，以便更快地缓存块组。这是一个持久的变化，可以安全地引导到旧的内核。</p>
</li>
<li><p>nospace_cache</p>
<p>使用此选项可禁用上述功能<code>space_cache</code>。</p>
</li>
<li><p>clear_cache</p>
<p>在安装过程中使用此选项清除所有可用空间缓存。这是一个安全的选项，但会触发空间缓存重建。因此，请保持文件系统安装，以便重建过程完成。此安装选项旨在仅在问题出现在可用空间后才能使用。</p>
</li>
<li><p>enospc_debug</p>
<p>这个选项用于调试“没有剩余空间”的问题。</p>
</li>
<li><p>recovery</p>
<p>使用此选项可以在安装时启用自动恢复。</p>
</li>
</ul>
<h2 id="调整BTRFS文件系统的大小"><a href="#调整BTRFS文件系统的大小" class="headerlink" title="调整BTRFS文件系统的大小"></a>调整BTRFS文件系统的大小</h2><p>无法调整btrfs文件系统的大小，但可以调整其使用的每个设备的大小。如果只有一个设备正在使用，那么这与调整文件系统的大小相同。如果有多个设备正在使用，则必须手动调整大小以达到预期的效果。</p>
<p><strong>注意</strong></p>
<p>单位大小不是特定的情况; 它接受两者<code>G</code>或<code>g</code>GiB。</p>
<p>该命令不接受<code>t</code>千兆字节或千兆<code>p</code>字节。它只接受<code>k</code>，<code>m</code>和<code>g</code>。</p>
<h2 id="扩大btrfs文件系统"><a href="#扩大btrfs文件系统" class="headerlink" title="扩大btrfs文件系统"></a>扩大btrfs文件系统</h2><p>To enlarge the file system on a single device, use the command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize +200M /btrfssingle</span></span><br><span class="line">Resize <span class="string">'/btrfssingle'</span> of <span class="string">'+200M'</span></span><br></pre></td></tr></table></figure>
<p>要放大多设备文件系统，必须指定要放大的设备。首先，显示具有指定挂载点的btrfs文件系统的所有设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /btrfstest</span></span><br><span class="line">Label: none  uuid: 755b41b7-7a20-4a24-abb3-45fdbed1ab39</span><br><span class="line">	Total devices 4 FS bytes used 192.00KiB</span><br><span class="line">	devid    1 size 1.00GiB used 224.75MiB path /dev/vdc</span><br><span class="line">	devid    2 size 524.00MiB used 204.75MiB path /dev/vdd</span><br><span class="line">	devid    3 size 1.00GiB used 8.00MiB path /dev/vde</span><br><span class="line">	devid    4 size 1.00GiB used 8.00MiB path /dev/vdf</span><br><span class="line"></span><br><span class="line">Btrfs v3.16.2</span><br></pre></td></tr></table></figure>
<p>然后，在识别<code>devid</code>要放大的设备之后，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize devid:amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize 2:+200M /btrfstest</span></span><br><span class="line">Resize <span class="string">'/btrfstest/'</span> of <span class="string">'2:+200M'</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p> <em>amount</em> 也可以是 <code>max</code> 代替特定量。这将使用设备上剩余的所有空间。</p>
<h2 id="缩小btrfs文件系统"><a href="#缩小btrfs文件系统" class="headerlink" title="缩小btrfs文件系统"></a>缩小btrfs文件系统</h2><p>要在单个设备上缩小文件系统，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize -200M /btrfssingle</span></span><br><span class="line">Resize <span class="string">'/btrfssingle'</span> of <span class="string">'-200M'</span></span><br></pre></td></tr></table></figure>
<p>要缩小多设备文件系统，必须指定要收缩的设备。首先，显示具有指定挂载点的btrfs文件系统的所有设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /btrfstest</span></span><br><span class="line">Label: none  uuid: 755b41b7-7a20-4a24-abb3-45fdbed1ab39</span><br><span class="line">	Total devices 4 FS bytes used 192.00KiB</span><br><span class="line">	devid    1 size 1.00GiB used 224.75MiB path /dev/vdc</span><br><span class="line">	devid    2 size 524.00MiB used 204.75MiB path /dev/vdd</span><br><span class="line">	devid    3 size 1.00GiB used 8.00MiB path /dev/vde</span><br><span class="line">	devid    4 size 1.00GiB used 8.00MiB path /dev/vdf</span><br><span class="line"></span><br><span class="line">Btrfs v3.16.2</span><br></pre></td></tr></table></figure>
<p>然后，在识别<code>devid</code>要缩小的设备之后，使用以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize devid:amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize 2:-200M /btrfstest</span></span><br><span class="line">Resize <span class="string">'/btrfstest'</span> of <span class="string">'2:-200M'</span></span><br></pre></td></tr></table></figure>
<h2 id="设置文件系统大小"><a href="#设置文件系统大小" class="headerlink" title="设置文件系统大小"></a>设置文件系统大小</h2><p>要在单个设备上将文件系统设置为特定大小，请使用以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize 700M /btrfssingle</span></span><br><span class="line">Resize <span class="string">'/btrfssingle'</span> of <span class="string">'700M'</span></span><br></pre></td></tr></table></figure>
<p>要设置多设备文件系统的文件系统大小，必须指定要更改的设备。首先，显示在指定的挂载点上具有btrfs文件系统的所有设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem show /btrfstest</span></span><br><span class="line">Label: none  uuid: 755b41b7-7a20-4a24-abb3-45fdbed1ab39</span><br><span class="line">	Total devices 4 FS bytes used 192.00KiB</span><br><span class="line">	devid    1 size 1.00GiB used 224.75MiB path /dev/vdc</span><br><span class="line">	devid    2 size 724.00MiB used 204.75MiB path /dev/vdd</span><br><span class="line">	devid    3 size 1.00GiB used 8.00MiB path /dev/vde</span><br><span class="line">	devid    4 size 1.00GiB used 8.00MiB path /dev/vdf</span><br><span class="line"></span><br><span class="line">Btrfs v3.16.2</span><br></pre></td></tr></table></figure>
<p>然后，在识别出<code>devid</code>要更改的设备后，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize devid:amount /mount-point</span></span><br></pre></td></tr></table></figure>
<p>For example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem resize 2:300M /btrfstest</span></span><br><span class="line">Resize <span class="string">'/btrfstest'</span> of <span class="string">'2:300M'</span></span><br></pre></td></tr></table></figure>
<h2 id="多个设备的集成卷管理"><a href="#多个设备的集成卷管理" class="headerlink" title="多个设备的集成卷管理"></a>多个设备的集成卷管理</h2><p>可以在许多设备上创建btrfs文件系统，在创建文件系统之后可以添加更多的设备。默认情况下，元数据将在两台设备之间镜像，数据将在所有设备上进行分条，但是如果只有一台设备，元数据将在该设备上复制。</p>
<h2 id="使用多个设备创建文件系统"><a href="#使用多个设备创建文件系统" class="headerlink" title="使用多个设备创建文件系统"></a>使用多个设备创建文件系统</h2><p>The <code>mkfs.btrfs</code> 命令接受数据选项和元数据选项。有效的规格是： <code>-d</code> for data, and <code>-m</code> for metadata. 有效的规格是:</p>
<ul>
<li><code>raid0</code></li>
<li><code>raid1</code></li>
<li><code>raid10</code></li>
<li><code>dup</code></li>
<li><code>single</code></li>
</ul>
<p>该<code>-m single</code>选项指示不会重复元数据。这在使用硬件RAID时可能是需要的。</p>
<p><strong>注意</strong></p>
<p>RAID 10至少需要四台设备才能正常运行。</p>
<p><strong>创建一个RAID 10 btrfs文件系统</strong></p>
<p>在四个设备上创建一个文件系统（元数据镜像，数据条带化）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs /dev/device1 /dev/device2 /dev/device3 /dev/device4</span></span><br></pre></td></tr></table></figure>
<p>在不镜像的情况下分割元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs -m raid0 /dev/device1 /dev/device2</span></span><br></pre></td></tr></table></figure>
<p>将raid10用于数据和元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs -m raid10 -d raid10 /dev/device1 /dev/device2 /dev/device3 /dev/device4</span></span><br></pre></td></tr></table></figure>
<p>不要在单个驱动器上复制元数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs -m single /dev/device</span></span><br></pre></td></tr></table></figure>
<p><code>single</code>当驱动器大小不同时， 使用该选项可以使用每个驱动器的全部容量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs -d single /dev/device1 /dev/device2 /dev/device3</span></span><br></pre></td></tr></table></figure>
<p>要将新设备添加到已创建的多设备文件系统，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs device add /dev/device1 /mount-point</span></span><br></pre></td></tr></table></figure>
<p>在重新启动或重新加载btrfs模块之后，使用该<code>btrfs device scan</code>命令来发现所有多设备文件系统。</p>
<h3 id="扫描btrfs设备"><a href="#扫描btrfs设备" class="headerlink" title="扫描btrfs设备"></a>扫描btrfs设备</h3><p>使用<code>btrfs device scan</code>扫描下的所有块设备<code>/dev</code>和探测BTRFS卷。如果使用文件系统中的多个设备运行，则必须在加载btrfs模块后执行此操作。</p>
<p>要扫描所有设备，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs device scan</span></span><br></pre></td></tr></table></figure>
<p>要扫描单个设备，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs device scan /dev/device</span></span><br></pre></td></tr></table></figure>
<h3 id="将新设备添加到btrfs文件系统"><a href="#将新设备添加到btrfs文件系统" class="headerlink" title="将新设备添加到btrfs文件系统"></a>将新设备添加到btrfs文件系统</h3><p>使用该<code>btrfs filesystem show</code>命令列出所有btrfs文件系统以及它们包含的设备。</p>
<p>该<code>btrfs device add</code>命令用于将新设备添加到已安装的文件系统。</p>
<p>该<code>btrfs filesystem balance</code>命令在所有现有设备之间平衡（重新分配）分配的盘区。</p>
<p>所有这些命令一起添加新设备的示例如下：</p>
<p><strong>添加新设备到btrfs文件系统</strong></p>
<p>首先，创建并挂载一个btrfs文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs /dev/device1</span></span><br><span class="line"><span class="comment"># mount /dev/device1</span></span><br></pre></td></tr></table></figure>
<p>接下来，将第二个设备添加到已安装的btrfs文件系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># btrfs device add &#x2F;dev&#x2F;device2 &#x2F;mount-point</span><br></pre></td></tr></table></figure>
<p>这些设备上的元数据和数据仍然只存储在 <code>/dev/*device1*</code>. 现在必须平衡分布在所有设备上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs filesystem balance /mount-point</span></span><br></pre></td></tr></table></figure>
<p>平衡文件系统需要一些时间，因为它读取文件系统的所有数据和元数据，并在新设备上重写。</p>
<h3 id="转换一个btrfs文件系统"><a href="#转换一个btrfs文件系统" class="headerlink" title="转换一个btrfs文件系统"></a>转换一个btrfs文件系统</h3><p>要将非raid文件系统转换为raid，请添加设备并运行更改块分配配置文件的平衡过滤器。</p>
<p><strong>转换一个btrfs文件系统</strong></p>
<p>要将现有的单个设备系统（<code>/dev/sdb1</code>在这种情况下）转换为两个设备raid1系统以防止单个磁盘发生故障，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount /dev/sdb1 /mnt</span></span><br><span class="line"><span class="comment"># btrfs device add /dev/sdc1 /mnt</span></span><br><span class="line"><span class="comment"># btrfs balance start -dconvert=raid1 -mconvert=raid1 /mnt</span></span><br></pre></td></tr></table></figure>
<p><strong>重要</strong></p>
<p>如果元数据未从单一设备默认转换，则保持为DUP。这并不保证块的副本位于不同的设备上。如果数据未被转换，则根本没有任何多余的副本。</p>
<h4 id="删除btrfs设备"><a href="#删除btrfs设备" class="headerlink" title="删除btrfs设备"></a>删除btrfs设备</h4><p>使用该<code>btrfs device delete</code>命令删除在线设备。它将任何正在使用的扩展区重新分配给文件系统中的其他设备，以便安全地删除。</p>
<p><strong>删除btrfs文件系统上的设备</strong></p>
<p>首先创建并安装几个btrfs文件系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs /dev/sdb /dev/sdc /dev/sdd /dev/sde</span></span><br><span class="line"><span class="comment"># mount /dev/sdb /mnt</span></span><br></pre></td></tr></table></figure>
<p>将一些数据添加到文件系统。</p>
<p>最后，移除所需的设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># btrfs device delete /dev/sdc /mnt</span></span><br></pre></td></tr></table></figure>
<h4 id="替换btrfs文件系统上的失败设备"><a href="#替换btrfs文件系统上的失败设备" class="headerlink" title="替换btrfs文件系统上的失败设备"></a>替换btrfs文件系统上的失败设备</h4><p>如果仍然可以读取超级块，则可以删除brtfs设备呢哦来删除发生故障的设备。但是，如果设备丢失或超级块损坏，文件系统将需要以降级模式进行挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkfs.btrfs -m raid1 /dev/sdb /dev/sdc /dev/sdd /dev/sde</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ssd is destroyed or removed, use -o degraded to force the mount</span><br><span class="line">  to ignore missing devices</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mount -o degraded /dev/sdb /mnt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">'missing'</span> is a special device name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># btrfs device delete missing /mnt</span></span><br></pre></td></tr></table></figure>
<p>该命令<code>btrfs device delete missing</code>将删除由文件系统元数据描述的第一个设备，但在装入文件系统时不会显示该设备。</p>
<p><strong>重要</strong></p>
<ol>
<li><p>这是不可能的，低于特定raid布局所需的最低设备数量，甚至包括缺少的设备。可能需要添加新设备才能删除失败的设备。</p>
<p>例如，对于具有两个设备的raid1布局，如果设备出现故障，则需要：</p>
<ol>
<li>以降级模式挂载，</li>
<li>添加一个新的设备，</li>
<li>并删除丢失的设备。</li>
</ol>
</li>
</ol>
<h3 id="在-etc-fstab文件中注册一个btrfs文件系统"><a href="#在-etc-fstab文件中注册一个btrfs文件系统" class="headerlink" title="在 /etc/fstab文件中注册一个btrfs文件系统"></a>在 <code>/etc/fstab</code>文件中注册一个btrfs文件系统</h3><p>如果您没有安装<code>initrd</code>或不执行btrfs设备扫描，则可以<code>btrfs</code>通过将文件系统中的所有设备明确传递到<code>mount</code>命令来安装多卷文件系统。</p>
<p><strong> /etc/fstab 条目</strong></p>
<p>一个合适的<code>/etc/fstab</code>条目的例子是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb    &#x2F;mnt    btrfs    device&#x3D;&#x2F;dev&#x2F;sdb,device&#x3D;&#x2F;dev&#x2F;sdc,device&#x3D;&#x2F;dev&#x2F;sdd,device&#x3D;&#x2F;dev&#x2F;sde    0</span><br></pre></td></tr></table></figure>
<p>请注意，使用通用唯一标识符（UUID）也可以工作，并且比使用设备路径更稳定。</p>
<h2 id="SSD优化"><a href="#SSD优化" class="headerlink" title="SSD优化"></a>SSD优化</h2><p>使用btrfs文件系统可以优化SSD。有两种方法可以完成。</p>
<p>第一种方法是当单个指定设备的 <code>/sys/block/*device*/queue/rotational</code>为零时， <code>mkfs.btrfs</code> 在单个设备上关闭元数据复制。 这相当于在命令行上指定<code>-m single</code>。 可以通过提供<code>-m dup</code>选项来覆盖它并复制元数据。 由于SSD固件可能会丢失两个副本，所以不需要复制。 这浪费空间并且是性能成本。</p>
<p>第二种方式是通过一组SSD挂载选项: <code>ssd</code>, <code>nossd</code>, and <code>ssd_spread</code>.</p>
<p> <code>ssd</code> 选项有几个作用:</p>
<ul>
<li>它允许更大的元数据集群分配。</li>
<li>它尽可能按顺序分配数据。</li>
<li>它禁用btree叶重写匹配键和块顺序。</li>
<li>它提交日志片段而不分批处理多个进程。</li>
</ul>
<p><strong>注意</strong></p>
<p>在<code>ssd</code>安装选项不但可以让SSD选项。使用该<code>nossd</code>选项来禁用它。</p>
<p>一些固态硬盘在经常重复使用块编号时性能最好，而另一些则在聚类严格分配大量未使用空间时性能更好。默认情况下，<code>mount -o ssd</code>将查找有多个空闲块的块的分组，这些空闲块可能已经分配了混合块。该命令<code>mount -o ssd_spread</code>确保没有混合分配的块。这样可以提高低端SSD的性能。</p>
<p><strong>注意</strong></p>
<p>该<code>ssd_spread</code>选项启用<code>ssd</code>和<code>ssd_spread</code>选项。使用<code>nossd</code>来禁用这两个选项。</p>
<p><code>ssd_spread</code>如果没有提供任何ssd选项并且任何设备不旋转，则 该选项永远不会自动设置。</p>
<p>这些选项都需要使用特定的版本进行测试，以查看它们的使用是否改善或降低了性能，因为SSD固件和应用程序负载的每个组合都不相同。</p>
<h2 id="BTRFS参考"><a href="#BTRFS参考" class="headerlink" title="BTRFS参考"></a>BTRFS参考</h2><p>手册页<code>btrfs(8)</code>涵盖了所有重要的管理命令。具体包括：</p>
<ul>
<li>所有用于管理快照的子卷命令。</li>
<li><code>device</code>管理设备 的命令。</li>
<li>的<code>scrub</code>，<code>balance</code>和<code>defragment</code>命令。</li>
</ul>
<p>手册页<code>mkfs.btrfs(8)</code>包含有关创建btrfs文件系统的信息，包括与之相关的所有选项。</p>
<p><code>btrfsck(8)</code>有关<code>fsck</code>btrfs系统信息 的手册页。</p>
<h1 id="GFS2"><a href="#GFS2" class="headerlink" title="GFS2"></a>GFS2</h1><p>GFS2 是直接与Linux内核文件系统接口（VFS层）接口的本地文件系统。作为集群文件系统实施时，GFS2采用分布式元数据和多个日志。</p>
<p>GFS2基于64位体系结构，理论上可以容纳8字节的文件系统。但是，当前支持的最大GFS2文件系统大小为100 TB。如果系统要求GFS2文件系统大于100 TB，请联系您的红帽服务代表。</p>
<p>在确定文件系统的大小时，请考虑其恢复需求。<code>fsck</code>在非常大的文件系统上运行该命令可能需要很长时间并消耗大量的内存。此外，如果发生磁盘或磁盘子系统故障，恢复时间受限于备份介质的速度。</p>
<p>在Red Hat Cluster Suite中进行配置时，可以使用Red Hat Cluster Suite配置和管理工具来配置和管理Red Hat GFS2节点。然后，红帽GFS2在红帽集群中的GFS2节点之间提供数据共享，并在GFS2节点之间提供一个统一的文件系统名称空间视图。这允许不同节点上的进程以相同的方式共享GFS2文件，即同一节点上的进程可以共享本地文件系统上的文件，而不会有明显的差异。有关红帽群集套件的信息，请参阅“红帽<em>群集管理</em>指南”。</p>
<p>GFS2必须构建在线性或镜像卷的逻辑卷（使用LVM创建）上。使用LVM在Red Hat集群套件中创建的逻辑卷由CLVM守护进程启用<code>clvmd</code>并在Red Hat Cluster Suite集群中运行的CLVM（集群范围的LVM实现）进行管理。守护进程可以使用LVM2来管理集群中的逻辑卷，从而允许集群中的所有节点共享逻辑卷。</p>
<p>该<code>gfs2.ko</code>内核模块实现了GFS2文件系统，并装载在GFS2集群节点。</p>
<h1 id="网络文件系统（NFS）"><a href="#网络文件系统（NFS）" class="headerlink" title="网络文件系统（NFS）"></a>网络文件系统（NFS）</h1><p>一个<em>网络文件系统</em>（<em>NFS</em>）允许远程主机通过网络挂载文件系统并与那些文件系统，就好像它们是本地安装的互动。这使得系统管理员可以将资源整合到网络上的中央服务器上。</p>
<p>本章重点介绍NFS的基本概念和补充信息。</p>
<h2 id="NFS简介"><a href="#NFS简介" class="headerlink" title="NFS简介"></a>NFS简介</h2><p>目前，Red Hat Enterprise Linux中包含两个主要的NFS版本。NFS版本3（NFSv3）支持安全异步写入，并且在错误处理方面比以前的NFSv2更强大; 它还支持64位文件大小和偏移量，允许客户端访问超过2 GB的文件数据。NFSv4通过防火墙和Internet工作，不再需要<code>rpcbind</code>服务，支持ACL并利用有状态的操作。</p>
<p>红帽企业版Linux 7增加了对NFS版本4.1（NFSv4.1）的支持，该版本提供了许多性能和安全增强功能，包括对并行NFS（pNFS）的客户端支持。NFSv4.1不再需要单独的TCP连接进行回调，即使无法联系客户端（例如，当NAT或防火墙干扰），也允许NFS服务器授予委派。此外，NFSv4.1现在提供了真正的一次语义（重启操作除外），防止了以前的问题，即如果回复丢失并且操作被发送了两次，某些操作可能返回不准确的结果。</p>
<p>红帽企业版Linux 7支持NFSv3，NFSv4.0和NVSv4.1客户端。NFS客户端默认尝试使用NFSv4.0进行挂载，如果挂载操作不成功，NFS客户端将回退到NFSv3。</p>
<p><strong>注意</strong></p>
<p>Red Hat不再支持NFS版本2（NFSv2）。</p>
<p>NFS的所有版本都可以使用通过IP网络运行的<em>传输控制协议</em>（<em>TCP</em>），而NFSv4则需要它。NFSv3可以使用通过IP网络运行的<em>用户数据报协议</em>（UDP）来提供客户端和服务器之间的无状态网络连接。</p>
<p>在UDP中使用NFSv3时，无状态UDP连接（正常情况下）的协议开销比TCP少。这可以转化为非常干净，非拥塞的网络上更好的性能。但是，因为UDP是无状态的，所以如果服务器意外关闭，那么UDP客户端继续使用服务器的请求来饱和网络。另外，当使用UDP丢失一个帧时，整个RPC请求必须被重新传输。与TCP，只有丢失的帧需要重新发送。由于这些原因，在连接到NFS服务器时，TCP是首选协议。</p>
<p>安装和锁定协议已被纳入NFSv4协议。服务器也监听众所周知的TCP端口2049这样上，NFSv4的不需要与之交互<code>rpcbind</code> ，<code>lockd</code>和<code>rpc.statd</code>守护程序。该<code>rpc.mountd</code>守护程序仍需要在NFS服务器上设置了出口，但不参与任何过度的线操作。</p>
<p><strong>注意</strong></p>
<p>TCP是红帽企业版Linux下NFS版本3的默认传输协议。可以根据需要将UDP用于兼容目的，但不建议将其用于广泛的用途。NFSv4需要TCP。</p>
<p>所有RPC / NFS守护进程都有一个<code>&#39;-p&#39;</code>可以设置端口的命令行选项，使得防火墙配置更容易。</p>
<p>在TCP封装器授予对客户端的访问权后，NFS服务器引用<code>/etc/exports</code>配置文件以确定是否允许客户端访问任何导出的文件系统。一旦验证完成，所有的文件和目录操作都可供用户使用。</p>
<p><strong>重要</strong></p>
<p>为了让NFS在启用了防火墙的情况下使用Red Hat Enterprise Linux的默认安装，请使用默认的TCP端口2049配置IPTables。如果没有正确的IPTables配置，NFS将无法正常运行。</p>
<p>NFS初始化脚本和<code>rpc.nfsd</code>进程现在允许在系统启动期间绑定到任何指定的端口。但是，如果端口不可用，或者与另一个守护进程发生冲突，则可能会出现错误。</p>
<h3 id="必需的服务"><a href="#必需的服务" class="headerlink" title="必需的服务"></a>必需的服务</h3><p>红帽企业Linux使用内核级支持和守护进程的组合来提供NFS文件共享。所有NFS版本都依赖于客户端和服务器之间的<em>远程过程调用</em>（<em>RPC</em>）。Red Hat Enterprise Linux 7下的RPC服务由<code>rpcbind</code>服务控制。要共享或安装NFS文件系统，下列服务可以协同工作，具体取决于实施的NFS版本：</p>
<p><strong>注意</strong></p>
<p>该<code>portmap</code>服务用于在早期版本的红帽企业版Linux中将RPC程序编号映射到IP地址端口号组合。<code>rpcbind</code>红帽企业版Linux 7 现在取代了这项服务，以支持IPv6。</p>
<ul>
<li><p>NFS</p>
<p><code>systemctl start nfs</code> 启动NFS服务器和相应的RPC进程来处理共享NFS文件系统的请求。</p>
</li>
<li><p>nfslock</p>
<p><code>systemctl start nfs-lock</code> 激活一个强制服务，启动相应的RPC进程，允许NFS客户端锁定服务器上的文件。</p>
</li>
<li><p>RPCBIND</p>
<p><code>rpcbind</code>接受来自本地RPC服务的端口保留。这些端口然后可用（或通告），以便相应的远程RPC服务可以访问它们。<code>rpcbind</code>响应对RPC服务的请求，并建立到请求的RPC服务的连接。这不用于NFSv4。</p>
</li>
</ul>
<p>以下RPC过程便于NFS服务：</p>
<ul>
<li><p>rpc.mountd</p>
<p>NFS服务器使用此进程来处理<code>MOUNT</code>来自NFSv3客户端的请求。它检查所请求的NFS共享当前是否由NFS服务器导出，并允许客户端访问它。如果允许安装请求，则rpc.mountd服务器将回复一个<code>Success</code>状态，并将<code>File-Handle</code>此NFS共享提供给NFS客户端。</p>
</li>
<li><p>rpc.nfsd</p>
<p><code>rpc.nfsd</code>允许服务器通告的明确的NFS版本和协议被定义。它与Linux内核一起工作，以满足NFS客户端的动态需求，例如每次NFS客户端连接时提供服务器线程。这个过程对应于<code>nfs</code>服务。</p>
</li>
<li><p>门锁配套</p>
<p><code>lockd</code>是在客户端和服务器上运行的内核线程。它实现了<em>网络锁管理器</em>（NLM）协议，它允许NFSv3客户端锁定服务器上的文件。无论何时运行NFS服务器以及挂载NFS文件系统，都会自动启动。</p>
</li>
<li><p>的rpc.statd</p>
<p>此过程实现了<em>网络状态监视器</em>（NSM）RPC协议，该协议在NFS服务器未正常关闭的情况下重新启动时通知NFS客户端。<code>rpc.statd</code>由<code>nfslock</code>服务自动启动，不需要用户配置。这不用于NFSv4。</p>
</li>
<li><p>rpc.rquotad</p>
<p>此过程为远程用户提供用户配额信息。<code>rpc.rquotad</code>由<code>nfs</code>服务自动启动，不需要用户配置。</p>
</li>
<li><p>rpc.idmapd</p>
<p><code>rpc.idmapd</code>提供NFSv4客户端和服务器上线，该上线在线上NFSv4名称（形式为字符串）与本地UID和GID 之间进行映射。为了与NFSv4一起运行，必须配置文件。至少应该指定“Domain”参数，它定义了NFSv4映射域。如果NFSv4映射域与DNS域名相同，则可以跳过此参数。客户端和服务器必须同意NFSv4映射域的ID映射才能正常工作。 <code>*user*@*domain*``idmapd``/etc/idmapd.conf</code><strong>注意</strong>在红帽企业版Linux 7中，只有NFSv4服务器使用<code>rpc.idmapd</code>。NFSv4客户端使用基于密钥环的idmapper <code>nfsidmap</code>。<code>nfsidmap</code>是由内核按需调用的执行ID映射的独立程序; 这不是一个守护进程。如果客户有问题，<code>nfsidmap</code>可以重新使用<code>rpc.idmapd</code>。有关的更多信息<code>nfsidmap</code>可以在nfsidmap手册页上找到。</p>
</li>
</ul>
<hr>
<h2 id="pNFS"><a href="#pNFS" class="headerlink" title="pNFS"></a>pNFS</h2><p>支持并行NFS（pNFS）作为NFS v4.1标准的一部分，自Red Hat Enterprise Linux 6.4起可用。pNFS体系结构提高了NFS的可扩展性，并可能提高性能。也就是说，当服务器也实现pNFS时，客户端可以同时通过多个服务器访问数据。它支持三种存储协议或布局：文件，对象和块。</p>
<p><strong>注意</strong></p>
<p>该协议允许三种可能的pNFS布局类型：文件，对象和块。虽然红帽企业Linux 6.4客户端只支持文件布局类型，红帽企业版Linux 7支持文件布局类型，对象和块布局类型作为技术预览。</p>
<p>要启用此功能，请在启用了pNFS的服务器上使用以下安装选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-o v4.1</span><br></pre></td></tr></table></figure>
<p>服务器启用pNFS后，<code>nfs_layout_nfsv41_files</code>内核会自动加载到第一个安装位置。输出中的装载条目应该包含<code>minorversion=1</code>。使用以下命令验证模块是否已加载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsmod | grep nfs_layout_nfsv41_files</span><br></pre></td></tr></table></figure>
<h2 id="配置NFS客户端"><a href="#配置NFS客户端" class="headerlink" title="配置NFS客户端"></a>配置NFS客户端</h2><p>该<code>mount</code>命令在客户端挂载NFS共享。其格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount -t nfs -o options server:/remote/<span class="built_in">export</span> /<span class="built_in">local</span>/directory</span><br></pre></td></tr></table></figure>
<p>该命令使用以下变量：</p>
<ul>
<li><p><em>options</em></p>
<p>以逗号分隔的挂载选项列表</p>
</li>
<li><p><em>server</em></p>
<p>输出您希望装载的文件系统的服务器的主机名，IP地址或标准域名</p>
</li>
<li><p><em>/remote/export</em></p>
<p>从<em>服务器</em>中导出的文件系统或目录，即要安装的目录</p>
</li>
<li><p><em>/local/directory</em></p>
<p>其中客户端位置<em>/远程/出口</em>被安装</p>
</li>
</ul>
<p>红帽企业版Linux 7中使用的NFS协议版本由<code>mount</code>选项<code>nfsvers</code>或<code>vers</code>。默认情况下，<code>mount</code>将使用NFSv4 <code>mount -t nfs</code>。如果服务器不支持NFSv4，客户端将自动下载到服务器支持的版本。如果<code>nfsvers</code>/ <code>vers</code>选项用于传递服务器不支持的特定版本，则挂载将失败。由于传统原因，文件系统类型nfs4也是可用的; 这相当于跑步。<code>mount -t nfs -o nfsvers=4 *host*:*/remote/export**/local/directory*</code></p>
<p>更多细节参考<code>man mount</code>。</p>
<p>如果手动挂载NFS共享，那么在重新引导时，共享将不会自动挂载。红帽企业Linux提供了两种在启动时自动安装远程文件系统的方法：<code>/etc/fstab</code>文件和<code>autofs</code>服务.</p>
<h4 id="使用安装NFS文件系统-etc-fstab"><a href="#使用安装NFS文件系统-etc-fstab" class="headerlink" title="使用安装NFS文件系统/etc/fstab"></a>使用安装NFS文件系统<code>/etc/fstab</code></h4><p>从另一台机器上挂载NFS共享的另一种方法是在<code>/etc/fstab</code>文件中添加一行。该行必须声明NFS服务器的主机名，要导出的服务器上的目录，以及要装载NFS共享的本地计算机上的目录。您必须是root用户才能修改<code>/etc/fstab</code>文件。</p>
<p><strong>语法示例</strong></p>
<p><code>/etc/fstab</code>的一般语法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:/usr/<span class="built_in">local</span>/pub    /pub   nfs    defaults 0 0</span><br></pre></td></tr></table></figure>
<p><code>/pub</code>在执行此命令之前，客户机上必须存在 安装点。在<code>/etc/fstab</code>客户端系统上添加此行后，使用该命令<code>mount /pub</code>，并<code>/pub</code>从服务器挂载安装点。</p>
<p><code>/etc/fstab</code>挂载NFS导出的 有效条目应包含以下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server:/remote/<span class="built_in">export</span> /<span class="built_in">local</span>/directory nfs options 0 0</span><br></pre></td></tr></table></figure>
<p>变量<em>server</em>，<em>/remote/export</em>，<em>/local/directory</em>和*options与手动挂载NFS共享时使用的是相同的</p>
<p><strong>Note</strong></p>
<p>在读取之前 ，挂载点  <em>/local/directory</em> 必须存在于客户端上<code>/etc/fstab</code>。否则，挂载将失败。</p>
<p>有关更多信息<code>/etc/fstab</code>，请参阅<code>man fstab</code>。</p>
<h2 id="autofs"><a href="#autofs" class="headerlink" title="autofs"></a><code>autofs</code></h2><p>使用的一个缺点<code>/etc/fstab</code>是，无论用户访问挂载的NFS文件系统的频率如何，系统都必须投入资源来保持挂载的文件系统。这对于一个或两个坐骑来说不是问题，但是当系统一次维护到多个系统时，整个系统的性能可能会受到影响。另一种方法<code>/etc/fstab</code>是使用基于内核的<code>automount</code>实用程序。自动挂载器由两部分组成：</p>
<ul>
<li>一个实现文件系统的内核模块</li>
<li>一个执行所有其他功能的用户空间守护进程。</li>
</ul>
<p>该<code>automount</code>实用程序可以自动安装和卸载NFS文件系统（按需安装），从而节省系统资源。它可以用来安装其他文件系统，包括AFS，SMBFS，CIFS和本地文件系统</p>
<p><strong>重要</strong></p>
<p>nfs-utils软件包现在是“NFS文件服务器”和“网络文件系统客户端”组的一部分。因此，默认情况下，基本组不会默认安装。确保在尝试自动挂载NFS共享之前，先在系统上安装nfs-utils。</p>
<p>autofs也是“网络文件系统客户端”组的一部分。</p>
<p><code>autofs</code>使用<code>/etc/auto.master</code>（主映射）作为其默认主配置文件。这可以更改为使用名称服务交换机制（NSS）机制中的<code>autofs</code>配置（in <code>/etc/sysconfig/autofs</code>）使用其他支持的网络源和名称。<code>autofs</code>针对主映射中配置的每个安装点运行版本4守护程序的实例，因此可以从命令行手动运行任何给定安装点。这是不可能的<code>autofs</code>版本5，因为它使用单个守护程序来管理所有配置的挂载点; 因此，必须在主映射中配置所有自动装载。这符合其他行业标准自动加载器的通常要求。挂载点，主机名，导出目录和选项都可以在一组文件（或其他支持的网络源）中指定，而不是为每个主机手动配置它们。</p>
<h4 id="autofs版本5比版本4改进"><a href="#autofs版本5比版本4改进" class="headerlink" title="autofs版本5比版本4改进"></a>autofs版本5比版本4改进</h4><p><code>autofs</code> 与版本4相比，版本5具有以下增强功能：</p>
<ul>
<li><p>直接映射支持</p>
<p>直接映射<code>autofs</code>提供了在文件系统层次结构中的任意点自动挂载文件系统的机制。直接映射由<code>/-</code>主映射中的挂载点表示。直接映射中的条目包含绝对路径名称作为键（而不是间接映射中使用的相对路径名）。</p>
<p>懒惰安装和卸载支持</p>
<p>多安装映射条目描述了单个密钥下的安装点层次结构。一个很好的例子就是<code>-hosts</code>地图，通常用于自动挂载主机下的所有导出，作为多装入映射条目。当使用地图，一个的将安装<em>的autofs</em>触发器安装用于从每个出口<em>主机</em>。这些会在访问时挂载和过期。这可以大大减少访问具有大量导出的服务器时所需的活动坐标的数量。<code>/net/*host*``-hosts``ls``/net/*host*</code><em>**</em></p>
<p>增强的LDAP支持</p>
<p>的<code>autofs</code>配置文件（<code>/etc/sysconfig/autofs</code>）提供了一种机制，以指定<code>autofs</code>一个站点执行的模式，从而排除，需要通过在应用程序本身试错法来确定这一点。另外，现在支持通过LDAP服务器认证的绑定，并使用通用LDAP服务器实现支持的大多数机制。为此支持添加了新的配置文件：<code>/etc/autofs_ldap_auth.conf</code>。默认配置文件是自我记录的，并使用XML格式。</p>
<p>正确使用名称服务Switch（<code>nsswitch</code>）配置。</p>
<p>名称服务交换机配置文件的存在是为了提供一种确定特定配置数据来自何处的方法。这种配置的原因是允许管理员灵活地使用所选择的后端数据库，同时保持统一的软件接口来访问数据。虽然版本4自动挂载机在处理NSS配置方面越来越好，但它仍然不完整。另一方面，Autofs版本5是一个完整的实现。</p>
<p>请参阅<code>man nsswitch.conf</code>此文件的支持语法的更多信息。并非所有的NSS数据库都是有效的地图源，解析器将会拒绝那些无效的地图源。合法来源的文件，<code>yp</code>，<code>nis</code>，<code>nisplus</code>，<code>ldap</code>，和<code>hesiod</code>。</p>
<p>每个autofs安装点有多个主映射条目</p>
<p>有一件经常使用但尚未提及的事情是处理直接安装点的多个主映射条目<code>/-</code>。每个条目的地图键合并，并作为一个映射。</p>
<p>​</p>
<p><strong>每个自动安装点的多个主映射条目</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/- /tmp/auto_dcthon</span><br><span class="line">/- /tmp/auto_test3_direct</span><br><span class="line">/- /tmp/auto_test4_direct</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="配置autofs"><a href="#配置autofs" class="headerlink" title="配置autofs"></a>配置autofs</h3><p>自动挂载程序的主要配置文件<code>/etc/auto.master</code>也称为主映射，主映射列出<code>autofs</code>了系统上的控制挂载点以及相应的配置文件或称为自动挂载映射的网络源。主图的格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount-point map-name options</span><br></pre></td></tr></table></figure>
<p>这种格式使用的变量是：</p>
<ul>
<li><p><em>mount-point</em></p>
<p>该<code>autofs</code>安装点，<code>/home</code>等。</p>
</li>
<li><p><em>map-name</em></p>
<p>包含挂载点列表的映射源的名称以及应该从中挂载这些挂载点的文件系统位置。地图条目的语法如下所述。</p>
</li>
<li><p><em>options</em></p>
<p>如果提供，这些将适用于给定的地图中的所有条目，只要它们本身没有指定的选项。此行为与<code>autofs</code>选项累积的版本4 不同。这已经被改变以实现混合的环境兼容性。</p>
</li>
</ul>
<p><strong>/etc/auto.master文件</strong></p>
<p>以下是来自<code>/etc/auto.master</code>文件（显示<code>cat /etc/auto.master</code>）的示例行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home /etc/auto.misc</span><br></pre></td></tr></table></figure>
<p>地图的一般格式类似于主地图，但是“选项”出现在装载点和位置之间，而不是在主地图的入口末尾：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount-point   [options]   location</span><br></pre></td></tr></table></figure>
<p>这种格式使用的变量是：</p>
<ul>
<li><p><em>mount-point</em></p>
<p>这是指<code>autofs</code>安装点。这可以是间接装入的单个目录名称，也可以是直接装入的装入点的完整路径。每个直接和间接映射条目键（<code>*mount-point*</code>上面）后面都可以跟一个以空格分隔的偏移目录列表（每个以“/”开头的子目录名称），使它们成为所谓的多装入条目。</p>
</li>
<li><p><em>options</em></p>
<p>无论何时提供，这些是没有指定自己的选项的地图项的装载选项。</p>
</li>
<li><p><em>location</em></p>
<p>这指的是文件系统位置，例如本地文件系统路径（以“/”开头的映射名称以太阳映射格式转义符“：”开头），NFS文件系统或其他有效的文件系统位置。</p>
</li>
</ul>
<p>以下是地图文件中的内容示例（例如<code>/etc/auto.misc</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">payroll -fstype=nfs personnel:/dev/hda3</span><br><span class="line">sales -fstype=ext3 :/dev/hda4</span><br></pre></td></tr></table></figure>
<p>映射文件中的第一列指示<code>autofs</code>安装点（<code>sales</code>并<code>payroll</code>从调用的服务器<code>personnel</code>）。第二列表示<code>autofs</code>安装选项，第三列表示安装源。按照上述配置，autofs挂载点会<code>/home/payroll</code>和<code>/home/sales</code>。该<code>-fstype=</code>选项通常被忽略，通常不需要正确的操作。</p>
<p>自动挂载程序将创建目录，如果它们不存在。如果目录在启动自动挂载程序之前存在，则自动挂载程序在退出时不会将其删除。您可以通过发出以下两个命令来启动或重新启动automount守护进程：</p>
<ul>
<li>如果自动挂载服务已停止：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start autofs</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果服务正在运行：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl restart autofs</span></span><br></pre></td></tr></table></figure>
<p>使用上述配置，如果进程需要访问<code>autofs</code>卸载的目录（例如<code>/home/payroll/2006/July.sxc</code>，automount守护进程），则会自动挂载目录。如果指定超时，如果目录在超时期间未被访问，则目录将自动被卸载。</p>
<p>您可以通过发出以下命令来查看automount守护进程的状态：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl status autofs</span></span><br></pre></td></tr></table></figure>
<h3 id="覆盖或增加站点配置文件"><a href="#覆盖或增加站点配置文件" class="headerlink" title="覆盖或增加站点配置文件"></a>覆盖或增加站点配置文件</h3><p>覆盖客户端系统上特定挂载点的站点默认值可能很有用。例如，考虑以下条件：</p>
<ul>
<li><p>Automounter地图存储在NIS中，<code>/etc/nsswitch.conf</code>文件具有以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">automount:    files nis</span><br></pre></td></tr></table></figure></li>
<li><p><code>auto.master</code>文件包含以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+auto.master</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIS <code>auto.master</code>映射文件包含以下内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home auto.home</span><br></pre></td></tr></table></figure>
</li>
<li><p>NIS <code>auto.home</code>地图包含以下内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beth        fileserver.example.com:/<span class="built_in">export</span>/home/beth</span><br><span class="line">joe        fileserver.example.com:/<span class="built_in">export</span>/home/joe</span><br><span class="line">*       fileserver.example.com:/<span class="built_in">export</span>/home/&amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件映射<code>/etc/auto.home</code>不存在。</p>
</li>
</ul>
<p>给定这些条件，让我们假设客户端系统需要重写NIS映射<code>auto.home</code>并从不同的服务器挂载主目录。在这种情况下，客户端将需要使用以下<code>/etc/auto.master</code>映射：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home /etc/auto.home</span><br><span class="line">+auto.master</span><br></pre></td></tr></table></figure>
<p><code>/etc/auto.home</code>地图包含的条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*    labserver.example.com:/<span class="built_in">export</span>/home/&amp;</span><br></pre></td></tr></table></figure>
<p>由于自动挂载程序仅处理挂载点的首次出现，<code>/home</code>将包含<code>/etc/auto.home</code>NIS <code>auto.home</code>映射的内容。</p>
<p>另外，为了增加<code>auto.home</code>只有几个条目的站点范围的地图，创建一个<code>/etc/auto.home</code>文件地图，并在其中放入新的条目。最后，包括NIS <code>auto.home</code>地图。然后<code>/etc/auto.home</code>文件映射将看起来类似于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mydir someserver:/<span class="built_in">export</span>/mydir</span><br><span class="line">+auto.home</span><br></pre></td></tr></table></figure>
<p>鉴于<code>auto.home</code>上面列出的NIS 地图，<code>ls /home</code>现在将输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">beth joe mydir</span><br></pre></td></tr></table></figure>
<p>这最后一个示例按预期方式工作，因为<code>autofs</code>不包含与正在读取的同名文件映射的内容。因此，<code>autofs</code>移到<code>nsswitch</code>配置中的下一个映射源。</p>
<h3 id="使用LDAP存储自动更新映射表"><a href="#使用LDAP存储自动更新映射表" class="headerlink" title="使用LDAP存储自动更新映射表"></a>使用LDAP存储自动更新映射表</h3><p>必须在配置为从LDAP中检索自动安装程序映射的所有系统上安装LDAP客户端库。在Red Hat Enterprise Linux上，<code>openldap</code>软件包应该作为依赖项自动安装<code>automounter</code>。要配置LDAP访问，请修改<code>/etc/openldap/ldap.conf</code>。确保为您的网站适当地设置BASE，URI和架构。</p>
<p>最近建立的用于在LDAP中存储自动安装映射的模式描述如下<code>rfc2307bis</code>。要使用这个模式，有必要通过从模式定义中删除注释字符来将其设置在<code>autofs</code>configuration（<code>/etc/sysconfig/autofs</code>）中。例如：</p>
<p><strong>设置autofs配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DEFAULT_MAP_OBJECT_CLASS=<span class="string">"automountMap"</span></span><br><span class="line">DEFAULT_ENTRY_OBJECT_CLASS=<span class="string">"automount"</span></span><br><span class="line">DEFAULT_MAP_ATTRIBUTE=<span class="string">"automountMapName"</span></span><br><span class="line">DEFAULT_ENTRY_ATTRIBUTE=<span class="string">"automountKey"</span></span><br><span class="line">DEFAULT_VALUE_ATTRIBUTE=<span class="string">"automountInformation"</span></span><br></pre></td></tr></table></figure>
<p>确保这些是在配置中未注释的唯一模式条目。该<code>automountKey</code>替换<code>cn</code>的属性<code>rfc2307bis</code>架构。一个<code>LDIF</code>样品的配置的描述如下：</p>
<p><strong>LDF配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># extended LDIF</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LDAPv3</span></span><br><span class="line"><span class="comment"># base &lt;&gt; with scope subtree</span></span><br><span class="line"><span class="comment"># filter: (&amp;(objectclass=automountMap)(automountMapName=auto.master))</span></span><br><span class="line"><span class="comment"># requesting: ALL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># auto.master, example.com</span></span><br><span class="line">dn: automountMapName=auto.master,dc=example,dc=com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: automountMap</span><br><span class="line">automountMapName: auto.master</span><br><span class="line"></span><br><span class="line"><span class="comment"># extended LDIF</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LDAPv3</span></span><br><span class="line"><span class="comment"># base &lt;automountMapName=auto.master,dc=example,dc=com&gt; with scope subtree</span></span><br><span class="line"><span class="comment"># filter: (objectclass=automount)</span></span><br><span class="line"><span class="comment"># requesting: ALL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /home, auto.master, example.com</span></span><br><span class="line">dn: automountMapName=auto.master,dc=example,dc=com</span><br><span class="line">objectClass: automount</span><br><span class="line">cn: /home</span><br><span class="line"></span><br><span class="line">automountKey: /home</span><br><span class="line">automountInformation: auto.home</span><br><span class="line"></span><br><span class="line"><span class="comment"># extended LDIF</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LDAPv3</span></span><br><span class="line"><span class="comment"># base &lt;&gt; with scope subtree</span></span><br><span class="line"><span class="comment"># filter: (&amp;(objectclass=automountMap)(automountMapName=auto.home))</span></span><br><span class="line"><span class="comment"># requesting: ALL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># auto.home, example.com</span></span><br><span class="line">dn: automountMapName=auto.home,dc=example,dc=com</span><br><span class="line">objectClass: automountMap</span><br><span class="line">automountMapName: auto.home</span><br><span class="line"></span><br><span class="line"><span class="comment"># extended LDIF</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># LDAPv3</span></span><br><span class="line"><span class="comment"># base &lt;automountMapName=auto.home,dc=example,dc=com&gt; with scope subtree</span></span><br><span class="line"><span class="comment"># filter: (objectclass=automount)</span></span><br><span class="line"><span class="comment"># requesting: ALL</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># foo, auto.home, example.com</span></span><br><span class="line">dn: automountKey=foo,automountMapName=auto.home,dc=example,dc=com</span><br><span class="line">objectClass: automount</span><br><span class="line">automountKey: foo</span><br><span class="line">automountInformation: filer.example.com:/<span class="built_in">export</span>/foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># /, auto.home, example.com</span></span><br><span class="line">dn: automountKey=/,automountMapName=auto.home,dc=example,dc=com</span><br><span class="line">objectClass: automount</span><br><span class="line">automountKey: /</span><br><span class="line">automountInformation: filer.example.com:/<span class="built_in">export</span>/&amp;</span><br></pre></td></tr></table></figure>
<h2 id="常见的NFS挂载选项"><a href="#常见的NFS挂载选项" class="headerlink" title="常见的NFS挂载选项"></a>常见的NFS挂载选项</h2><p>除了在远程主机上使用NFS挂载文件系统之外，还可以在挂载时指定其他选项，以使挂载的共享更易于使用。这些选项可用于手动<code>mount</code>命令，<code>/etc/fstab</code>设置和<code>autofs</code>。</p>
<p>以下是NFS安装常用的选项：</p>
<ul>
<li><p>intr</p>
<p>如果服务器关闭或无法访问，则允许NFS请求中断。</p>
</li>
<li><p>lookupcache=<em>mode</em></p>
<p>指定内核如何管理给定挂载点的目录条目的缓存。为有效参数<em>模式</em>是<code>all</code>，<code>none</code>或<code>pos</code>/ <code>positive</code>。</p>
</li>
<li><p>nfsvers=<em>version</em></p>
<p>指定<em>版本</em>为3或4 的NFS协议的<em>版本</em>。对于运行多个NFS服务器的主机很有用。如果未指定版本，则NFS使用内核和<code>mount</code>命令支持的最高版本。</p>
<p>该选项<code>vers</code>与<code>nfsvers</code>此版本相同，并且出于兼容性原因包含在此版本中。</p>
</li>
<li><p>noacl</p>
<p>关闭所有ACL处理。当与旧版本的Red Hat Enterprise Linux，Red Hat Linux或Solaris接口连接时，这可能是需要的，因为最新的ACL技术与旧系统不兼容。</p>
</li>
<li><p>nolock</p>
<p>禁用文件锁定。连接到较旧的NFS服务器时偶尔需要此设置。</p>
</li>
<li><p>noexec</p>
<p>防止在挂载的文件系统上执行二进制文件。如果系统挂载包含不兼容的二进制文件的非Linux文件系统，这非常有用。</p>
</li>
<li><p>nosuid</p>
<p>禁用<code>set-user-identifier</code>或<code>set-group-identifier</code>位。这可以防止远程用户通过运行<code>setuid</code>程序获得更高的权限。</p>
</li>
<li><p>port=<em>num</em></p>
<p>禁用<code>set-user-identifier</code>或<code>set-group-identifier</code>位。这可以防止远程用户通过运行<code>setuid</code>程序获得更高的权限。</p>
</li>
<li><p>rsize=<em>num</em> and wsize=<em>num</em></p>
<p>这些设置加快NFS通信为读（<code>rsize</code>）和写入（<code>wsize</code>）通过设定较大的数据块的大小（<em>NUM</em>，以字节为单位），在同一时间进行传输。更改这些值时要小心; 一些较旧的Linux内核和网卡在较大的块大小下不能正常工作。对于NFSv3，两个参数的默认值均设置为8192.对于NFSv4，两个参数的默认值均设置为32768。</p>
</li>
<li><p>sec=<em>mode</em></p>
<p>它的默认设置是<code>sec=sys</code>使用本地UNIX UID和GID。这些用于<code>AUTH_SYS</code>验证NFS操作。</p>
<p><code>sec=krb5</code> 使用Kerberos V5而不是本地UNIX UID和GID来认证用户。</p>
<p><code>sec=krb5i</code> 使用Kerberos V5进行用户身份验证，并使用安全校验和来执行NFS操作的完整性检查，以防止数据被篡改。</p>
<p><code>sec=krb5p</code>使用Kerberos V5进行用户验证，完整性检查以及加密NFS流量以防止流量嗅探。这是最安全的设置，但它也涉及最高的性能开销。</p>
</li>
<li><p>tcp</p>
<p>指示NFS挂载使用TCP协议。</p>
</li>
<li><p>udp</p>
<p>指示NFS挂载使用UDP协议。</p>
</li>
</ul>
<p>有关选项的完整列表和更详细的信息，请参阅<code>man mount</code>和<code>man nfs</code>。</p>
<h2 id="启动和停止NFS服务器"><a href="#启动和停止NFS服务器" class="headerlink" title="启动和停止NFS服务器"></a>启动和停止NFS服务器</h2><p>要运行未配置为仅使用NFSv4的NFS服务器，<code>rpcbind</code>服务必须正在运行。要验证它<code>rpcbind</code>是否处于活动状态，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl status rpcbind</span><br></pre></td></tr></table></figure>
<p>如果<code>rpcbind</code>服务正在运行，则<code>nfs</code>服务可以启动。要启动NFS服务器，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl start nfs</span><br></pre></td></tr></table></figure>
<p>要使NFS在引导时启动，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl <span class="built_in">enable</span> nfs-server</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>对于NFSv3，如果NFS设置为在引导时启动，则<code>nfs-lock</code>需要启用该服务。在红帽企业版Linux 7.1及更高版本上，<code>nfs-lock</code>如果需要自动启动，并尝试手动启用它将失败。在Red Hat Enterprise Linux 7.0上，运行检查状态<code>systemctl status nfs-lock</code>。如果<code>nfs-lock</code>未启用，请运行<code>systemctl start nfs-lock</code>。要设置<code>nfs-lock</code>为在Red Hat Enterprise Linux 7.0上自动启动，请运行<code>systemctl enable nfs-lock</code>。</p>
<p>要停止服务器，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl stop nfs</span><br></pre></td></tr></table></figure>
<p>该<code>restart</code>选项是停止然后启动NFS的简写方式。在编辑NFS配置文件后，这是使配置更改生效的最有效的方法。重新启动服务器类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl restart nfs</span><br></pre></td></tr></table></figure>
<p>编辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/nfs</span><br></pre></td></tr></table></figure>
<p>文件后，通过运行以下命令重新启动nfs-config服务以使新值生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl restart nfs-config</span><br></pre></td></tr></table></figure>
<p>该<code>try-restart</code>命令仅<code>nfs</code>在当前正在运行时才开始。这个命令相当于红帽init脚本中的<code>condrestart</code>（<em>条件重启</em>），并且非常有用，因为如果NFS没有运行，它不会启动守护进程。</p>
<p>要有条件地重新启动服务器类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl try-restart nfs</span><br></pre></td></tr></table></figure>
<p>重新加载NFS服务器配置文件而不重新启动服务类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ systemctl reload nfs</span><br></pre></td></tr></table></figure>
<h2 id="配置NFS服务器"><a href="#配置NFS服务器" class="headerlink" title="配置NFS服务器"></a>配置NFS服务器</h2><ul>
<li>方法可以在NFS服务器上配置导出：<ul>
<li>手动编辑NFS配置文件，即<code>/etc/exports</code>，和</li>
<li>通过命令行，即通过使用该命令 <code>exportfs</code></li>
</ul>
</li>
</ul>
<h3 id="etc-exports配置文件"><a href="#etc-exports配置文件" class="headerlink" title="/etc/exports配置文件"></a><code>/etc/exports</code>配置文件</h3><p>该<code>/etc/exports</code>文件控制将哪个文件系统导出到远程主机并指定选项。它遵循以下语法规则：</p>
<ul>
<li>空白行被忽略。</li>
<li>要添加评论，请使用散列标记（<code>#</code>）开始一行。</li>
<li>你可以用一个反斜杠（<code>\</code>）包住长长的一行。</li>
<li>每个导出的文件系统应该在自己的行中。</li>
<li>在导出的文件系统之后放置的任何授权主机列表必须用空格字符分隔。</li>
<li>每个主机的选项都必须放在主机标识符后面的括号中，而主机和第一个括号之间没有任何空格。</li>
</ul>
<p>导出文件系统的每个条目具有以下结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> host(options)</span><br></pre></td></tr></table></figure>
<p>上述结构使用以下变量：</p>
<ul>
<li><p><em>export</em></p>
<p>正在导出的目录</p>
</li>
<li><p><em>host</em></p>
<p>要共享导出的主机或网络</p>
</li>
<li><p><em>options</em></p>
<p>要用于<em>主机</em>的选项</p>
</li>
</ul>
<p>可以指定多个主机，以及每个主机的特定选项。为此，请将它们列在空格分隔的列表的同一行上，每个主机名后跟其各自的选项（括号），如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> host1(options1) host2(options2) host3(options3)</span><br></pre></td></tr></table></figure>
<p>最简单的形式是<code>/etc/exports</code>文件只指定导出的目录和允许访问的主机，如下例所示：</p>
<p><strong>/etc/exports文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/exported/directory bob.example.com</span><br></pre></td></tr></table></figure>
<p>在这里，<code>bob.example.com</code>可以<code>/exported/directory/</code>从NFS服务器上挂载。由于在本例中没有指定选项，NFS将使用<em>默认</em>设置。</p>
<p>默认设置是：</p>
<ul>
<li><p>ro</p>
<p>导出的文件系统是只读的。远程主机不能更改在文件系统上共享的数据。要允许主机对文件系统进行更改（即读/写），请指定该<code>rw</code>选项。</p>
</li>
<li><p>sync</p>
<p>在将先前的请求所做的更改写入磁盘之前，NFS服务器不会回应请求。要启用异步写入，请指定该选项<code>async</code>。</p>
</li>
<li><p>wdelay</p>
<p>如果怀疑另一个写入请求即将发生，NFS服务器将延迟写入磁盘。这可以提高性能，因为它减少了磁盘必须通过单独的写入命令访问的次数，从而减少了写入开销。要禁用此功能，请指定<code>no_wdelay</code>。<code>no_wdelay</code>仅在<code>sync</code>还指定了默认选项时才可用。</p>
</li>
<li><p>root_squash</p>
<p>这防止<em>远程</em>连接的root用户（与本地相反）拥有root权限; 相反，NFS服务器将为其分配用户标识<code>nfsnobody</code>。这有效地将远程root用户的权限“压缩”到最低的本地用户，从而防止在远程服务器上可能的未经授权的写入。要禁用root压缩，请指定<code>no_root_squash</code>。</p>
</li>
</ul>
<p>要压缩每个远程用户（包括root），请使用<code>all_squash</code>。要指定NFS服务器应从特定主机分配给远程用户的用户和组ID ，请分别使用<code>anonuid</code>和<code>anongid</code>选项，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> host(anonuid=uid,anongid=gid)</span><br></pre></td></tr></table></figure>
<p>在这里，<em>uid</em>和<em>gid</em>分别是用户ID号和组ID号。在<code>anonuid</code>和<code>anongid</code>选项允许您创建远程NFS用户共享一个特殊的用户和组帐户。</p>
<p>默认情况下，红帽企业版Linux支持<em>访问控制列表</em>（<em>ACL</em>）。要禁用此功能，请<code>no_acl</code>在导出文件系统时指定该选项。</p>
<p>每个导出的文件系统的每个默认值必须被显式覆盖。例如，如果<code>rw</code>未指定该选项，则导出的文件系统将以只读方式共享。以下是<code>/etc/exports</code>覆盖两个默认选项的示例行：</p>
<p><code>/another/exported/directory 192.168.0.3(rw,async)</code></p>
<p>在这个例子中，<code>192.168.0.3</code>可以挂载<code>/another/exported/directory/</code>读/写，并且所有写入磁盘都是异步的。有关导出选项的更多信息，请参阅<code>man exportfs</code>。</p>
<p>其他选项在没有指定默认值的情况下可用。其中包括禁用子树检查，允许从不安全的端口访问，以及允许不安全的文件锁定（对于某些早期的NFS客户端实现是必需的）。请参阅<code>man exports</code>这些较少使用的选项的详细信息。</p>
<p><strong>重要</strong></p>
<p><code>/etc/exports</code>文件 的格式非常精确，特别是在使用空格字符方面。请记住始终使用空格字符将导出的文件系统与主机和主机相互隔离。但是，除了注释行之外，文件中不应该有其他空格字符。</p>
<p>例如，以下两行并不意味着同一件事：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/home bob.example.com(rw) </span><br><span class="line">/home bob.example.com (rw)</span><br></pre></td></tr></table></figure>
<p>第一行只允许用户<code>bob.example.com</code>读/写访问<code>/home</code>目录。第二行允许用户<code>bob.example.com</code>将目录挂载为只读（默认），而世界其他地方可以挂载它的读/写。</p>
<h3 id="exportfs命令"><a href="#exportfs命令" class="headerlink" title="exportfs命令"></a><code>exportfs</code>命令</h3><p>文件中列出了每个使用NFS导出到远程用户的文件系统以及这些文件系统的访问级别<code>/etc/exports</code>。当<code>nfs</code>服务启动时，<code>/usr/sbin/exportfs</code>命令将启动并读取此文件，将控制权交给<code>rpc.mountd</code>（如果NFSv3）实际的安装过程，然后传递<code>rpc.nfsd</code>到远程用户可以使用的文件系统的位置。</p>
<p>当手动发布时，该<code>/usr/sbin/exportfs</code>命令允许root用户有选择地导出或取消导出目录，而无需重新启动NFS服务。当给出正确的选项时，该<code>/usr/sbin/exportfs</code>命令将导出的文件系统写入<code>/var/lib/nfs/xtab</code>。由于在决定对文件系统的访问权限时<code>rpc.mountd</code>引用<code>xtab</code>文件，对导出的文件系统列表的更改立即生效。</p>
<p>以下是可供选择的常用选项列表<code>/usr/sbin/exportfs</code>：</p>
<ul>
<li><p>-r</p>
<p><code>/etc/exports</code>通过在中构建新的导出列表， 导致列出的所有目录被导出<code>/etc/lib/nfs/xtab</code>。此选项可以有效地刷新导出列表并进行任何更改<code>/etc/exports</code>。</p>
</li>
<li><p>-a</p>
<p>导致所有目录被导出或取消导出，具体取决于传递到的其他选项<code>/usr/sbin/exportfs</code>。如果没有指定其他选项，则<code>/usr/sbin/exportfs</code>导出在中指定的所有文件系统<code>/etc/exports</code>。</p>
</li>
<li><p>-o <em>file-systems</em></p>
<p>指定未列入的要导出的目录<code>/etc/exports</code>。将<em>文件系统</em>替换为要导出的其他文件系统。这些文件系统必须按照指定的相同方式进行格式化<code>/etc/exports</code>。此选项通常用于测试导出的文件系统，然后将其永久添加到要导出的文件系统列表中。</p>
</li>
<li><p>-i</p>
<p>忽略<code>/etc/exports</code>; 只有从命令行给出的选项用于定义导出的文件系统。</p>
</li>
<li><p>-u</p>
<p>取消导出所有共享目录。该命令<code>/usr/sbin/exportfs -ua</code>挂起NFS文件共享，同时保持所有的NFS守护进程。要重新启用NFS共享，请使用<code>exportfs -r</code>。</p>
</li>
<li><p>-v</p>
<p>详细操作，<code>exportfs</code>执行该命令时将更详细地显示正在导出或未导出的文件系统。</p>
</li>
</ul>
<p>如果没有选项传递给<code>exportfs</code>命令，则会显示当前导出的文件系统的列表。有关该<code>exportfs</code>命令的更多信息，请参阅<code>man exportfs</code>。</p>
<h3 id="exportfs与NFSv4一起使用"><a href="#exportfs与NFSv4一起使用" class="headerlink" title="exportfs与NFSv4一起使用"></a><code>exportfs</code>与NFSv4一起使用</h3><p>在红帽企业版Linux 7中，不需要额外的步骤来配置NFSv4导出，因为所提及的任何文件系统都可以自动使用相同路径的NFSv3和NFSv4客户端。以前的版本并非如此。</p>
<p>为了防止客户端使用的NFSv4，通过设置将其关闭<code>RPCNFSDARGS= -N 4</code>在<code>/etc/sysconfig/nfs</code>。</p>
<h3 id="在防火墙后面运行NFS"><a href="#在防火墙后面运行NFS" class="headerlink" title="在防火墙后面运行NFS"></a>在防火墙后面运行NFS</h3><p>NFS要求<code>rpcbind</code>为RPC服务动态分配端口，并可能导致配置防火墙规则的问题。要允许客户端访问防火墙后面的NFS共享，请编辑该<code>/etc/sysconfig/nfs</code>文件以设置运行RPC服务的端口。</p>
<p>该<code>/etc/sysconfig/nfs</code>文件在所有系统上默认情况下不存在。如果<code>/etc/sysconfig/nfs</code>不存在，请创建它并指定以下内容：</p>
<ul>
<li><p>RPCMOUNTDOPTS=”-p <em>port</em>“</p>
<p>这将“-p <em>port</em> ” 添加到rpc.mount命令行：。 <code>rpc.mount -p *port*</code></p>
</li>
</ul>
<p>To specify the ports to be used by the <code>nlockmgr</code> service, set the port number for the <em>nlm_tcpport</em> and <em>nlm_udpport</em> options in the <code>/etc/modprobe.d/lockd.conf</code> file.</p>
<p>要指定<code>nlockmgr</code>服务使用的端口，请为文件中的<em>nlm_tcpport</em>和<em>nlm_udpport</em>选项设置端口号<code>/etc/modprobe.d/lockd.conf</code>。</p>
<p>如果NFS无法启动，请检查<code>/var/log/messages</code>。通常，如果您指定了一个已经在使用的端口号，NFS将无法启动。编辑之后<code>/etc/sysconfig/nfs</code>，您需要重新启动<code>nfs-config</code>服务以使新值在红帽企业版Linux 7.2及更高版本中生效，方法是运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃systemctl restart nfs-config</span><br></pre></td></tr></table></figure>
<p>然后，重新启动NFS服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃systemctl restart nfs-server</span><br></pre></td></tr></table></figure>
<p>运行<code>rpcinfo -p</code>确认更改已生效。</p>
<p><strong>注意</strong></p>
<p>许NFSv4.0回调通过防火墙设置，<code>/proc/sys/fs/nfs/nfs_callback_tcpport</code>并允许服务器连接到客户端的端口。</p>
<p>不需要用于的NFSv4.1或更高，而对于其他端口这个过程<code>mountd</code>，<code>statd</code>和<code>lockd</code>不以纯的NFSv4环境必需的。</p>
<h3 id="发现NFS导出"><a href="#发现NFS导出" class="headerlink" title="发现NFS导出"></a>发现NFS导出</h3><p>有两种方法可以发现NFS服务器导出的文件系统。</p>
<p>首先，在任何支持NFSv3的服务器上，使用以下<code>showmount</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ showmount -e myserver</span><br><span class="line">Export list <span class="keyword">for</span> mysever</span><br><span class="line">/exports/foo</span><br><span class="line">/exports/bar</span><br></pre></td></tr></table></figure>
<p>其次，在任何支持NFSv4的服务器上，挂载<code>/</code>并浏览。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount myserver:/ /mnt/</span></span><br><span class="line"><span class="comment">#cd /mnt/</span></span><br><span class="line">exports</span><br><span class="line"><span class="comment"># ls exports</span></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>在同时支持NFSv4和NFSv3的服务器上，这两种方法都可以工作，并得到相同的结果。</p>
<p><strong>注意</strong></p>
<p>在旧版NFS服务器上的红帽企业版Linux 6之前，根据配置方式，可以将文件系统导出到不同路径的NFSv4客户端。由于这些服务器默认情况下不启用NFSv4，因此通常不会造成问题。</p>
<h3 id="通过防火墙访问RPC配额"><a href="#通过防火墙访问RPC配额" class="headerlink" title="通过防火墙访问RPC配额"></a>通过防火墙访问RPC配额</h3><p>如果导出使用磁盘配额的文件系统，则可以使用配额远程过程调用（RPC）服务向NFS客户端提供磁盘配额数据。</p>
<p><strong>使RPC配额可以在防火墙后面访问</strong></p>
<ol>
<li><p>要启用<code>rpc-rquotad</code>服务，请输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl enable rpc-rquotad</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>要启动<code>rpc-rquotad</code>服务，请输入：</p>
<p>​</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl start rpc-rquotad</span></span><br></pre></td></tr></table></figure>
<p>请注意<code>rpc-rquotad</code>，如果启用，启动<code>nfs-server</code>服务后自动启动。</p>
<p>​</p>
</li>
<li><p>要使配额RPC服务在防火墙后可访问，<code>875</code>需要打开UDP或TCP端口。默认的端口号是在<code>/etc/services</code>文件中定义的。</p>
<p>您可以通过附加到文件中的变量来覆盖默认的端口号。 <code>-p *port-number*``RPCRQUOTADOPTS``/etc/sysconfig/rpc-rquotad</code></p>
</li>
<li><p>重新启动<code>rpc-rquotad</code>了在改变<code>/etc/sysconfig/rpc-rquotad</code>文件生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rpc-rquotad</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="从远程主机设置配额"><a href="#从远程主机设置配额" class="headerlink" title="从远程主机设置配额"></a>从远程主机设置配额</h3><p>默认情况下，配额只能被远程主机读取。要允许设置配额，请将该<code>-S</code>选项附加到文件中的<code>RPCRQUOTADOPTS</code>变量<code>/etc/sysconfig/rpc-rquotad</code>。</p>
<p>重新启动<code>rpc-rquotad</code>了在改变<code>/etc/sysconfig/rpc-rquotad</code>文件生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># systemctl restart rpc-rquotad</span></span><br></pre></td></tr></table></figure>
<h3 id="主机名格式"><a href="#主机名格式" class="headerlink" title="主机名格式"></a>主机名格式</h3><p>host(s)可以采用以下形式：</p>
<ul>
<li><p>Single machine</p>
<p>一个完全合格的域名（可由服务器解析），主机名（可由服务器解析）或IP地址。</p>
</li>
<li><p>Series of machines specified with wildcards</p>
<p>使用<code>*</code>或<code>?</code>字符来指定一个字符串匹配。通配符不能与IP地址一起使用; 但是，如果反向DNS查找失败，他们可能会意外地工作。在完全限定的域名中指定通配符时，通配符中<code>.</code>不包含dots（）。例如，<code>*.example.com</code>包括<code>one.example.com</code>但不是<code>include one.two.example.com</code>。</p>
</li>
<li><p>IP networks</p>
<p>使用<em>abcd / **z</em>，其中<em>abcd</em>是网络，<em>z</em>是网络掩码中的位数（例如192.168.0.0/24）。另一种可接受的格式是<em>abcd / **netmask</em>，其中<em>abcd</em>是网络，<em>netmask</em>是网络掩码（例如，192.168.100.8/255.255.255.0）。</p>
</li>
<li><p>Netgroups</p>
<p>使用格式@ <em>group-name</em>，其中<em>group-name</em>是NIS网络组的名称。</p>
</li>
</ul>
<h3 id="通过RDMA启用NFS（NFSoRDMA）"><a href="#通过RDMA启用NFS（NFSoRDMA）" class="headerlink" title="通过RDMA启用NFS（NFSoRDMA）"></a>通过RDMA启用NFS（NFSoRDMA）</h3><p>如果RDMA支持硬件，则远程直接内存访问（RDMA）服务将在Red Hat Enterprise Linux 7中自动运行。</p>
<p>安装rdma软件包。该<code>/etc/rdma/rdma.conf</code>文件包含一条<em>XPRTRDMA_LOAD=yes</em>默认设置的行，它要求<code>rdma</code>服务加载NFSoRDMA <em>客户端</em>模块。</p>
<p>要启用NFSoRDMA <em>服务器</em>模块的自动加载，请添加<em>SVCRDMA_LOAD=yes</em>一个新行<code>/etc/rdma/rdma.conf</code>。</p>
<p><em>RPCNFSDARGS=”—rdma=20049”</em>在该<code>/etc/sysconfig/nfs</code>文件中指定NFSoRDMA服务侦听客户端的端口号。<a href="https://tools.ietf.org/html/rfc5667" target="_blank" rel="noopener"><em>RFC 5667</em></a>指定在<code>20049</code>通过RDMA提供NFSv4服务时，服务器必须侦听端口。</p>
<p><code>nfs</code>编辑<code>/etc/rdma/rdma.conf</code>文件后 重新启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃service nfs restart</span><br></pre></td></tr></table></figure>
<p>请注意，对于较早的内核版本，编辑后需要重新启动系统才能<code>/etc/rdma/rdma.conf</code>使更改生效。</p>
<h2 id="保护NFS"><a href="#保护NFS" class="headerlink" title="保护NFS"></a>保护NFS</h2><p>NFS适用于大量已知主机透明共享整个文件系统。但是，易用性带来了各种潜在的安全问题。要最大限度地降低NFS安全风险并保护服务器上的数据，请在将NFS文件系统导出到服务器上或挂载到客户机上时考虑以下几节。</p>
<h3 id="使用AUTH-SYS和导出控件的NFS安全性"><a href="#使用AUTH-SYS和导出控件的NFS安全性" class="headerlink" title="使用AUTH_SYS和导出控件的NFS安全性"></a>使用AUTH_SYS和导出控件的NFS安全性</h3><p>传统上，NFS提供了两个选项来控制对导出文件的访问。</p>
<p>首先，服务器限制哪些主机可以通过IP地址或主机名来安装哪些文件系统。</p>
<p>其次，服务器以与本地用户相同的方式为NFS客户端上的用户强制执行文件系统权限。传统上，它使用<code>AUTH_SYS</code>（也称为<code>AUTH_UNIX</code>）依赖于客户端来声明用户的UID和GID。请注意，这意味着恶意或错误配置的客户端可能很容易出错，并允许用户访问不应该访问的文件。</p>
<p>为了限制潜在的风险，管理员经常允许只读访问权限或压缩用户权限到普通用户和组ID。不幸的是，这些解决方案阻止了NFS共享的使用方式。</p>
<p>此外，如果攻击者获得对导出NFS文件系统的系统使用的DNS服务器的控制，则可以将与特定主机名或完全限定的域名关联的系统指向未授权的机器。此时，未经授权的机器<em>是</em>允许安装NFS共享的系统，因为没有交换用户名或密码信息来为NFS安装提供额外的安全性。</p>
<p>在通过NFS导出目录时，应该谨慎使用通配符，因为通配符的范围可能包含比预期更多的系统。</p>
<p>也可以通过TCP封装来限制对<code>rpcbind</code>服务的访问。与创建规则<code>iptables</code>还可以限制访问由使用的端口<code>rpcbind</code>，<code>rpc.mountd</code>和<code>rpc.nfsd</code>。</p>
<p>有关保护NFS的更多信息<code>rpcbind</code>，请参阅<code>man iptables</code>。</p>
<h3 id="NFS安全与AUTH-GSS"><a href="#NFS安全与AUTH-GSS" class="headerlink" title="NFS安全与AUTH_GSS"></a>NFS安全与<code>AUTH_GSS</code></h3><p>NFSv4通过强制实施RPCSEC_GSS和Kerberos版本5 GSS-API机制，彻底改变了NFS的安全性。但是，RPCSEC_GSS和Kerberos机制也适用于所有版本的NFS。在FIPS模式下，只能使用FIPS认可的算法。</p>
<p>与AUTH_SYS不同，使用RPCSEC_GSS Kerberos机制，服务器不依赖于客户端来正确表示哪个用户正在访问该文件。而是使用加密技术来向服务器验证用户身份，从而防止恶意客户端在没有该用户的Kerberos凭据的情况下冒充用户。使用RPCSEC_GSS Kerberos机制是保护安装最直接的方式，因为在配置Kerberos之后，不需要额外的安装。</p>
<h3 id="配置Kerberos"><a href="#配置Kerberos" class="headerlink" title="配置Kerberos"></a>配置Kerberos</h3><p>在配置支持NFSv4 Kerberos的服务器之前，您需要安装并配置Kerberos密钥分发中心（KDC）。Kerberos是一个网络认证系统，它允许客户端和服务器通过使用对称加密和可信的第三方KDC相互认证。红帽推荐使用身份管理（IdM）来设置Kerberos。</p>
<p><strong>程序8.2。为IdM配置NFS服务器和客户端以使用RPCSEC_GSS</strong></p>
<ol>
<li><ul>
<li>在NFS服务器端 创建主体。<code>nfs/hostname.*domain@REALM*</code></li>
<li>在服务器和客户端都 创建主体。<code>host/hostname.*domain@REALM*</code></li>
<li>将相应的密钥添加到客户端和服务器的密钥表中。</li>
</ul>
<p>​</p>
</li>
<li><p>在服务器端，使用<code>sec=</code>选项来启用所需的安全风格。要启用所有的安全风格以及非加密安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/<span class="built_in">export</span> *（sec=sys:krb5:krb5i:krb5p）</span><br></pre></td></tr></table></figure>
<p>与该<code>sec=</code>选项一起使用的有效安全风格是：</p>
<ul>
<li><code>sys</code>：没有密码保护，默认</li>
<li><code>krb5</code>：只有身份验证</li>
<li><code>krb5i</code>：完整性保护</li>
<li><code>krb5p</code>： 隐私保护</li>
</ul>
</li>
<li><p>在客户端，添加<code>sec=krb5</code>（或<code>sec=krb5i</code>，或者<code>sec=krb5p</code>，取决于设置）到挂载选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃mount -o sec=krb5 server:/<span class="built_in">export</span> / mnt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>尽管红帽建议使用IdM，但也支持Active Directory（AD）Kerberos服务器。</p>
<h3 id="使用NFSv4的NFS安全性"><a href="#使用NFSv4的NFS安全性" class="headerlink" title="使用NFSv4的NFS安全性"></a>使用NFSv4的NFS安全性</h3><p>NFSv4包含基于Microsoft Windows NT模型的ACL支持，而不是POSIX模型，因为Microsoft Windows NT模型的功能和广泛的部署。</p>
<p>NFSv4的另一个重要安全功能是删除使用<code>MOUNT</code>协议来安装文件系统。<code>MOUNT</code>由于协议处理文件处理的方式，该协议带来了安全风险。</p>
<h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>一旦NFS文件系统被远程主机读取/写入，每个共享文件的唯一保护就是其权限。如果共享相同用户标识值的两个用户安装相同的NFS文件系统，则可以修改彼此的文件。另外，以root身份登录到客户端系统的任何人都可以使用该<code>su -</code>命令访问具有NFS共享的任何文件。</p>
<p>默认情况下，红帽企业版Linux支持访问控制列表（ACL）。红帽建议保持启用此功能。</p>
<p>默认情况下，NFS 在导出文件系统时使用<em>root</em>压缩。这将在本地计算机上以root用户身份设置访问NFS共享的任何用户的用户标识<code>nobody</code>。</p>
<p>以只读方式导出NFS共享时，请考虑使用该<code>all_squash</code>选项。此选项使每个访问导出的文件系统的用户都可以获取用户的用户标识<code>nfsnobody</code>。</p>
<h2 id="NFS-AND-RPCBIND"><a href="#NFS-AND-RPCBIND" class="headerlink" title="NFS AND RPCBIND"></a>NFS AND RPCBIND</h2><p><strong>注意</strong></p>
<p>以下部分仅适用于需要<code>rpcbind</code>向后兼容服务的NFSv3实现。</p>
<p>在<code>rpcbind</code>实用的地图RPC服务上，他们听的端口。RPC进程<code>rpcbind</code>在启动时进行通知，注册他们正在监听的端口以及他们期望提供的RPC程序编号。客户端系统然后<code>rpcbind</code>用特定的RPC程序号在服务器上联系。该<code>rpcbind</code>服务将客户端重定向到正确的端口号，以便与请求的服务进行通信。</p>
<p>因为基于RPC的服务依赖<code>rpcbind</code>与传入的客户端请求进行所有连接，所以<code>rpcbind</code>必须在这些服务中的任何一个启动之前可用。</p>
<p>该<code>rpcbind</code>服务使用TCP包装进行访问控制，并使用访问控制规则来<code>rpcbind</code>影响<em>所有</em>基于RPC的服务。或者，可以为每个NFS RPC守护进程指定访问控制规则。这些规则的<code>man</code>页面<code>rpc.mountd</code>和<code>rpc.statd</code>包含有关这些规则的精确语法的信息。</p>
<h3 id="NFS和rpcbind故障排除"><a href="#NFS和rpcbind故障排除" class="headerlink" title="NFS和rpcbind故障排除"></a>NFS和<code>rpcbind</code>故障排除</h3><p>因为<code>rpcbind</code>提供了RPC服务和用于与之通信的端口号之间的协调，所以<code>rpcbind</code>在排除故障时查看当前RPC服务的状态是非常有用的。该<code>rpcinfo</code>命令用端口号，RPC程序号，版本号和IP协议类型（TCP或UDP）显示每个基于RPC的服务。</p>
<p>要确保启用适当的基于NFS RPC的服务<code>rpcbind</code>，请发出以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpcinfo -p</span></span><br></pre></td></tr></table></figure>
<p><strong>rpcinfo -p命令输出</strong></p>
<p>以下是此命令的输出示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">program vers proto  port service</span><br><span class="line">      100021    1   udp  32774  nlockmgr</span><br><span class="line">      100021    3   udp  32774  nlockmgr</span><br><span class="line">      100021    4   udp  32774  nlockmgr</span><br><span class="line">      100021    1   tcp  34437  nlockmgr</span><br><span class="line">      100021    3   tcp  34437  nlockmgr</span><br><span class="line">      100021    4   tcp  34437  nlockmgr</span><br><span class="line">      100011    1   udp    819  rquotad</span><br><span class="line">      100011    2   udp    819  rquotad</span><br><span class="line">      100011    1   tcp    822  rquotad</span><br><span class="line">      100011    2   tcp    822  rquotad</span><br><span class="line">      100003    2   udp   2049  nfs</span><br><span class="line">      100003    3   udp   2049  nfs</span><br><span class="line">      100003    2   tcp   2049  nfs</span><br><span class="line">      100003    3   tcp   2049  nfs</span><br><span class="line">      100005    1   udp    836  mountd</span><br><span class="line">      100005    1   tcp    839  mountd</span><br><span class="line">      100005    2   udp    836  mountd</span><br><span class="line">      100005    2   tcp    839  mountd</span><br><span class="line">      100005    3   udp    836  mountd</span><br><span class="line">      100005    3   tcp    839  mountd</span><br></pre></td></tr></table></figure>
<p>如果其中一个NFS服务启动不正确，<code>rpcbind</code>将无法将来自该服务的客户端的RPC请求映射到正确的端口。在许多情况下，如果<code>rpcinfo</code>输出中不存在NFS，则重新启动NFS会使服务正确注册<code>rpcbind</code>并开始工作。</p>
<p>有关更多信息和选项列表<code>rpcinfo</code>，请参阅其<code>man</code>页面。</p>
<h2 id="NFS参考"><a href="#NFS参考" class="headerlink" title="NFS参考"></a>NFS参考</h2><p>管理NFS服务器可能是一个挑战。许多选项（包括本章中未提及的许多选项）都可用于导出或装载NFS共享。有关更多信息，请参阅以下资源。</p>
<h2 id="已安装的文档"><a href="#已安装的文档" class="headerlink" title="已安装的文档"></a>已安装的文档</h2><ul>
<li><code>man mount</code> - 全面了解NFS服务器和客户端配置的安装选项。</li>
<li><code>man fstab</code>- 提供<code>/etc/fstab</code>在启动时用于装入文件系统的文件格式的详细信息。</li>
<li><code>man nfs</code> - 提供有关NFS特定的文件系统导出和安装选项的详细信息。</li>
<li><code>man exports</code>- 显示<code>/etc/exports</code>导出NFS文件系统时在文件中使用的常用选项。</li>
</ul>
<h1 id="FS缓存"><a href="#FS缓存" class="headerlink" title="FS缓存"></a>FS缓存</h1><p>FS-Cache是一个持久的本地缓存，可以被文件系统用来从网络上获取数据并将其缓存在本地磁盘上。这有助于最大限度地减少从网络上安装的文件系统（例如NFS）访问数据的用户的网络流量。</p>
<p>下图是FS-Cache工作原理的高级示例：</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/bB9d6a5FD8.png?imageslim" alt="FS高速缓存概述"></p>
<p>FS-Cache被设计为尽可能透明的系统的用户和管理员。与<code>cachefs</code>Solaris 不同，FS-Cache允许服务器上的文件系统直接与客户端的本地缓存进行交互，而无需创建超量安装的文件系统。通过NFS，挂载选项指示客户端挂载启用FS缓存的NFS共享。</p>
<p>FS-Cache不会改变在网络上工作的文件系统的基本操作 - 它只是为文件系统提供一个可以缓存数据的永久位置。例如，无论是否启用FS-Cache，客户端仍可以挂载NFS共享。另外，缓存的NFS可以处理不适合缓存的文件（无论是单独的还是整体的），因为文件可以被部分缓存，并且不需要在前面完整地读取。FS-Cache还隐藏了客户端文件系统驱动程序中发生在缓存中的所有I / O错误。</p>
<p>为了提供缓存服务，FS-Cache需要一个<em>缓存后端</em>。高速缓存后端是配置为提供高速缓存服务（即<code>cachefiles</code>）的存储驱动程序。在这种情况下，FS-Cache需要一个挂载的基于块的文件系统，支持<code>bmap</code>和扩展属性（例如ext3）作为其缓存后端。</p>
<p>FS-Cache不能随意缓存任何文件系统，无论是通过网络还是以其他方式：共享文件系统的驱动程序必须进行更改以允许与FS-Cache进行交互，数据存储/检索以及元数据设置和验证。FS-Cache需要<em>对</em>来自缓存文件系统的<em>密钥</em>和<em>一致性数据</em>进行索引以支持持久性：索引键将文件系统对象与缓存对象进行匹配，以及通过一致性数据确定缓存对象是否仍然有效。</p>
<p><strong>注意</strong></p>
<p>在红帽企业版Linux 7中，<code>cachefilesd</code>默认情况下不安装，需要手动安装。</p>
<h2 id="履约担保"><a href="#履约担保" class="headerlink" title="履约担保"></a>履约担保</h2><p>FS-Cache并<em>不能</em>保证性能的提高，但是通过避免网络拥塞来保证一致的性能。使用高速缓存后端会导致性能降低：例如，高速缓存的NFS共享将磁盘访问添加到跨网络查找。尽管FS-Cache尝试尽可能异步，但在不可能的地方存在同步路径（例如读取）。</p>
<p>例如，使用FS-Cache在两台计算机之间缓存非共享GigE网络的NFS共享，将不会显示文件访问方面的任何性能改进。相反，NFS请求将从服务器内存而不是从本地磁盘得到满足。</p>
<p>因此FS-Cache的使用是各种因素之间的<em>妥协</em>。例如，如果正在使用FS-Cache来缓存NFS流量，则可能会稍微降低客户端的速度，但通过在本地满足读取请求而大幅减少网络和服务器负载，而不消耗网络带宽。</p>
<h2 id="设置一个缓存"><a href="#设置一个缓存" class="headerlink" title="设置一个缓存"></a>设置一个缓存</h2><p>目前，红帽企业Linux 7只提供<code>cachefiles</code>缓存后端。该<code>cachefilesd</code>守护程序启动和管理<code>cachefiles</code>。该<code>/etc/cachefilesd.conf</code>文件控制如何<code>cachefiles</code>提供缓存服务。要配置此类型的缓存后端，<code>cachefilesd</code>必须安装该包。</p>
<p>在缓存后端配置的第一个设置是将哪个目录用作缓存。要配置它，请使用以下参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dir /path/to/cache</span><br></pre></td></tr></table></figure>
<p>通常，高速缓存后端目录设置<code>/etc/cachefilesd.conf</code>为<code>/var/cache/fscache</code>，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dir /var/cache/fscache</span><br></pre></td></tr></table></figure>
<p>FS-Cache将缓存存储在主机的文件系统中<code>*/path/to/cache*</code>。在笔记本电脑上，建议使用根文件系统（<code>/</code>）作为主机文件系统，但对于桌面计算机来说，将特别为高速缓存装入磁盘分区将更为谨慎。</p>
<p>支持FS-Cache缓存后端所需功能的文件系统包括以下文件系统的Red Hat Enterprise Linux 7实施：</p>
<ul>
<li>ext3（启用扩展属性）</li>
<li>EXT4</li>
<li>BTRFS</li>
<li>XFS</li>
</ul>
<p>主机文件系统必须支持用户定义的扩展属性; FS-Cache使用这些属性来存储一致性维护信息。要为ext3文件系统（即<code>*device*</code>）启用用户定义的扩展属性，请使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ tune2fs -o user_xattr /dev/device</span><br></pre></td></tr></table></figure>
<p>或者，可以在挂载时启用文件系统的扩展属性，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount /dev/device /path/to/cache -o user_xattr</span><br></pre></td></tr></table></figure>
<p>缓存后端通过在托管缓存的分区上维持一定量的可用空间来工作。它使用可用空间来响应系统的其他元素来增长和缩小缓存，使其可以安全地用于根文件系统（例如，在笔记本电脑上）。FS-Cache设置此行为的默认值，可以通过<em>高速缓存剔除限制</em>进行配置。</p>
<p>一旦配置文件就位，启动该<code>cachefilesd</code>服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start cachefilesd</span><br></pre></td></tr></table></figure>
<p>要配置<code>cachefilesd</code>为在引导时启动，请以root身份执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> cachefilesd</span><br></pre></td></tr></table></figure>
<h2 id="通过NFS使用高速缓存"><a href="#通过NFS使用高速缓存" class="headerlink" title="通过NFS使用高速缓存"></a>通过NFS使用高速缓存</h2><p>除非明确指示，否则NFS不会使用缓存。要将NFS挂载配置为使用FS高速缓存，请<code>-o fsc</code>在<code>mount</code>命令中包含以下选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">＃ mount nfs-share:/ /mount/point -o fsc</span><br></pre></td></tr></table></figure>
<p>对文件的所有访问<code>*/mount/point*</code>都将通过缓存，除非打开文件直接I / O或写入。NFS使用NFS文件句柄索引缓存内容，<em>而不是</em>文件名; 这意味着硬链接文件正确共享缓存。</p>
<p>NFS的版本2,3和4支持缓存。但是，每个版本使用不同的分支进行缓存。</p>
<h3 id="缓存共享"><a href="#缓存共享" class="headerlink" title="缓存共享"></a>缓存共享</h3><p>NFS缓存共享有几个潜在的问题。由于缓存是持久的，因此缓存中的数据块将按照四个键的顺序进行索引：</p>
<ul>
<li>级别1：服务器详细信息</li>
<li>等级2：一些安装选项; 安全类型; FSID; 唯一标志</li>
<li>等级3：文件句柄</li>
<li>级别4：文件中的页码</li>
</ul>
<p>为了避免超级块之间的一致性管理问题，所有希望缓存数据的NFS超级块都有唯一的2级密钥。通常情况下，两个具有相同源卷和选项的NFS安装将共享一个超级块，并共享缓存，即使它们在该卷内安装不同的目录。</p>
<p><strong>缓存共享</strong></p>
<p>采取以下两个<code>mount</code>命令：</p>
<p><code>mount home0:/disk0/fred /home/fred -o fsc</code></p>
<p><code>mount home0:/disk0/jim /home/jim -o fsc</code></p>
<p>在这里，<code>/home/fred</code>并且<code>/home/jim</code>很可能会分享超级因为他们有同样的选择，特别是如果他们来自同一个卷/分区NFS服务器上（<code>home0</code>）。现在考虑接下来的两个安装命令：</p>
<p><code>mount home0:/disk0/fred /home/fred -o fsc,rsize=230</code></p>
<p><code>mount home0:/disk0/jim /home/jim -o fsc,rsize=231</code></p>
<p>在这种情况下，<code>/home/fred</code>并<code>/home/jim</code>不会因为他们有不同的网络接入参数，这是二级键的一部分共享超级块。以下装载顺序也是如此：</p>
<p><code>mount home0:/disk0/fred /home/fred1 -o fsc,rsize=230</code></p>
<p><code>mount home0:/disk0/fred /home/fred2 -o fsc,rsize=231</code></p>
<p>这里，两个子树（<code>/home/fred1</code>和<code>/home/fred2</code>）的内容将被缓存<em>两次</em>。</p>
<p>避免超级数据块共享的另一种方法是用<code>nosharecache</code>参数明确地禁止它。使用相同的例子：</p>
<p><code>mount home0:/disk0/fred /home/fred -o nosharecache,fsc</code></p>
<p><code>mount home0:/disk0/jim /home/jim -o nosharecache,fsc</code></p>
<p>然而，在这种情况下，只有超级块中的一个将被允许使用高速缓存，因为没有什么区分等级的2键<code>home0:/disk0/fred</code>和<code>home0:/disk0/jim</code>。为了解决这个问题，添加一个<em>唯一的标识符</em>对安装件中的至少一个，即，。例如： <code>fsc=*unique-identifier*</code></p>
<p><code>mount home0:/disk0/fred /home/fred -o nosharecache,fsc</code></p>
<p><code>mount home0:/disk0/jim /home/jim -o nosharecache,fsc=jim</code></p>
<p>这里，唯一标识符<code>jim</code>将被添加到缓存中使用的级别2密钥中<code>/home/jim</code>。</p>
<h3 id="使用NFS缓存限制"><a href="#使用NFS缓存限制" class="headerlink" title="使用NFS缓存限制"></a>使用NFS缓存限制</h3><p>从共享文件系统中打开直接I / O文件将自动绕过缓存。这是因为这种访问类型必须直接连接到服务器。</p>
<p>从共享文件系统中打开文件以进行写入在NFS版本2和3上将不起作用。这些版本的协议不能为客户端提供足够的一致性管理信息，以检测来自另一个客户端的同一文件的并发写入。</p>
<p>因此，从共享文件系统中为直接I / O或写入打开文件将刷新文件的缓存副本。FS-Cache将不会再次缓存文件，直到不再为直接I / O或写入而打开。</p>
<p>而且，这个FS-Cache的版本只缓存常规的NFS文件。FS-Cache <em>不会</em>缓存目录，符号链接，设备文件，FIFO和套接字。</p>
<h2 id="设置高速缓存限制"><a href="#设置高速缓存限制" class="headerlink" title="设置高速缓存限制"></a>设置高速缓存限制</h2><p>该<code>cachefilesd</code>守护程序的工作原理是从共享文件系统的远程数据缓存到磁盘上的可用空间。这可能会消耗所有可用的可用空间，如果该磁盘也容纳了根分区，则这可能是不好的。为了控制这一点，<code>cachefilesd</code>通过从缓存中丢弃旧对象（即，最近访问较少）来尝试保持一定量的可用空间。这种行为被称为<em>高速缓存剔除</em>。</p>
<p>高速缓存剔除是根据块的百分比和底层文件系统中可用文件的百分比来完成的。有六个限制由以下设置控制<code>/etc/cachefilesd.conf</code>：</p>
<ul>
<li><p>brun <em>N</em>％（块的百分比），frun <em>N</em>％（文件的百分比）</p>
<p>如果可用空间量和缓存中可用文件的数量超过这两个限制，则关闭剔除。</p>
</li>
<li><p>bcull <em>N</em>％（块的百分比），fcull <em>N</em>％（文件的百分比）</p>
<p>如果可用空间量或缓存中的文件数量低于这些限制中的任何一个，则将开始剔除。</p>
</li>
<li><p>bstop <em>N</em>％（块的百分比），brun<code>/</code>frun`- 10％</p>
</li>
</ul>
<ul>
<li><code>bcull</code>/ <code>fcull</code>- 7％</li>
<li><code>bstop</code>/ <code>fstop</code>- 3％</li>
</ul>
<p>配置这些设置时，必须满足以下条件：</p>
<p>0 &lt;= <code>bstop</code>&lt; <code>bcull</code>&lt; <code>brun</code>&lt;100</p>
<p>0 &lt;= <code>fstop</code>&lt; <code>fcull</code>&lt; <code>frun</code>&lt;100</p>
<p>这些是可用空间和可用文件的百分比，并不显示为100减去<code>df</code>程序显示的百分比。</p>
<p><strong>重要</strong></p>
<p>剔除同时取决于b <em>xxx</em>和f <em>xxx</em>对; 他们不能分开处理。</p>
<h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p>FS-Cache也跟踪一般的统计信息。要查看此信息，请使用：</p>
<p><code>cat /proc/fs/fscache/stats</code></p>
<p>FS-Cache统计信息包括有关决策点和对象计数器的信息。有关FS-Cache提供的统计信息的更多细节，请参阅以下内核文档：</p>
<p><code>/usr/share/doc/kernel-doc-*version*/Documentation/filesystems/caching/fscache.txt</code></p>
<h2 id="FS-高速缓存引用"><a href="#FS-高速缓存引用" class="headerlink" title="FS-高速缓存引用"></a>FS-高速缓存引用</h2><p>有关<code>cachefilesd</code>如何配置的更多信息，请参阅<code>man cachefilesd</code>和<code>man cachefilesd.conf</code>。以下内核文档还提供了附加信息：</p>
<ul>
<li><code>/usr/share/doc/cachefilesd-*version-number*/README</code></li>
<li><code>/usr/share/man/man5/cachefilesd.conf.5.gz</code></li>
<li><code>/usr/share/man/man8/cachefilesd.8.gz</code></li>
</ul>
<p>有关FS-Cache的一般信息，包括其设计约束，可用统计信息和功能的详细信息，请参阅以下内核文档：</p>
<p><code>/usr/share/doc/kernel-doc-*version*/Documentation/filesystems/caching/fscache.txt</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Filesystem</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 安装</title>
    <url>/2017/11/11/ubuntu/</url>
    <content><![CDATA[<h1 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h1><p>独立磁盘冗余阵列“RAID”是根据所使用的RAID级别，使用多个磁盘来提供不同的增加数据可靠性和/或增加输入/输出性能的平衡的方法。RAID可以通过软件（操作系统知道两个驱动器并主动维护两个驱动器）或硬件（一个特殊的控制器使操作系统认为只有一个驱动器并保持驱动器不可见）实现。</p>
<p>当前版本的Linux（和Ubuntu）包含的RAID软件基于“mdadm” 驱动程序，运行良好，甚至比许多所谓的“硬件”RAID控制器更好。本节将指导您如何在两个物理硬盘驱动器上使用两个RAID1分区来安装Ubuntu Server Edition，一个用于  “/“   和另一个用于swap。</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>按照安装步骤进行操作，直到进入“ 分区磁盘”步骤，然后：</p>
<ol>
<li><p>选择Manual作为分区方法。</p>
</li>
<li><p>选择第一个硬盘，并同意“Create a new empty partition table on this device?”。</p>
<p>对于您希望成为RAID阵列一部分的每个驱动器重复此步骤。</p>
</li>
<li><p>选择第一个驱动器上的“FREE SPACE”，然后选择“Create a new partition”。</p>
</li>
<li><p>接下来，选择分区的大小。这个分区将是交换分区，交换大小的一般规则是RAM的两倍。输入分区大小，然后选择“ Primary”，然后选择“ Beginning”。</p>
<a id="more"></a>
<p>可用RAM容量的两倍的swap大小可能并不总是可取的，特别是在具有大量RAM的系统上。计算服务器的交换分区大小主要取决于系统将如何使用。</p>
</li>
<li><p>选择顶部的“Use as：”行。默认情况下，这是 “Ext4日志文件系统”，将其更改为“physical volume for RAID”， 然后“Done setting up partition”。</p>
</li>
<li><p>对于 “ / “ 分区再次选择第一个驱动器上的“Free Space”，然后 “Create a new partition”。</p>
</li>
<li><p>使用驱动器上其余的可用空间，然后选择Continue ，然后选择Primary。</p>
</li>
<li><p>与swap一样，选择顶部的“Use as：”physical volume for RAID”。还要选择 “Bootable flag：”来将该值更改为 “on”。然后选择“完成设置分区”。</p>
</li>
<li><p>对其他磁盘和分区重复第三步到第八步。</p>
</li>
</ol>
<h3 id="RAID配置"><a href="#RAID配置" class="headerlink" title="RAID配置"></a>RAID配置</h3><p>通过分区设置，阵列可以进行配置：</p>
<ol>
<li><p>回到主“Partition Disks”页面，选择顶部的“Configure Software RAID”。</p>
</li>
<li><p>选择“yes”将更改写入磁盘。</p>
</li>
<li><p>选择“Create MD device”。</p>
</li>
<li><p>在这个例子中，选择“RAID1”，但如果使用不同的设置，请选择适当的类型（RAID0 RAID1 RAID5）。</p>
<p>为了使用RAID5，您至少需要三个驱动器。使用RAID0或RAID1只需要两个驱动器。</p>
</li>
<li><p>为阵列 输入活动设备的数量“2”，或者硬盘的数量。然后选择“Continue”。</p>
</li>
<li><p>接下来，默认输入备用设备的数量“0”，然后选择“Continue”。</p>
</li>
<li><p>选择使用哪个分区。通常它们是sda1，sdb1，sdc1等。数字通常会匹配，不同的字母对应不同的硬盘。</p>
<p>对于swap，选择sda1和sdb1。选择“Continue”进入下一步。</p>
</li>
<li><p>为 “/“ 分区选择 sda2和sdb2 重复第三步到第七步。</p>
</li>
<li><p>完成后，选择“Continue”。</p>
</li>
</ol>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>现在应该有一个硬盘和RAID设备的列表。下一步是格式化和设置RAID设备的安装点。将RAID设备视为本地硬盘驱动器，进行相应的格式化和安装。</p>
<ol>
<li>选择“ RAID1 device ＃0”分区下的“＃1”。</li>
<li>选择“Use as：”。然后选择“swap”，然后选择 “Done setting up partitio”。</li>
<li>接下来，选择“ RAID1 device ＃1”分区下的“＃1”。</li>
<li>选择“Use as：”。然后选择“Ext4日志文件系统”。</li>
<li>然后选择“挂载点”并选择“/ - 根文件系统”。根据需要更改任何其他选项，然后选择“Done setting up partition”。</li>
<li>最后，选择“Finish partitioning and write changes to disk”。</li>
</ol>
<p>如果您选择将根分区放置在RAID阵列上，则安装程序会询问您是否要在降级状态下引导。有关更多详细信息，请参阅“ <a href="https://help.ubuntu.com/14.04/serverguide/advanced-installation.html#raid-degraded" target="_blank" rel="noopener">降级RAID</a> ”。</p>
<p>安装过程将继续正常。</p>
<h3 id="降级的RAID"><a href="#降级的RAID" class="headerlink" title="降级的RAID"></a>降级的RAID</h3><p>在计算机生命中的某个时刻，可能会发生磁盘故障事件。发生这种情况时，使用软件RAID，操作系统将把阵列置于所谓的降级状态。</p>
<p>如果阵列已经降级，由于数据损坏的可能性，默认情况下，Ubuntu Server Edition将在三十秒后启动到initramfs。initramfs启动后，会有15秒的提示，让您选择继续并引导系统，或尝试手动恢复。引导到initramfs提示可能会或可能不是所需的行为，特别是如果机器位于远程位置。引导到降级阵列可以通过以下几种方式进行配置：</p>
<ul>
<li><p>在参阅dpkg-重新配置工具可以用来配置默认行为，过程中你会被问及有关阵列其他设置。如监控，电子邮件警报等。要重新配置mdadm，请输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure mdadm</span><br></pre></td></tr></table></figure>
</li>
<li><p>在参阅dpkg-重新配置mdadm的进程将改变/etc/initramfs-tools/conf.d/mdadm 配置文件。该文件的优点是可以预先配置系统的行为，也可以手动编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BOOT_DEGRADED=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>配置文件可以通过使用Kernel参数来覆盖。</p>
</li>
<li><p>使用Kernel参数将允许系统启动到降级阵列：</p>
<ul>
<li>当服务器启动时，按下Shift打开Grub菜单。</li>
<li>按e编辑您的内核命令选项。</li>
<li>按down箭头突出显示内核行。</li>
<li>将“bootdegraded = true”（不带引号）添加到该行的末尾。</li>
<li>按Ctrl+x启动系统。</li>
</ul>
</li>
</ul>
<p>一旦系统启动后，您可以修复阵列，请参阅“ <a href="https://help.ubuntu.com/14.04/serverguide/advanced-installation.html#raid-maintenance" target="_blank" rel="noopener">RAID维护”</a>以了解详细信息，或者将重要数据复制到另一台计算机，因为严重的硬件故障。</p>
<h3 id="RAID维护"><a href="#RAID维护" class="headerlink" title="RAID维护"></a>RAID维护</h3><p>所述mdadm的实用程序可用于查看一个阵列的状态，将磁盘添加到阵列，删除磁盘等：</p>
<ul>
<li><p>要从终端提示符查看数组的状态，请输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mdadm -D /dev/md0</span><br></pre></td></tr></table></figure>
<p>所述-D告诉mdadm的显示详细有关信息的/ dev / MD0设备。用相应的RAID设备替换/ dev / md0。</p>
</li>
<li><p>要查看数组中磁盘的状态，请执行以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mdadm -E /dev/sda1</span><br></pre></td></tr></table></figure>
<p>输出如果非常类似于mdadm -D命令，请为每个磁盘调整/ dev / sda1。</p>
</li>
<li><p>如果磁盘发生故障，需要从阵列中删除，请输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mdadm  --remove /dev/md0 /dev/sda1</span><br></pre></td></tr></table></figure>
<p>将/ dev / md0和/ dev / sda1更改为相应的RAID设备和磁盘。</p>
</li>
<li><p>同样，要添加一个新的磁盘：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mdadm --add /dev/md0 /dev/sda1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有时，即使驱动器没有任何物理错误，磁盘也可能会更改为故障状态。通常值得从阵列中移除驱动器，然后重新添加它。这将导致驱动器与阵列重新同步。如果驱动器不能与阵列同步，则表示硬件故障。</p>
<p>在的/ proc / mdstat文件还包含了系统的RAID设备的有用信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/mdstat</span><br><span class="line">Personalities : [linear] [multipath] [raid0] [raid1] [raid6] [raid5] [raid4] [raid10] </span><br><span class="line">md0 : active raid1 sda1[0] sdb1[1]</span><br><span class="line">      10016384 blocks [2/2] [UU]</span><br><span class="line">unused devices: &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>以下命令非常适合查看同步驱动器的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n1 cat /proc/mdstat</span><br></pre></td></tr></table></figure>
<p>按下Ctrl + c停止监视命令。</p>
<p>如果确实需要更换有故障的驱动器，在更换和同步驱动器之后，需要安装grub。要在新驱动器上安装grub，请输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo grub-install /dev/md0</span><br></pre></td></tr></table></figure>
<p>用相应的阵列设备名称替换/ dev/md0。</p>
<h3 id="扩展卷组"><a href="#扩展卷组" class="headerlink" title="扩展卷组"></a>扩展卷组</h3><p>继续以srv作为LVM卷的例子，本节介绍添加第二个硬盘，创建物理卷（PV），将其添加到卷组（VG），扩展逻辑卷srv 并最终扩展文件系统。这个例子假定第二个硬盘已经被添加到系统中。在这个例子中，这个硬盘将被命名为/ dev/sdb，我们将使用整个磁盘作为物理卷（您可以选择创建分区并将它们用作不同的物理卷）</p>
<p>在发出下面的命令之前， 请确保您没有现有的/ dev / sdb。如果您在非空磁盘上执行这些命令，则可能会丢失一些数据。</p>
<ol>
<li><p>首先创建物理卷，在终端执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pvcreate /dev/sdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在扩展卷组（VG）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vgextend vg01 /dev/sdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vgdisplay来找出剩余的物理盘区 - 剩余的PE /大小（你可以分配的大小）。我们将假定一个511 PE的自由大小（相当于2GB，PE大小为4MB），我们将使用整个可用空间。使用自己的PE和/或剩余空间。</p>
<p>逻辑卷（LV）现在可以通过不同的方法扩展，我们只会看到如何使用PE来扩展LV：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lvextend /dev/vg01/srv -l +511</span><br></pre></td></tr></table></figure>
<p>的-l选项允许LV使用PE来扩展。的-L选项允许LV使用梅格，吉格，特拉等字节被扩展。</p>
</li>
<li><p>即使你应该能够扩展一个ext3或者ext4文件系统，而不需要先卸载它，但是最好还是卸载它，然后检查一下文件系统，这样你就不会搞砸了你想要减少的那一天逻辑卷（在这种情况下首先卸载是强制性的）。</p>
<p>以下命令适用于EXT3或EXT4文件系统。如果您正在使用其他文件系统，则可能有其他实用程序可用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount /srv</span><br><span class="line">sudo e2fsck -f /dev/vg01/srv</span><br></pre></td></tr></table></figure>
<p>即使系统看起来干净，e2fsck 的-f选项也会强制检查。</p>
</li>
<li><p>最后，调整文件系统的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo resize2fs /dev/vg01/srv</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在安装分区并检查其大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/vg01/srv /srv &amp;&amp; df -h /srv</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>用Typora编辑Markdown</title>
    <url>/2017/11/11/Markdown%20Reference/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="段落和换行符"><a href="#段落和换行符" class="headerlink" title="段落和换行符"></a>段落和换行符</h2><p>一个段落只是一个或多个连续的文本行。在Markdown源代码中，段落由多个空行分隔。在Typora，你只需要按下来<code>Return</code>创建一个新的段落。</p>
<p>按<code>Shift</code>+ <code>Return</code>创建一个换行符。但是，大多数Markdown解析器将忽略单行断点，使其他降价解析器识别您的换行符，您可以在行的末尾留下两个空格，或插入<code>&lt;br/&gt;</code>。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题在行首使用1-6个哈希字符，对应于标题级别1-6。例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure>
<p>在typora中，输入’＃’，然后输入标题内容，然后<code>Return</code>按键将创建一个标题。</p>
<h2 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h2><a id="more"></a>
<p>Markdown使用电子邮件风格&gt;字符来块引用。他们被呈现为：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. This is first paragraph.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote.</span></span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>输入<code>* list item 1</code>将创建一个无序列表，该<code>*</code>符号可以替换为<code>+</code>或<code>-</code>。</p>
<p>输入<code>1. list item 1</code>将创建一个有序列表，其Markdown代码是这样的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">## un-ordered list</span></span><br><span class="line"><span class="bullet">*   </span>Red</span><br><span class="line"><span class="bullet">*   </span>Green</span><br><span class="line"><span class="bullet">*   </span>Blue</span><br><span class="line"></span><br><span class="line"><span class="section">## ordered list</span></span><br><span class="line"><span class="bullet">1.  </span>Red</span><br><span class="line"><span class="bullet">2. 	</span>Green</span><br><span class="line"><span class="bullet">3.	</span>Blue</span><br></pre></td></tr></table></figure>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>任务列表是列出项目标记为[   ]或[x]（不完整或不完整）的列表。例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] a task list item</span><br><span class="line"><span class="bullet">- </span>[ ] list syntax required</span><br><span class="line"><span class="bullet">- </span>[ ] normal <span class="strong">**formatting**</span>, @mentions, #1234 refs</span><br><span class="line"><span class="bullet">- </span>[ ] incomplete</span><br><span class="line"><span class="bullet">- </span>[x] completed</span><br></pre></td></tr></table></figure>
<p>您可以通过点击项目前面的复选框来更改完整/不完整状态。</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>Typora只支持Github Flavored Markdown中的栅栏。不支持Markdown的原始代码块。</p>
<p>使用围栏很容易：输入<code>`然后按`return`。在</code>后面添加一个可选的语言标识符，我们将通过语法高亮来运行它：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'redcarpet'</span></span><br><span class="line">markdown = Redcarpet.new(<span class="string">"Hello World!"</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>输入<code>| First Header | Second Header |</code>并按下<code>return</code>键将创建一个两列的表格。</p>
<p>在创建表之后，将焦点放在该表上将弹出一个表格的工具栏，您可以在其中调整，对齐或删除表格。您还可以使用上下文菜单来复制和添加/删除列/行。</p>
<p>以下描述可以跳过，因为表格的降价源代码是由typora自动生成的。</p>
<p>在markdown源代码，他们看起来像：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure>
<p>您还可以包含内联Markdown，如链接，粗体，斜体或删除线。</p>
<p>最后，通过在标题行中包含冒号，可以定义要左对齐，右对齐或居中对齐的文本：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure>
<p>最左侧的冒号表示左对齐的列; 最右侧的冒号表示右对齐的列; 两边的冒号表示一个中心对齐的列。</p>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">You can create footnotes like this[^footnote].</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^footnote</span>]: <span class="link">Here is the *text* of the **footnote**.</span></span><br></pre></td></tr></table></figure>
<p>You can create footnotes like this<sup><a href="#fn_1" id="reffn_1">1</a></sup>.</p>
<p>鼠标在’脚注’上标上看脚注的内容。</p>
<h2 id="横向规则"><a href="#横向规则" class="headerlink" title="横向规则"></a>横向规则</h2><p>输入<code>***</code>或<code>---</code>在一个空行，然后按<code>return</code>将绘制一条水平线。</p>
<hr>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>现在，Typora支持<a href="http://jekyllrb.com/docs/frontmatter/" target="_blank" rel="noopener">YAML前端技术</a>。<code>---</code>在文章的顶部输入，然后按<code>Enter</code>会介绍一个。或者从菜单中插入一个元数据块。</p>
<h2 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h2><p>输入<code>[toc]</code>然后<code>Return</code>按键将创建一个“目录”部分提取所有标题从一个人的写作，其内容将自动更新。</p>
<h1 id="span元素"><a href="#span元素" class="headerlink" title="span元素"></a>span元素</h1><p>Span元素将在您输入后被解析和渲染。将光标移动到这些span元素的中间，将这些元素展开为markdown 。以下将解释这些span元素的语法。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown支持两种链接：内联和引用。</p>
<p>在这两种样式中，链接文本均由[方括号]分隔。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>](<span class="link">http://example.com/ "Title"</span>) inline link.</span><br><span class="line"></span><br><span class="line">[<span class="string">This link</span>](<span class="link">http://example.net/</span>) has no title attribute.</span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<p>这是<a href="http://example.com/%22Title%22" target="_blank" rel="noopener">一个</a>内联链接<a href="http://example.com/%22Title%22" target="_blank" rel="noopener">的例子</a>。（<code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</code>）</p>
<p><a href="http://example.net/" target="_blank" rel="noopener">此链接</a>没有标题属性。（<code>&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</code>）</p>
<h3 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h3><p><strong>您可以将href设置为标题</strong>，这将创建一个书签，允许您在单击后跳转到该部分。例如：</p>
<p>命令（在Windows上：Ctrl）+单击<a href="http://support.typora.io/Markdown-Reference/#block-elements" target="_blank" rel="noopener">此链接</a>将跳转到标题<code>Block Elements</code>。要了解如何编写该代码，请移动光标或<code>⌘</code>按下按键以将该元素展开为markdown来源。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>引用样式链接使用第二组方括号，在其中放置您选择的标签以标识链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">This is [<span class="string">an example</span>][<span class="symbol">id</span>] reference-style link.</span><br><span class="line"></span><br><span class="line">Then, anywhere in the document, you define your link label like this, on a line by itself:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">id</span>]: <span class="link">http://example.com/  "Optional Title Here"</span></span><br></pre></td></tr></table></figure>
<p>在typora中，它们将被渲染为：</p>
<p>这是<a href="http://example.com/" target="_blank" rel="noopener">一个示例</a>引用样式的链接。</p>
<p>隐式链接名称快捷方式允许您省略链接的名称，在这种情况下链接文本本身被用作名称。只需使用一组空白的方括号 - 例如，将单词“Google”链接到google.com网站，您可以简单地写：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br><span class="line">And then define the link:</span><br><span class="line"></span><br><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>
<p>在typora点击链接将其展开进行编辑，commond+单击将在Web浏览器中打开超链接。</p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>Typora允许你将URL作为链接插入，用<code>&lt;</code>括号括起来<code>&gt;</code>。</p>
<p><code>&lt;i@typora.io&gt;</code>变成<a href="mailto:i@typora.io">i@typora.io</a>。</p>
<p>Typora将自动链接标准URL。例如：www.google.com。</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图像看起来与链接类似，但是<code>!</code>在链接开始之前它需要额外的字符。图像语法如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg "Optional title"</span>)</span><br></pre></td></tr></table></figure>
<p>您可以使用拖放功能从图像文件或网络浏览器插入图像。点击图片修改降价源代码。如果图像在拖放时处于与当前编辑文档相同的目录或子目录中，则会使用相对路径。</p>
<p>如果您使用markdown来构建网站，则可以在本地计算机中指定一个URL前缀用于<code>typora-root-url</code>在YAML前台事件中使用属性的图像预览。例如，<code>typora-root-url:/User/Abner/Website/typora.io/</code>在YAML Front Matters中输入，然后<code>![alt](/blog/img/test.png)</code>将被视为<code>![alt](file:///User/Abner/Website/typora.io/blog/img/test.png)</code>在typora中。</p>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>Markdown把星号（<code>*</code>）和下划线（<code>_</code>）作为重点指标。用一个HTML 标签包装的文本<code>*</code>或<code>_</code>将被包装<code>&lt;em&gt;</code>。例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*single asterisks*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_single underscores_</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><em>单星号</em></p>
<p><em>单下划线</em></p>
<p>GFM将会忽略下面的代码和名称中常用的下划线，如下所示：</p>
<blockquote>
<p>wow_great_stuff</p>
<p>do_this_and_do_that_and_another_thing。</p>
</blockquote>
<p>要在原本应该用作强调分隔符的位置上生成一个字面星号或下划线，可以使用反斜杠进行转义：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\<span class="emphasis">*this text is surrounded by literal asterisks\*</span></span><br></pre></td></tr></table></figure>
<p>Typora建议使用<code>*</code>符号。</p>
<h3 id="Strong"><a href="#Strong" class="headerlink" title="Strong"></a>Strong</h3><p>双*或s将被包装一个HTML <code>&lt;strong&gt;</code>标签，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**double asterisks**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__double underscores__</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><strong>双星号</strong></p>
<p><strong>双下划线</strong></p>
<p>Typora建议使用<code>**</code>符号。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>为了表示一段代码，用反引号（`）来包装它。与预格式化的代码块不同，代码段指示正常段落内的代码。例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Use the <span class="code">`printf()`</span> function.</span><br></pre></td></tr></table></figure>
<p>会产生：</p>
<p>使用该<code>printf()</code>功能。</p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>GFM添加语法来创建删除线文本，这是从标准的Markdown中丢失的。</p>
<p><code>~~Mistaken text.~~</code> 变 <del>错误的文本。</del></p>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>下划线由原始HTML驱动。</p>
<p><code>&lt;u&gt;Underline&lt;/u&gt;</code>成为下划线。</p>
<h3 id="表情符号：开心："><a href="#表情符号：开心：" class="headerlink" title="表情符号：开心："></a>表情符号：开心：</h3><p>用语法输入表情符号<code>:smile:</code>。</p>
<p>用户可以通过<code>ESC</code>按键触发表情符号的自动完成建议，或在偏好面板上启用后自动触发。此外，还支持从菜单栏直接从<code>Edit</code>- &gt; 输入UTF8表情符号字符<code>Emoji &amp; Symbols</code>。</p>
<h3 id="内联数学"><a href="#内联数学" class="headerlink" title="内联数学"></a>内联数学</h3><p>要使用此功能，首先，请在<code>Preference</code>面板 - &gt; <code>Markdown</code>选项卡中启用它。然后使用<script type="math/tex">`包装TeX命令，例如：`$\lim_{x \to \infty} \exp(-x) = 0</script>将被渲染为LaTeX命令。</p>
<p>要触发内嵌数学的内联预览，请输入“$”，然后<code>ESC</code>按键，然后输入TeX命令，预览工具提示将如下所示：</p>
<p>$\l</p>
<p><img src="http://typora.io/img/inline-math.gif" alt="内列数学"></p>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>要使用此功能，首先，请在<code>Preference</code>面板 - &gt; <code>Markdown</code>选项卡中启用它。然后使用<code>~</code>包装下标内容，例如：<code>H~2~O</code>，<code>X~long\ text~</code>/</p>
<h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>要使用此功能，首先，请在<code>Preference</code>面板 - &gt; <code>Markdown</code>选项卡中启用它。然后<code>^</code>用来包装上标内容，例如：<code>X^2^</code>。</p>
<h3 id="突出"><a href="#突出" class="headerlink" title="突出"></a>突出</h3><p>要使用此功能，首先，请在<code>Preference</code>面板 - &gt; <code>Markdown</code>选项卡中启用它。然后<code>==</code>用来包装高亮内容，例如：<code>==highlight==</code>。</p>
<blockquote id="fn_1">
<sup>1</sup>. Here is the <em>text</em> of the <strong>footnote</strong>. <a href="http://support.typora.io/Markdown-Reference/#fnref:1" target="_blank" rel="noopener">↩</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM虚拟化基础</title>
    <url>/2017/11/11/Virtualization/</url>
    <content><![CDATA[<h1 id="虚拟化概述"><a href="#虚拟化概述" class="headerlink" title="虚拟化概述"></a>虚拟化概述</h1><h2 id="什么是虚拟化？"><a href="#什么是虚拟化？" class="headerlink" title="什么是虚拟化？"></a>什么是虚拟化？</h2><p><em>虚拟化</em>是一个广泛的计算术语，用于运行软件，通常是多个操作系统，与单个系统上的其他程序隔离。虚拟化是通过使用<em>管理程序</em>完成的。这是一个软件层或子系统，可以控制硬件，并且可以在单个（通常是物理）机器上运行多个操作系统（称为VM（虚拟机）或guests）。这台装有操作系统的机器被称为<em>HOST</em>。有几种虚拟化方法：</p>
<ul>
<li><p><strong>完全虚拟化</strong></p>
<p>完全虚拟化使用未经修改的客户操作系统版本。访客通过管理程序创建的通道来访问主机的CPU。因为guest虚拟机与CPU直接通信，所以这是最快的虚拟化方法。</p>
</li>
<li><p><strong>半虚拟化</strong></p>
<p>半虚拟化使用修改的客户操作系统。访客与管理程序进行通信。虚拟机管理程序将来自guest虚拟机的未修改的调用传递给CPU和其他接口，包括实际的和虚拟的。由于呼叫是通过管理程序路由的，因此此方法比完全虚拟化慢。</p>
</li>
<li><p><strong>软件虚拟化（或仿真）</strong></p>
<p>软件虚拟化使用二进制翻译和其他仿真技术来运行未经修改的操作系统。管理程序将来宾呼叫转换为主机系统可以使用的格式。由于所有的调用都被翻译，所以这个方法比虚拟化要慢。请注意，红帽不支持红帽企业Linux上的软件虚拟化。</p>
<a id="more"></a>
<h2 id="虚拟化解决方案"><a href="#虚拟化解决方案" class="headerlink" title="虚拟化解决方案"></a>虚拟化解决方案</h2></li>
</ul>
<p>红帽提供以下主要的虚拟化解决方案，每个解决方案都有不同的用户焦点和功能：</p>
<ul>
<li><p>红帽企业Linux</p>
<p>红帽企业版Linux 7中包含了 创建，运行和管理虚拟机以及<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/chap-Virtualization_Getting_Started-Products" target="_blank" rel="noopener">大量虚拟化工具和功能的</a>能力。该解决方案支持每台主机有限的运行guest 虚拟机数量，以及有限的来宾类型。因此，红帽企业Linux上的虚拟化对于需要在多个环境中进行测试的开发人员，或者对于运行多个服务器的小型企业（没有严格的正常运行时间要求或服务级别协议（SLA））是有用的。<strong>重要</strong>本指南提供了关于红帽企业Linux上虚拟化的信息，并没有详细介绍其他虚拟化解决方案。</p>
</li>
<li><p>红帽虚拟化</p>
<p>红帽虚拟化（RHV）基于基于内核的虚拟机（<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/chap-Virtualization_Getting_Started-Products#sec-Virtualization_Getting_Started-Products-kvm_and_virt" target="_blank" rel="noopener">KVM</a>）技术，如红帽企业Linux上的虚拟化，但提供了一系列增强的功能。专为企业级可扩展性和性能而设计，可以从集中的图形界面管理整个虚拟基础架构，包括主机，虚拟机，网络，存储和用户。<strong>注意</strong>有关红帽企业版Linux和红帽虚拟化之间的差异的更多信息，请参阅<a href="https://access.redhat.com/solutions/629513" target="_blank" rel="noopener">红帽客户门户。</a>运行大型部署或任务关键型应用程序的企业可以使用红帽虚拟化。适用于红帽虚拟化的大型部署的例子包括数据库，交易平台和消息系统，这些系统必须连续运行而不会停机。<strong>注意</strong>有关红帽虚拟化的更多信息，或下载完全支持的60天评估版本，请参阅<a href="http://www.redhat.com/en/technologies/virtualization/enterprise-virtualization" target="_blank" rel="noopener">http://www.redhat.com/en/technologies/virtualization/enterprise-virtualization</a>。或者，请参阅<a href="https://access.redhat.com/documentation/en/red-hat-virtualization/" target="_blank" rel="noopener">红帽虚拟化文档套件</a>。</p>
</li>
<li><p>红帽OpenStack平台</p>
<p>红帽OpenStack平台为创建，部署和扩展安全可靠的公共或私有<a href="https://www.redhat.com/en/insights/openstack" target="_blank" rel="noopener">OpenStack</a>云提供了一个综合基础。<strong>注意</strong>有关红帽OpenStack平台的更多信息。</p>
</li>
</ul>
<h2 id="为什么要使用虚拟化？"><a href="#为什么要使用虚拟化？" class="headerlink" title="为什么要使用虚拟化？"></a>为什么要使用虚拟化？</h2><p>虚拟化对服务器部署和个人台式电脑都有用。桌面虚拟化提供经济高效的集中管理和更好的灾难恢复。另外，通过使用连接工具（如<em>ssh）</em>，可以远程连接到桌面。</p>
<p>当用于服务器时，虚拟化不仅可以使大型网络受益，还可以使用多台服务器进行部署。虚拟化提供实时迁移，高可用性，容错和简化的备份。</p>
<h2 id="虚拟化成本"><a href="#虚拟化成本" class="headerlink" title="虚拟化成本"></a>虚拟化成本</h2><p>虚拟化的引入可能很昂贵，但是从长远来看，这往往会节省资金。考虑以下好处：</p>
<ul>
<li><p>较少的权力</p>
<p>使用虚拟化消除了多个物理平台的需求。这相当于减少了机器运行和冷却的功率，从而降低了能源成本。购买多个物理平台的初始成本，加上机器的功耗和所需的冷却，通过使用虚拟化大幅削减。</p>
</li>
<li><p>少维护</p>
<p>如果在将物理系统迁移到虚拟化系统之前进行了适当的规划，则需要更少的时间来维护它们。这意味着需要花费更少的钱在零件和劳动力上。</p>
</li>
<li><p>已安装软件的使用寿命延长</p>
<p>老版本的软件可能无法直接在更新的裸机上运行。通过在更大，更快的系统上虚拟运行较旧的软件，可以延长软件的使用寿命，同时利用更新系统的更好性能。</p>
</li>
<li><p>可预测的成本</p>
<p>红帽企业Linux订阅以固定的速率提供对虚拟化的支持，使预测成本变得容易。</p>
</li>
<li><p>更小的空间</p>
<p>将服务器整合到更少的机器上意味着计算机系统需要更少的物理空间。</p>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>较早的虚拟化版本仅支持单个CPU。结果，虚拟机器经历了明显的性能限制。这造成了虚拟化解决方案缓慢的长期误解。</p>
<p>这不再是这种情况。现代虚拟化技术大大提高了虚拟机的速度。基准测试表明，虚拟机可以像裸机系统一样有效运行典型的服务器应用程序：</p>
<ul>
<li>红帽企业Linux 6.4和KVM记录<a href="http://www.redhat.com/about/news/archive/2013/2/red-hat-and-ibm-achieve-leading-performance-benchmark-results" target="_blank" rel="noopener">了业界领先的TPC-C基准测试</a>，其中IBM DB2数据库运行在完全虚拟化的x86环境中，提供了88％的裸机性能。由于资源需求，数据库以前只保留用于裸机部署。</li>
<li>行业标准的SAP销售和分销（SD）标准应用基准测试发现，与在相同硬件上运行的裸机系统相比，红帽企业Linux 6.2和KVM <a href="https://access.redhat.com/articles/216943" target="_blank" rel="noopener">的虚拟化效率高达85％</a>。</li>
<li>红帽企业Linux 6.1和KVM 在标准性能评估公司（SPEC）记录<a href="https://www.redhat.com/en/about/press-releases/Red-Hat-Achieves-New-Top-Virtualization-Performance-Benchmark-with-HP" target="_blank" rel="noopener">的SPECvirt_sc2010基准测试中</a>获得了<a href="https://www.redhat.com/en/about/press-releases/Red-Hat-Achieves-New-Top-Virtualization-Performance-Benchmark-with-HP" target="_blank" rel="noopener">创纪录的虚拟化性能</a>，设置了任何已发布的SPECvirt结果的最佳虚拟性能标志。SPECvirt_sc2010度量度量虚拟化数据中心服务器中系统组件的端到端性能。</li>
</ul>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p><em>迁移</em>描述了将访客虚拟机从一台主机移动到另一台主机的过程。这是可能的，因为虚拟机在虚拟环境中运行，而不是直接在硬件上运行。有两种迁移虚拟机的方式：在线和离线。</p>
<p><strong>迁移类型</strong></p>
<ul>
<li><p><strong>离线迁移</strong></p>
<p>脱机迁移会暂停来宾虚拟机，然后将虚拟机内存的映像移动到目标主机。然后在目标主机上恢复虚拟机，释放源主机上虚拟机使用的内存。</p>
</li>
<li><p><strong>实时迁移</strong></p>
<p>实时迁移是将活动虚拟机从一台物理主机迁移到另一台物理主机的过程。请注意，这在所有红帽企业Linux版本之间是不可能的。</p>
</li>
</ul>
<h3 id="迁移虚拟机的好处"><a href="#迁移虚拟机的好处" class="headerlink" title="迁移虚拟机的好处"></a>迁移虚拟机的好处</h3><p>迁移对于：</p>
<ul>
<li><p><strong>负载均衡</strong></p>
<p>当主机过载时，可以使用实时迁移将其一个或多个虚拟机迁移到其他主机。同样，可以使用脱机迁移来迁移未运行且倾向于过载的计算机。</p>
</li>
<li><p><strong>升级或更改主机</strong></p>
<p>当需要升级，添加或删除主机上的硬件设备时，可以将虚拟机安全地重新分配给其他主机。这意味着客人不会因为对主机所做的更改而遭受任何停机时间。</p>
</li>
<li><p><strong>节能</strong></p>
<p>可以将虚拟机重新分配给其他主机，并且卸载的主机系统可以关闭以节省能源并在低使用期间降低成本。</p>
</li>
<li><p><strong>地理移民</strong></p>
<p>虚拟机可以移动到其他物理位置以降低延迟或其他原因。</p>
</li>
</ul>
<p>当迁移过程移动虚拟机的内存时，与虚拟机关联的磁盘卷也将被迁移。该过程使用实时块迁移来执行。</p>
<h3 id="虚拟化到虚拟化迁移（V2V）"><a href="#虚拟化到虚拟化迁移（V2V）" class="headerlink" title="虚拟化到虚拟化迁移（V2V）"></a>虚拟化到虚拟化迁移（V2V）</h3><p>作为一种特殊类型的迁移，红帽企业Linux 7提供了将虚拟机从其他类型的虚拟机管理程序转换为KVM的工具。该<code>virt-v2v</code>工具从Xen，其他版本的KVM和VMware ESX转换并导入虚拟机。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>KVM虚拟机使用以下功能来提高其安全性：</p>
<ul>
<li><p>SELinux的</p>
<p>安全增强型Linux或SELinux为所有Linux系统提供强制访问控制（MAC），因此也受益于Linux客户机。在SELinux的控制下，所有的进程和文件都被赋予一个<em>类型</em>，并且通过各种类型的精细控制来限制它们在系统上的访问。SELinux限制了攻击者的能力，可以防止许多常见的安全漏洞，例如缓冲区溢出攻击和特权升级。</p>
</li>
<li><p>sVirt</p>
<p>sVirt是Red Hat Enterprise Linux 7中的一项技术，它集成了SELinux和虚拟化技术。它使用强制访问控制（MAC）来提高使用虚拟机时的安全性，并针对可能用于攻击主机或其他虚拟机的虚拟机管理程序错误加强系统。</p>
</li>
</ul>
<h2 id="灾难恢复"><a href="#灾难恢复" class="headerlink" title="灾难恢复"></a>灾难恢复</h2><p>当系统虚拟化时，灾难恢复更快，更容易。在物理系统上，如果出现严重错误，通常需要完全重新安装操作系统，导致几个小时的恢复时间。但是，如果系统是虚拟化的，则由于迁移能力而更快。如果遵循实时迁移的要求，则可以在另一个主机上重新启动虚拟机，并且最长的可能延迟是恢复访客数据。而且，因为每个虚拟化系统都是完全独立的，所以一个系统的停机时间不会影响其他任何系统。</p>
<h1 id="红帽虚拟化产品和功能介绍"><a href="#红帽虚拟化产品和功能介绍" class="headerlink" title="红帽虚拟化产品和功能介绍"></a>红帽虚拟化产品和功能介绍</h1><p>本章介绍红帽企业版Linux 7中的主要虚拟化产品和功能。</p>
<h2 id="红帽企业Linux中的KVM和虚拟化"><a href="#红帽企业Linux中的KVM和虚拟化" class="headerlink" title="红帽企业Linux中的KVM和虚拟化"></a>红帽企业Linux中的KVM和虚拟化</h2><p>KVM（基于内核的虚拟机）是适用于各种架构的Linux的完整虚拟化解决方案。它内置于标准的红帽企业Linux 7内核中，并与Quick Emulator（QEMU）集成在一起，可运行多个客户操作系统。Red Hat Enterprise Linux中的KVM管理程序使用<strong>libvirt</strong> API进行管理，并为<strong>libvirt</strong>（例如<code>virt-manager</code>和<code>virsh</code>）构建工具。虚拟机作为多线程的Linux进程执行并运行，由这些工具控制。</p>
<p><strong>警告</strong></p>
<p>QEMU和<strong>libvirt</strong>也支持使用QEMU Tiny Code Generator（TCG）的动态翻译模式，它不需要硬件虚拟化支持。Red Hat不支持这种配置。</p>
<p>有关此限制的更多信息，请参阅“ <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Virtualization_restrictions-KVM_restrictions.html" target="_blank" rel="noopener"><em>Red Hat Enterprise Linux 7虚拟化部署和管理指南”</em></a>。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/klfal2eGaE.png?imageslim" alt="KVM架构"></p>
<p><strong>图3.1。KVM架构</strong></p>
<p>红帽企业版7上的KVM支持的虚拟化功能包括：</p>
<ul>
<li><p>过量使用</p>
<p>KVM管理程序支持系统资源的<em>过度</em>使用。过度使用意味着分配比系统上可用资源更多的虚拟CPU或内存，这样资源可以在一个guest虚拟机需要时动态交换，而另一个guest虚拟机不使用。这可以提高客户机使用主机资源的效率，并且可以使用户需要更少的主机。<strong>重要</strong>过度使用涉及系统稳定性的可能风险。有关KVM过度使用的更多信息，以及应采取的预防措施，请参阅“ <a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/chap-Overcommitting_with_KVM.html" target="_blank" rel="noopener"><em>红帽企业版Linux 7虚拟化部署和管理指南”</em></a>。</p>
</li>
<li><p>KSM</p>
<p><strong>KVM虚拟机管理程序使用的<em>内核相同页面合并（KSM）</em>使KVM来宾共享相同的内存页面。这些共享页面通常是通用的库或其他相同的，高度使用的数据。通过避免内存重复，KSM允许相同或相似客户操作系统的更高客户密度。</strong>注意<em>*有关KSM的更多信息，请参阅“ [</em>Red Hat Enterprise Linux 7虚拟化调整和优化指南”*](<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Tuning_and_Optimization_Guide/chap-KSM.html)。" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Tuning_and_Optimization_Guide/chap-KSM.html)。</a></p>
</li>
<li><p>QEMU嘉宾代理</p>
<p>该<em>QEMU访客代理</em>客户机操作系统上运行，它使主机发出的来宾操作系统的命令。<strong>注意</strong>有关QEMU访客代理的更多信息，请参阅“ <a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/chap-QEMU_Guest_Agent.html" target="_blank" rel="noopener"><em>Red Hat Enterprise Linux 7虚拟化部署和管理指南”</em></a>。</p>
</li>
<li><p>磁盘I / O限制</p>
<p>当多个虚拟机同时运行时，它们会通过使用过多的磁盘I / O来干扰整个系统的性能。KVM中的<em>磁盘I / O限制</em>提供了对从单个虚拟机发送到主机的磁盘I / O请求设置限制的功能。这可以防止虚拟机过度使用共享资源，并影响其他虚拟机的性能。<strong>注意</strong>有关使用磁盘I / O限制的说明，请参阅“ <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Tuning_and_Optimization_Guide/sect-Virtualization_Tuning_Optimization_Guide-BlockIO-Techniques.html#sect-Virtualization_Tuning_Optimization_Guide-BlockIO-IO_Throttling" target="_blank" rel="noopener"><em>Red Hat Enterprise Linux 7虚拟化调整和优化指南”</em></a>。</p>
</li>
<li><p>自动NUMA平衡</p>
<p><em>自动非均匀内存访问（NUMA）平衡</em>移动任务，可以是更接近正在访问的内存的线程或进程。这提高了在非统一内存访问（NUMA）硬件系统上运行的应用程序的性能，而无需Red Hat Enterprise Linux 7 guest虚拟机所需的任何手动调整。<strong>注意</strong>有关自动NUMA平衡的更多信息，请参阅“ <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Tuning_and_Optimization_Guide/sect-Virtualization_Tuning_Optimization_Guide-NUMA-Auto_NUMA_Balancing.html" target="_blank" rel="noopener"><em>Red Hat Enterprise Linux 7虚拟化调优和优化指南”</em></a>。</p>
</li>
<li><p>虚拟CPU热添加</p>
<p>虚拟CPU（vCPU）热添加功能可根据需要提高运行虚拟机的处理能力，而无需关闭客户机。分配给虚拟机的vCPU可以添加到正在运行的guest虚拟机，以满足工作负载的需求，或维护与工作负载相关的服务级别协议（SLA）。<strong>注意</strong>有关虚拟CPU热添加的更多信息，请参阅“ <a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Managing_guest_virtual_machines_with_virsh-Displaying_per_guest_virtual_machine_information.html#sect-Displaying_per_guest_virtual_machine_information-Configuring_virtual_CPU_count" target="_blank" rel="noopener"><em>红帽企业版Linux 7虚拟化部署和管理指南”</em></a>。</p>
</li>
<li><p>嵌套的虚拟化</p>
<p>作为一项技术预览，红帽企业Linux 7.2及更高版本提供硬件辅助的嵌入式虚拟化。此功能使KVM客人可以充当管理程序并创建他们自己的客人。例如，这可以用于在虚拟机上调试虚拟机管理程序，或者在有限数量的物理机器上测试更大的虚拟部署。<strong>注意</strong>有关设置和使用嵌套虚拟化的更多信息，请参阅<a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/Nested_Virt.html" target="_blank" rel="noopener"><em>“红帽企业版Linux 7虚拟化部署和管理指南”</em></a>。</p>
</li>
<li><p>KVM Guest 虚拟机兼容性</p>
<p>红帽企业Linux 7服务器有一定的支持限制。以下URL解释了红帽企业版Linux的处理器和内存量限制：对于主机系统：<a href="https://access.redhat.com/site/articles/rhel-limits" target="_blank" rel="noopener">https</a>：<a href="https://access.redhat.com/site/articles/rhel-limits" target="_blank" rel="noopener">//access.redhat.com/site/articles/rhel-limits</a>对于KVM管理程序：<a href="https://access.redhat.com/site/articles/rhel-kvm-limits" target="_blank" rel="noopener">https</a>：<a href="https://access.redhat.com/site/articles/rhel-kvm-limits" target="_blank" rel="noopener">//access.redhat.com/site/articles/rhel-kvm-limits</a>有关受支持的操作系统以及主机和来宾组合的完整图表，请参阅<a href="https://access.redhat.com/certified-hypervisors" target="_blank" rel="noopener">红帽客户门户</a><strong>注意</strong>要验证您的处理器是否支持虚拟化扩展，以及有关禁用虚拟化扩展的信息，请参阅“ <a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Troubleshooting-Enabling_Intel_VT_x_and_AMD_V_virtualization_hardware_extensions_in_BIOS.html" target="_blank" rel="noopener"><em>Red Hat Enterprise Linux 7虚拟化部署和管理指南”</em></a>。</p>
</li>
</ul>
<h3 id="LIBVIRT和LIBVIRT工具"><a href="#LIBVIRT和LIBVIRT工具" class="headerlink" title="LIBVIRT和LIBVIRT工具"></a>LIBVIRT和LIBVIRT工具</h3><p>的libvirt的包提供了管理程序的虚拟化独立API可以与各种操作系统的虚拟化功能进行交互。这包括：</p>
<ul>
<li><p>一个虚拟化层来安全地管理主机上的虚拟机。</p>
</li>
<li><p>用于管理本地和联网主机的界面。</p>
</li>
<li><p>调配，创建，修改，监控，控制，迁移和停止虚拟机所需的API。虽然可以同时使用<strong>libvirt</strong>访问多个主机，但这些API仅限于单节点操作。</p>
<p><strong>注意</strong></p>
<p>只有管理程序支持的操作可以使用libvirt执行。</p>
</li>
</ul>
<p><strong>libvirt</strong>专注于管理单个主机，并提供API来枚举，监视和使用受管节点上可用的资源，包括CPU，内存，存储，网络和非一致内存访问（NUMA）分区。管理工具不需要与运行主机的机器在同一台物理机器上。在这种情况下，运行管理工具的机器使用安全协议与运行主机的机器通信。</p>
<p>红帽企业版Linux 7支持<strong>libvirt，</strong>并且包含基于<strong>libvirt</strong>的工具作为虚拟化管理的默认方法（如在Red Hat Virtualization Management中）。</p>
<p>该libvirt的包为GNU宽通用公共许可证下的免费软件。该libvirt的项目旨在提供一个长期稳定的C API到虚拟化管理工具，在不同的虚拟机管理程序技术之上运行。的libvirt的包支持红帽企业Linux 5，和KVM红帽企业Linux 5，红帽企业Linux 6和Red Hat企业Linux 7的Xen。</p>
<p>值得注意的是，libvirt的还提供了用于控制红帽企业Linux 7虚拟化的两种主要工具：virsh和virt-manager</p>
<h3 id="虚拟化硬件设备"><a href="#虚拟化硬件设备" class="headerlink" title="虚拟化硬件设备"></a>虚拟化硬件设备</h3><p>红帽企业版Linux 7上的虚拟化允许虚拟机将主机的物理硬件用作三种不同类型的设备：</p>
<ul>
<li>虚拟化和仿真设备</li>
<li>准虚拟化设备</li>
<li>物理共享设备</li>
</ul>
<p>这些硬件设备都显示为物理连接到虚拟机，但设备驱动程序以不同的方式工作。</p>
<h3 id="虚拟化和仿真设备"><a href="#虚拟化和仿真设备" class="headerlink" title="虚拟化和仿真设备"></a>虚拟化和仿真设备</h3><p>KVM作为软件实现了许多虚拟机的核心设备。这些模拟硬件设备对于虚拟化操作系统至关重要。仿真设备是完全以软件存在的虚拟设备。</p>
<p>另外，KVM提供了仿真驱动程序。这些形成了虚拟机和Linux内核（管理源设备）之间的转换层。设备级别的指令完全由KVM管理程序翻译。任何可以被Linux内核识别的相同类型的设备（存储设备，网络设备，键盘或鼠标）都可以用作仿真驱动程序的后备源设备。</p>
<ul>
<li><p>虚拟CPU（vCPU）</p>
<p>在Red Hat Enterprise Linux 7.2及更高版本上，主机系统最多可以有240个虚拟CPU（vCPU），无论主机CPU的数量如何，都可以呈现给客户使用。这在红帽企业Linux 7.0中是160。</p>
</li>
<li><p>仿真的系统组件</p>
<p>仿真以下核心系统组件以提供基本的系统功能：英特尔i440FX主机PCI桥接器PIIX3 PCI到ISA桥接器PS / 2鼠标和键盘EvTouch USB绘图板PCI UHCI USB控制器和虚拟USB集线器仿真的串行端口EHCI控制器，虚拟USB存储器和USB鼠标USB 3.0 xHCI主机控制器（Red Hat Enterprise Linux 7.3中的技术预览）</p>
</li>
<li><p>仿真的存储驱动程序</p>
<p>存储设备和存储池可以使用模拟驱动程序将存储设备连接到虚拟机。来宾使用模拟存储驱动程序来访问存储池。请注意，与所有虚拟设备一样，存储驱动程序不是存储设备。驱动程序用于将后备存储设备，文件或存储池卷连接到虚拟机。后备存储设备可以是任何支持的存储设备类型，文件或存储池卷。仿真的IDE驱动程序KVM提供两个仿真的PCI IDE接口。仿真的IDE驱动程序可用于将最多四个虚拟IDE硬盘或虚拟IDE CD-ROM驱动器的任意组合连接到每个虚拟机。仿真的IDE驱动程序也用于虚拟化的CD-ROM和DVD-ROM驱动器。仿真的软盘驱动器驱动程序仿真的软盘驱动器驱动程序用于创建虚拟软盘驱动器。</p>
</li>
<li><p>仿真声音设备</p>
<p><code>intel-hda</code>以下客户操作系统支持 仿真（Intel）HDA声音设备：红帽企业Linux 7，用于AMD64和Intel 64架构红帽企业Linux 4,5和6，用于32位AMD和Intel架构以及AMD64和Intel 64架构<strong>注意</strong>以下仿真声音设备也可用，但由于某些客户机操作系统的兼容性问题，因此不推荐使用该设备：<code>ac97</code>，一个模拟英特尔82801AA AC97音频兼容声卡</p>
</li>
<li><p>仿真图形卡</p>
<p>提供以下仿真图形卡。Cirrus CLGD 5446 PCI显卡带有Bochs VESA扩展的标准VGA图形卡（硬件级别，包括所有非标准模式）客人可以使用独立计算环境简单协议（SPICE）协议或虚拟网络计算（VNC）系统连接到这些设备。</p>
</li>
<li><p>仿真的网络设备</p>
<p>提供以下两个仿真网络设备：该<code>e1000</code>设备模拟英特尔E1000网络适配器（英特尔82540EM，82573L，82544GC）。该<code>rtl8139</code>设备模拟Realtek 8139网络适配器。</p>
</li>
<li><p>仿真看门狗设备</p>
<p>当机器过载或无响应时，可以使用看门狗来自动重启虚拟机。红帽企业版Linux 7提供了以下仿真看门狗设备：<code>i6300esb</code>，一个仿真的英特尔6300 ESB PCI看门狗设备。它在客户机操作系统Red Hat Enterprise Linux 6.0及以上版本中受支持，并且是推荐使用的设备。<code>ib700</code>，一个仿真的iBase 700 ISA看门狗设备。该<code>ib700</code>监视设备仅在使用红帽企业版Linux 6.2及以上的房间。在来宾操作系统Red Hat Enterprise Linux 6.2及以上版本的i386和x86_64体系结构中，两种看门狗设备均受支持。</p>
</li>
</ul>
<h3 id="半虚拟化设备"><a href="#半虚拟化设备" class="headerlink" title="半虚拟化设备"></a>半虚拟化设备</h3><p>半虚拟化为客人在主机上使用设备提供了一种快速有效的通信方式。KVM使用virtio API作为虚拟机管理程序和guest虚拟机之间的一个层，为虚拟机提供半虚拟化设备。</p>
<p>一些准虚拟化设备减少了I / O延迟，并将I / O吞吐量提高到接近裸机级别，而其他半虚拟化设备为虚拟机增加了功能，而这些虚拟机不具备其他功能。建议对运行I / O密集型应用程序的虚拟机使用半虚拟化设备，而不要使用仿真设备。</p>
<p>所有virtio设备都有两部分：主机设备和来宾驱动程序。半虚拟化设备驱动程序允许来宾操作系统访问主机系统上的物理设备。</p>
<p>要使用此设备，必须在来宾操作系统上安装半虚拟化设备驱动程序。默认情况下，半虚拟化设备驱动程序包含在红帽企业Linux 4.7及更高版本，红帽企业Linux 5.4及更高版本以及红帽企业Linux 6.0及更高版本中。</p>
<p><strong>注意</strong></p>
<p>有关使用半虚拟化设备和驱动程序的更多信息，请参阅“ <a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/chap-KVM_Para_virtualized_virtio_Drivers.html" target="_blank" rel="noopener"><em>红帽企业版Linux 7虚拟化部署和管理指南”</em></a>。<a href="http://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/chap-KVM_Para_virtualized_virtio_Drivers.html" target="_blank" rel="noopener">**</a></p>
<ul>
<li><p>半虚拟化网络设备（virtio-net）</p>
<p>半虚拟化网络设备是一种虚拟网络设备，可为虚拟机提供网络访问，从而提高I / O性能和延迟。</p>
</li>
<li><p>半虚拟块设备（virtio-blk）</p>
<p>半虚拟化块设备是一种高性能虚拟存储设备，可为虚拟机提供存储，从而提高I / O性能和延迟。半虚拟化块设备由虚拟机管理程序支持，并且连接到虚拟机（软盘驱动器除外，必须进行仿真）。</p>
</li>
<li><p>半虚拟化控制器设备（virtio-scsi）</p>
<p>半虚拟化SCSI控制器设备为virtio-blk提供了更灵活和可扩展的选择。virtio-scsi guest可以继承目标设备的功能集，可以处理数百个设备，而virtio-blk只能处理28个设备。virtio-scsi完全支持以下客户机操作系统：红帽企业Linux 7红帽企业Linux 6.4及以上</p>
</li>
<li><p>半虚拟时钟</p>
<p>使用时间戳计数器（TSC）作为时钟源的用户可能会遇到计时问题。KVM通过为客户提供半虚拟化时钟，在没有固定时间戳计数器的主机周围工作。另外，半虚拟时钟协助客户运行睡眠（S3）或暂停RAM操作之后所需的时间调整。</p>
</li>
<li><p>准虚拟串行设备（virtio-serial）</p>
<p>半虚拟串行设备是一种面向字节流的字符流设备，在主机的用户空间和客户的用户空间之间提供了简单的通信接口。</p>
</li>
<li><p>气球装置（virtio-balloon）</p>
<p>气球设备可以指定虚拟机的一部分RAM没有被使用（一个称为<em>膨胀</em>气球的过程），这样内存就可以释放给主机（或主机上的其他虚拟机）使用。当虚拟机再次需要内存时，可以<em>缩小</em>气球，主机可以将RAM分配回虚拟机。</p>
</li>
<li><p>半虚拟随机数发生器（virtio-rng）</p>
<p>半虚拟化随机数生成器使虚拟机能够直接从主机收集熵或随机性，以用于加密数据和安全性。由于典型的输入（如硬件使用）不可用，因此虚拟机通常可能因为熵而不足。采购熵可能是耗时的。<strong>virtio-rng</strong>通过从主机直接向客户虚拟机注入熵来使得这个过程更快。</p>
</li>
<li><p>半虚拟化显卡（QXL）</p>
<p>半虚拟化图形卡与QXL驱动程序配合使用，可以有效地从远程主机显示虚拟机的图形。QXL驱动程序需要使用SPICE。</p>
</li>
</ul>
<h3 id="物理主机设备"><a href="#物理主机设备" class="headerlink" title="物理主机设备"></a>物理主机设备</h3><p>某些硬件平台使虚拟机可以直接访问各种硬件设备和组件。虚拟化中的这个过程称为<em>设备分配</em>，或者也称为<em>直通</em>。</p>
<ul>
<li><p>VFIO设备分配</p>
<p>虚拟功能I / O（VFIO）是红帽企业版Linux 7中的新内核驱动程序，为虚拟机提供了对物理硬件的高性能访问。VFIO将主机系统上的PCI设备直接连接到虚拟机，为客户提供独占访问PCI设备的一系列任务。这使得PCI设备能够以物理方式连接到来宾虚拟机的方式显示和运行。通过将设备分配移出KVM管理程序，VFIO改进了之前的PCI设备分配体系结构，并在内核级别实施设备隔离。VFIO提供更好的安全性，并与安全启动兼容。这是Red Hat Enterprise Linux 7中的默认设备分配机制。VFIO将红帽企业版Linux 7中分配的设备数量从32个增加到32个，而红帽企业版Linux 6中的最多8个设备。VFIO还支持分配NVIDIA GPU。</p>
</li>
<li><p>USB，PCI和SCSI直通</p>
<p>KVM管理程序支持将主机系统上的USB，PCI和SCSI设备连接到虚拟机。USB，PCI和SCSI设备分配使设备可以看起来像虚拟机物理连接一样。因此，它为客人提供独占访问这些设备的各种任务。</p>
</li>
<li><p>SR-IOV</p>
<p>SR-IOV（单根I / O虚拟化）是一种PCI Express（PCI-e）标准，它扩展了单个物理PCI功能，以共享其独立的虚拟功能（VF）的PCI资源。每个功能都可以通过PCI设备分配由不同的虚拟机使用。支持SR-IOV的PCI-e设备提供单根功能（例如，单个以太网端口），并将多个独立的虚拟设备呈现为唯一的PCI设备功能。每个虚拟设备可能都有自己独特的PCI配置空间，内存映射寄存器和各个基于MSI的中断。。</p>
</li>
<li><p>NPIV</p>
<p>N_Port ID虚拟化（NPIV）是一些光纤通道设备可用的功能。NPIV共享单个物理N_Port作为多个N_Port ID。NPIV为SR-IOV为PCIe接口提供的光纤通道主机总线适配器（HBA）提供了类似的功能。借助NPIV，虚拟机可以为存储区域网络（SAN）提供虚拟光纤通道启动器。NPIV可以为企业级存储解决方案提供高密度的虚拟化环境。</p>
</li>
</ul>
<h3 id="客户CPU模型"><a href="#客户CPU模型" class="headerlink" title="客户CPU模型"></a>客户CPU模型</h3><p><em>CPU模型</em>定义哪些主机CPU功能暴露给来宾操作系统。<strong>KVM</strong>和<strong>libvirt</strong>包含许多处理器型号的定义，允许用户启用仅在较新CPU型号中可用的CPU功能。可以暴露给guest虚拟机的一组CPU功能取决于主机CPU，内核和<strong>KVM</strong>代码中的支持。</p>
<p>为确保具有不同CPU特性集的主机之间的虚拟机安全迁移，<strong>KVM</strong>默认情况下不会将主机CPU的所有功能公开给来宾操作系统。相反，CPU功能是基于所选的CPU模型公开的。如果虚拟机启用了给定的CPU功能，则无法将其迁移到不支持向客户端公开该功能的主机。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>虚拟机的存储从分配给虚拟机的物理存储抽象出来。它使用半虚拟化或仿真的块设备驱动程序连接到虚拟机。</p>
<h3 id="存储池"><a href="#存储池" class="headerlink" title="存储池"></a>存储池</h3><p>甲<em>存储池</em>是由管理的文件，目录或存储设备<strong>libvirt的</strong>用于向虚拟机提供存储的目的。存储池分为存储虚拟机映像的存储<em>卷</em>或附加到虚拟机作为附加存储。</p>
<ul>
<li><p>本地存储池</p>
<p>本地存储池直接连接到主机服务器。它们包括本地目录，直接连接的磁盘，物理分区和本地设备上的逻辑卷管理（LVM）卷组。本地存储池对于不需要迁移或大量虚拟机的开发，测试和小型部署非常有用。本地存储池可能不适合许多生产环境，因为它们不支持实时迁移。</p>
</li>
<li><p>联网（共享）存储池</p>
<p>网络存储池包括使用标准协议通过网络共享的存储设备。使用<strong>virt-manager</strong>在主机之间迁移虚拟机时需要网络存储，但在迁移时为可选<code>virsh</code>。网络存储池由<strong>libvirt</strong>管理。</p>
</li>
</ul>
<h3 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h3><p>存储池分为<em>存储卷</em>。存储卷是物理分区，LVM逻辑卷，基于文件的磁盘映像以及由<strong>libvirt</strong>处理的其他存储类型的抽象。存储卷作为本地存储设备呈现给虚拟机，而不管底层硬件如何。</p>
<h3 id="仿真存储设备"><a href="#仿真存储设备" class="headerlink" title="仿真存储设备"></a>仿真存储设备</h3><p>虚拟机可以呈现一系列由主机模拟的存储设备。每种类型的存储设备都适合特定的使用情况，从而实现最大的灵活性和与客户操作系统的兼容性。</p>
<ul>
<li><p>为Virtio-SCSI</p>
<p>对于使用大量磁盘或高级存储功能（如TRIM）的guest虚拟机，<strong>virtio-scsi</strong>是推荐的半虚拟化设备。在使用Red Hat Enterprise Linux 7以外的操作系统的guest虚拟机上可能需要安装guest虚拟机驱动程序。</p>
</li>
<li><p>为Virtio-BLK</p>
<p><strong>virtio-blk</strong>是一个半虚拟化的存储设备，适用于向客户展示图像文件。<strong>virtio-blk</strong>可以为虚拟机提供最佳的磁盘I / O性能，但功能比virtio-scsi少。</p>
</li>
<li><p>IDE</p>
<p>对于不支持virtio驱动程序的传统guest虚拟机，建议使用IDE。IDE性能低于virtio-scsi或virtio-blk，但是它与不同的系统广泛兼容。</p>
</li>
<li><p>光盘</p>
<p>ATAPI CD-ROM和virtio-scsi CD-ROM是可用的，并且使客人可以使用ISO文件或主机的CD-ROM驱动器。virtio-scsi CD-ROM可以与安装了virtio-scsi驱动程序的guest虚拟机一起使用。ATAPI光盘提供更广泛的兼容性，但性能较低。</p>
</li>
<li><p>USB大容量存储设备和软盘</p>
<p>当需要可移动介质时，仿真的USB大容量存储设备和软盘可用。USB大容量存储设备比软盘容量大，因此比软盘更受欢迎。</p>
</li>
</ul>
<h3 id="主机存储"><a href="#主机存储" class="headerlink" title="主机存储"></a>主机存储</h3><p>磁盘映像可以存储在连接到主机的一系列本地和远程存储技术上。</p>
<ul>
<li><p>图像文件</p>
<p>图像文件只能存储在主机文件系统上。映像文件可以存储在本地文件系统（如ext4或xfs）或网络文件系统（如NFS）上。像<strong>libguestfs</strong>这样的工具可以管理，备份和监视文件。KVM上的磁盘映像格式包括：生的原始图像文件包含没有额外元数据的磁盘的内容。如果主机文件系统允许的话，原始文件可以是预先分配的，也可以是稀疏的。稀疏文件按需分配主机磁盘空间，因此是精简配置的一种形式。预分配的文件已完全配置，但具有比稀疏文件更高的性能。当磁盘I / O性能非常关键，并且很少需要通过网络传输映像文件时，原始文件是可取的。qcow2，qcow2映像文件提供了许多高级磁盘映像功能，包括备份文件，快照，压缩和加密。它们可以用来从模板图像实例化虚拟机。通过网络传输qcow2文件通常效率更高，因为只有虚拟机写入的扇区才被分配到映像中。红帽企业版Linux 7支持qcow2版本3的图像文件格式。</p>
</li>
<li><p>LVM卷</p>
<p>逻辑卷（LV）可用于磁盘映像，并使用系统的LVM工具进行管理。LVM提供比文件系统更高的性能，因为其更简单的块存储模型。LVM精简配置为LVM卷提供了快照和高效的空间使用，可以用作迁移到qcow2的替代方案。</p>
</li>
<li><p>主机设备</p>
<p>主机设备（如物理CD-ROM，原始磁盘和逻辑单元号（LUN））可以呈现给来宾。这使得SAN或iSCSI LUN以及本地CD-ROM介质能够被客户使用，性能良好。在SAN上而不是在主机上完成存储管理时，可以使用主机设备。</p>
</li>
<li><p>分布式存储系统</p>
<p>Gluster卷可以用作磁盘映像。这使得网络上的高性能集群存储成为可能。红帽企业Linux 7包含对GlusterFS磁盘映像的本地支持。这使KVM主机能够从GlusterFS卷启动虚拟机映像，并将来自GlusterFS卷的映像用作虚拟机的数据磁盘。与GlusterFS FUSE相比，KVM的原生支持提供了更高的性能。</p>
</li>
</ul>
<h2 id="虚拟网络"><a href="#虚拟网络" class="headerlink" title="虚拟网络"></a>虚拟网络</h2><p>虚拟客户与任何网络的连接使用物理主机的软件网络组件。这些软件组件可以通过使用<code>libvirt</code>虚拟网络配置来重新安排和重新配置。因此，主机充当虚拟网络交换机，可以以许多不同的方式来配置虚拟网络交换机以适应客户的网络需求。</p>
<p>默认情况下，单个主机上的所有guest虚拟机都连接到同名的libvirt虚拟网络<code>default</code>。此网络上的访客可以进行以下连接：</p>
<ul>
<li><p>彼此和虚拟主机</p>
<p>入站和出站流量都是可能的，但受到来宾操作系统的网络堆栈中的防火墙以及连接到访客接口的libvirt网络过滤规则的影响。</p>
</li>
<li><p>与虚拟主机之外的网络上的其他主机一起使用</p>
<p>只有出站流量是可能的，受到网络地址转换（NAT）规则以及主机系统的防火墙的影响。</p>
</li>
</ul>
<p>但是，如果需要，可以将访客接口设置为以下模式之一：</p>
<ul>
<li><p>隔离模式</p>
<p>客户端连接到不允许虚拟化主机之外的任何流量的网络。</p>
</li>
<li><p>路由模式</p>
<p>客户端连接到一个网络，该客户端与外部主机之间路由流量，而不执行任何NAT。这将启用传入连接，但需要额外的路由表条目用于外部网络上的系统。</p>
</li>
<li><p>桥接模式</p>
<p>客户端连接到桥接设备，该设备也直接连接到连接到本地以太网的物理以太网设备。这使得guest虚拟机在物理网络上直接可见，从而启用传入连接，但不需要任何额外的路由表条目。</p>
</li>
</ul>
<p>对于从虚拟机进行基本出站的网络访问，通常不需要额外的网络设置，因为<code>default</code>网络与libvirt包一起安装，并在<code>libvirtd</code>服务启动时自动启动。如果需要更高级的功能，可以使用virsh或virt-manager创建和配置额外的网络，并且可以编辑XML配置文件以使用其中一个新网络。</p>
<h2 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h2><p>必需的包</p>
<p>在使用虚拟化之前，必须在计算机上安装一套基本的虚拟化软件包。</p>
<p><strong>程序4.1。使用安装虚拟化软件包yum</strong></p>
<p>要在Red Hat Enterprise Linux的，在使用虚拟化<code>qemu-kvm</code>，<code>qemu-img</code>以及<code>libvirt</code>必须安装的软件包。这些在主机系统上提供用户级KVM仿真器，磁盘镜像管理器和虚拟化管理工具。</p>
<ol>
<li><p>安装qemu-kvm，qemu-img，libvirt和virt-manager软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install qemu-kvm qemu-img libvirt virt-manager</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用VIRTUAL-MACHINE-MANAGER创建虚拟机"><a href="#使用VIRTUAL-MACHINE-MANAGER创建虚拟机" class="headerlink" title="使用VIRTUAL MACHINE MANAGER创建虚拟机"></a>使用VIRTUAL MACHINE MANAGER创建虚拟机</h2><p><strong>虚拟机管理器</strong>（也称为 virt-manager<strong>）是在红帽企业版Linux中快速部署虚拟机的图形化工具。在本教程中，您将熟悉其基本功能，并能够使用</strong> Virtual Machine Manager创建虚拟机。</p>
<h3 id="虚拟机管理器简介"><a href="#虚拟机管理器简介" class="headerlink" title="虚拟机管理器简介"></a>虚拟机管理器简介</h3><p>要打开<strong>虚拟机管理器</strong>，请单击<strong>应用程序</strong> → <strong>系统工具</strong> → <strong>虚拟机管理器</strong> ; 或按<strong>超级</strong>键→键入<code>virt-manager</code>→按下<strong>Enter键</strong>。</p>
<p>下图显示了<strong>Virtual Machine Manager</strong>界面。该界面使您可以从一个中央位置控制所有虚拟机。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/II2Dkmdjl9.png?imageslim" alt="mark"></p>
<p><strong>图4.1。虚拟机管理器界面</strong></p>
<p>界面常用的元素包括：</p>
<ul>
<li><p><strong>创建新的虚拟机</strong>：单击以创建新的虚拟机。</p>
</li>
<li><p><strong>虚拟机</strong>：配置的连接和与之关联的所有访客虚拟机的列表。虚拟机创建时，在此处列出。guest虚拟机正在运行时，动画图表会在<strong> CPU使用率</strong>列中显示guest虚拟机的CPU使用<strong>情况</strong>。</p>
<p>从此列表中选择虚拟机后，使用以下按钮来控制所选虚拟机的状态：</p>
<ul>
<li><strong>打开</strong>：在新窗口中打开访客虚拟机控制台和详细信息。</li>
<li><strong>运行</strong>：打开虚拟机。</li>
<li><strong>暂停</strong>：暂停虚拟机。</li>
<li><strong>关机</strong>：关闭虚拟机。单击箭头将显示一个下拉菜单，其中包含几个关闭虚拟机的选项，包括重新启动，关机，强制重置，强制关闭和保存。</li>
</ul>
</li>
</ul>
<p>右键单击虚拟机将显示具有更多功能的菜单，其中包括：</p>
<ul>
<li><strong>克隆</strong>：克隆虚拟机。</li>
<li><strong>迁移</strong>：将虚拟机迁移到其他主机。</li>
<li><strong>删除</strong>：删除虚拟机。</li>
</ul>
<h3 id="使用Virtual-Machine-Manager创建虚拟机"><a href="#使用Virtual-Machine-Manager创建虚拟机" class="headerlink" title="使用Virtual Machine Manager创建虚拟机"></a>使用Virtual Machine Manager创建虚拟机</h3><p>按照以下步骤在<strong>Virtual Machine Manager</strong>上创建一个Red Hat Enterprise Linux 6虚拟机。</p>
<p><strong>程序4.2。使用Virtual Machine Manager创建客户虚拟机</strong></p>
<ol>
<li><p><strong>打开虚拟机管理器</strong></p>
<p>点击<strong>应用程序</strong> → <strong>系统工具</strong> → <strong>虚拟机管理器</strong></p>
<p>要么</p>
<p>按<strong>超级</strong>键，输入<code>virt-manager</code>，然后按<strong>Enter键</strong></p>
</li>
<li><p><strong>创建一个新的虚拟机</strong></p>
<p>点击 <strong>新建VM</strong>向导。</p>
</li>
<li><p><strong>指定安装方法</strong></p>
<p>通过选择安装新虚拟机的方法来启动创建过程。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/biK84fLgk7.png?imageslim" alt="mark"></p>
<p><strong>图4.2。选择安装方法</strong></p>
<p>对于本教程，请选择<strong>本地安装媒体（ISO映像）</strong>。此安装方法使用安装盘的映像（在本例中为<code>.iso</code>文件）。点击<strong>转发</strong>继续下一步。</p>
</li>
<li><p><strong>找到安装媒体</strong></p>
<ol>
<li>选择该<code>Use ISO Image</code>选项。</li>
<li>单击<strong>浏览</strong> → <strong>浏览本地</strong>按钮。</li>
<li>在机器上安装虚拟软件包中找到下载的ISO 。</li>
<li>选择ISO文件，然后单击<strong>打开</strong>。</li>
<li>确保Virtual Machine Manager正确检测到操作系统类型。如果不是，取消<code>Automatically detect operating system based on install media</code>选择<strong>的Linux</strong>从<strong>操作系统类型</strong>下拉和<strong>红帽企业Linux 6</strong>从<strong>版本</strong>下拉。</li>
</ol>
<p><img src="https://blog-image.nos-eastchina1.126.net/8i1FkgF5hj.png?imageslim" alt="mark"></p>
<p><strong>图4.3。本地ISO映像安装</strong></p>
</li>
<li><p><strong>配置内存和CPU</strong></p>
<p>您可以使用向导的第3步来配置分配给虚拟机的内存量和CPU数量。该向导显示可用于分配的CPU数量和内存量。</p>
<p>在本教程中，保留默认设置，然后单击<strong>前进</strong>。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/dbb7gLLl1C.png?imageslim" alt="mark"></p>
<p>​</p>
<p><strong>图4.4。配置CPU和内存</strong></p>
</li>
<li><p><strong>配置存储</strong></p>
<p>使用向导的第4步，可以将存储分配给来宾虚拟机。该向导显示存储选项，包括在主机上存储虚拟机的位置。在本教程中，保留默认设置，然后单击<strong>前进</strong>。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/LBffiK0LDL.png?imageslim" alt="mark"></p>
<p><strong>图4.5。配置存储</strong></p>
</li>
<li><p><strong>名称和审查</strong></p>
<p>使用向导的步骤5，可以为虚拟机创建一个名称并配置网络设置。在本教程中，输入虚拟机的名称，验证设置，然后单击<strong>完成</strong>。<strong>Virtual Machine Manager</strong>将创建一个具有指定硬件设置的虚拟机。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/caJB1EmIBk.png?imageslim" alt="mark"></p>
<p><strong>图4.6。命名和验证</strong></p>
</li>
</ol>
<p>在<strong>Virtual Machine Manager</strong>创建红帽企业版Linux 6虚拟机之后，虚拟机的窗口将打开，所选操作系统的安装将开始。按照红帽企业版Linux 6安装程序中的说明完成虚拟机操作系统的安装。</p>
<h3 id="探索访客虚拟机"><a href="#探索访客虚拟机" class="headerlink" title="探索访客虚拟机"></a>探索访客虚拟机</h3><p>您可以通过在</p>
<p><strong>Virtual Machine Manager</strong></p>
<p>窗口中选择一个虚拟机并单击</p>
<p><strong>Open</strong></p>
<p>来查看虚拟机的控制台。您可以像控制物理系统一样从控制台操作红帽企业版Linux 6虚拟机。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/2AegFiDc4i.png?imageslim" alt="mark"></p>
<p><strong>图4.7。来宾虚拟机控制台</strong></p>
<ul>
<li><strong>显示图形控制台</strong>：显示虚拟机的显示。虚拟机可以像控制物理机一样从控制台操作。</li>
<li><strong>显示虚拟硬件详细信息</strong>：显示有关客户正在使用的<strong>虚拟硬件的详细</strong>信息。其中包括基本系统详细信息，性能，处理器，内存和引导设置以及系统虚拟设备的详细信息。</li>
<li><strong>运行</strong>：打开虚拟机。</li>
<li><strong>暂停</strong>：暂停虚拟机。</li>
<li><strong>关机</strong>：关闭虚拟机。单击箭头将显示一个下拉菜单，其中包含几个关闭虚拟机的选项，包括重新启动，关机，强制重置，强制关闭和保存。</li>
<li><strong>管理快照</strong>：启用创建，运行和管理虚拟机的快照。</li>
<li><strong>发送密钥</strong>：向虚拟机发送Ctrl + Alt + Backspace，Ctrl + Alt + Delete，Ctrl + Alt + F1，PrintScreen等组合键。</li>
<li><strong>全屏</strong>：将虚拟机切换到全屏视图。</li>
</ul>
<h2 id="虚拟化工具"><a href="#虚拟化工具" class="headerlink" title="虚拟化工具"></a>虚拟化工具</h2><h3 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h3><p><em>virsh</em>是用于管理虚拟机管理程序和来宾虚拟机的命令行界面（CLI）工具，是控制红帽企业版Linux 7虚拟化的主要手段。其功能包括创建，配置，暂停，列出和关闭虚拟机，以及管理虚拟网络，或加载虚拟机磁盘映像。因此，它是创建虚拟化管理脚本的理想选择。没有root权限的用户也可以使用该<code>virsh</code>命令，但是处于只读模式。 <code>virsh</code>作为libvirt-client包的一部分进行安装。</p>
<h3 id="VIRT-MANAGER中"><a href="#VIRT-MANAGER中" class="headerlink" title="VIRT-MANAGER中"></a>VIRT-MANAGER中</h3><p><em>虚拟机管理器</em>（也称为<em>virt-manager</em>）是一种用于管理虚拟机的轻量级图形工具，比用户更友好，功能更强大<code>virsh</code>。它使用户能够使用GUI执行的动作相当于数的<code>virsh</code>和<code>virt-</code>的命令，如控制现有机器的生命周期，供应新的机器，管理虚拟网络，访问虚拟机的图形控制台和查看性能统计数据。</p>
<h3 id="VIRT-INSTALL"><a href="#VIRT-INSTALL" class="headerlink" title="VIRT-INSTALL"></a>VIRT-INSTALL</h3><p><em>irt-install</em>是用于配置新虚拟机的命令行工具。它支持基于文本和图形化安装，使用串行控制台，SPICE或VNC客户机 - 服务器对图形。安装介质可以是本地的，也可以远程存在于NFS，HTTP或FTP服务器上。该工具还可以配置为无人值守运行，并使用kickstart方法为guest虚拟机做好准备，从而实现安装的自动化。该工具包含在virt-install软件包中。</p>
<h3 id="GUESTFISH"><a href="#GUESTFISH" class="headerlink" title="GUESTFISH"></a>GUESTFISH</h3><p><em>guestfish</em>是用于检查和修改虚拟机磁盘映像的外壳和命令行实用程序，因为这些操作不能使用<code>virsh</code>或执行<code>virt-manager</code>。该<code>guestfish</code>工具使用libguestfs库并公开<code>guestfs</code>API 提供的所有功能。</p>
<p><strong>警告</strong></p>
<p>使用<code>guestfish</code>上运行的虚拟机可能导致磁盘映像损坏。如果正在运行的虚拟机正在使用磁盘映像，请使用<code>guestfish</code>带有<code>--ro</code>（只读）选项的命令。</p>
<h3 id="GNOME-BOXES"><a href="#GNOME-BOXES" class="headerlink" title="GNOME BOXES"></a>GNOME BOXES</h3><p><em>Boxes</em>是一个轻量级的图形桌面虚拟化工具，用于查看和访问虚拟机和远程系统。它可以作为一个更容易使用的替代方案virt-manager，但提供更少的客人管理选项。Boxes提供了一种以最少配置从桌面测试不同操作系统和应用程序的方法。虚拟系统可以手动安装，也可以使用快速安装功能进行安装，该功能可以自动预配置具有最佳设置的虚拟机。这个工具是由gnome-box包提供的。</p>
<h3 id="其他有用的工具"><a href="#其他有用的工具" class="headerlink" title="其他有用的工具"></a>其他有用的工具</h3><p>以下工具可用于使用主机上的命令访问和修改客户机虚拟机的磁盘映像。</p>
<ul>
<li><p><a href="http://libguestfs.org/guestmount.1.html" target="_blank" rel="noopener"><code>guestmount</code></a></p>
<p>用于在主机上安装虚拟机文件系统和磁盘映像的命令行实用程序。要以这种方式卸载内容，请使用<a href="http://libguestfs.org/guestunmount.1.html" target="_blank" rel="noopener"><code>guestunmount</code></a>Both工具作为libguestfs-tools-c软件包的一部分。<strong>警告</strong>使用<code>guestmount</code>在<code>--rw</code>（读/写）模式来访问当前正在使用由客户磁盘可能导致磁盘损坏。不要使用<code>guestmount</code>在<code>--rw</code>（读/写）上的虚拟机实时模式。如果正在使用磁盘映像，请使用<code>guestmount</code>带有<code>--ro</code>（只读）选项的命令。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-builder.1.html" target="_blank" rel="noopener"><code>virt-builder</code></a></p>
<p>用于快速构建和定制新虚拟机的命令行实用程序。该工具作为libguestfs-tools软件包的一部分安装在Red Hat Enterprise Linux 7.1及更高版本中。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Other_commands.html" target="_blank" rel="noopener"><code>virt-cat</code></a></p>
<p>一个命令行实用程序，可用于快速查看指定虚拟机的磁盘或磁盘映像中的一个或多个文件的内容。该工具作为libguestfs-tools软件包的一部分进行安装。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-copy-in.1.html" target="_blank" rel="noopener"><code>virt-copy-in</code></a> 和 <a href="http://libguestfs.org/virt-copy-out.1.html" target="_blank" rel="noopener"><code>virt-copy-out</code></a></p>
<p>用于将文件或目录从主机复制到来宾，以及从来宾到主机的命令行实用程序。这些工具是作为libguestfs-tools包的一部分安装的。<strong>警告</strong>使用<code>virt-copy-in</code>仅关闭未使用的另一个磁盘编辑工具的虚拟机。使用<code>virt-copy-in</code>活动guest图像或正在编辑可能会导致磁盘损坏在虚拟机中的图像上。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Using_virt_customize.html" target="_blank" rel="noopener"><code>virt-customize</code></a></p>
<p>用于自定义虚拟机磁盘映像的命令行实用程序。virt-customize可用于安装软件包，编辑配置文件，运行脚本和设置密码。该工具作为libguestfs-tools软件包的一部分安装在Red Hat Enterprise Linux 7.1及更高版本中。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-virt_df_Monitoring_disk_usage.html" target="_blank" rel="noopener"><code>virt-df</code></a></p>
<p>一个命令行实用程序，用于显示虚拟机的实际物理磁盘使用情况，与命令行实用程序类似<code>df</code>。请注意，该工具在远程连接中不起作用。它作为libguestfs-tools软件包的一部分进行安装。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Using_virt_diff.html" target="_blank" rel="noopener"><code>virt-diff</code></a></p>
<p>一个命令行实用程序，用于显示两个虚拟机的文件系统之间的差异。这可以用于例如发现哪些文件在快照之间改变。该工具作为libguestfs-tools软件包的一部分安装在Red Hat Enterprise Linux 7.1及更高版本中。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Other_commands.html" target="_blank" rel="noopener"><code>virt-edit</code></a></p>
<p>用于编辑指定虚拟机上存在的文件的命令行实用程序。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>警告</strong>使用<code>virt-edit</code>活的虚拟机可能会在虚拟机磁盘损坏。尽管该<code>virt-edit</code>命令将尝试阻止用户在实时虚拟机上编辑文件，但不能保证捕获所有实例。不要<code>virt-edit</code>在活动的虚拟机上使用。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-filesystems.1.html" target="_blank" rel="noopener"><code>virt-filesystems</code></a></p>
<p>用于发现磁盘映像或虚拟机中的文件系统，分区，逻辑卷及其大小的命令行实用程序。一个常见的用法是在shell脚本中，遍历磁盘映像中的所有文件系统。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>注意</strong>这个工具取代<code>virt-list-filesystems</code>和<code>virt-list-partitions</code>。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-format.1.html" target="_blank" rel="noopener"><code>virt-format</code></a></p>
<p>一个命令行实用程序，可以格式化来宾图像文件，也可以在主机上逻辑卷。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>警告</strong>使用<code>virt-format</code>仅关闭未使用的另一个磁盘编辑工具的虚拟机。使用<code>virt-format</code>活动guest图像或正在编辑可能会导致磁盘损坏在虚拟机中的图像上。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-virt_inspector_inspecting_guest_virtual_machines.html" target="_blank" rel="noopener"><code>virt-inspector</code></a></p>
<p>一个命令行实用程序，可以检查虚拟机或磁盘映像以确定其操作系统的版本和其他信息。它也可以生成XML输出，可以将其输出到其他程序中。请注意，<code>virt-inspector</code>一次只能检查一个虚拟机。该工具作为libguestfs-tools软件包的一部分进行安装。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-log.1.html" target="_blank" rel="noopener"><code>virt-log</code></a></p>
<p>用于列出来自虚拟机的日志文件的命令行工具。该工具作为libguestfs-tools软件包的一部分安装在Red Hat Enterprise Linux 7.1及更高版本中。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Other_commands.html" target="_blank" rel="noopener"><code>virt-ls</code></a></p>
<p>一个列出虚拟机内的文件和目录的命令行工具。该工具作为libguestfs-tools软件包的一部分进行安装。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-make-fs.1.html" target="_blank" rel="noopener"><code>virt-make-fs</code></a></p>
<p>一个命令行实用程序，用于根据tar归档文件或目录中的文件创建文件系统。它类似于像工具<code>mkisofs</code>和<code>mksquashfs</code>，但它可以创建一个通用的文件系统类型，如ext2，ext3和NTFS，创造可以等于或大于它是基于文件的尺寸越大，文件系统的大小。这个工具是作为libguestfs-tools包的一部分提供的。</p>
</li>
<li><p><a href="https://access.redhat.com/articles/2702281" target="_blank" rel="noopener"><code>virt-p2v</code></a></p>
<p>与<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_getting_started_guide/sect-Virtualization_Getting_Started-Tools-Other#ent-tools-v2v" target="_blank" rel="noopener">virt-v2v</a>结合使用时，可以将物理机转换为KVM虚拟机。请注意，virt-p2v仅在Red Hat Enterprise Linux 7.3和更高版本中受支持。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-virt_rescue_The_rescue_shell.html" target="_blank" rel="noopener"><code>virt-rescue</code></a></p>
<p>一个命令行实用程序，为不可启动的虚拟机和磁盘映像提供了一个rescue shell和一些简单的恢复工具。它可以在已知<strong>libvirt的</strong>任何虚拟机上运行，也可以直接在磁盘映像上运行。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>警告</strong>使用<code>virt-rescue</code>上运行的虚拟机可能会在虚拟机磁盘损坏。<code>virt-rescue</code>试图阻止它自己在运行虚拟机上的使用，但不能捕获所有的情况。与<code>--ro</code>（只读）选项使用该命令不会导致磁盘损坏，但可能会给出奇怪或不一致的结果。避免<code>virt-rescue</code>在正在运行的虚拟机上使用。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-virt_resize_resizing_guest_virtual_machines_offline.html" target="_blank" rel="noopener"><code>virt-resize</code></a></p>
<p>一个命令行实用程序来调整虚拟机磁盘的大小，并调整或删除虚拟机磁盘上的所有分区。它通过复制访客映像并保持原始磁盘映像不变。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>重要</strong>使用<code>virt-resize</code>上运行的虚拟机可以给不一致的结果。建议在尝试调整它们的大小之前关闭虚拟机。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-sparsify.1.html" target="_blank" rel="noopener"><code>virt-sparsify</code></a></p>
<p>用于制作虚拟机磁盘（或任何磁盘映像）的精简配置的命令行实用程序。该工具可以将磁盘映像中的可用空间转换为主机上的可用空间。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/sect-Guest_virtual_machine_disk_access_with_offline_tools-Using_virt_sysprep.html" target="_blank" rel="noopener"><code>virt-sysprep</code></a></p>
<p>用于重置，自定义或取消配置虚拟机的命令行实用程序，以准备创建克隆的模板。该工具作为libguestfs-tools软件包的一部分进行安装。<strong>重要</strong>运行之前，必须关闭虚拟机<code>virt-sysprep</code>。要保留虚拟机的现有内容，请在运行之前快照，复制或克隆磁盘<code>virt-sysprep</code>。</p>
</li>
<li><p><a href="http://libguestfs.org/virt-tar-out.1.html" target="_blank" rel="noopener"><code>virt-tar-out</code></a> 和 <a href="http://libguestfs.org/virt-tar-in.1.html" target="_blank" rel="noopener"><code>virt-tar-in</code></a></p>
<p>用于将虚拟机磁盘映像目录打包为tar包的命令行归档工具，以及将未压缩的tarball分别解压缩为虚拟机磁盘映像或指定的libvirt guest虚拟机。这些工具是作为libguestfs-tools包的一部分安装的。<strong>警告</strong><code>virt-tar-in</code>在活动虚拟机上 使用命令可能会导致虚拟机中的磁盘损坏。在使用此命令之前，必须先关闭虚拟机。</p>
</li>
<li><p><code>virt-top</code></p>
<p><code>top</code>与之 类似的命令行实用程序，显示与来宾虚拟机相关的统计信息。这个工具包含了virt-top包。见<code>man virt-top</code>细节。</p>
</li>
<li><p><a href="https://access.redhat.com/articles/1351473" target="_blank" rel="noopener"><code>virt-v2v</code></a></p>
<p>用于将虚拟机从外部虚拟机管理程序转换为在由libvirt管理的KVM上运行的命令行实用程序。目前，virt-v2v可以转换运行在Xen和VMware ESX上的红帽企业Linux和Windows客户端。virt-v2v工具作为virt-v2v软件包的一部分安装在Red Hat Enterprise Linux 7.1及更高版本中。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/chap-Graphic_User_Interface_tools_for_guest_virtual_machine_management.html#sect-Graphic_User_Interface_tools_for_guest_virtual_machine_management-Using_virt_viewer_command_line" target="_blank" rel="noopener"><code>virt-viewer</code></a></p>
<p>一个轻量级实用程序，用于通过VNC和SPICE协议显示虚拟机的图形控制台。这个工具是由virt-viewer包提供的。</p>
</li>
<li><p><a href="https://people.redhat.com/~rjones/virt-what/virt-what.txt" target="_blank" rel="noopener"><code>virt-what</code></a></p>
<p>一个shell脚本，用于检测程序是否在虚拟机中运行。这个工具由virt-what包提供。</p>
</li>
<li><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Virtualization_Deployment_and_Administration_Guide/reg-virt-machine.html" target="_blank" rel="noopener"><code>virt-who</code></a></p>
<p>该VIRT-谁包的是，查询一个红帽企业版Linux主机代理<strong>的libvirt</strong>为客人的UUID。然后它将这些数据传递给本地权利服务器，用于颁发证书。这个工具由virt-who包提供。</p>
</li>
<li><p><code>virt-xml-validate</code></p>
<p>一个命令行工具，用于验证<strong>libvirt</strong> XML文件是否符合发布的模式。该工具作为libvirt-client包的一部分进行安装。见<code>man virt-xml-validate</code>细节。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title>MegaCli使用方法</title>
    <url>/2017/09/29/Linux/storage/MegaCli/</url>
    <content><![CDATA[<h1 id="JBOD"><a href="#JBOD" class="headerlink" title="JBOD"></a>JBOD</h1><p>​    一天小明做了个系统，要装ceph，也许是Raid卡不支持JBOD,就只能做Raid0咯，表面看着好像没区别，大佬还会跟你讲做Raid0有毛线用，我在想也许他还不知道Ceph是替代什么的吧,像我这种小白，连JBOD是什么都不知道，（之前Cisco UCS 做Raid的时候看到过这个选项）。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/cL9fmF09il.png?imageslim" alt="mark"></p>
<p>​JBOD是存储领域中一类重要的存储设备，Low点的说法叫Raid卡直通，Just a Bunch Of Disks是JBOD的全名，奥，JBOD真的是只是一堆盘的缩写，23333。</p>
<p>​如果已经安装完系统，并且没有配置JBOD 而是做了RAID 插入新磁盘， 系统是看不到的，但是有些业务是不能重启的 ，但是你还想加盘，这就需要Megacli来搞事情了。</p>
<h1 id="安装MegaCli"><a href="#安装MegaCli" class="headerlink" title="安装MegaCli"></a>安装MegaCli</h1><p>下载并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wegt https://docs.broadcom.com/docs-and-downloads/raid-controllers/raid-controllers-common-files/8-07-10_MegaCLI_Linux.zip</span><br><span class="line">unzip 8-07-10_MegaCLI_Linux.zip </span><br><span class="line">yum localinstall 8.07.10_MegaCLI_Linux/Linux\ MegaCLI\ 8.07.10/MegaCli-8.07.10-1.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong>目录根据情况修改</strong></p>
<p>我们看下都生成了什么！！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ql  rpm -ql MegaCli</span><br><span class="line">/opt/MegaRAID/MegaCli/MegaCli</span><br><span class="line">/opt/MegaRAID/MegaCli/MegaCli64</span><br><span class="line">/opt/MegaRAID/MegaCli/libstorelibir-2.so.14.07-0</span><br></pre></td></tr></table></figure>
<p>/opt/MegaRAID/MegaCli/MegaCli64这个文件就是我们要用到的，<br><a id="more"></a></p>
<h1 id="Megacli概念"><a href="#Megacli概念" class="headerlink" title="Megacli概念"></a>Megacli概念</h1><h2 id="适配器，物理驱动器和虚拟驱动器"><a href="#适配器，物理驱动器和虚拟驱动器" class="headerlink" title="适配器，物理驱动器和虚拟驱动器"></a>适配器，物理驱动器和虚拟驱动器</h2><p>在我们通过megacli命令之前，我们需要遵循megacli概念。</p>
<p><strong>适配器</strong> - 我们要使用的物理控制器，由id（通常为0）表示。</p>
<p><strong>机柜</strong> - 物理机箱所附的物理驱动器，以id为代表，例如254,252等。</p>
<p><strong>物理驱动器</strong> - 附加到控制器的物理硬盘，由id，0,1,2,3等代表</p>
<p><strong>虚拟驱动器</strong> - 这些驱动器包含物理驱动器，并等同于由id，0,1,2,3等代表的RAID设备。</p>
<p>例如，如果我们的RAID 0超过3个物理驱动器，我们得到：</p>
<p>物理驱动器ID：0,1,2</p>
<p>虚拟驱动器ID：0</p>
<p>虚拟驱动器包含物理驱动器0,1和2，并包括突袭设备的设置，如RAID级别，条带大小等。</p>
<p>我们可以通过一个物理驱动器看到具有RAID 0的虚拟驱动器中的配置，我们有这种设置，因为物理驱动器连接到RAID控制器，并且为了将设备表示给系统，我们必须将其设置为兆位。</p>
<p>默认情况下，我们将在RAID 0中看到虚拟驱动器的所有物理设备。</p>
<h2 id="获取RAID控制器信息"><a href="#获取RAID控制器信息" class="headerlink" title="获取RAID控制器信息"></a>获取RAID控制器信息</h2><p>使用lspci确保您的服务器已连接到RAID控制器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i raid</span><br></pre></td></tr></table></figure>
<p><em>我的输出</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">03:00.0 RAID bus controller: LSI Logic / Symbios Logic MegaRAID SAS 2208 [Thunderbolt] (rev 05)</span><br></pre></td></tr></table></figure>
<p><em>这表明我这存在MegaRaid  controller ；我可以愉快的使用MegaCli搞事！</em></p>
<h2 id="获取RAID适配器的信息"><a href="#获取RAID适配器的信息" class="headerlink" title="获取RAID适配器的信息"></a>获取RAID适配器的信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64  -AdpGetPciInfo -aAll</span><br></pre></td></tr></table></figure>
<p><em>带上路径执行</em></p>
<p>我的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PCI information <span class="keyword">for</span> Controller 0</span><br><span class="line">--------------------------------</span><br><span class="line">Bus Number      : 23c0</span><br><span class="line">Device Number   : 0</span><br><span class="line">Function Number : a0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></table></figure>
<p><em>这里看到适配器信息，适配器id为0。</em></p>
<h2 id="获取硬盘背板信息"><a href="#获取硬盘背板信息" class="headerlink" title="获取硬盘背板信息"></a>获取硬盘背板信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -EncInfo -a0</span><br></pre></td></tr></table></figure>
<p>我的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">                                     </span><br><span class="line">    Number of enclosures on adapter 0 -- 1</span><br><span class="line"></span><br><span class="line">    Enclosure 0:</span><br><span class="line">    Device ID                     : 252</span><br><span class="line">    Number of Slots               : 8</span><br><span class="line">    Number of Power Supplies      : 0</span><br><span class="line">    Number of Fans                : 0</span><br><span class="line">    Number of Temperature Sensors : 0</span><br><span class="line">    Number of Alarms              : 0</span><br><span class="line">    Number of SIM Modules         : 1</span><br><span class="line">    Number of Physical Drives     : 8</span><br><span class="line">    Status                        : Normal</span><br><span class="line">    Position                      : 1</span><br><span class="line">    Connector Name                : Unavailable</span><br><span class="line">    Enclosure <span class="built_in">type</span>                : SGPIO</span><br><span class="line">    FRU Part Number               : N/A</span><br><span class="line">    Enclosure Serial Number       : N/A </span><br><span class="line">    ESM Serial Number             : N/A </span><br><span class="line">    Enclosure Zoning Mode         : N/A </span><br><span class="line">    Partner Device Id             : Unavailable</span><br><span class="line"></span><br><span class="line">    Inquiry data                  :</span><br><span class="line">        Vendor Identification     : LSI     </span><br><span class="line">        Product Identification    : SGPIO           </span><br><span class="line">        Product Revision Level    : N/A </span><br><span class="line">        Vendor Specific           :                     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit Code: 0x00</span><br></pre></td></tr></table></figure>
<p>记录下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Device ID</th>
<th style="text-align:center">252</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Number of Slots( 可以连接到这个背板的最大物理驱动器</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</div>
<h2 id="获取物理驱动器的信息"><a href="#获取物理驱动器的信息" class="headerlink" title="获取物理驱动器的信息"></a>获取物理驱动器的信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -LdPdInfo -a0</span><br></pre></td></tr></table></figure>
<p>因为我的盘比较多。这里输出就列出一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 1</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 1, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 3</span></span><br><span class="line"><span class="string">WWN: 500003963820BFE1</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820bfe2</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 1(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A05KFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :24C (75.20 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s </span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 2 (Target Id: 2)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 3</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 2, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 14</span></span><br><span class="line"><span class="string">WWN: 500003963820C81D</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820c81e</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 3(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A08RFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None</span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s</span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s</span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :26C (78.80 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No</span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s</span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s</span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 3 (Target Id: 3)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 2</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 3, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 16</span></span><br><span class="line"><span class="string">WWN: 500003963820C225</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820c226</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 2(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A06AFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :26C (78.80 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s</span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 4 (Target Id: 4)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 837.843 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 4</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 4, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 15</span></span><br><span class="line"><span class="string">WWN: 5000C500958D1EB8</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 838.362 GB [0x68cb9e30 Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 837.862 GB [0x68bb9e30 Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 837.843 GB [0x68bb0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: L56Q</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x5000c500958d1eb9</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 4(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: LENOVO-XST900MM0006     L56QS0N5129S0521B5C9    </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :28C (82.40 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  Yes </span></span><br><span class="line"><span class="string">Number of bytes of user data in LBA: 512 </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  Yes </span></span><br><span class="line"><span class="string">PI: PI with type 2</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s</span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 5 (Target Id: 5)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 5</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 5, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 18</span></span><br><span class="line"><span class="string">WWN: 500003963820C429</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820c42a</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 5(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A06TFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :24C (75.20 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s </span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 6 (Target Id: 6)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 6</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 6, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 19</span></span><br><span class="line"><span class="string">WWN: 500003963820BFF1</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820bff2</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 6(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A05MFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :24C (75.20 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s </span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 7 (Target Id: 7)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line">Number of Spans: 1</span><br><span class="line">Span: 0 - Number of PDs: 1</span><br><span class="line"></span><br><span class="line">PD: 0 Information</span><br><span class="line">Enclosure Device ID: 252</span><br><span class="line">Slot Number: 7</span><br><span class="line">Drive<span class="string">'s position: DiskGroup: 7, Span: 0, Arm: 0</span></span><br><span class="line"><span class="string">Enclosure position: N/A</span></span><br><span class="line"><span class="string">Device Id: 20</span></span><br><span class="line"><span class="string">WWN: 500003963820C2D1</span></span><br><span class="line"><span class="string">Sequence Number: 2</span></span><br><span class="line"><span class="string">Media Error Count: 0</span></span><br><span class="line"><span class="string">Other Error Count: 0</span></span><br><span class="line"><span class="string">Predictive Failure Count: 0</span></span><br><span class="line"><span class="string">Last Predictive Failure Event Seq Number: 0</span></span><br><span class="line"><span class="string">PD Type: SAS</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Raw Size: 279.396 GB [0x22ecb25c Sectors]</span></span><br><span class="line"><span class="string">Non Coerced Size: 278.896 GB [0x22dcb25c Sectors]</span></span><br><span class="line"><span class="string">Coerced Size: 278.875 GB [0x22dc0000 Sectors]</span></span><br><span class="line"><span class="string">Sector Size:  512</span></span><br><span class="line"><span class="string">Logical Sector Size:  512</span></span><br><span class="line"><span class="string">Physical Sector Size:  512</span></span><br><span class="line"><span class="string">Firmware state: Online, Spun Up</span></span><br><span class="line"><span class="string">Commissioned Spare : No</span></span><br><span class="line"><span class="string">Emergency Spare : No</span></span><br><span class="line"><span class="string">Device Firmware Level: 1004</span></span><br><span class="line"><span class="string">Shield Counter: 0</span></span><br><span class="line"><span class="string">Successful diagnostics completion on :  N/A</span></span><br><span class="line"><span class="string">SAS Address(0): 0x500003963820c2d2</span></span><br><span class="line"><span class="string">SAS Address(1): 0x0</span></span><br><span class="line"><span class="string">Connected Port Number: 7(path0) </span></span><br><span class="line"><span class="string">Inquiry Data: TOSHIBA AL13SEB300      100445O0A06HFWC9        </span></span><br><span class="line"><span class="string">FDE Capable: Not Capable</span></span><br><span class="line"><span class="string">FDE Enable: Disable</span></span><br><span class="line"><span class="string">Secured: Unsecured</span></span><br><span class="line"><span class="string">Locked: Unlocked</span></span><br><span class="line"><span class="string">Needs EKM Attention: No</span></span><br><span class="line"><span class="string">Foreign State: None </span></span><br><span class="line"><span class="string">Device Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Link Speed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Media Type: Hard Disk Device</span></span><br><span class="line"><span class="string">Drive:  Not Certified</span></span><br><span class="line"><span class="string">Drive Temperature :24C (75.20 F)</span></span><br><span class="line"><span class="string">PI Eligibility:  No </span></span><br><span class="line"><span class="string">Drive is formatted for PI information:  No</span></span><br><span class="line"><span class="string">PI: No PI</span></span><br><span class="line"><span class="string">Port-0 :</span></span><br><span class="line"><span class="string">Port status: Active</span></span><br><span class="line"><span class="string">Port'</span>s Linkspeed: 6.0Gb/s </span><br><span class="line">Port-1 :</span><br><span class="line">Port status: Active</span><br><span class="line">Port<span class="string">'s Linkspeed: 6.0Gb/s </span></span><br><span class="line"><span class="string">Drive has flagged a S.M.A.R.T alert : No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Exit Code: 0x00</span></span><br></pre></td></tr></table></figure>
<p>Slot Number是物理驱动器连接的插槽号，也就是对应物理驱动器id</p>
<h2 id="获取Virtual-drives信息"><a href="#获取Virtual-drives信息" class="headerlink" title="获取Virtual drives信息"></a>获取Virtual drives信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64  -LDInfo -Lall -a0</span><br></pre></td></tr></table></figure>
<p><em>我的输出</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">                                     </span><br><span class="line"></span><br><span class="line">Adapter 0 -- Virtual Drive Information:</span><br><span class="line">Virtual Drive: 0 (Target Id: 0)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 185.781 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : Yes</span><br><span class="line">Parity Size         : 0</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 256 KB</span><br><span class="line">Number Of Drives    : 1</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Enabled</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Virtual Drive: 1 (Target Id: 1)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 278.875 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 0</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 256 KB</span><br><span class="line">Number Of Drives    : 1</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk<span class="string">'s Default</span></span><br><span class="line"><span class="string">Encryption Type     : None</span></span><br><span class="line"><span class="string">PI type: No PI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Is VD Cached: No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 2 (Target Id: 2)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Virtual Drive: 3 (Target Id: 3)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 278.875 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 0</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 256 KB</span><br><span class="line">Number Of Drives    : 1</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk<span class="string">'s Default</span></span><br><span class="line"><span class="string">Encryption Type     : None</span></span><br><span class="line"><span class="string">PI type: No PI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Is VD Cached: No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 4 (Target Id: 4)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 837.843 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAhead, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Virtual Drive: 5 (Target Id: 5)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 278.875 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 0</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 256 KB</span><br><span class="line">Number Of Drives    : 1</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk<span class="string">'s Default</span></span><br><span class="line"><span class="string">Encryption Type     : None</span></span><br><span class="line"><span class="string">PI type: No PI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Is VD Cached: No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Virtual Drive: 6 (Target Id: 6)</span></span><br><span class="line"><span class="string">Name                :</span></span><br><span class="line"><span class="string">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span></span><br><span class="line"><span class="string">Size                : 278.875 GB</span></span><br><span class="line"><span class="string">Sector Size         : 512</span></span><br><span class="line"><span class="string">Is VD emulated      : No</span></span><br><span class="line"><span class="string">Parity Size         : 0</span></span><br><span class="line"><span class="string">State               : Optimal</span></span><br><span class="line"><span class="string">Strip Size          : 256 KB</span></span><br><span class="line"><span class="string">Number Of Drives    : 1</span></span><br><span class="line"><span class="string">Span Depth          : 1</span></span><br><span class="line"><span class="string">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache if Bad BBU</span></span><br><span class="line"><span class="string">Default Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Current Access Policy: Read/Write</span></span><br><span class="line"><span class="string">Disk Cache Policy   : Disk'</span>s Default</span><br><span class="line">Encryption Type     : None</span><br><span class="line">PI <span class="built_in">type</span>: No PI</span><br><span class="line"></span><br><span class="line">Is VD Cached: No</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Virtual Drive: 7 (Target Id: 7)</span><br><span class="line">Name                :</span><br><span class="line">RAID Level          : Primary-0, Secondary-0, RAID Level Qualifier-0</span><br><span class="line">Size                : 278.875 GB</span><br><span class="line">Sector Size         : 512</span><br><span class="line">Is VD emulated      : No</span><br><span class="line">Parity Size         : 0</span><br><span class="line">State               : Optimal</span><br><span class="line">Strip Size          : 256 KB</span><br><span class="line">Number Of Drives    : 1</span><br><span class="line">Span Depth          : 1</span><br><span class="line">Default Cache Policy: WriteBack, ReadAdaptive, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Current Cache Policy: WriteThrough, ReadAdaptive, Direct, No Write Cache <span class="keyword">if</span> Bad BBU</span><br><span class="line">Default Access Policy: Read/Write</span><br><span class="line">Current Access Policy: Read/Write</span><br><span class="line">Disk Cache Policy   : Disk<span class="string">'s Default</span></span><br><span class="line"><span class="string">Encryption Type     : None</span></span><br><span class="line"><span class="string">PI type: No PI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Is VD Cached: No</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Exit Code: 0x00</span></span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>Target ID</th>
<th>表RAID创建过程中 创建的虚拟驱动器</th>
</tr>
</thead>
<tbody>
<tr>
<td>Size</td>
<td>RAID设备的大小，这个大小是实际可分配的大小</td>
</tr>
</tbody>
</table>
</div>
<h2 id="获取Virtual-drives内的物理驱动器信息"><a href="#获取Virtual-drives内的物理驱动器信息" class="headerlink" title="获取Virtual drives内的物理驱动器信息"></a>获取Virtual drives内的物理驱动器信息</h2><p>这就有点难了， 其实没什么卵用,记下来留着以后copy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64  -LdPdInfo -a0 | grep -E <span class="string">"Virtual Drive:|Slot Number:"</span> | xargs | sed -r <span class="string">'s/(Slot Number:)(\s[0-9]+)/\2,/g'</span> | sed <span class="string">'s/(Target Id: .)/Physical Drives ids:/g'</span> | sed <span class="string">'s/Virtual Drive:/\nVirtual Drive:/g'</span></span><br></pre></td></tr></table></figure>
<p>我的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Virtual Drive: 0 Physical Drives ids:  0, </span><br><span class="line">Virtual Drive: 1 Physical Drives ids:  1, </span><br><span class="line">Virtual Drive: 2 Physical Drives ids:  3, </span><br><span class="line">Virtual Drive: 3 Physical Drives ids:  2, </span><br><span class="line">Virtual Drive: 4 Physical Drives ids:  4, </span><br><span class="line">Virtual Drive: 5 Physical Drives ids:  5, </span><br><span class="line">Virtual Drive: 6 Physical Drives ids:  6, </span><br><span class="line">Virtual Drive: 7 Physical Drives ids:  7,</span><br></pre></td></tr></table></figure>
<p>或者使用这个工具 “megasasctl”</p>
<h2 id="创建RAID设备（Virtual-drives）"><a href="#创建RAID设备（Virtual-drives）" class="headerlink" title="创建RAID设备（Virtual drives）"></a>创建RAID设备（Virtual drives）</h2><p>前面主要是收集信息，有信息，才可以准确的创建</p>
<p>比如我们来一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Adpater id: 0</span><br><span class="line">Enclosure id: 252</span><br><span class="line">Physical Drive ids: 3</span><br><span class="line">Raid Level: 0</span><br></pre></td></tr></table></figure>
<p>命令参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -CfgLdAdd -rX[enclosure_id:physical_id,enclosure_id:physical_id] -aN</span><br></pre></td></tr></table></figure>
<p>X 是 RAID级别</p>
<p>N 是 adapter ID</p>
<p>举个栗子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64  -CfgLdAdd -r0[252:3,252:4] -a0</span><br></pre></td></tr></table></figure>
<p><em>设备编号为3和4的磁盘，创建RAID0</em></p>
<p>来个RAID10</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -CfgSpanAdd -r10 -Array0 [252:2,252:3] -Array1 [252:4,252:5] -a0</span><br></pre></td></tr></table></figure>
<h2 id="删除RAID设备"><a href="#删除RAID设备" class="headerlink" title="删除RAID设备"></a>删除RAID设备</h2><p>删Virtual drives2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/MegaRAID/MegaCli/MegaCli64 -CfgLdDel -L2 -a0</span><br></pre></td></tr></table></figure>
<p>常用选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">相关命令及其解析： </span><br><span class="line">查看机器型号    <span class="comment"># dmidecode | grep "Product" </span></span><br><span class="line">查看厂商    <span class="comment"># dmidecode| grep  "Manufacturer" </span></span><br><span class="line">查看序列号    <span class="comment"># dmidecode | grep  "Serial Number" </span></span><br><span class="line">查看CPU信息    <span class="comment"># dmidecode | grep  "CPU" </span></span><br><span class="line">查看CPU个数    <span class="comment"># dmidecode | grep  "Socket Designation: CPU" |wc –l </span></span><br><span class="line">查看出厂日期    <span class="comment"># dmidecode | grep "Date" </span></span><br><span class="line">查看充电状态    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Charger Status" </span></span><br><span class="line">显示BBU状态信息    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuStatus –aALL </span></span><br><span class="line">显示BBU容量信息    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuCapacityInfo –aALL </span></span><br><span class="line">显示BBU设计参数    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuDesignInfo –aALL </span></span><br><span class="line">显示当前BBU属性    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuProperties –aALL </span></span><br><span class="line">查看充电进度百分比    <span class="comment"># MegaCli -AdpBbuCmd -GetBbuStatus -aALL |grep "Relative State of Charge" </span></span><br><span class="line">查询Raid阵列数    <span class="comment"># MegaCli -cfgdsply -aALL |grep "Number of DISK GROUPS:" </span></span><br><span class="line">显示Raid卡型号，Raid设置，Disk相关信息      <span class="comment"># MegaCli -cfgdsply –aALL </span></span><br><span class="line">显示所有物理信息    <span class="comment"># MegaCli -PDList -aALL </span></span><br><span class="line">显示所有逻辑磁盘组信息    <span class="comment"># MegaCli -LDInfo -LALL –aAll </span></span><br><span class="line">查看物理磁盘重建进度(重要)    <span class="comment"># MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0 </span></span><br><span class="line">查看适配器个数    <span class="comment">#MegaCli –adpCount </span></span><br><span class="line">查看适配器时间    <span class="comment">#MegaCli -AdpGetTime –aALL </span></span><br><span class="line">显示所有适配器信息    <span class="comment">#MegaCli -AdpAllInfo –aAll </span></span><br><span class="line">查看Cache 策略设置    <span class="comment"># MegaCli -cfgdsply -aALL |grep Polic</span></span><br><span class="line"></span><br><span class="line">硬盘方面：</span><br><span class="line"></span><br><span class="line">1、查看所有物理磁盘信息 </span><br><span class="line">MegaCli -PDList -aALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、查看磁盘缓存策略 </span><br><span class="line">MegaCli -LDGetProp -Cache -L0 -a0</span><br><span class="line">or </span><br><span class="line">MegaCli -LDGetProp -Cache -L1 -a0</span><br><span class="line">or </span><br><span class="line">MegaCli -LDGetProp -Cache -LALL -a0</span><br><span class="line">or </span><br><span class="line">MegaCli -LDGetProp -Cache -LALL -aALL</span><br><span class="line">or </span><br><span class="line">MegaCli -LDGetProp -DskCache -LALL -aALL</span><br><span class="line"></span><br><span class="line">3、设置磁盘缓存策略 </span><br><span class="line">缓存策略解释： </span><br><span class="line">WT    (Write through </span><br><span class="line">WB    (Write back) </span><br><span class="line">NORA  (No <span class="built_in">read</span> ahead) </span><br><span class="line">RA    (Read ahead) </span><br><span class="line">ADRA  (Adaptive <span class="built_in">read</span> ahead) </span><br><span class="line">Cached </span><br><span class="line">Direct </span><br><span class="line">例子： </span><br><span class="line">MegaCli -LDSetProp WT|WB|NORA|RA|ADRA -L0 -a0 </span><br><span class="line">or </span><br><span class="line">MegaCli -LDSetProp -Cached|-Direct -L0 -a0 </span><br><span class="line">or </span><br><span class="line"><span class="built_in">enable</span> / <span class="built_in">disable</span> disk cache </span><br><span class="line">MegaCli -LDSetProp -EnDskCache|-DisDskCache -L0 -a0 </span><br><span class="line">4、创建/删除 阵列 </span><br><span class="line">    4.1 创建一个 raid5 阵列，由物理盘 2,3,4 构成，该阵列的热备盘是物理盘 5 </span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct -Hsp[1:5] –a0 </span><br><span class="line">    4.2 创建阵列，不指定热备 </span><br><span class="line">MegaCli -CfgLdAdd -r5 [1:2,1:3,1:4] WB Direct –a0 </span><br><span class="line">    4.3 删除阵列 </span><br><span class="line">MegaCli -CfgLdDel -L1 –a0 </span><br><span class="line">    4.4 在线添加磁盘 </span><br><span class="line">MegaCli -LDRecon -Start -r5 -Add -PhysDrv[1:4] -L1 -a0 </span><br><span class="line">意思是，重建逻辑磁盘组1，raid级别是5，添加物理磁盘号：1:4。重建完后，新添加的物理磁盘会自动处于重建(同步)状态，这个 时候 fdisk -l是看不到阵列的空间变大的，只有在系统重启后才能看见。 </span><br><span class="line">5、查看阵列初始化信息 </span><br><span class="line">    5.1 阵列创建完后，会有一个初始化同步块的过程，可以看看其进度。 </span><br><span class="line">MegaCli -LDInit -ShowProg -LALL -aALL </span><br><span class="line">或者以动态可视化文字界面显示 </span><br><span class="line">MegaCli -LDInit -ProgDsply -LALL –aALL </span><br><span class="line">    5.2 查看阵列后台初始化进度 </span><br><span class="line">MegaCli -LDBI -ShowProg -LALL -aALL </span><br><span class="line">或者以动态可视化文字界面显示 </span><br><span class="line">MegaCli -LDBI -ProgDsply -LALL -aALL </span><br><span class="line">6、创建全局热备 </span><br><span class="line">指定第 5 块盘作为全局热备 </span><br><span class="line">MegaCli -PDHSP -Set [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0 </span><br><span class="line">也可以指定为某个阵列的专用热备 </span><br><span class="line">MegaCli -PDHSP -Set [-Dedicated [-Array1]] [-EnclAffinity] [-nonRevertible] -PhysDrv[1:5] -a0 </span><br><span class="line">7、删除全局热备 </span><br><span class="line">MegaCli -PDHSP -Rmv -PhysDrv[1:5] -a0 </span><br><span class="line">8、将某块物理盘下线/上线 </span><br><span class="line">MegaCli -PDOffline -PhysDrv [1:4] -a0 </span><br><span class="line">MegaCli -PDOnline -PhysDrv [1:4] -a0 </span><br><span class="line">9、查看物理磁盘重建进度 </span><br><span class="line">MegaCli -PDRbld -ShowProg -PhysDrv [1:5] -a0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Device Mapper Multipathing</title>
    <url>/2017/09/16/Linux/storage/multipath/</url>
    <content><![CDATA[<h1 id="第-1-章-简单MULTIPATH-功能实现"><a href="#第-1-章-简单MULTIPATH-功能实现" class="headerlink" title="第 1 章 简单MULTIPATH 功能实现"></a>第 1 章 简单MULTIPATH 功能实现</h1><h2 id="实现dm功能"><a href="#实现dm功能" class="headerlink" title="实现dm功能"></a>实现dm功能</h2><p>如果仅仅是想实现多路径功能  请直接安装 device-mapper-multipath </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install  -y device-mapper-multipath</span><br></pre></td></tr></table></figure>
<p>修改 /etc/multipath.conf 配置文件内容</p>
<p>生效内容为以下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">devnode <span class="string">"^sda"</span></span><br><span class="line">&#125;</span><br><span class="line">defaults &#123;</span><br><span class="line">		user_friendly_names yes</span><br><span class="line">		path_grouping_policy multibus</span><br><span class="line">		failback immediate</span><br><span class="line">		no_path_retry fail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>sda为你要排除的非多路径设备</em></p>
<p>然后你启动服务就好咯<br><a id="more"></a><br>CentOS6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd start</span><br><span class="line">chkconfig multipathd on</span><br></pre></td></tr></table></figure>
<p>CentOS7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start multipathd</span><br><span class="line">systemctl <span class="built_in">enable</span> multipathd</span><br></pre></td></tr></table></figure>
<p>服务启动了， 看看多路径现在的状态吧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -ll</span><br></pre></td></tr></table></figure>
<p> 然后查看下 /dev/mapper/ 目录下是否多了mpath开头的设备文件</p>
<p>如果有  <code>fdisk -l</code>看下</p>
<p>可以格式化 或者创建pv咯</p>
<p>因为多路径为san设备， 所以开机挂在需要谨慎，写fstab时 主要要使用  <code>_netdev</code>选项</p>
<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/mapper/Xsky-Xsky   /xsky       xfs    defaults,_netdev        0 0</span><br></pre></td></tr></table></figure>
<p>下面的内容都是参考官方文档， 整理到这里是为了以后不会配置去百度！！！</p>
<h2 id="DM-MULTIPATH-概述"><a href="#DM-MULTIPATH-概述" class="headerlink" title="DM MULTIPATH 概述"></a>DM MULTIPATH 概述</h2><p>可使用 DM Multipath 提供以下功能：</p>
<ul>
<li><p>冗余</p>
<p>DM Multipath 能够在主动／被动配置下提供故障转移。在主动／被动配置下，只有一半的路径在每次进行 I/O 时会被使用。若一条 I/O 路径的任一元素（电缆、交换器或者控制器）出现故障，DM Multipath 就会将它切换到备用路径。</p>
<p>​</p>
</li>
<li><p>改进的性能</p>
<p>​</p>
<p>可将 DM Multipath 配置为主动／主动模式， 这会将 I/O 以轮循机制（round-robin）的方式分布到所有的路径中。在有些配置中，DM Multipath 能够检测 I/O 路径的负载，并且重新动态平衡负载。</p>
</li>
</ul>
<p>图 1.1 “带一个 RAID 设备的主动／被动多路径配置”演示了在服务器和 RAID 设备之间有两个 I/O 路径的主动／被动配置。这里服务器中有两个 HBA，两个 SAN 交换机以及两个 RAID 控制器。</p>
<p>⁠</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/m45k774b6m.png?imageslim" alt="mark"></p>
<p>​<strong>图 1.1. 带一个 RAID 设备的主动／被动多路径配置</strong></p>
<p>在这个配置中，一个 I/O 路径通过 hba1、SAN1 以及控制器 1。另一个 I/O 路径通过 hba2、SAN2 以及控制器 2。在这个配置中有很多地方可能出现故障：</p>
<ul>
<li>HBA 故障</li>
<li>FC 电缆故障</li>
<li>SAN 交换机故障</li>
<li>阵列控制器端口故障</li>
</ul>
<p>阵列控制器端口故障</p>
<p>图 1.2 “带两个 RAID 设备的主动／被动多路径配置” 演示了更复杂的主动／被动配置，其中服务器中有两个 HBA、两个 SAN 交换机以及两个 RAID 设备（每个带两个 RAID 控制器）。</p>
<p>⁠</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/DacBIGBIg1.png?imageslim" alt="mark"></p>
<p>​<strong>图 1.2. 带两个 RAID 设备的主动／被动多路径配置</strong></p>
<p>在图 1.2 “带两个 RAID 设备的主动／被动多路径配置”演示的示例中，每个 RAID 设备都有两个 I/O 路径（与 图 1.1 “带一个 RAID 设备的主动／被动多路径配置”的示例相同）。如果配置了 DM Multipath，任一 RAID 设备的 I/O 路径的任一点出现故障，都将会导致 DM Multipath 为该设备切换到备用 I/O 路径。</p>
<p>图 1.3 “带一个 RAID 设备的主动/主动多路径配置” 演示在服务器中有两个 HBA、一个 SAN 交换机以及两个 RAID 控制器的主动／主动配置。在服务器和存储设备间有四条 I/O 路径：</p>
<ul>
<li>hba1 到控制器 1</li>
<li>hba1 到控制器 2</li>
<li>hba2 到控制器 1</li>
<li>hba2 到控制器 2</li>
</ul>
<p>在这个配置中，可将 I/O 分布到上述四条路径中。</p>
<p>⁠</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/GLD42i9FI3.png?imageslim" alt="mark"></p>
<p>​<strong>图 1.3. 带一个 RAID 设备的主动/主动多路径配置</strong></p>
<h2 id="存储阵列支持"><a href="#存储阵列支持" class="headerlink" title="存储阵列支持"></a>存储阵列支持</h2><p>默认情况下，DM Multipath 支持大多数常用的支持 DM Multipath 的储存阵列。若要了解默认配置值和支持的设备的相关信息，请运行下列指令中的任何一个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipathd show config</span><br><span class="line">multipath -t</span><br></pre></td></tr></table></figure>
<p>若储存阵列支持 DM Multipath 但是默认情况下未被配置，您需要将它加入 DM Multipath 配置文件 <code>multipath.conf</code>。</p>
<p>有些存储阵列对 I/O 错误和路径切换需要特殊处理。这些都需要独立的硬件处理器 kernel 模块。</p>
<h2 id="DM-MULTIPATH-组件"><a href="#DM-MULTIPATH-组件" class="headerlink" title="DM MULTIPATH 组件"></a>DM MULTIPATH 组件</h2><p><a href="#table1.1">表 1.1 “DM Multipath 组件”</a>对 DM Multipath 组件进行了描述。</p>
<p>⁠</p>
<p><span id="table1.1"><strong>表 1.1. DM Multipath 组件</strong></span></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">组件</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>dm-multipath</code> kernel 模块</td>
<td style="text-align:center">为路径和路径组重新指定 I/O 并支持故障转移。</td>
</tr>
<tr>
<td style="text-align:left"><code>mpathconf</code> 工具程序</td>
<td style="text-align:center">配置并启用 DM Multipath。</td>
</tr>
<tr>
<td style="text-align:left"><code>multipath</code> 指令</td>
<td style="text-align:center">列出并配置多路径设备。通常使用 <code>/etc/rc.sysinit</code> 启动，还可以在添加块设备时通过 <code>udev</code> 程序启动。</td>
</tr>
<tr>
<td style="text-align:left"><code>multipathd</code> 守护进程</td>
<td style="text-align:center">监视路径；若路径故障并返回，它可能会启动路径组切换。允许对多路径设备进行交互式修改。若需对 <code>/etc/multipath.conf</code> 文件进行任何修改，都必须重新启动本守护进程。</td>
</tr>
<tr>
<td style="text-align:left"><code>kpartx</code> 命令</td>
<td style="text-align:center">为设备分区生成设备映射器。对于带 DM Multipath 的基于 DOS 的分区来说，使用此命令很有必要。<code>kpartx</code> 命令包含在它自己的软件包当中，但是 <code>device-mapper-multipath</code> 软件包需要依赖它。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="DM-MULTIPATH-设置概述"><a href="#DM-MULTIPATH-设置概述" class="headerlink" title="DM MULTIPATH 设置概述"></a>DM MULTIPATH 设置概述</h2><p>DM Multipath 包含适用于常用多路径配置的已编译默认设置。为系统配置 DM Multipath 的基本步骤如下：</p>
<ol>
<li>安装 <code>device-mapper-multipath</code> rpm。</li>
<li>使用 <code>mpathconf</code> 命令创建配置文件并启用多路径。若无需编辑该配置文件，可使用此命令启动多路径守护程序。</li>
<li>如需编辑该配置文件，请编辑 <code>multipath.conf</code> 配置文件，修改默认值并保存更新的文件。</li>
<li>启动多路径守护进程。</li>
</ol>
<h1 id="第-2-章-多路径设备"><a href="#第-2-章-多路径设备" class="headerlink" title="第 2 章 多路径设备"></a>第 2 章 多路径设备</h1><p>若没有 DM Multipath，从服务器节点到储存控制器的每一条路径都会被系统视为独立的设备，即使 I/O 路径连接的是相同的服务器节点到相同的储存控制器也是如此。DM Multipath 提供了有逻辑的管理 I/O 路径的方法，即在基础设备顶端生成单一多路径设备。</p>
<h2 id="多路径设备识别符"><a href="#多路径设备识别符" class="headerlink" title="多路径设备识别符"></a>多路径设备识别符</h2><p>每个多路径设备都有一个全球识别符（WWID），它是一个全球唯一的无法更改的号码。默认情况下会将多路径设备的名称设定为它的 WWID。另外，您还可以在多路径配置文件中设置 <code>user_friendly_names</code> 选项，该选项可将别名设为格式为 <code>mpath</code><em>n</em> 的节点唯一名称。</p>
<p>例如：有两个 HBA 的节点通过单一不分区 FC 交换机附加到有两个端口的储存控制器中时，可看到四个设备：<code>/dev/sda</code>、<code>/dev/sdb</code>、<code>dev/sdc</code> 以及 <code>/dev/sdd</code>。DM Multipath 会生成由唯一 WWID 的单一设备，该设备可根据多路径配置将 I/O 重新路由到那四个基础设备。<code>user_friendly_names</code> 配置选项的值被设为 <code>yes</code> 时，多路径设备的名称会被设定为 <code>mpath</code><em>n</em>。</p>
<p>新设备被纳入 DM Multipath 控制时，该设备会显示在 <code>/dev</code> 目录的两个不同位置： <code>/dev/mapper/mpath</code><em>n</em> 和 <code>/dev/dm-</code><em>n</em>。</p>
<ul>
<li><code>/dev/mapper</code> 中的设备是在引导过程中生成的。可使用这些设备访问多路径设备，例如在生成逻辑卷时。</li>
<li>任何 <code>/dev/dm-</code><em>n</em> 格式的设备都只适用于内部使用，管理员请勿直接使用。</li>
</ul>
<h2 id="在集群中保持多路径设备名称一致"><a href="#在集群中保持多路径设备名称一致" class="headerlink" title="在集群中保持多路径设备名称一致"></a>在集群中保持多路径设备名称一致</h2><p>当将 <code>user_friendly_names</code> 配置选项设为 <code>yes</code> 时，该多路径设备的名称对于节点来说是唯一的，但不保证对使用多路径设备的所有节点都一致。同样，如果您为 <code>multipath.conf</code> 配置文件的 <code>multipaths</code> 部分中的设备设定 <code>alias</code> 选项，该名称不会自动在集群的所有节点中保持一致。如果您使用 LVM 在多路径设备中创建逻辑设备，这不应是问题。但如果您需要将您的多路径设备名称在集群中的每个节点上都保持一致，请不要将 <code>user_friendly_names</code> 选项设定为 <code>yes</code>，且不要为那些设备配置别名。默认情况下，如果您不将 <code>user_friendly_names</code> 设定为 <code>yes</code>，或者为某个设备配置别名，则设备名称将是该设备的 WWID，它是不会变的。</p>
<p>如果您要系统定义的用户友好名称在集群的所有节点中都一致，您可按照以下步骤操作：</p>
<ol>
<li><p>在一台机器中设定所有多路径设备。</p>
</li>
<li><p>运行以下命令禁用其它机器上所有的多路径设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd stop</span><br><span class="line">multipath -F</span><br></pre></td></tr></table></figure>
</li>
<li><p>将第一台机器中的 <code>/etc/multipath/bindings</code> 文件复制到集群中的其它所有机器中。</p>
</li>
<li><p>使用以下命令在集群的其他机器中重新 <code>multipathd</code> 守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd start</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果您添加新设备，您将需要重复这个过程。</p>
<p>同样，如果您为某个设备配置别名以便在集群的节点中使其保持一致，您应确定 <code>/etc/multipath.conf</code> 文件对于集群中的每个节点都是一样的，步骤如下：</p>
<ol>
<li><p>为一台机器上 <code>multipath.conf</code> 文件中的多路径设备配置别名。</p>
</li>
<li><p>运行以下命令禁用其它机器上所有的多路径设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd stop</span><br><span class="line">multipath -F</span><br></pre></td></tr></table></figure>
</li>
<li><p>将第一台机器中的 <code>/etc/multipath.conf</code> 文件复制到集群中的其它所有机器中。</p>
</li>
<li><p>使用以下命令在集群的其他机器中重新 <code>multipathd</code> 守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd start</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当您添加新设备时，您将需要重复这个过程。</p>
<h2 id="多路径设备属性"><a href="#多路径设备属性" class="headerlink" title="多路径设备属性"></a>多路径设备属性</h2><p>除 <code>user_friendly_names</code> 和 <code>alias</code> 选项外，multipath 设备有大量属性。您可以为具体 multipath 设备修改这些属性，方法是在 multipath 配置文件的 <code>multipaths</code> 部分为那个设备创建一个条目。</p>
<h2 id="逻辑卷中的多路径设备"><a href="#逻辑卷中的多路径设备" class="headerlink" title="逻辑卷中的多路径设备"></a>逻辑卷中的多路径设备</h2><p>生成多路径设备后，多路径设备的名称可以与您生成一个 LVM 物理卷时使用的物理设备名称相同。例如：如果多路径名称为 <code>/dev/mapper/mpatha</code>，以下命令可将 <code>/dev/mapper/mpatha</code> 标记为一个物理卷。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/mapper/mpatha</span><br></pre></td></tr></table></figure>
<p>您可以如在使用其它 LVM 物理设备一样在创建 LVM 卷组时使用得到的 LVM 物理卷。</p>
<p><strong><em>注意</em></strong></p>
<p><em>如果您要在配置了分区的整个设备中创建 LVM 物理卷，<code>pvcreate</code> 命令将会失败。请注意：如果您不具体指定每个块设备，Anaconda 和 Kickstart 安装程序会生成空分区表。您可以使用 <code>kpartx -d</code> 和 <code>fdisk</code> 命令删除现有分区。如果您的系统有大于 2 TB 的块设备，您可使用 <code>parted</code> 命令删除分区。</em></p>
<p>当您创建使用主动／被动多路径阵列的 LVM 逻辑卷作为基础物理设备时，您应该在 <code>/etc/lvm/lvm.conf</code> 文件中添加过滤器，以排除构成多路径设备的磁盘。这是因为如果不过滤，阵列在接收到 I/O 时自动从主动路径切换到被动路径，只要 LVM 扫描到被动路径，多路径将会进行故障转移和自动恢复。对于需要使用命令激活被动路径的主动／被动阵列，LVM 会给出警告信息。</p>
<p>要过滤 LVM 配置文件（<code>lvm.conf</code>）中的所有 SCSI 设备，请在该文件的 <code>devices</code> 部分添加以下过滤器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter = [ <span class="string">"r/block/"</span>, <span class="string">"r/disk/"</span>, <span class="string">"r/sd.*/"</span>, <span class="string">"a/.*/"</span> ]</span><br></pre></td></tr></table></figure>
<h1 id="第-3-章-设置-DM-MULTIPATH"><a href="#第-3-章-设置-DM-MULTIPATH" class="headerlink" title="第 3 章 设置 DM MULTIPATH"></a>第 3 章 设置 DM MULTIPATH</h1><p>配置 DM Multipath 的分步示例，其中包括以下步骤：</p>
<ul>
<li>基本 DM Multipath 设置</li>
<li>忽略本地磁盘</li>
<li>在配置文件中添加更多设备</li>
<li>在 <code>initramfs</code> 文件系统中启动 Multipath</li>
</ul>
<h2 id="设置-DM-MULTIPATH"><a href="#设置-DM-MULTIPATH" class="headerlink" title="设置 DM MULTIPATH"></a>设置 DM MULTIPATH</h2><p>安装 DM-Multipath 前，请确定系统已升级，其中包括 <code>device-mapper-multipath</code> 软件包升级。</p>
<p>可使用 <code>mpathconf</code> 程序设置多路径，它可创建多路径配置文件 <code>/etc/multipath.conf</code>。</p>
<ul>
<li>如果 <code>/etc/multipath.conf</code> 文件已存在，<code>mpathconf</code> 程序将会编辑该文件。</li>
<li>如果 <code>/etc/multipath.conf</code> 文件不存在，<code>mpathconf</code> 程序将使用 <code>/usr/share/doc/device-mapper-multipath-0.4.9/multipath.conf</code> 文件作为起始文件。</li>
<li>如果 <code>/usr/share/doc/device-mapper-multipath-0.4.9/multipath.conf</code> 文件不存在，则 <code>mpathconf</code> 程序将从头开始创建 <code>/etc/multipath.conf</code> 文件。</li>
</ul>
<p>如果不需要编辑 <code>/etc/multipath.conf</code> 文件，则可以运行以下命令为 DM-Multipath 设定基本故障切换配置。这个命令可启用多路径配置文件并启动 <code>multipathd</code> 守护进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">enable</span> --with_multipathd y</span><br></pre></td></tr></table></figure>
<p>如果需要在启动 <code>multipathd</code> 守护进程前编辑 <code>/etc/multipath.conf</code> 文件，请执行以下步骤为 DM-Multipath 设置基本故障切换配置。</p>
<ol>
<li><p>运行带 <code>--enable</code> 选项的 <code>mpathconf</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">enable</span></span><br></pre></td></tr></table></figure>
<p>有关可能需要的 <code>mpathconf</code> 命令的其它选项，请参考 <code>mpathconf</code> 手册页，或者运行指定 <code>--help</code> 选项的 <code>mpathconf</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">usage: /sbin/mpathconf &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">Enable: --<span class="built_in">enable</span> </span><br><span class="line">Disable: --<span class="built_in">disable</span></span><br><span class="line">Set user_friendly_names (Default y): --user_friendly_names &lt;y|n&gt;</span><br><span class="line">Set find_multipaths (Default y): --find_multipaths &lt;y|n&gt; </span><br><span class="line">Load the dm-multipath modules on <span class="built_in">enable</span> (Default y): --with_module  &lt;y|n&gt;</span><br><span class="line">start/stop/reload multipathd (Default n): --with_multipathd  &lt;y|n&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>必要时请编辑 <code>/etc/multipath.conf</code> 文件。会将 DM Multipath 的默认设置编译到系统中，且无需在 <code>/etc/multipath.conf</code> 文件中明确设定。</p>
<p><code>path_grouping_policy</code> 的默认值是设为 <code>failover</code>，因此在这个示例中您不需要编辑 <code>/etc/multipath.conf</code> 文件。</p>
<p>在您系统配置文件的初始默认部分配置您的系统以便多路径设备的名称格式为 <code>mpath</code><em>n</em>。如果没有这个设置，多路径设备的名称将会是该设备 WWID 别名。</p>
</li>
<li><p>需要时保存配置文件并退出编辑器。</p>
</li>
<li><p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd start</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为在配置文件中将 <code>user_friendly_name</code> 值设为 <code>yes</code>，那么生成的多路径设备将为 <code>/dev/mapper/mpath</code><em>n</em>。</p>
<p>如果不想使用用户友好名称，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">enable</span> --user_friendly_names n</span><br></pre></td></tr></table></figure>
<p><strong><em>注意</em></strong></p>
<p><em>如果在启动 multipath 守护进程后发现需要编辑 multipath 配置文件，则必须执行 <code>service multipathd reload</code> 命令方可使更改生效。</em></p>
<h2 id="在生成多路径设备时忽略逻辑磁盘"><a href="#在生成多路径设备时忽略逻辑磁盘" class="headerlink" title="在生成多路径设备时忽略逻辑磁盘"></a>在生成多路径设备时忽略逻辑磁盘</h2><p>有些机器在其内部磁盘中有本地 SCSI 卡。不建议在这些设备中使用 DM Multipath。如果将 <code>find_multipaths</code> 配置参数设定为 <code>yes</code>，则不一定要将这些设备列入黑名单。</p>
<p>如果没有将 <code>find_multipaths</code> 配置参数设定为 <code>yes</code>，则可以使用以下步骤修改多路径配置文件，以便在配置多路径时忽略本地磁盘。</p>
<ol>
<li><p>确定哪些磁盘是内部磁盘并将其列入黑名单。</p>
<p>在这个示例中，<code>/dev/sda</code> 是内部磁盘。注：因为在默认多路径配置文件中已经对其进行了配置，所以执行 <code>multipath -v2</code> 会在多路径映射中显示本地磁盘 <code>/dev/sda</code>。</p>
<p>​</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipath -v2</span></span><br><span class="line">create: SIBM-ESXSST336732LC____F3ET0EP0Q000072428BX1 undef WINSYS,SF2372</span><br><span class="line">size=33 GB features=<span class="string">"0"</span> hwhandler=<span class="string">"0"</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 0:0:0:0 sda 8:0  [--------- </span><br><span class="line"></span><br><span class="line">device-mapper ioctl cmd 9 failed: Invalid argument</span><br><span class="line">device-mapper ioctl cmd 14 failed: No such device or address</span><br><span class="line">create: 3600a0b80001327d80000006d43621677 undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:0 sdb 8:16  undef ready  running</span><br><span class="line">  `- 3:0:0:0 sdf 8:80 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327510000009a436215ec undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:1 sdc 8:32 undef ready  running</span><br><span class="line">  `- 3:0:0:1 sdg 8:96 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327d800000070436216b3 undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:2 sdd 8:48 undef ready  running</span><br><span class="line">  `- 3:0:0:2 sdg 8:112 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327510000009b4362163e undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:3 sdd 8:64 undef ready  running</span><br><span class="line">  `- 3:0:0:3 sdg 8:128 undef ready  running</span><br></pre></td></tr></table></figure>
<ol>
<li><p>为防止设备映射器将 <code>/dev/sda</code> 与其多路径对应，请编辑 <code>/etc/multipath.conf</code> 文件的 blacklist 部分，使其包括该设备。虽然可以使用 <code>devnode</code> 类型将 <code>sda</code> 设备列入黑名单，但并不安全，因为重启时无法保证 <code>/dev/sda</code> 使用同一个名称。要将单独的设备列入黑名单，可以使用那个设备的 WWID 将其列入黑名单。</p>
<p>请注意：在 <code>multipath -v2</code> 命令的输出中，<code>/dev/sda</code> 设备的 WWID 是 SIBM-ESXSST336732LC____F3ET0EP0Q000072428BX1。要将这个设备列入黑名单，请在 <code>/etc/multipath.conf</code> 文件中添加以下内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">      wwid SIBM-ESXSST336732LC____F3ET0EP0Q000072428BX1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 <code>/etc/multipath.conf</code> 文件后，必须手动让 <code>multipathd</code> 守护进程重新载入该文件。以下命令可重新载入更新的 <code>/etc/multipath.conf</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service multipathd reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令删除多路径设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -f SIBM-ESXSST336732LC____F3ET0EP0Q000072428BX1</span><br></pre></td></tr></table></figure>
</li>
<li><p>要查看是否删除了该设备，可以输入 <code>multipath -ll</code> 命令显示当前的多路径配置。</p>
<p>要确定被列入黑名单的设备没有被重新添加回来，可输入 <code>multipath</code> 命令，如下所示。如果没有指定 <code>-v</code> 选项，则 <code>multipath</code> 命令默认详细等级为 <code>v2</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327d80000006d43621677 undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:0 sdb 8:16  undef ready  running</span><br><span class="line">  `- 3:0:0:0 sdf 8:80 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327510000009a436215ec undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:1 sdc 8:32 undef ready  running</span><br><span class="line">  `- 3:0:0:1 sdg 8:96 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327d800000070436216b3 undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:2 sdd 8:48 undef ready  running</span><br><span class="line">  `- 3:0:0:2 sdg 8:112 undef ready  running</span><br><span class="line"></span><br><span class="line">create: 3600a0b80001327510000009b4362163e undef WINSYS,SF2372</span><br><span class="line">size=12G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=undef</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=undef</span><br><span class="line">  |- 2:0:0:3 sdd 8:64 undef ready  running</span><br><span class="line">  `- 3:0:0:3 sdg 8:128 undef ready  running</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="配置存储设备"><a href="#配置存储设备" class="headerlink" title="配置存储设备"></a>配置存储设备</h2><p>默认情况下，DM Multipath 支持大多数常用的支持 DM Multipath 的储存阵列。若要了解默认配置值和支持的设备的相关信息，请运行下列指令中的任意一个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipathd show config</span><br><span class="line">multipath -t</span><br></pre></td></tr></table></figure>
<p>如果需要添加一个在默认情况下不支持的存储设备作为已知多路径设备，请编辑 <code>/etc/multipath.conf</code> 文件，并插入正确的设备信息。</p>
<p>例如：要添加有关 HP Open-V 系列的信息（其条目示例如下）。在这个示例中将设备设定在所有路径均失败后排队 1 分钟（或 12 次尝试，每 5 秒后重试一次）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">devices &#123;</span><br><span class="line">        device &#123;</span><br><span class="line">                vendor <span class="string">"HP"</span></span><br><span class="line">                product <span class="string">"OPEN-V"</span></span><br><span class="line">                no_path_retry 12</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在-INITRAMFS-文件系统中设置启动-MULTIPATH"><a href="#在-INITRAMFS-文件系统中设置启动-MULTIPATH" class="headerlink" title="在 INITRAMFS 文件系统中设置启动 MULTIPATH"></a>在 INITRAMFS 文件系统中设置启动 MULTIPATH</h2><p>可以在 <code>initramfs</code> 文件系统中设定启动 multipath。配置 multipath 后，可使用该 multipath 配置文件重建 <code>initramfs</code> 文件系统，方法是执行附带以下选项的 <code>dracut</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dracut --force --add multipath --include /etc/multipath</span><br></pre></td></tr></table></figure>
<p>如果在 <code>initramfs</code> 文件系统中运行 multipath，并更改 multipath 配置文件，则必须重建 <code>initramfs</code>文件系统方可使更改生效。</p>
<h1 id="第-4-章-DM-MULTIPATH-配置文件"><a href="#第-4-章-DM-MULTIPATH-配置文件" class="headerlink" title="第 4 章 DM MULTIPATH 配置文件"></a>第 4 章 DM MULTIPATH 配置文件</h1><p>DM Multipath 默认为大多数常用多路径提供配置值。此外，DM Multipath 还包括对那些本身支持 DM Multipath 的常见储存阵列的支持。如需了解有关默认配置值以及支持的设备的相关信息，请运行下列命令之一。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipathd show config</span><br><span class="line">multipath -t</span><br></pre></td></tr></table></figure>
<p>可以编辑 <code>/etc/multipath.conf</code> 配置文件覆盖 DM Multipath 的默认配置值。必要时可在配置文件中添加默认不支持的储存阵列。</p>
<p><strong>注意</strong></p>
<p>可以在 <code>initramfs</code> 文件系统中运行 set up multipathing。如果在 <code>initramfs</code> 文件系统中运行 multipath，并可以更改 multipath 配置文件，则必须重建 <code>initramfs</code> 文件系统以便使更改生效。</p>
<p>本章提供了解析和修改 <code>multipath.conf</code> 文件的详情。它包含以下小节：</p>
<ul>
<li>配置文件概述</li>
<li>配置文件黑名单</li>
<li>配置文件默认</li>
<li>配置文件多路径</li>
<li>配置文件设备</li>
</ul>
<p>在 multipath 配置文件中，只需指定您的配置需要的部分，或者是您想要修改的默认值即可。如果文件中有和您的环境不相关的部分，或者是不需要覆盖的默认值，可以将它们注释出来，因为它们位于初始文件中。</p>
<p>配置文件使用正则表达式描述语法。</p>
<p>关于配置文件的详细信息，请参阅 <code>multipath.conf</code>(5) 手册页。</p>
<h2 id="配置文件概述"><a href="#配置文件概述" class="headerlink" title="配置文件概述"></a>配置文件概述</h2><p>多路径配置文件可分为以下几个部分：</p>
<ul>
<li><p>blacklist</p>
<p>不被视为多路径的具体设备列表。</p>
</li>
<li><p>blacklist_exceptions</p>
<p>根据 blacklist 部分中的参数列出不在黑名单中的多路径设备。</p>
</li>
<li><p>defaults</p>
<p>DM Multipath 的常规默认设置。</p>
</li>
<li><p>multipaths</p>
<p>各个独立多路径设备的特性设置。这些数值覆盖了在配置文件的 <code>defaults</code> 和 <code>devices</code> 部分中指定的数值。</p>
</li>
<li><p>devices</p>
<p>各个存储控制器的设置。这些数值覆盖了在配置文件的 <code>defaults</code> 部分指定的数值。如果要使用不是默认支持的存储阵列，则可能需要为您的阵列创建 <code>devices</code> 子部分。</p>
</li>
</ul>
<p>系统决定多路径设备的属性时，会先检查多路径设置，然后检查设备设置，最后才检查多路径系统默认设置。</p>
<h2 id="配置文件黑名单"><a href="#配置文件黑名单" class="headerlink" title="配置文件黑名单"></a>配置文件黑名单</h2><p>多路径配置文件的 <code>blacklist</code> 部分指定在系统配置多路径设备时不能使用的设备。黑名单中的设备将无法分组到多路径设备中。</p>
<p>在旧版 Red Hat Enterprise Linux 中，multipath 总是尝试为每个没有明确列入黑名单的路径创建多路径设备。但在 Red Hat Enterprise Linux 6 中，如果 <code>find_multipaths</code> 配置参数被设定为 <code>yes</code> ， multipath 将只在满足以下三个条件之一时创建设备：</p>
<ul>
<li><p>至少有两个使用同一 WWID 的路径没有被 列入黑名单。</p>
</li>
<li><p>用户可使用 <code>multipath</code> 命令手动强制创建该设备。</p>
</li>
<li><p>有与之前创建的多路径设备相同 WWID 的路径（即使那个多路径设备目前不存在）。无论何时，创建多路径设备后，多路径会记住该设备的 WWID，以便在它看到有使用那个 WWID 的路径时即自动再次创建该设备。这可允许您让多路径自动选择正确的路径以便创建多路径设备而无需编辑多路径黑名单。</p>
<p>如果您之前创建了一个 multipath 设备而没有使用 <code>find_multipaths</code> 参数，然后您随后将该参数设定为 <code>yes</code>，您需要删除所有设备的 WWID，您不想从 <code>/etc/multipath/wwids</code> 文件中将其创建为 multipath 设备。以下显示示例 <code>/etc/multipath/wwids</code> 文件。WWID 由斜线（/）括起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Multipath wwids, Version : 1.0</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> This file is automatically maintained by multipath and multipathd.</span></span><br><span class="line"><span class="comment"># You should not need to edit this file in normal circumstances.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Valid WWIDs:</span></span><br><span class="line">/3600d0230000000000e13955cc3757802/</span><br><span class="line">/3600d0230000000000e13955cc3757801/</span><br><span class="line">/3600d0230000000000e13955cc3757800/</span><br><span class="line">/3600d02300069c9ce09d41c31f29d4c00/</span><br><span class="line">/SWINSYS  SF2372         0E13955CC3757802/</span><br><span class="line">/3600d0230000000000e13955cc3757803/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如将 <code>find_multipaths</code> 参数设定为 <code>yes</code>，则您只需要将那些您不想使其具有多路径功能的多路径设备列入黑名单，通常不需要将设备列入黑名单。</p>
<p>如果您需要将设备列入黑名单，您可以根据以下条件进行选择：</p>
<ul>
<li>根据 WWID，如<a href="#4.2.1">第 4.2.1 节 “根据 WWID 将设备列入黑名单”</a>所述</li>
<li>根据设备名称，如 <a href="#4.2.2">第 4.2.2 节 “根据设备名称将设备列入黑名单”</a> 所述</li>
<li>根据设备类型，如 <a href="#4.2.3">第 4.2.3 节 “根据设备类型将其加入黑名单”</a>所述</li>
</ul>
<p>默认情况下，各种设备类型都是列在黑名单中的，即使您将配置文件的初始黑名单部分注释出来也是如此。<a href="#4.2.2">第 4.2.2 节 “根据设备名称将设备列入黑名单”</a>。</p>
<p><span id="4.2.1"></span></p>
<h3 id="根据-WWID-将设备列入黑名单"><a href="#根据-WWID-将设备列入黑名单" class="headerlink" title="根据 WWID 将设备列入黑名单"></a>根据 WWID 将设备列入黑名单</h3><p>您可根据全球识别符将单独的设备列入黑名单，即在配置文件的 <code>blacklist</code> 部分加入 <code>wwid</code> 条目。</p>
<p>以下示例显示了在配置文件中可将 WWID 为 26353900f02796769 的设备列入黑名单的行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">       wwid 26353900f02796769</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="4.2.2"></span></p>
<h3 id="根据设备名称将设备列入黑名单"><a href="#根据设备名称将设备列入黑名单" class="headerlink" title="根据设备名称将设备列入黑名单"></a>根据设备名称将设备列入黑名单</h3><p>您可以根据设备名称将设备类型列入黑名单，以便在配置文件 <code>blacklist</code> 部分的 <code>devnode</code> 条目中指定不要将它们分组到多路径设备中。</p>
<p>以下实例显示该配置文件中的可以将所有 SCSI 设备放入黑名单的行，因为它将所有 sd* 设备放入黑名单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">       devnode <span class="string">"^sd[a-z]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用配置文件 <code>blacklist</code> 部分的 <code>devnode</code> 条目指定要列入黑名单的每个设备，而不是指定具体类型的所有设备，我们不推荐使用后一种情况。除非根据 <code>udev</code> 规则的静态映射，我们无法保证在重启后每个设备的名称是一样的。例如：重启后，某个设备的名称可能从 <code>/dev/sda</code> 变为 <code>/dev/sdb</code>。</p>
<p>默认情况下，以下 <code>devnode</code> 条目将会被列入默认黑名单中；因为这些条目而被列入黑名单的设备通常不支持 DM Multipath。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">       devnode <span class="string">"^(ram|raw|loop|fd|md|dm-|sr|scd|st)[0-9]*"</span></span><br><span class="line">       devnode <span class="string">"^(td|ha)d[a-z]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="4.2.3"></span></p>
<h3 id="根据设备类型将其加入黑名单"><a href="#根据设备类型将其加入黑名单" class="headerlink" title="根据设备类型将其加入黑名单"></a>根据设备类型将其加入黑名单</h3><p>您可以在配置文件的 <code>blacklist</code> 部分与 <code>device</code> 一同指定具0体设备类型。以下实例将所有 IBM DS4200 和 HP 设备放入黑名单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">       device &#123;</span><br><span class="line">               vendor  <span class="string">"IBM"</span></span><br><span class="line">               product <span class="string">"3S42"</span>       <span class="comment">#DS4200 Product 10</span></span><br><span class="line">       &#125;</span><br><span class="line">       device &#123;</span><br><span class="line">               vendor  <span class="string">"HP"</span></span><br><span class="line">               product <span class="string">"*"</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="根据设备类型将其加入黑名单"></span></p>
<h3 id="黑名单之外的设备"><a href="#黑名单之外的设备" class="headerlink" title="黑名单之外的设备"></a>黑名单之外的设备</h3><p>您可使用配置文件的 <code>blacklist_exceptions</code> 部分为被默认加入黑名单的设备启用多路径。</p>
<p>例如：如果您有大量设备，但只有一个需要多路径（WWID 为 3600d0230000000000e13955cc3757803），您不需要将您想要使用多路径的设备之外的每个设备单独加入黑名单，您只需要将所有设备都加入黑名单，然后在 <code>/etc/multipath.conf</code> 文件中添加以下行以便只允许您想要使用多路径的设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blacklist &#123;</span><br><span class="line">        wwid <span class="string">"*"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blacklist_exceptions &#123;</span><br><span class="line">        wwid <span class="string">"3600d0230000000000e13955cc3757803"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在配置文件的 <code>blacklist_exceptions</code> 指定设备时，您必须以指定黑名单的相同方法来指定例外情况。例如：在 <code>devnode</code> 黑名单条目中指定的设备无法使用 WWID 将其指定为例外情况，即使列入黑名单的设备和该 WWID 关联也不行。同样，<code>devnode</code> 例外也只适用于 <code>devnode</code> 条目，而 <code>device</code> 例外只适用于 device 条目。</p>
<h2 id="配置文件默认设置"><a href="#配置文件默认设置" class="headerlink" title="配置文件默认设置"></a>配置文件默认设置</h2><p><code>/etc/multipath.conf</code> 配置文件包括 <code>defaults</code> 部分，在该部分中将 <code>user_friendly_names</code> 参数设为 <code>yes</code>，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults &#123;</span><br><span class="line">        user_friendly_names yes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可覆盖 <code>user_friendly_names</code> 参数的默认值。</p>
<p>该配置文件包括配置默认模板。这部分要被注释出来，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#defaults &#123;</span></span><br><span class="line"><span class="comment">#       polling_interval        10</span></span><br><span class="line"><span class="comment">#       path_selector           "round-robin 0"</span></span><br><span class="line"><span class="comment">#       path_grouping_policy    multibus</span></span><br><span class="line"><span class="comment">#       uid_attribute           ID_SERIAL</span></span><br><span class="line"><span class="comment">#       prio                    alua</span></span><br><span class="line"><span class="comment">#       path_checker            readsector0</span></span><br><span class="line"><span class="comment">#       rr_min_io               100</span></span><br><span class="line"><span class="comment">#       max_fds                 8192</span></span><br><span class="line"><span class="comment">#       rr_weight               priorities</span></span><br><span class="line"><span class="comment">#       failback                immediate</span></span><br><span class="line"><span class="comment">#       no_path_retry           fail</span></span><br><span class="line"><span class="comment">#       user_friendly_names     yes</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>
<p>要覆盖任意配置参数的默认值，您可将这个模板中相关的行复制到 <code>defaults</code> 部分并取消其注释。例如：要覆盖 <code>path_grouping_policy</code> 参数以便用 <code>multibus</code> 覆盖默认的 <code>failover</code>，请将模板中正确的行复制到配置文件的 <code>defaults</code> 部分并取消对它的注释，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">defaults &#123;</span><br><span class="line">        user_friendly_names     yes</span><br><span class="line">        path_grouping_policy    multibus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表 4.1 “多路径配置默认设置”描述了 <code>multipath.conf</code> 配置文件的 <code>defaults</code> 部分中设置的属性。DM Multipath 会使用这些值，除非该属性被 <code>multipath.conf</code> 文件的 <code>devices</code> 和 <code>multipaths</code> 部分所指定的属性覆盖。</p>
<p>⁠</p>
<p><strong>表 4.1. 多路径配置默认设置</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>polling_interval</code></td>
<td>以秒为单位指定两次路径检查之间的间隔。对正常工作的路径，两次检查间的间隔会逐渐增加到 <code>polling_interval</code> 的四倍。默认值为 5。</td>
</tr>
<tr>
<td><code>multipath_dir</code></td>
<td>保存动态共享对象的目录。默认值依系统而定，通常为 <code>/lib/multipath</code>。</td>
</tr>
<tr>
<td><code>find_multipaths</code></td>
<td>定义设定多路径设备的模式。如果将这个参数设定为 <code>yes</code>，那么多路径将不会尝试为每个不在黑名单中的路径创建设备。反之，多路径将只在满足以下三给条件之一时创建设备：- 至少有两个路径没有使用同一 WWID 列入黑名单。- 用户通过使用 <code>multipath</code> 命令指定设备强制创建该设备。- 路径拥有与之前创建的多路径设备相同的 WWID。无论何时使用 <code>find_multipaths</code> 组件创建多路径设备后，多路径都会记住该设备的 WWID 以便在再次看到使用那个 WWID 的路径时自动创建设备。这可让您自动选择正确的所路径创建多路径设备而无需编辑多路径黑名单。如果之前您在没有设定 <code>find_multipaths</code> 参数的情况下创建了多路径设备，默认值为 <code>no</code>。默认 <code>multipath.conf</code> 文件由 <code>mpathconf</code> 命令生成，但从 Red Hat Enterprise Linux 7 开始才启用 <code>find_multipaths</code>。</td>
</tr>
<tr>
<td><code>reassign_maps</code></td>
<td>启用 device-mapper 映射的创新分配。使用这个选项后，<code>multipathd</code> 守护进程将重新映射现有 device-mapper 映射，使其永远指向多路径设备，而不是基础块设备。可能的值包括 <code>yes</code> 和 <code>no</code>。默认值为 <code>yes</code>。</td>
</tr>
<tr>
<td><code>verbosity</code></td>
<td>默认详情。数值越高则详细程度越高。有效等级在 0 - 6 之间。默认值为 <code>2</code>。</td>
</tr>
<tr>
<td><code>path_selector</code></td>
<td>指定用来决定下一个 I/O 操作所使用路径的默认算法。可能的值包括：<code>round-robin 0</code>：在路径组中循环每个路径，向每个路径发送同样数量的 I/O。<code>queue-length 0</code>：将下一组 I/O 发送到具有最少未处理 I/O 请求的路径。<code>service-time 0</code>：将下一组 I/O 发送到具有最短预计服务时间的路径，这是由未处理 I/O 的总量除以每个路径的相对流量决定的。默认值为 <code>round-robin 0</code>。</td>
</tr>
<tr>
<td><code>path_grouping_policy</code></td>
<td>指定用于未指定路径的默认路径分组策略，可能的值包括：<code>failover</code>：每个优先组群有一个路径。<code>multibus</code>：所有有效路径在一个优先组群中。<code>group_by_serial</code>：每个检测到的系列号有一个优先组群。<code>group_by_prio</code>：每个优先组群有一个路径优先值。优先权根据指定为 global、per-controller 或者 per-multipath 选项的调用程序决定。<code>group_by_node_name</code>：每个目标节点名有一个优先组。目标节点名保存在 <code>/sys/class/fc_transport/target*/node_name</code> 文件中。默认值为 <code>failover</code>。</td>
</tr>
<tr>
<td><code>prio</code></td>
<td>指定要获得路径优先值所需调用的默认程序及参数。例如：SPC-3 中的 ALUA 字节提供了一个可改变的 <code>prio</code> 值。可能的值包括：<code>const</code>：为所有路径设定优先权 1。<code>emc</code>：为 EMC 阵列生成路径优先权。<code>alua</code>：根据 SCSI-3 ALUA 设置生成路径有限级。从 Red Hat Enterprise Linux 7.3 开始，如果在设备配置中指定 <code>prio &quot;alua exclusive_pref_bit&quot;</code>，多路径将生成包含只使用 <code>pref</code> 字节集的路径组，并为该组设定最高优先级。<code>ontap</code>：为 NetApp 阵列生成路径优先权。<code>rdac</code>：为 LSI/Engenio RDAC 控制程序生成路径优先权。<code>hp_sw</code>：为 Compaq/HP 控制程序在激活/等待模式中生成路径优先权。<code>hds</code>：为 Hitachi HDS Modular 存储阵列生成路径优先权。默认值为 <code>const</code>。</td>
</tr>
<tr>
<td><code>features</code></td>
<td>多路径设备的默认额外功能，使用以下格式：”<em>number_of_features_plus_arguments</em> <em>feature1</em> …”。<code>features</code> 可能的值包括：<code>queue_if_no_path</code>，与将 <code>no_path_retry</code> 设置为 <code>queue</code> 相同。<code>retain_attached_hw_handler</code>：若此参数值被设为 <code>yes</code>，并且 SCSI 层已经为路径设备添加了硬件控制程序，multipath 将不会强制设备使用 <code>multipath.conf</code> 文件指定的 <code>hardware_handler</code>。若 SCSI 层没有添加硬件控制程序，multipath 仍然会使用已配置的硬件控制程序。默认值为 <code>no</code>。<code>pg_init_retries *n*</code>：路径组初始化重试，失败前最多重试 <em>n</em> 次，1 &lt;= <em>n</em> &lt;= 50。<code>pg_init_delay_msecs *n*</code>：在路径组初始化重试的间隔，等待 <em>n</em> 毫秒，0 &lt;= <em>n</em> &lt;= 60000。</td>
</tr>
<tr>
<td><code>path_checker</code></td>
<td>指定用于决定路径状态的默认方法，可能的值包括：<code>readsector0</code>：读取该设备的第一扇区。<code>tur</code>：在设备中执行 <code>TEST UNIT READY</code> 命令。<code>emc_clariion</code>：查询 EMC Clariion 具体 EVPD 页面 0xCO 以便决定路径。<code>hp_sw</code>：为使用 Active/Standby 固件的 HP 存储阵列检查路径状态。<code>rdac</code>：检查 LSI/Engenio RDAC 储存控制器的路径状态。<code>directio</code>：使用直接 I/O 读取第一个扇区。默认值为 <code>directio</code>。</td>
</tr>
<tr>
<td><code>failback</code></td>
<td>管理路径组群出错切换。<code>immediate</code> 值指定立即恢复到包含活跃路径的最高级别路径组群。<code>manual</code> 值指定不需要立即恢复，只有在操作者干预的情况下会发生恢复。<code>followover</code> 值指定当路径组的第一个路径成为活跃路径时应执行自动恢复。这可让节点在另一个节点请求故障修复时不会自动恢复。大于 0 的数字值指定推迟出错切换，以秒表示。默认值为 <code>manual</code>。</td>
</tr>
<tr>
<td><code>rr_min_io</code></td>
<td>指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行内核为 2.6.31 之前的系统。使用新版本的系统应使用 <code>rr_min_io_rq</code>。默认值为 1000。</td>
</tr>
<tr>
<td><code>rr_min_io_rq</code></td>
<td>使用 request-based device-mapper-multipath 指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行当前内核的系统。在使用内核 2.6.31 版本之前的系统应使用 <code>rr_min_io</code>。默认值为 1。</td>
</tr>
<tr>
<td><code>rr_weight</code></td>
<td>如果将其设为 <code>priorities</code>，就不会在调用 <code>selector</code> 选择下一个路径前向路径发送 <code>rr_min_io</code> 请求，而是由 <code>rr_min_io</code> 乘以路径优先权决定发送的请求数，即由 <code>prio</code> 功能决定。如果将其设定为 <code>uniform</code>，则所有路径都有相同的加权。默认值为 <code>uniform</code>。</td>
</tr>
<tr>
<td><code>no_path_retry</code></td>
<td>此属性的数字值指定了系统在禁用队列前，应该尝试使用失败路径的次数。值为 <code>fail</code> 意味着立即失败，无需排队。值为 <code>queue</code> 意味着路径固定前不会停止排队。默认值为 0。</td>
</tr>
<tr>
<td><code>user_friendly_names</code></td>
<td>如果将其设为 <code>yes</code>，即指定该系统应该使用文件 <code>/etc/multipath/bindings</code> 为该多路径分配一个持久且唯一的别名，格式为 <code>mpath</code><em>n</em>。如果设定为 <code>no</code>，即指定该系统应使用 WWID 作为该多路径的别名。在这两种情况下，您在这里指定的数值将被您在配置文件 <code>multipaths</code> 部分指定的具体设备别名覆盖。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>queue_without_daemon</code></td>
<td>如果将其设为 <code>no</code>，则 <code>multipathd</code> 守护程序将会在其关闭时禁用所有设备队列。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>flush_on_last_del</code></td>
<td>如果将其设为 <code>yes</code>，那么 <code>multipathd</code> 守护程序将会在设备的最后一条路径被删除时禁用队列。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>max_fds</code></td>
<td>设定 multipath 可以打开的文件提示符以及 <code>multipathd</code> 守护进程的最大值。这与 <code>ulimit -n</code> 命令效果一致。从 Red Hat Enterprise Linux 6.3 开始，默认值为 <code>max</code>，该值将该系统限制到 <code>/proc/sys/fs/nr_open</code>。对其较早的版本，如果没有设定这个值，则使用调用进程作为打开文件提示符的最大值，通常为 1024。安全起见，如果该数值大于 1024，应将其设定为路径最大值+32。</td>
</tr>
<tr>
<td><code>checker_timeout</code></td>
<td>路径检查器和排序器执行带显式超时的 SCSI 命令的超时时间，以秒为单位。默认值为 <code>sys/block/sd*x*/device/timeout</code> 中指定的值。</td>
</tr>
<tr>
<td><code>fast_io_fail_tmo</code></td>
<td>在 FC 远程端口发现问题后，无法在那个远程端口设备中执行 I/O 前 SCSI 层要等待的时间。默认值应小于 <code>dev_loss_tmo</code> 值。将其设定为 <code>off</code> 则会禁用超时。默认值由该操作系统决定。</td>
</tr>
<tr>
<td><code>dev_loss_tmo</code></td>
<td>在 FC 远程端口发现问题后，到从该系统中删除它之前 SCSI 层要等待的时间。将其设定为无限，则会将其设定为 2147483647 秒，或者 68 年。默认值由该操作系统决定。</td>
</tr>
<tr>
<td><code>hw_string_match</code></td>
<td><code>multipath.conf</code> 文件 <code>devices</code> 部分中的每个设备配置都将会创建自己的设备配置，或是修改某个内置设备配置。如果 <code>hw_string_match</code> 被设为 <code>yes</code>，那么如果某用户设备配置中的供应商、产品和修订字符串与内置设备配置中的字符串完全匹配，则该用户配置选项就会修改内置配置。否则该用户设备配置会被视为新配置。如果 <code>hw_string_match</code> 被设为 <code>no</code>，那么就会使用正则表达式匹配，而不使用字符串匹配。默认情况下会将 <code>hw_string_match</code> 设定为 <code>no</code>。</td>
</tr>
<tr>
<td><code>retain_attached_hw_handler</code></td>
<td>如果此参数被设为 <code>yes</code>，并且 SCSI 层已经为路径设备附加了硬件处理程序，那么 multipath 将不会强制设备使用 <code>multipath.conf</code> 文件指定的 <code>hardware_handler</code>。如果 SCSI 层未附加硬件处理程序，multipath 将会继续使用其配置的硬件处理程序。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>detect_prio</code></td>
<td>如果将此参数设定为 <code>yes</code>，multipath 将会首先检查该设备是否支持 ALUA。如果支持，则自动为该设备分配 <code>alua</code> 排序器；如果不支持，则按惯例确定排序器。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>uid_attribute</code></td>
<td>提供唯一路径标识符。默认值为 <code>ID_SERIAL</code>。</td>
</tr>
<tr>
<td><code>force_sync</code></td>
<td>（从 Red Hat Enterprise Linux 7.1 开始）如果将其设定为“yes”，则会阻止路径检查程序在异步（async）模式下运行。这意味着每次只能运行一个检查程序。这对同时运行很多 <code>multipathd</code> 检查程序而造成明显 CPU 负担过重时会有帮助。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>delay_watch_checks</code></td>
<td>（从 Red Hat Enterprise Linux Release 7.2 开始）如果将其设定为大于 0 的值，<code>multipathd</code> 守护进程将监视最近有效的路径，并执行指定数量的检查。如果在监视期间这些路径再次变为无法使用，则不会在这些路径下一次可用时就使用它们，直到连续检查使用 <code>delay_wait_checks</code> 指定的次数后它们都可用为止。 这样可防止将那些可能不太可靠的路径在上线后立即投入使用。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>delay_wait_checks</code></td>
<td>（从 Red Hat Enterprise Linux 7.2 开始）如果将其设定为大于 0 的值，则最近重新上线的设备在由 <code>delay_watch_checks</code> 指定的检查次数内再次无法使用后，那么它下一次上线后就不会被标记并延迟，并在经过使用 <code>delay_watch_checks</code> 指定的检查次数后方可使用。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>ignore_new_boot_devs</code></td>
<td>（从 Red Hat Enterprise Linux 7.2 开始）如果设定为 <code>yes</code>，在引导初期该节点仍处于 <code>initramfs</code> 文件系统中时，multipath 不会创建任何 WWID 属于 <code>/etc/multipath/wwids</code> 的 <code>initramfs copy</code> 中的设备。当 multipath 另外尝试在手册出现时未使用 <code>udev</code> 规则声明的设备中进行设置时，这个功能可用于在安装过程中引导。可将这个参数设定为 <code>yes</code> 或者 <code>no</code>。如果未设置，则默认将其设定为 <code>no</code>。</td>
</tr>
<tr>
<td><code>retrigger_tries</code>, <code>retrigger_delay</code></td>
<td>（从 Red Hat Enterprise Linux 7.2 开始）如果 <code>udev</code> 无法完成原始命令让多路径无法使用该设备，则联合使用 <code>retrigger_tries</code> 和 <code>retrigger_delay</code> 参数，以便 <code>multipathd</code> 命令可以重新激发 uevent。<code>retrigger_tries</code> 参数为没有完全设置的设备设定多路径尝试重新触发 <code>uevent</code> 的次数。<code>retrigger_delay</code> 参数设定两次重试之间的秒数。这两个选项均接受大于或等于 0 的数字。将 <code>retrigger_delay</code> 设定为 0 就是禁用重试。将 <code>retrigger_delay</code> 参数设定为 0 可导致在路径检查器的下一次检查中重新启动 <code>uevent</code>。如果没有设定 <code>retrigger_tries</code> 参数，则会使用默认值 3。如果没有设定 <code>retrigger_delay</code> 参数，则会使用默认值 10。</td>
</tr>
<tr>
<td><code>new_bindings_in_boot</code></td>
<td>（从 Red Hat Enterprise Linux Release 7.2 开始）使用 <code>new_bindings_in_boot</code> 参数在 <code>initramfs</code> 文件系统中保持已被常规文件系统中绑定文件耗尽的 <code>user_friendly_name</code>。这样会造成问题，因为只有重建 <code>initramfs</code> 文件系统时才会将 <code>initramfs</code> 文件系统中的 <code>user_friendly_names</code> 绑定与常规文件系统中的绑定同步。当将此参数设定为 <code>no</code> 后，多路经不会在 <code>initramfs</code> 文件系统中创建任何新绑定。如果某个设备中原来没有在 <code>/etc/multipath/bindings</code> 的 <code>initramfs</code>副本中有任何绑定，多路经会使用其 WWID 作为别名，而不是为其分配 <code>user_friendly_name</code>。之后在引导后，该节点会挂载至常规文件系统，多路径会为该设备分配 <code>user_friendly_name</code>。可将该参数设定为 <code>yes</code>或者 <code>no</code>。如果未设定，则默认使用 <code>no</code>。</td>
</tr>
<tr>
<td><code>config_dir</code></td>
<td>（从 Red Hat Enterprise Linux Release 7.2 开始）如果设定为 <code>&quot;&quot;</code> 以外的内容，多路径会按字母顺序搜索这些路径，查找以 “.conf” 结尾的文件，并从中读取配置信息，就如同该信息位于 <code>/etc/multipath.conf</code> 文件中一样。这样您就会在具体机器的配置文件以外有一个主配置文件。<code>config_dir</code> 参数必须为 <code>&quot;&quot;</code> 或者完全限定目录名。只能在主 <code>/etc/multipath.conf</code> 文件中设定这个参数，不能在由 <code>config_dir</code>文件自己指定的某个文件中设定这个参数。默认值为 <code>/etc/multipath/conf.d</code>。</td>
</tr>
<tr>
<td><code>deferred_remove</code></td>
<td>如果设定为 <code>yes</code>，则在删除最后一个路径设备时，multipathd 将会执行延期删除，而不是常规删除。这样就会保证如果执行常规删除且操作失败时某个多路径设备正在使用中，该设备会在最后一个用户关闭该设备时自动被删除。</td>
</tr>
<tr>
<td><code>log_checker_err</code></td>
<td>如果设定为 <code>once</code>，multipathd 会采用详细等级 2 记录第一个路径检查器错误。之后的所有错误都要在该设备恢复后采用详细等级 3 记录。如果设定为 <code>always</code>，multipathd 会一直使用详细等级 2 记录路径检查器错误。默认值为 <code>always</code>。</td>
</tr>
<tr>
<td><code>skip_kpartx</code></td>
<td>如果设定为 <code>yes</code>，<code>kpartx</code> 不会在该设备中自动创建分区。这样即使该设备有分区表，也可以允许用户在不创建分区的情况下创建多路径设备。这个选项的默认值为 <code>no</code>。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="多路径设备配置属性"><a href="#多路径设备配置属性" class="headerlink" title="多路径设备配置属性"></a>多路径设备配置属性</h2><p>表 4.2 “多路径属性”显示在 <code>multipath.conf</code> 配置文件 <code>multipaths</code> 部分中可为每个特定多路径设备设置的属性。这些属性只适用于一个指定的 multipath。这些默认属性可供 DM Multipath 使用，并且能覆盖 <code>multipath.conf</code> 文件中 <code>defaults</code> 和 <code>devices</code> 部分设置的属性。</p>
<p>⁠</p>
<p><strong>表 4.2. 多路径属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>wwid</code></td>
<td>指定 <code>multipath</code> 属性采用的多路径设备的 WWID。这个参数在 <code>multipath.conf</code> 文件的这个部分是必须的。</td>
</tr>
<tr>
<td><code>alias</code></td>
<td>指定使用 <code>multipath</code> 属性的多路径设备的符号名称。如果您使用的是 <code>user_friendly_names</code>，请必要将其设定为 <code>mpath*n*</code>，这样可能会与自动分配的用户友好名称冲突，进而给出不正确的设备节点名称。</td>
</tr>
<tr>
<td><code>path_grouping_policy</code></td>
<td>指定用于未指定路径的默认路径分组策略，可能的值包括：<code>failover</code> = 每个优先组群有一个路径<code>multibus</code> = 所有有效路径在一个优先组群中<code>group_by_serial</code> = 每个检测到的系列号有一个优先组群<code>group_by_prio</code> = 每个路径优先值有一个优先组群<code>group_by_node_name</code> = 每个目标节点名有一个优先组群</td>
</tr>
<tr>
<td><code>path_selector</code></td>
<td>指定用来决定下一个 I/O 操作所使用路径的默认算法。可能的值包括：<code>round-robin 0</code>：在路径组中循环每个路径，向每个路径发送同样数量的 I/O。<code>queue-length 0</code>：将下一组 I/O 发送到具有最少未处理 I/O 请求的路径。<code>service-time 0</code>：将下一组 I/O 发送到具有最短预计服务时间的路径，这是由未处理 I/O 的总量除以每个路径的相对流量决定的。</td>
</tr>
<tr>
<td><code>failback</code></td>
<td>管理路径组群出错切换。<code>immediate</code> 值指定立即恢复到包含活跃路径的最高级别路径组群。<code>manual</code> 值指定不需要立即恢复，只有在操作者干预的情况下会发生恢复。<code>followover</code> 值指定当路径组的第一个路径成为活跃路径时应执行自动恢复。这可让节点在另一个节点请求故障修复时不会自动恢复。大于 0 的数字值指定推迟出错切换，以秒表示。</td>
</tr>
<tr>
<td><code>prio</code></td>
<td>指定要获得路径优先值所需调用的默认程序及参数。例如：SPC-3 中的 ALUA 字节提供了一个可改变的 <code>prio</code> 值。可能的值包括：<code>const</code>：为所有路径设定优先权 1。<code>emc</code>：为 EMC 阵列生成路径优先权。<code>alua</code>：根据 SCSI-3 ALUA 设置生成路径有限级。从 Red Hat Enterprise Linux 7.3 开始，如果在设备配置中指定 <code>prio &quot;alua exclusive_pref_bit&quot;</code>，多路径将生成包含只使用 <code>pref</code> 字节集的路径组，并为该组设定最高优先级。<code>ontap</code>：为 NetApp 阵列生成路径优先权。<code>rdac</code>：为 LSI/Engenio RDAC 控制程序生成路径优先权。<code>hp_sw</code>：为 Compaq/HP 控制程序在激活/等待模式中生成路径优先权。<code>hds</code>：为 Hitachi HDS Modular 存储阵列生成路径优先权。</td>
</tr>
<tr>
<td><code>features</code></td>
<td>多路径设备的默认额外功能，使用以下格式：”<em>number_of_features_plus_arguments</em> <em>feature1</em> …”。<code>features</code> 可能的值包括：<code>queue_if_no_path</code>，与将 <code>no_path_retry</code> 设置为 <code>queue</code> 相同。<code>retain_attached_hw_handler</code>：若此参数值被设为 <code>yes</code>，并且 SCSI 层已经为路径设备添加了硬件控制程序，multipath 将不会强制设备使用 <code>multipath.conf</code> 文件指定的 <code>hardware_handler</code>。若 SCSI 层没有添加硬件控制程序，multipath 仍然会使用已配置的硬件控制程序。默认值为 <code>no</code>。<code>pg_init_retries *n*</code>：路径组初始化重试，失败前最多重试 <em>n</em> 次，1 &lt;= <em>n</em> &lt;= 50。<code>pg_init_delay_msecs *n*</code>：在路径组初始化重试的间隔，等待 <em>n</em> 毫秒，0 &lt;= <em>n</em> &lt;= 60000。</td>
</tr>
<tr>
<td><code>no_path_retry</code></td>
<td>此属性的数字值指定了系统在禁用队列前，应该尝试使用失败路径的次数。值为 <code>fail</code> 意味着立即失败，无需排队。值为 <code>queue</code> 意味着路径固定前不会停止排队。</td>
</tr>
<tr>
<td><code>rr_min_io</code></td>
<td>指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行内核为 2.6.31 之前的系统。使用新版本的系统应使用 <code>rr_min_io_rq</code>。默认值为 1000。</td>
</tr>
<tr>
<td><code>rr_min_io_rq</code></td>
<td>使用 request-based device-mapper-multipath 指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行当前内核的系统。在使用内核 2.6.31 版本之前的系统应使用 <code>rr_min_io</code>。默认值为 1。</td>
</tr>
<tr>
<td><code>rr_weight</code></td>
<td>如果将其设为 <code>priorities</code>，就不会在调用 <code>selector</code> 选择下一个路径前向路径发送 <code>rr_min_io</code> 请求，而是由 <code>rr_min_io</code> 乘以路径优先权决定发送的请求数，即由 <code>prio</code> 功能决定。如果将其设定为 <code>uniform</code>，则所有路径都有相同的加权。</td>
</tr>
<tr>
<td><code>flush_on_last_del</code></td>
<td>如果将其设为 <code>yes</code>，那么当设备的最后一条路径被删除时，multipath 将会禁用队列。</td>
</tr>
<tr>
<td><code>user_friendly_names</code></td>
<td>如果将其设为 <code>yes</code>，即指定该系统应该使用文件 <code>/etc/multipath/bindings</code> 为该多路径分配一个持久且唯一的别名，格式为 <code>mpath</code><em>n</em>。如果设定为 <code>no</code>，即指定该系统应使用 WWID 作为该多路径的别名。在这两种情况下，您在这里指定的数值将被您在配置文件 <code>multipaths</code> 部分指定的具体设备别名覆盖。</td>
</tr>
<tr>
<td><code>delay_watch_checks</code></td>
<td>（从 Red Hat Enterprise Linux Release 7.2 开始）如果将其设定为大于 0 的值，<code>multipathd</code> 守护进程将监视最近有效的路径，并执行指定数量的检查。如果在监视期间这些路径再次变为无法使用，则不会在这些路径下一次可用时就使用它们，直到连续检查使用 <code>delay_wait_checks</code> 指定的次数后它们都可用为止。 这样可防止将那些可能不太可靠的路径在上线后立即投入使用。</td>
</tr>
<tr>
<td><code>delay_wait_checks</code></td>
<td>（从 Red Hat Enterprise Linux 7.2 开始）如果将其设定为大于 0 的值，则最近重新上线的设备在由 <code>delay_watch_checks</code> 指定的检查次数内再次无法使用后，那么它下一次上线后就不会被标记并延迟，并在经过使用 <code>delay_watch_checks</code> 指定的检查次数后方可使用。</td>
</tr>
<tr>
<td><code>deferred_remove</code></td>
<td>如果设定为 <code>yes</code>，则在删除最后一个路径设备时，multipathd 将会执行延期删除，而不是常规删除。这样就会保证如果执行常规删除且操作失败时某个多路径设备正在使用中，该设备会在最后一个用户关闭该设备时自动被删除。</td>
</tr>
<tr>
<td><code>skip_kpartx</code></td>
<td>如果设定为 <code>yes</code>，<code>kpartx</code> 不会在该设备中自动创建分区。这样即使该设备有分区表，也可以允许用户在不创建分区的情况下创建多路径设备。</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例显示在配置文件中为两个特定多路径设备指定的多路径属性。第一个设备的 WWID 为 <code>3600508b4000156d70001200000b0000</code>，符号名称为 <code>yellow</code>。</p>
<p>示例中第二个多路径设备的 WWID 为 <code>1DEC_____321816758474</code>，符号名称为 <code>red</code>。在这个示例中，<code>rr_weight</code> 属性被设为 <code>priorities</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipaths &#123;</span><br><span class="line">       multipath &#123;</span><br><span class="line">              wwid                  3600508b4000156d70001200000b0000</span><br><span class="line">              <span class="built_in">alias</span>                 yellow</span><br><span class="line">              path_grouping_policy  multibus</span><br><span class="line">              path_selector         <span class="string">"round-robin 0"</span></span><br><span class="line">              failback              manual</span><br><span class="line">              rr_weight             priorities</span><br><span class="line">              no_path_retry         5</span><br><span class="line">       &#125;</span><br><span class="line">       multipath &#123;</span><br><span class="line">              wwid                  1DEC_____321816758474</span><br><span class="line">              <span class="built_in">alias</span>                 red</span><br><span class="line">              rr_weight             priorities</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件设备"><a href="#配置文件设备" class="headerlink" title="配置文件设备"></a>配置文件设备</h2><p>表 4.3 “设备属性”显示您可以为 <code>multipath.conf</code> 配置文件 <code>devices</code> 部分的每个独立储存设备能设置的属性。DM Multipath 会使用这些属性，除非它们被 <code>multipath.conf</code> 文件 <code>multipaths</code> 部分为包含该设备的路径所指定的属性覆盖。这些属性会覆盖 <code>multipath.conf</code> 文件 <code>defaults</code> 部分设定的属性。</p>
<p>多路径配置中默认包含许多支持 multipath 的设备。如需了解默认配置值（包括支持的设备）的相关信息，请运行以下命令之一。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd show config</span></span><br><span class="line"><span class="comment"># multipath -t</span></span><br></pre></td></tr></table></figure>
<p>您可能不需要为这些设备修改默认值，但如果您想要修改，可以通过在配置文件中添加条目来覆盖默认值。您可以为设备复制 <code>multipathd show config</code> 命令显示的设备配置默认值，并覆盖您想要修改的值。</p>
<p>如需在配置文件的这部分添加没有默认自动配置的设备，您需要设置 <code>vendor</code> 和 <code>product</code> 参数。您能在 <code>/sys/block/*device_name*/device/vendor</code> 和 <code>/sys/block/*device_name*/device/model</code>中找到这些值，其中 <em>device_name</em> 是要进行多路径操作的设备，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /sys/block/sda/device/vendor</span></span><br><span class="line">WINSYS  </span><br><span class="line"><span class="comment"># cat /sys/block/sda/device/model</span></span><br><span class="line">SF2372</span><br></pre></td></tr></table></figure>
<p>要指定的附加参数要视具体设备而定。如果设备是主动/主动模式，您通常不需要设置附加参数。您可能想要将 <code>path_grouping_policy</code> 设为 <code>multibus</code>。其它您可能需要设定的参数有 <code>no_path_retry</code>和 <code>rr_min_io</code>，详见 表 4.3 “设备属性”</p>
<p>如果设备是主动/被动模式，但它会自动将路径切换到被动路径，那么您需要将检查器功能改为不需向路径发送 I/O 来测试其是否工作（否则，您的设备将一直进行出错冗余）的功能。这几乎意味着您将 <code>path_checker</code> 设为 <code>tur</code>。这对所有支持 Test Unit Ready 命令的 SCSI 设备都适用。</p>
<p>如果该设备需要一个特殊的命令切换路径，那么为多路径配置此设备需要硬件处理器内核模块。当前的硬件处理器是 <code>emc</code>。如果这样还不能满足您的设备，则您可能无法为多路径配置该设备。</p>
<p>⁠</p>
<p><strong>表 4.3. 设备属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vendor</code></td>
<td>指定 <code>device</code> 采用的存储设备的零售商名称，例如 <code>COMPAQ</code>。</td>
</tr>
<tr>
<td><code>product</code></td>
<td>指定 <code>device</code> 属性使用的存储设备产品名，比如 <code>HSV110 (C) COMPAQ</code>。</td>
</tr>
<tr>
<td><code>revision</code></td>
<td>指定存储设备的产品修订识别程序。</td>
</tr>
<tr>
<td><code>product_blacklist</code></td>
<td>根据产品指定用来将设备列入黑名单的正则表达式。</td>
</tr>
<tr>
<td><code>alias_prefix</code></td>
<td>这个设备类型使用的 <code>user_friendly_names</code> 前缀，而不是默认的”mpath”。</td>
</tr>
<tr>
<td><code>hardware_handler</code></td>
<td>指定将在切换路径组群或者处理 I/O 错误时用来执行硬件具体动作的模块。可能的值包括：<code>1 emc</code>：EMC 存储阵列的硬件处理程序。<code>1 alua</code>：SCSI-3 ALUA 阵列的硬件处理程序。<code>1 hp_sw</code>：Compaq/HP 控制器的硬件处理程序。<code>1 rdac</code>：LSI/Engenio RDAC 控制器的硬件处理程序。</td>
</tr>
<tr>
<td><code>path_grouping_policy</code></td>
<td>指定用于未指定路径的默认路径分组策略，可能的值包括：<code>failover</code> = 每个优先组群有一个路径<code>multibus</code> = 所有有效路径在一个优先组群中<code>group_by_serial</code> = 每个检测到的系列号有一个优先组群<code>group_by_prio</code> = 每个路径优先值有一个优先组群<code>group_by_node_name</code> = 每个目标节点名有一个优先组群</td>
</tr>
<tr>
<td><code>path_selector</code></td>
<td>指定用来决定下一个 I/O 操作所使用路径的默认算法。可能的值包括：<code>round-robin 0</code>：在路径组中循环每个路径，向每个路径发送同样数量的 I/O。<code>queue-length 0</code>：将下一组 I/O 发送到具有最少未处理 I/O 请求的路径。<code>service-time 0</code>：将下一组 I/O 发送到具有最短预计服务时间的路径，这是由未处理 I/O 的总量除以每个路径的相对流量决定的。</td>
</tr>
<tr>
<td><code>path_checker</code></td>
<td>指定用于决定路径状态的默认方法，可能的值包括：<code>readsector0</code>：读取该设备的第一扇区。<code>tur</code>：在该设备中执行 <code>TEST UNIT READY</code>。<code>emc_clariion</code>：查询 EMC Clariion 具体 EVPD 页面 0xCO 以便决定路径。<code>hp_sw</code>：为使用 Active/Standby 固件的 HP 存储阵列检查路径状态。<code>rdac</code>：为 LSI/Engenio RDAC 存储控制器检查路径状态。<code>directio</code>：使用直接 I/O 读取第一个扇区。</td>
</tr>
<tr>
<td><code>features</code></td>
<td>多路径设备的默认额外功能，使用以下格式：”<em>number_of_features_plus_arguments</em> <em>feature1</em> …”。<code>features</code> 可能的值包括：<code>queue_if_no_path</code>，与将 <code>no_path_retry</code> 设置为 <code>queue</code> 相同。<code>retain_attached_hw_handler</code>：如果此参数被设为 <code>yes</code>，并且 SCSI 层已经为路径设备附加硬件处理程序，multipath 将不会强制设备使用 <code>multipath.conf</code> 文件指定的 <code>hardware_handler</code>。如果 SCSI 层未附加硬件处理程序，multipath 将会继续使用配置的硬件处理程序。<code>pg_init_retries *n*</code>：路径组初始化重试，失败前最多重试 <em>n</em> 次，1 &lt;= <em>n</em> &lt;= 50。<code>pg_init_delay_msecs *n*</code>：在路径组初始化重试的间隔，等待 <em>n</em> 毫秒，0 &lt;= <em>n</em> &lt;= 60000。</td>
</tr>
<tr>
<td><code>prio</code></td>
<td>指定要获得路径优先值所需调用的默认程序及参数。例如：SPC-3 中的 ALUA 字节提供了一个可改变的 <code>prio</code> 值。可能的值包括：<code>const</code>：为所有路径设定优先权 1。<code>emc</code>：为 EMC 阵列生成路径优先权。<code>alua</code>：根据 SCSI-3 ALUA 设置生成路径有限级。从 Red Hat Enterprise Linux 7.3 开始，如果在设备配置中指定 <code>prio &quot;alua exclusive_pref_bit&quot;</code>，多路径将生成包含只使用 <code>pref</code> 字节集的路径组，并为该组设定最高优先级。<code>ontap</code>：为 NetApp 阵列生成路径优先权。<code>rdac</code>：为 LSI/Engenio RDAC 控制程序生成路径优先权。<code>hp_sw</code>：为 Compaq/HP 控制程序在激活/等待模式中生成路径优先权。<code>hds</code>：为 Hitachi HDS Modular 存储阵列生成路径优先权。</td>
</tr>
<tr>
<td><code>failback</code></td>
<td>管理路径组群出错切换。<code>immediate</code> 值指定立即恢复到包含活跃路径的最高级别路径组群。<code>manual</code> 值指定不需要立即恢复，只有在操作者干预的情况下会发生恢复。<code>followover</code> 值指定当路径组的第一个路径成为活跃路径时应执行自动恢复。这可让节点在另一个节点请求故障修复时不会自动恢复。大于 0 的数字值指定推迟出错切换，以秒表示。</td>
</tr>
<tr>
<td><code>rr_weight</code></td>
<td>如果将其设为 <code>priorities</code>，就不会在调用 <code>selector</code> 选择下一个路径前向路径发送 <code>rr_min_io</code> 请求，而是由 <code>rr_min_io</code> 乘以路径优先权决定发送的请求数，即由 <code>prio</code> 功能决定。如果将其设定为 <code>uniform</code>，则所有路径都有相同的加权。</td>
</tr>
<tr>
<td><code>no_path_retry</code></td>
<td>此属性的数字值指定了系统在禁用队列前，应该尝试使用失败路径的次数。值为 <code>fail</code> 意味着立即失败，无需排队。值为 <code>queue</code> 意味着路径固定前不会停止排队。</td>
</tr>
<tr>
<td><code>rr_min_io</code></td>
<td>指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行内核为 2.6.31 之前的系统。使用新版本的系统应使用 <code>rr_min_io_rq</code>。默认值为 1000。</td>
</tr>
<tr>
<td><code>rr_min_io_rq</code></td>
<td>使用 request-based device-mapper-multipath 指定切换到当前路径组的下一个路径前路由到该路径的 I/O 请求数。这个设置值用于运行当前内核的系统。在使用内核 2.6.31 版本之前的系统应使用 <code>rr_min_io</code>。默认值为 1。</td>
</tr>
<tr>
<td><code>fast_io_fail_tmo</code></td>
<td>在 FC 远程端口发现问题后，无法在那个远程端口设备中执行 I/O 前 SCSI 层要等待的时间。默认值应小于 <code>dev_loss_tmo</code> 值。将其设定为 <code>off</code> 则会禁用超时。</td>
</tr>
<tr>
<td><code>dev_loss_tmo</code></td>
<td>在 FC 远程端口发现问题后，到从该系统中删除它之前 SCSI 层要等待的时间。将其设定为无限，则会将其设定为 2147483647 秒，或者 68 年。</td>
</tr>
<tr>
<td><code>flush_on_last_del</code></td>
<td>如果被设为 <code>yes</code>，当设备的最后一条路径被删除时，<code>multipathd</code> 守护程序将会禁用队列。</td>
</tr>
<tr>
<td><code>user_friendly_names</code></td>
<td>如果将其设为 <code>yes</code>，即指定该系统应该使用文件 <code>/etc/multipath/bindings</code> 为该多路径分配一个持久且唯一的别名，格式为 <code>mpath</code><em>n</em>。如果设定为 <code>no</code>，即指定该系统应使用 WWID 作为该多路径的别名。在这两种情况下，您在这里指定的数值将被您在配置文件 <code>multipaths</code> 部分指定的具体设备别名覆盖。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>retain_attached_hw_handler</code></td>
<td>如果此参数被设为 <code>yes</code>，并且 SCSI 层已经为路径设备附加了硬件处理程序，那么 multipath 将不会强制设备使用 <code>multipath.conf</code> 文件指定的 <code>hardware_handler</code>。如果 SCSI 层未附加硬件处理程序，multipath 将会继续使用其配置的硬件处理程序。默认值为 <code>no</code>。</td>
</tr>
<tr>
<td><code>detect_prio</code></td>
<td>如果被设为 <code>yes</code>，multipath 将会首先检查设备是否支持 ALUA。若支持，将会自动为设备分配 <code>alua</code> 排序器；若不支持，将会按惯例确定排序器。</td>
</tr>
<tr>
<td><code>uid_attribute</code></td>
<td>提供唯一路径标识符。</td>
</tr>
<tr>
<td><code>delay_watch_checks</code></td>
<td>（从 Red Hat Enterprise Linux Release 7.2 开始）如果将其设定为大于 0 的值，<code>multipathd</code> 守护进程将监视最近有效的路径，并执行指定数量的检查。如果在监视期间这些路径再次变为无法使用，则不会在这些路径下一次可用时就使用它们，直到连续检查使用 <code>delay_wait_checks</code> 指定的次数后它们都可用为止。 这样可防止将那些可能不太可靠的路径在上线后立即投入使用。</td>
</tr>
<tr>
<td><code>delay_wait_checks</code></td>
<td>（从 Red Hat Enterprise Linux 7.2 开始）如果将其设定为大于 0 的值，则最近重新上线的设备在由 <code>delay_watch_checks</code> 指定的检查次数内再次无法使用后，那么它下一次上线后就不会被标记并延迟，并在经过使用 <code>delay_watch_checks</code> 指定的检查次数后方可使用。</td>
</tr>
<tr>
<td><code>deferred_remove</code></td>
<td>如果设定为 <code>yes</code>，则在删除最后一个路径设备时，multipathd 将会执行延期删除，而不是常规删除。这样就会保证如果执行常规删除且操作失败时某个多路径设备正在使用中，该设备会在最后一个用户关闭该设备时自动被删除。</td>
</tr>
<tr>
<td><code>skip_kpartx</code></td>
<td>如果设定为 <code>yes</code>，<code>kpartx</code> 不会在该设备中自动创建分区。这样即使该设备有分区表，也可以允许用户在不创建分区的情况下创建多路径设备。</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例显示了多路径配置文件的 <code>device</code> 条目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#	&#125;</span></span><br><span class="line"><span class="comment">#	device &#123;</span></span><br><span class="line"><span class="comment">#		vendor			"COMPAQ  "</span></span><br><span class="line"><span class="comment">#		product			"MSA1000         "</span></span><br><span class="line"><span class="comment">#		path_grouping_policy	multibus</span></span><br><span class="line"><span class="comment">#		path_checker		tur</span></span><br><span class="line"><span class="comment">#		rr_weight		priorities</span></span><br><span class="line"><span class="comment">#	&#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="第-5-章-DM-MULTIPATH-管理及故障排除"><a href="#第-5-章-DM-MULTIPATH-管理及故障排除" class="headerlink" title="第 5 章 DM MULTIPATH 管理及故障排除"></a>第 5 章 DM MULTIPATH 管理及故障排除</h1><p>本章提供了在运行的系统中管理 DM Multipath 的相关信息。</p>
<h2 id="使用多路径帮助程序（MULTIPATH-HELPER）自动生成配置文件"><a href="#使用多路径帮助程序（MULTIPATH-HELPER）自动生成配置文件" class="headerlink" title="使用多路径帮助程序（MULTIPATH HELPER）自动生成配置文件"></a>使用多路径帮助程序（MULTIPATH HELPER）自动生成配置文件</h2><p>可在 Red Hat Enterprise Linux 中使用 Multipath Helper 应用程序为多路径设备生成基本配置。该应用程序可使用自定义别名、设备黑名单和各个多路径设备的特别设定创建多路径配置。完成后，该应用程序可生成安装脚本，该脚本包含所选配置参数，并提供 <code>multipath.conf</code> 配置文件供检查。</p>
<p>可以在 <a href="https://access.redhat.com/labsinfo/multipathhelper" target="_blank" rel="noopener">https://access.redhat.com/labsinfo/multipathhelper</a> 找到 Multipath Helper 应用程序。</p>
<h2 id="重新定义在线多路径设备大小"><a href="#重新定义在线多路径设备大小" class="headerlink" title="重新定义在线多路径设备大小"></a>重新定义在线多路径设备大小</h2><p>如果要重新定义在线多路径设备，请按以下步骤操作。</p>
<ol>
<li><p>重新定义物理设备大小。</p>
</li>
<li><p>使用以下命令查找 LUN 路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新定义路径大小。对于 SCSI 设备，在 <code>rescan</code> 文件中写入 1，以便让 SCSI 驱动器重新扫描，如以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/block/device_name/device/rescan</span><br></pre></td></tr></table></figure>
</li>
<li><p>如需重新定义多路径设备的大小，请执行 <code>multipathd resize</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipathd -k<span class="string">'resize map mpatha'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新定义文件系统大小（假设没有使用 LVM 或者 DOS 分区）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/mapper/mpatha</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="将-ROOT-文件系统从单路径设备移动到多路径设备中"><a href="#将-ROOT-文件系统从单路径设备移动到多路径设备中" class="headerlink" title="将 ROOT 文件系统从单路径设备移动到多路径设备中"></a>将 ROOT 文件系统从单路径设备移动到多路径设备中</h2><p>如果在单路径设备中安装系统，并稍后在 root 文件系统中添加了另一个路径，则需要将 root 文件系统移动到多路径设备中。本小节记录了从单路径移动到多路径设备的过程。</p>
<p>安装 <code>device-mapper-multipath</code> 软件包后执行以下步骤：</p>
<ol>
<li><p>执行以下命令创建 <code>/etc/multipath.conf</code> 配置文件，载入多路径模块并将 <code>multipathd</code> 的 <code>chkconfig</code> 设定为 <code>on</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mpathconf --<span class="built_in">enable</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有将 <code>find_multipaths</code> 参数配置为 <code>yes</code>，请编辑 <code>/etc/multipath.conf</code> 文件的 <code>blacklist</code> 和 <code>blacklist_exceptions</code> 部分所述。</p>
</li>
<li><p>要让 multipath 在 root 设备顶层发现多路径后尽快创建多路径设备，请输入以下命令。该命令还会确保 <code>find_multipaths</code> 会允许该设备，即使该设备只有一个路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -a root_devname</span><br></pre></td></tr></table></figure>
<p>例如：如果 root 设备是 <code>/dev/sdb</code>，则请输入以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath -a /dev/sdb</span><br><span class="line">wwid <span class="string">'3600d02300069c9ce09d41c4ac9c53200'</span> added</span><br></pre></td></tr></table></figure>
</li>
<li><p>为确定已正确设置配置文件，请输入 <code>multipath</code> 命令，并在输出结果中搜索使用以下格式的行。这表示该命令无法创建这个多路径设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date  wwid: ignoring map</span><br></pre></td></tr></table></figure>
<p>例如，如果设备的 WWID 为 3600d02300069c9ce09d41c4ac9c53200，则会看到以下输出行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipath</span><br><span class="line">Oct 21 09:37:19 | 3600d02300069c9ce09d41c4ac9c53200: ignoring map</span><br></pre></td></tr></table></figure>
</li>
<li><p>要使用 <code>multipath</code> 重建 <code>initramfs</code> 文件系统，请执行附带以下选项的 <code>dracut</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dracut --force -H --add multipath</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭机器。</p>
</li>
<li><p>配置 FC 开关以便可在该机器中看到其他路径。</p>
</li>
<li><p>引导机器。</p>
</li>
<li><p>查看 root 文件系统（’/‘）是否在多路径设备中。</p>
</li>
</ol>
<h2 id="将-SWAP-文件系统从单路径设备移动到多路径设备中"><a href="#将-SWAP-文件系统从单路径设备移动到多路径设备中" class="headerlink" title="将 SWAP 文件系统从单路径设备移动到多路径设备中"></a>将 SWAP 文件系统从单路径设备移动到多路径设备中</h2><p>默认情况下会将 swap 设备设定为逻辑卷。将其配置 为多路径设备不需要特殊的操作，只要在由逻辑卷组构成的物理卷中设定多路径即可。如果 swap 设备不是 LVM 卷，却使用设备名称挂载，就可能需要编辑 <code>/etc/fstab</code> 文件将其转换为正确的多路径设备名称。</p>
<ol>
<li><p>运行 <code>/sbin/multipath</code> 命令使用 <code>-v3</code> 选项确定 swap 设备的 WWID 号。该命令的输出应该在路径列表中显示该 swap 设备。</p>
<p>可以在该命令输出中看到有以下格式的行，它代表 swap 设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WWID  H:B:T:L devname MAJOR:MINOR</span><br></pre></td></tr></table></figure>
<p>例如：如果在 <code>sda</code> 或其分区之一中设置 swap 文件系统，则会在输出中看到类似如下的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">===== paths list =====</span><br><span class="line">...</span><br><span class="line">1ATA     WDC WD800JD-75MSA3                           WD-WMAM9F 1:0:0:0 sda 8:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/etc/multipath.conf</code> 文件中为 swap 设备配置别名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">multipaths &#123;</span><br><span class="line">    multipath &#123;</span><br><span class="line">        wwid WWID_of_swap_device</span><br><span class="line">        <span class="built_in">alias</span> swapdev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>/etc/fstab</code> 文件，并使用附带多路径设备的 root 设备替换旧的设备路径。</p>
<p>例如：如果在 <code>/etc/fstab</code> 文件中有以下条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/sda2 swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure>
<p>可将该条目更改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/mapper/swapdev swap          swap    defaults        0 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="多路径守护进程"><a href="#多路径守护进程" class="headerlink" title="多路径守护进程"></a>多路径守护进程</h2><p>如果在进行多路径配置时遇到问题，则应该确定多路径守护进程正在运行，必须运行 <code>multipathd</code> 守护进程方可使用多路径设备。</p>
<h2 id="大量-LUN-造成的问题"><a href="#大量-LUN-造成的问题" class="headerlink" title="大量 LUN 造成的问题"></a>大量 LUN 造成的问题</h2><p>在某个节点中添加大量 LUN 时，使用多路径设备可明显延长 <code>udev</code> 设备管理器为其生成设备节点所消耗的时间。如果遇到这个问题，请在 <code>/etc/udev/rules.d/40-multipath.rules</code> 文件中删除以下行解决这个问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KERNEL!=<span class="string">"dm-[0-9]*"</span>, ACTION==<span class="string">"add"</span>, PROGRAM==<span class="string">"/bin/bash -c '/sbin/lsmod | /bin/grep ^dm_multipath'"</span>, RUN+=<span class="string">"/sbin/multipath -v0 %M:%m"</span></span><br></pre></td></tr></table></figure>
<p>这行会在每次向该节点中添加块设备时让 <code>udev</code> 设备管理器运行 <code>multipath</code>。即使删除了这一行，<code>multipathd</code> 守护进程仍将自动生成多路径设备，同时在引导附带多路径 root 文件系统节点的过程中仍会调用 <code>multipath</code>。唯一的变化就是没有运行 <code>multipathd</code> 守护进程不再自动生成多路径设备，对大多数多路径用户来说应该不是个问题。</p>
<h2 id="有-QUEUE-IF-NO-PATH-功能的问题"><a href="#有-QUEUE-IF-NO-PATH-功能的问题" class="headerlink" title="有 QUEUE_IF_NO_PATH 功能的问题"></a>有 QUEUE_IF_NO_PATH 功能的问题</h2><p>如果使用 <code>features &quot;1 queue_if_no_path&quot;</code> 配置多路径设备，那么所有采用 I/O 操作的进程都将被挂起直到恢复一个或者多个路径为止。要避免这种情况，请在 <code>/etc/multipath.conf</code> 文件中设定 <code>no_path_retry</code> <em>N</em> 参数（其中 <em>N</em> 是该系统应该重试某个路径的次数）。</p>
<p>如果需要使用 <code>features &quot;1 queue_if_no_path&quot;</code> 选项，且遇到这里提到的问题，请使用 <code>dmsetup</code>命令为特定 LUN 编辑运行时策略（就是说对该特定 LUN 来说所有路径都不可用）。例如：如果想要将多路径设备 <code>mpath2</code> 的策略从 <code>&quot;queue_if_no_path&quot;</code> 改为 <code>&quot;fail_if_no_path&quot;</code>，请执行以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmsetup message mpathc 0 <span class="string">"fail_if_no_path"</span></span><br></pre></td></tr></table></figure>
<p>请注意：必须指定 <code>mpath</code><em>n</em> 别名而不是该路径。</p>
<h2 id="多路径命令输出"><a href="#多路径命令输出" class="headerlink" title="多路径命令输出"></a>多路径命令输出</h2><p>创建、修改或者列出多路径设备时，会显示当前设备设置状态，格式如下所示。</p>
<p>对于每个多路径设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">action_if_any: <span class="built_in">alias</span> (wwid_if_different_from_alias) dm_device_name_if_known vendor,product size=size features=<span class="string">'features'</span> hwhandler=<span class="string">'hardware_handler'</span> wp=write_permission_if_known</span><br></pre></td></tr></table></figure>
<p>对与每个路径组群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-+- policy=<span class="string">'scheduling_policy'</span> prio=prio_if_known status=path_group_status_if_known</span><br></pre></td></tr></table></figure>
<p>对于每个路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`- host:channel:id:lun devnode major:minor dm_status_if_known path_status online_status</span><br></pre></td></tr></table></figure>
<p>例如，多路径命令的输出可能是如下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3600d0230000000000e13955cc3757800 dm-1 WINSYS,SF2372</span><br><span class="line">size=269G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=rw</span><br><span class="line">|-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=active</span><br><span class="line">| `- 6:0:0:0 sdb 8:16  active ready  running</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=enabled</span><br><span class="line">  `- 7:0:0:0 sdf 8:80  active ready  running</span><br></pre></td></tr></table></figure>
<p>如果该路径已经启用并准备好执行 I/O，那么路径的状态就是 <code>ready</code> 或者 <code>ghost</code>。如果该路径无法使用，则状态为 <code>faulty</code> 或者 <code>shaky</code>。路径的状态由 <code>multipathd</code> 守护进程根据在 <code>/etc/multipath.conf</code> 文件中定义的轮询间隔进行定期更新。</p>
<p>dm 状态与路径状态相似，但从内核来看，dm 有两个状态：<code>failed</code>（类似 <code>faulty</code>）和 <code>active</code>（涵盖所有其它路径状态）。少数情况下，设备的路径状态和 dm 状态会暂时不同。</p>
<p><em>online_status</em> 的可能值为 <code>running</code> 和 <code>offline</code>。<code>offline</code> 意味着这个 SCSI 设备已被禁用。</p>
<p><strong><em>注意</em></strong></p>
<p><em>生成或者修改多路径设备时，路径组群状态、dm 设备名称、写入权限和 dm 状态是未知的。另外，功能也不一定正确。</em></p>
<h2 id="使用多路径命令进行多路径查询"><a href="#使用多路径命令进行多路径查询" class="headerlink" title="使用多路径命令进行多路径查询"></a>使用多路径命令进行多路径查询</h2><p>可以使用 <code>multipath</code> 命令的 <code>-l</code> 和 <code>-ll</code> 选项来显示当前 multipath 配置。<code>-l</code> 选项会显示从 <code>sysfs</code> 以及设备映射器中的信息搜集到的多路径拓扑。<code>-ll</code> 选项会显示 <code>-l</code> 选项显示的信息以及系统的其他可用组件。</p>
<p>显示多路径配置时，可以使用 <code>multipath</code> 命令的 <code>-v</code> 选项指定三种详细等级。指定为 <code>-v0</code> 时没有输出。指定为 <code>-v1</code> 则只输出生成或者更新的路径名称。指定 <code>-v2</code> 将输出所有检测到的路径、多路径和设备映射。</p>
<p>以下示例显示了 <code>multipath -l</code> 命令的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipath -l</span></span><br><span class="line">3600d0230000000000e13955cc3757800 dm-1 WINSYS,SF2372</span><br><span class="line">size=269G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=rw</span><br><span class="line">|-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=active</span><br><span class="line">| `- 6:0:0:0 sdb 8:16  active ready  running</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=enabled</span><br><span class="line">  `- 7:0:0:0 sdf 8:80  active ready  running</span><br></pre></td></tr></table></figure>
<p>以下示例显示了 <code>multipath -l1</code> 命令的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipath -ll</span></span><br><span class="line">3600d0230000000000e13955cc3757801 dm-10 WINSYS,SF2372</span><br><span class="line">size=269G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=rw</span><br><span class="line">|-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=enabled</span><br><span class="line">| `- 19:0:0:1 sdc 8:32  active ready  running</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=enabled</span><br><span class="line">  `- 18:0:0:1 sdh 8:112 active ready  running</span><br><span class="line">3600d0230000000000e13955cc3757803 dm-2 WINSYS,SF2372</span><br><span class="line">size=125G features=<span class="string">'0'</span> hwhandler=<span class="string">'0'</span> wp=rw</span><br><span class="line">`-+- policy=<span class="string">'round-robin 0'</span> prio=1 status=active</span><br><span class="line">  |- 19:0:0:3 sde 8:64  active ready  running</span><br><span class="line">  `- 18:0:0:3 sdj 8:144 active ready  running</span><br></pre></td></tr></table></figure>
<h2 id="多路径命令选项"><a href="#多路径命令选项" class="headerlink" title="多路径命令选项"></a>多路径命令选项</h2><p>表 5.1 “有用的 <code>multipath</code> 命令选项”描述了一些您可能会用到的 <code>multipath</code> 命令选项。</p>
<p>⁠</p>
<p><strong>表 5.1. 有用的 multipath 命令选项</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-l</code></td>
<td>显示来自 <code>sysfs</code> 和设备映射器的当前多路径配置。</td>
</tr>
<tr>
<td><code>-ll</code></td>
<td>显示来自 <code>sysfs</code> 、设备映射器以及系统中其他所有可用组件的当前多路径配置。</td>
</tr>
<tr>
<td><code>-f *device*</code></td>
<td>删除命名的多路径设备。</td>
</tr>
<tr>
<td><code>-F</code></td>
<td>删除所有不使用的多路经设备。</td>
</tr>
<tr>
<td><code>-w *device*</code></td>
<td>从 <code>wwids</code> 文件中删除指定设备的 <code>wwid</code>。</td>
</tr>
<tr>
<td><code>-W</code></td>
<td>重新设定 <code>wwids</code> 文件使其只包含当前 multipath 设备。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="使用-DMSETUP-命令确定设备映射器条目"><a href="#使用-DMSETUP-命令确定设备映射器条目" class="headerlink" title="使用 DMSETUP 命令确定设备映射器条目"></a>使用 DMSETUP 命令确定设备映射器条目</h2><p>可以使用 <code>dmsetup</code> 找出哪个设备映射器条目与多路径的设备映射。</p>
<p>以下命令显示所有设备映射器设备及其主、副号码。副号码确定 dm 设备的名称。例如：副号码 3 与多路径的设备 <code>/dev/dm-3</code> 对映。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dmsetup ls</span></span><br><span class="line">mpathd  (253:4)</span><br><span class="line">mpathep1        (253:12)</span><br><span class="line">mpathfp1        (253:11)</span><br><span class="line">mpathb  (253:3)</span><br><span class="line">mpathgp1        (253:14)</span><br><span class="line">mpathhp1        (253:13)</span><br><span class="line">mpatha  (253:2)</span><br><span class="line">mpathh  (253:9)</span><br><span class="line">mpathg  (253:8)</span><br><span class="line">VolGroup00-LogVol01     (253:1)</span><br><span class="line">mpathf  (253:7)</span><br><span class="line">VolGroup00-LogVol00     (253:0)</span><br><span class="line">mpathe  (253:6)</span><br><span class="line">mpathbp1        (253:10)</span><br><span class="line">mpathd  (253:5)</span><br></pre></td></tr></table></figure>
<h2 id="MULTIPATHD-命令"><a href="#MULTIPATHD-命令" class="headerlink" title="MULTIPATHD 命令"></a>MULTIPATHD 命令</h2><p>可使用 <code>multipathd</code> 命令管理 <code>multipathd</code> 守护进程。有关可用的 <code>multipathd</code> 命令的详情，请查看 <code>multipathd</code>(8) 手册页。</p>
<p>某些 <code>multipathd</code> 命令包含 <code>format</code> 选项，后接通配符。可以使用以下命令显示可用的通配符清单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd show wildcards</span></span><br></pre></td></tr></table></figure>
<p>从 Red Hat Enterprise Linux release 7.3 开始，<code>multipathd</code> 命令支持新格式命令，以便显示多路径状态以及使用 “raw”格式版本的路径。在 raw 格式中，不会显示标头，且不会添加字段以便将标头与该列对其。反之，该字段以指定的格式显示。这样就可以更好地使用输出结果编写脚本。现在可使用 <code>multipathd show wildcards</code> 命令显示格式字符串中的通配符。</p>
<p>要按照 <code>multipathd</code> 命令显示 <code>multipathd</code> 监控的多路径设备，使用带多路径通配符的格式字符串，可以是常规格式，也可以是 raw 格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list|show maps|multipaths format <span class="variable">$format</span></span><br><span class="line">list|show maps|multipaths raw format <span class="variable">$format</span></span><br></pre></td></tr></table></figure>
<p>以下 <code>multipathd</code> 命令显示 <code>multipathd</code> 监控的多路径设备，使用带多路径通配符的格式字符串，可以是常规格式，也可以是 raw 格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">list|show paths format <span class="variable">$format</span></span><br><span class="line">list|show paths raw format <span class="variable">$format</span></span><br></pre></td></tr></table></figure>
<p>以下命令显示 <code>multipathd show maps</code> 中非 raw 和 raw 格式之间的不同。注：在 <code>raw</code> 格式中没有标头，只在每个列之间有一个空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd show maps format "%n %w %d %s"</span></span><br><span class="line">name   uuid                              sysfs vend/prod/rev</span><br><span class="line">mpathc 360a98000324669436c2b45666c567942 dm-0  NETAPP,LUN   </span><br><span class="line"></span><br><span class="line"><span class="comment"># multipathd show maps raw format "%n %w %d %s"</span></span><br><span class="line">mpathc 360a98000324669436c2b45666c567942 dm-0 NETAPP,LUN</span><br></pre></td></tr></table></figure>
<h2 id="使用-MULTIPATHD-互动控制台进行故障排除"><a href="#使用-MULTIPATHD-互动控制台进行故障排除" class="headerlink" title="使用 MULTIPATHD 互动控制台进行故障排除"></a>使用 MULTIPATHD 互动控制台进行故障排除</h2><p><code>multipathd -k</code> 命令是 <code>multipathd</code> 守护程序的交互式界面。输入这一命令将进入交互式多路径控制台。执行此命令后，就可以输入 <code>help</code> 获取可用命令列表。可输入交互式命令，或者按 <code>CTRL-D</code> 退出。</p>
<p><code>multipathd</code> 交互式控制台可用来在系统出问题时进行故障排除。例如：以下命令会在退出控制台前显示多路径配置，其中包括默认配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd -k</span></span><br><span class="line">&gt; &gt; show config</span><br><span class="line">&gt; &gt; CTRL-D</span><br></pre></td></tr></table></figure>
<p>以下命令确定多路径已经识别了所有对 <code>multipath.conf</code> 的修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multipathd -k</span></span><br><span class="line">&gt; &gt; reconfigure</span><br><span class="line">&gt; &gt; CTRL-D</span><br><span class="line"><span class="comment"># multipathd -k</span></span><br><span class="line">&gt; &gt; show paths</span><br><span class="line">&gt; &gt; CTRL-D</span><br></pre></td></tr></table></figure>
<h2 id="删除软件包后清除多路径文件"><a href="#删除软件包后清除多路径文件" class="headerlink" title="删除软件包后清除多路径文件"></a>删除软件包后清除多路径文件</h2><p>如果不小心删除了 <code>device-mapper-multipath</code> <code>rpm</code>. 文件，请注意这不会删除 <code>/etc/multipath.conf</code>、<code>/etc/multipath/bindings</code> 和 <code>/etc/multipath/wwids</code> 文件。但可能需要在后续 <code>device-mapper-multipath</code> 软件包安装中手动删除这些文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Target实现（IP SAN）</title>
    <url>/2017/09/16/Linux/storage/iSCSI/</url>
    <content><![CDATA[<p> 先说明下，不建议在生产环境使用，写这个只是为了理解ISCSI以及Multipath* I/O 的工作方式；这次测试的操作系统是CENTOS6 ；没别的了懒得装 就先用这个，7系列可能包的名字有些不同， 根据情况百度吧！</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/a2GD2mDjeh.jpg?imageslim" alt="mark"><br><a id="more"></a></p>
<h1 id="iSCSI目标创建"><a href="#iSCSI目标创建" class="headerlink" title="iSCSI目标创建"></a>iSCSI目标创建</h1><p>iSCSI目标可以是网络中的专用物理设备，也可以是网络存储服务器上的iSCSI软件配置的逻辑设备。目标是SCSI总线通信的终点。由发起者访问的目标上的存储由LUN定义。</p>
<p><strong>创建iSCSI目标</strong></p>
<ol>
<li><p>安装 <code>scsi-target-utils</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install scsi-target-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开iptables3260端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp -m tcp --dport 3260 -j ACCEPT</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动并启用target服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service tgtd start</span><br><span class="line">chkconfig tgtd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>为LUN分配存储空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x43eb8efd.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): *Enter*</span><br><span class="line">Using default response p</span><br><span class="line">Partition number (1-4, default 1): *Enter*</span><br><span class="line">First sector (2048-2097151, default 2048): *Enter*</span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +250M</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 250 MiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑/etc/tgt/targets.conf创建目标容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/tgt/targets.conf</span><br><span class="line">...</span><br><span class="line">default-driver iscsi</span><br><span class="line">&lt;target iqn.2015-06.com.example.test:target1&gt;</span><br><span class="line">	backing-store /dev/sdb1</span><br><span class="line">	initiator-address 192.168.10.1</span><br><span class="line">&lt;/target&gt;</span><br></pre></td></tr></table></figure>
<p>创建一个backing-store  sdb1，允许192.168.10.1启动target，</p>
<p>iqn命名规则：</p>
<p>​    <code>iqn.*YYYY*-*MM*.*reverse.domain.name*:*OptionalIdentifier*</code>.</p>
</li>
<li><p>重启target服务.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service tgtd restart</span><br><span class="line">Stopping SCSI target daemon:     [ OK ]</span><br><span class="line">Starting SCSI target daemon:     [ OK ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看配置.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tgt-admin --show</span><br><span class="line">Target 1: iqn.2015.06.com.example.test: server</span><br><span class="line">	System information:</span><br><span class="line">		Driver: iscsi</span><br><span class="line">		State: ready</span><br><span class="line">	I_T nexus information:</span><br><span class="line">	LUN information:</span><br><span class="line">		Lun: 0</span><br><span class="line">			Type: controller</span><br><span class="line">			SCSI ID: IET    00010000</span><br><span class="line">			SCSI SN: beaf10</span><br><span class="line">			Size: 0 MB, Block size: 1</span><br><span class="line">			Online: Yes </span><br><span class="line">			Removable media: No</span><br><span class="line">			Prevent removal: No</span><br><span class="line">			Readonly: No</span><br><span class="line">			Backing store <span class="built_in">type</span>: null</span><br><span class="line">			Backing store path: None</span><br><span class="line">			Backing store flags:</span><br><span class="line">		LUN: 1</span><br><span class="line">			Type: disk</span><br><span class="line">			SCSI ID: IET     00010001</span><br><span class="line">			SCSI SN: beaf11</span><br><span class="line">			Size: 2147 MB, Block size: 512</span><br><span class="line">			Online: Yes</span><br><span class="line">			Removable media: No</span><br><span class="line">			Prevent removal: No</span><br><span class="line">			Readonly: No</span><br><span class="line">			Backing store <span class="built_in">type</span>: rdwr</span><br><span class="line">			Backing store path: /dev/sdb1</span><br><span class="line">			Backing store flags:</span><br><span class="line">	Account information:</span><br><span class="line">	ACL information:</span><br><span class="line">		10.10.1.1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="创建-iSCSI-Initiator"><a href="#创建-iSCSI-Initiator" class="headerlink" title="创建 iSCSI Initiator"></a>创建 iSCSI Initiator</h1><p>iSCSI启动器是希望访问目标或服务器上的存储的客户端。该过程需要知道目标的IP地址。 </p>
<p><strong>创建 iSCSI Initiator</strong></p>
<ol>
<li><p>安装 <code>iscsi-initiator-utils</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install iscsi-initiator-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现 target.使用target端ip.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m discovery -t sendtargets -p 192.168.1.2</span><br><span class="line">Starting iscsid:     [ OK ]</span><br><span class="line">192.168.1.2:3260,1 iqn.2015-06.com.example.test:target1</span><br></pre></td></tr></table></figure>
<p>显示了target端的iqn，login时需要此项.</p>
</li>
<li><p>连接到 target.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm -m node -T iqn.2015-06.com.example:target1 --login</span><br><span class="line">Logging <span class="keyword">in</span> to [iface: default, target: iqn.2015-06.com.example:target1, portal: 192.168.1.2,3260] (multiple)</span><br><span class="line">Login <span class="keyword">in</span> to [iface: default, target: iqn.2015-06.com.example:target1, portal: 192.168.1.2,3260] successful.</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示ISCSI磁盘名称.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">"Attached SCSI"</span> /var/<span class="built_in">log</span>/messages</span><br><span class="line">Jun 19 01:30:26 <span class="built_in">test</span> kernel: sd 7:0:0:1 [sdb] Attached SCSI disk</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建个lvm玩.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sdb &amp;&amp; vgcreate <span class="built_in">test</span> /dev/sdb &amp;&amp; lvcreate -n newtest -l 100%FREE <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/iscsiTest</span><br><span class="line">mount /dev/mapper/<span class="built_in">test</span>-newtest /mnt/iscsiTest</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make it persistent across reboots by editing the <code>/etc/fstab</code> file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">blkid /dev/mapper/<span class="built_in">test</span>-newtest</span><br><span class="line">/dev/sdb: UUID=<span class="string">"b01cd289-0f48-4e7c-bf4b-3b822f0a4332"</span> TYPE=<span class="string">"ext4"</span></span><br><span class="line">vim /etc/fstab</span><br><span class="line">UUID=b01cd289-0f48-4e7c-bf4b-3b822f0a4332	/mnt/iscsiTest	ext4	_netdev	0 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="命令手册"><a href="#命令手册" class="headerlink" title="命令手册"></a>命令手册</h1><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a><strong>名称</strong></h2><p>iscsiadm  -  open-iscsi管理实用程序</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a><strong>概要</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       iscsiadm -m discovery [ -hV ] [ -d debug_level ] [ -P printlevel ] [ -I</span><br><span class="line">       iface -t <span class="built_in">type</span> -p ip:port [ -l ] ] | [ -o operation ] [ -n name ]  [  -v</span><br><span class="line">       value ]</span><br><span class="line"></span><br><span class="line">       iscsiadm  -m  node  [  -hV  ] [ -d debug_level ] [ -P printlevel ] [ -L</span><br><span class="line">       all,manual,automatic ] [ -U all,manual,automatic  ]  [  -S  ]  [  [  -T</span><br><span class="line">       targetname  -p  ip:port  -I  iface  ]  [  -l  |  -u | -R | -s] ] [ [ -o</span><br><span class="line">       operation ]  [ -n name ] [ -v value ] [ -p ip:port ] ]</span><br><span class="line"></span><br><span class="line">       iscsiadm -m session [ -hV ] [ -d debug_level ] [ -P printlevel ]  [  -r</span><br><span class="line">       sessionid | sysfsdir [ -R ] [ -u | -s ] ]</span><br><span class="line"></span><br><span class="line">       iscsiadm  -m  iface  [  -hV ] [ -d debug_level ] [ -P printlevel ] [ -I</span><br><span class="line">       ifacename ] [ [ -o  operation  ] [ -n name ] [ -v value ] ]</span><br><span class="line"></span><br><span class="line">       iscsiadm -m fw [-l]</span><br><span class="line"></span><br><span class="line">       iscsiadm -m host [ -P printlevel ] [ -H hostno ]</span><br><span class="line"></span><br><span class="line">       iscsiadm -k priority</span><br></pre></td></tr></table></figure>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iscsiadm实用程序是一个允许发现的命令行工具</span><br><span class="line">登录到iSCSI目标，以及访问和管理开放源码，</span><br><span class="line">iscsi数据库。</span><br><span class="line"></span><br><span class="line">Open-iscsi不使用iSCSI RFC定义的术语节点，</span><br><span class="line">节点是单个iSCSI启动器或目标。Open-iscsi使用</span><br><span class="line">术语节点指向目标上的门户。</span><br><span class="line"></span><br><span class="line">对于会话模式，使用会话ID（sid）。一个会话的sid可以</span><br><span class="line">通过运行iscsiadm -m session -P找到。会话ID和sysfs</span><br><span class="line">路径目前不持续，部分由时间决定</span><br><span class="line">会话设置。</span><br><span class="line"></span><br><span class="line">请注意，许多节点和发现操作都要求</span><br><span class="line">iSCSI守护进程（iscsid）正在运行。</span><br></pre></td></tr></table></figure>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a><strong>OPTIONS</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d，-- debug = debug_level</span><br><span class="line">       打印调试信息。debug_level的有效值为0</span><br><span class="line">       到8。</span><br><span class="line"></span><br><span class="line">-h，-- <span class="built_in">help</span></span><br><span class="line">       显示帮助文本并退出</span><br><span class="line"></span><br><span class="line">-I， - 接口[iface]</span><br><span class="line">       interface参数指定要用于的iSCSI接口</span><br><span class="line">       操作。iSCSI接口（iface）定义在</span><br><span class="line">       的/ etc /的iSCSI / ifaces。对于硬件iSCSI（qla4xxx），iface配置</span><br><span class="line">       必须具有硬件地址（iface.hwaddress = port的MAC</span><br><span class="line">       地址）和driver / transport_name（iface.transport_name）。</span><br><span class="line">       iface的名字是iface配置的文件名。对于</span><br><span class="line">       软件iSCSI，iface配置必须具有硬件</span><br><span class="line">       地址（iface.hwaddress）或网络层的接口名称</span><br><span class="line">       （iface.net_ifacename），它必须具有</span><br><span class="line">       驱动器/ TRANSPORT_NAME</span><br><span class="line"></span><br><span class="line">       可用的驱动程序/ iscsi_transports是tcp（软件iSCSI</span><br><span class="line">       通过TCP / IP），iser（软件iSCSI over infinniband）或qla4xxx</span><br><span class="line">       （Qlogic 4XXXX HBA）。hwaddress是MAC地址或<span class="keyword">for</span></span><br><span class="line">       软件iSCSI可能是特殊值“默认”</span><br><span class="line">       指示启动器不将会话绑定到特定的会话</span><br><span class="line">       硬件资源，而是允许网络或infinniband</span><br><span class="line">       层决定做什么。没有必要创建一个iface</span><br><span class="line">       配置默认行为。如果不指定iface，</span><br><span class="line">       那么使用默认行为。</span><br><span class="line"></span><br><span class="line">       如上所述，有一个特殊的iface名称是默认的。那里</span><br><span class="line">       是三个其他 -  cxgb3i，bnx2i和iser，它不绑定</span><br><span class="line">       会话到一个特定的卡，但会绑定会话</span><br><span class="line">       cxgb3i，bnx2i或iser传输。这些是实验和</span><br><span class="line">       不支持使用稳定的界面。</span><br><span class="line"></span><br><span class="line">       在发现模式下，多个接口可以通过传递</span><br><span class="line">       在多个I /  - 接口实例中。例如，</span><br><span class="line"></span><br><span class="line">       “iscsiadm -m discovery -t st -p mytarget -I iface0 -I iface2”</span><br><span class="line"></span><br><span class="line">       将直接使用iscsiadm设置节点数据库以创建记录</span><br><span class="line">       这将通过传入的两个内容创建会话。</span><br><span class="line"></span><br><span class="line">       在节点模式下，每个呼叫中只支持单个接口</span><br><span class="line">       到iscsiadm。</span><br><span class="line"></span><br><span class="line">       此选项对发现，节点和iface模式有效。</span><br><span class="line"></span><br><span class="line">-k，-- killiscsid = [priority]</span><br><span class="line">       当前优先级必须为零。这将立即停止</span><br><span class="line">       iscsid操作和关闭iscsid。它不注销任何</span><br><span class="line">       会话。运行此命令与执行“killall”相同</span><br><span class="line">       iscsid“，通常不能使用，因为如果iscsid</span><br><span class="line">       正在进行错误恢复，或者iscsid是否存在错误</span><br><span class="line">       没有运行，系统可能无法恢复。这个</span><br><span class="line">       命令和iscsid的SIGTERM处理是实验性的。</span><br><span class="line"></span><br><span class="line">-l，-- login</span><br><span class="line">       对于节点和fw模式，登录到指定的记录。发现</span><br><span class="line">       模式，登录到所有发现的目标。</span><br><span class="line"></span><br><span class="line">       此选项仅对发现和节点模式有效。</span><br><span class="line"></span><br><span class="line">-L，-- loginall == [all | manual | automatic]</span><br><span class="line">       对于节点模式，使用节点或连接启动登录所有会话</span><br><span class="line">       值得传入或全部运行，除了标记</span><br><span class="line">       onboot，如果全部被传入。</span><br><span class="line"></span><br><span class="line">       此选项仅对节点模式有效（它是有效的但不是</span><br><span class="line">       功能用于会话模式）。</span><br><span class="line"></span><br><span class="line">-m， -mode  op </span><br><span class="line">       指定模式。  op必须是发现，节点，fw，主机</span><br><span class="line">       iface或会话之一。</span><br><span class="line"></span><br><span class="line">       如果没有指定其他选项：对于发现和   节点，全部显示各自的记录; </span><br><span class="line">       为会议，所有显示活动会话和连接; </span><br><span class="line">       对于fw，所有启动显示固件值; </span><br><span class="line">       对于主机，所有iSCSI主机都是</span><br><span class="line">       显示; 对于iface，所有的ifaces都设置在/ etc / iscsi / ifaces中</span><br><span class="line">       被显示。</span><br><span class="line"></span><br><span class="line">-n，-- name = name   在记录中</span><br><span class="line">       指定字段   名称。用于更新</span><br><span class="line">       运营商。</span><br><span class="line"></span><br><span class="line">-o，-- op = op </span><br><span class="line">       指定数据库操作符op。op必须是新的，删除，</span><br><span class="line">        更新或显示之一。</span><br><span class="line"></span><br><span class="line">       此选项对于除fw以外的所有模式均有效。删除不应该</span><br><span class="line">       用于运行会话。如果iscsiadm会停止</span><br><span class="line">       会话，然后删除记录。</span><br><span class="line"></span><br><span class="line">       new为给定的门户（IP地址）创建一个新的数据库记录</span><br><span class="line">       和端口号）。在发现模式下，iscsiadm将创建新的</span><br><span class="line">       目标返回的门户的记录。</span><br><span class="line"></span><br><span class="line">       删除删除指定的recid。在发现节点中，如果是iscsiadm</span><br><span class="line">       正在执行发现，它将删除门户的记录</span><br><span class="line">       不再退回。</span><br><span class="line"></span><br><span class="line">       更新   将使用名称将recid更新为指定的值。</span><br><span class="line">       在发现节点中，如果iscsiadm正在执行发现</span><br><span class="line">       不需要recid，   name    和   value   参数。更新</span><br><span class="line">       操作将对目标返回的门户进行操作，</span><br><span class="line">       并将使用配置文件中的info更新节点记录</span><br><span class="line">       和命令行。</span><br><span class="line"></span><br><span class="line">       show是node，discovery和iface的默认行为</span><br><span class="line">       模式。当没有传入命令时也会使用它</span><br><span class="line">       会话模式和一个运行的sid被传入。   名称和值是</span><br><span class="line">       当与show一起使用时，被忽略。</span><br><span class="line"></span><br><span class="line">-p，-- portal = ip [：port] </span><br><span class="line">       使用ip-address ip和port的目标端口，默认端口</span><br><span class="line">       值为3260。</span><br><span class="line"></span><br><span class="line">       此选项仅对发现或节点操作有效</span><br><span class="line">       与新的操作员。</span><br><span class="line"></span><br><span class="line">       这应该与节点模式下的--target一起使用，以指定</span><br><span class="line">       open-iscsi文档被称为节点或节点记录。</span><br><span class="line">       注意：open-iscsi使用单词节点，不匹配</span><br><span class="line">       iSCSI RFC的iSCSI节点术语。</span><br><span class="line"></span><br><span class="line">-P，--   <span class="built_in">print</span> = printlevel</span><br><span class="line">       如果在节点模式下以树形式打印节点。如果在会话模式</span><br><span class="line">       以树形式打印会话。如果在发现模式下打印</span><br><span class="line">       节点树形式。</span><br><span class="line"></span><br><span class="line">-T，--targetname = TARGETNAME </span><br><span class="line">       使用目标 TARGETNAME。</span><br><span class="line"></span><br><span class="line">       这应该与节点模式中的--portal一起使用来指定</span><br><span class="line">       open-iscsi文档被称为节点或节点记录。</span><br><span class="line">       注意：open-iscsi使用单词节点，不匹配</span><br><span class="line">       iSCSI RFC的iSCSI节点术语。</span><br><span class="line"></span><br><span class="line">-r，   -- sid  = sid |  sysfsdir </span><br><span class="line">       使用会话ID   sid。会话的sid可以从中找到</span><br><span class="line">       在会话模式下运行iscsiadm和--info参数。</span><br><span class="line"></span><br><span class="line">       可以使用包含会话的sysfs路径，而不是sid。</span><br><span class="line">       例如使用以下之一：</span><br><span class="line">       /sys/devices/platform/hostH/sessionS/targetH:B:I/H:B:I:L,</span><br><span class="line">       /sys/devices/platform/hostH/sessionS/targetH:B:I, or</span><br><span class="line">       /sys/devices/platform/hostH/sessionS,</span><br><span class="line"></span><br><span class="line">       sid  |  sysfsdir 仅用于会话模式。</span><br><span class="line"></span><br><span class="line">-R，--   rescan</span><br><span class="line">       在会话模式下，如果sid也通过重新扫描会话。如果</span><br><span class="line">       没有通过重新扫描所有正在运行的会话。</span><br><span class="line"></span><br><span class="line">       在节点模式下，重新扫描通过目标运行的会话，</span><br><span class="line">       门户，iface元组传入。</span><br><span class="line"></span><br><span class="line">-s，-- stats</span><br><span class="line">       显示会话统计信息</span><br><span class="line"></span><br><span class="line">-S，--show</span><br><span class="line">       显示记录时，不要隐藏屏蔽值，例如</span><br><span class="line">       CHAP密码（密码）。</span><br><span class="line"></span><br><span class="line">       此选项仅对节点和会话模式有效。</span><br><span class="line"></span><br><span class="line">-t，-- <span class="built_in">type</span> = <span class="built_in">type</span> </span><br><span class="line">       类型必须是sendtargets（或缩写为st），   slp，   isns   或</span><br><span class="line">        fw。目前只支持sendtargets，fw和iSNS，请参阅</span><br><span class="line">       DISCOVERY TYPES部分。</span><br><span class="line"></span><br><span class="line">       此选项仅对发现模式有效。</span><br><span class="line"></span><br><span class="line">-u，-- <span class="built_in">logout</span></span><br><span class="line">       注销指定的记录。</span><br><span class="line"></span><br><span class="line">       此选项仅对节点和会话模式有效。</span><br><span class="line"></span><br><span class="line">-U，-- logoutall == [全部，手动，自动]</span><br><span class="line">       注销所有会话与节点或conn启动值传递</span><br><span class="line">       在或所有运行的sesssion，除了标记在启动，如果一切都是</span><br><span class="line">       传入</span><br><span class="line"></span><br><span class="line">       此选项仅对节点模式有效（它是有效的但不是</span><br><span class="line">       功能用于会话模式）。</span><br><span class="line"></span><br><span class="line">-v，-- value = value </span><br><span class="line">       指定与更新运算符一起使用的值。</span><br><span class="line"></span><br><span class="line">       此选项仅对节点模式有效。</span><br><span class="line"></span><br><span class="line">-V，-- version</span><br><span class="line">       显示版本并退出</span><br></pre></td></tr></table></figure>
<h3 id="发现类型"><a href="#发现类型" class="headerlink" title="发现类型"></a>发现类型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iSCSI定义了3种发现类型：SendTargets，SLP和iSNS。</span><br><span class="line"></span><br><span class="line">发送目标</span><br><span class="line">       一种本地iSCSI协议，允许每个iSCSI目标发送一个</span><br><span class="line">       启动器的可用目标列表。</span><br><span class="line"></span><br><span class="line">SLP（     可选）iSCSI目标可以使用服务定位协议</span><br><span class="line">       （SLP）宣布可用的目标。发起者可以</span><br><span class="line">       可以直接实现SLP查询，也可以使用单独的工具</span><br><span class="line">       获取有关可用目标的信息。</span><br><span class="line"></span><br><span class="line">iSNS    iSNS（Internet存储名称服务）记录有关信息</span><br><span class="line">       较大网络中的存储卷。利用iSNS，</span><br><span class="line">       使用iSNS服务器的地址必须在iscsid.conf中设置</span><br><span class="line">       “isns.address”值，iscsiadm必须在发现模式下运行</span><br><span class="line">       与“isns”发现类型。</span><br><span class="line"></span><br><span class="line">       open-iscsi中的iSNS支持是实验性的。iscsid.conf</span><br><span class="line">       设置，iscsiadm语法和节点DB布局可能会改变。</span><br><span class="line"></span><br><span class="line">fw      几个NIC和系统包含一个迷你iSCSI启动器</span><br><span class="line">       可用于启动。获取用于启动fw的值</span><br><span class="line">       选项可以使用。做fw发现，不存储</span><br><span class="line">       持久记录在节点或发现DB中，因为</span><br><span class="line">       值存储在系统或NIC的资源中。</span><br><span class="line"></span><br><span class="line">       执行fw发现将打印门户，像其他</span><br><span class="line">       发现方法。查看其他设置，如CHAP值和</span><br><span class="line">       启动器设置，就像在节点模式下一样，运行“iscsiadm”</span><br><span class="line">       -m fw“。</span><br><span class="line"></span><br><span class="line">       open-iscsi中的fw支持是实验性的。设置和</span><br><span class="line">       iscsiadm语法和输出格式可能会改变。</span><br><span class="line"></span><br><span class="line">iscsiadm支持iSNS  （isns）或SendTargets  （st）   发现类型。</span><br><span class="line">SLP实施正在开发中。</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">发现给定IP地址的目标：</span><br><span class="line"></span><br><span class="line">     iscsiadm  - 模式发现--<span class="built_in">type</span> sendtargets --portal 192.168.1.10</span><br><span class="line"></span><br><span class="line">登录，必须使用发现找到的节点记录ID：</span><br><span class="line"></span><br><span class="line">     iscsiadm --mode node --targetname iqn.2001-05.com.doe：<span class="built_in">test</span> --portal 192.168.1.1:3260 --login</span><br><span class="line"></span><br><span class="line">登出：</span><br><span class="line"></span><br><span class="line">     iscsiadm --mode node --targetname iqn.2001-05.com.doe：<span class="built_in">test</span> --portal 192.168.1.1:3260 --<span class="built_in">logout</span></span><br><span class="line"></span><br><span class="line">列表节点记录：</span><br><span class="line"></span><br><span class="line">     iscsiadm  --mode node</span><br><span class="line"></span><br><span class="line">显示给定节点记录的所有数据：</span><br><span class="line"></span><br><span class="line">     iscsiadm --mode node --targetname iqn.2001-05.com.doe：<span class="built_in">test</span> --portal 192.168.1.1:3260</span><br></pre></td></tr></table></figure>
<h4 id="FILES"><a href="#FILES" class="headerlink" title="FILES"></a>FILES</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/iscsi/iscsid.conf</span><br><span class="line">启动时由iscsid和iscsiadm读取的配置文件。</span><br><span class="line">/etc/iscsi/initiatorname.iscsi</span><br><span class="line">启动时由iscsid和iscsiadm读取的包含iSCSI InitiatorName和InitiatorAlias的文件。</span><br><span class="line">/var/lib/iscsi/nodes/</span><br><span class="line">此目录包含具有目标的节点。</span><br><span class="line">/var/lib/iscsi/send_targets</span><br><span class="line">此目录包含门户。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04 部署 open-falcon</title>
    <url>/2017/09/07/open-falcon/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://blog-image.nos-eastchina1.126.net/arch.jpgfunc_intro_1.png" alt="arch"></p>
<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install  -y redis-server</span><br></pre></td></tr></table></figure>
<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y mysql-server</span><br></pre></td></tr></table></figure>
<p><strong>注意，请确保redis和MySQL已启动。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status mysql redis</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="初始化MySQL表结构"><a href="#初始化MySQL表结构" class="headerlink" title="初始化MySQL表结构"></a>初始化MySQL表结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/ &amp;&amp; git <span class="built_in">clone</span> https://github.com/open-falcon/falcon-plus.git </span><br><span class="line"><span class="built_in">cd</span> /tmp/falcon-plus/scripts/mysql/db_schema/</span><br><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 1_uic-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 2_portal-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 3_dashboard-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 4_graph-db-schema.sql</span><br><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 5_alarms-db-schema.sql</span><br><span class="line">rm -rf /tmp/falcon-plus/</span><br></pre></td></tr></table></figure>
<p><strong>如果你是从v0.1.0升级到当前版本v0.2.0，那么只需要执行如下命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u root -p &lt; 5_alarms-db-schema.sql</span><br></pre></td></tr></table></figure>
<h1 id="从源码编译"><a href="#从源码编译" class="headerlink" title="从源码编译"></a>从源码编译</h1><p>首先，安装golang环境;并设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/golang/go1.9.linux-amd64.tar.gz <span class="comment"># download</span></span><br><span class="line">tar -zxvf go1.9.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>/                   <span class="comment"># 解压缩</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:/usr/local/go/bin"</span> &gt;&gt; /etc/profile          <span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">go  version                                                         <span class="comment"># 检查是否可用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/go/src/github.com/open-falcon/falcon-plus/</span><br><span class="line">apt install make gcc pack							 <span class="comment"># 必要依赖</span></span><br><span class="line">make all											<span class="comment"># make all modules</span></span><br><span class="line">make pack											<span class="comment"># pack all modules</span></span><br></pre></td></tr></table></figure>
<p>这时候，你会在当前目录下面，得到open-falcon-v0.2.0.tar.gz的压缩包，就表示已经编译和打包成功了。</p>
<h1 id="下载编译好的二进制版本"><a href="#下载编译好的二进制版本" class="headerlink" title="下载编译好的二进制版本"></a>下载编译好的二进制版本</h1><p>如果你不想自己编译的话，那么可以下载官方编译好的<a href="https://github.com/open-falcon/falcon-plus/releases" target="_blank" rel="noopener">二进制版本(x86 64位平台)</a>。</p>
<p>到这一步，准备工作就完成了。 open-falcon-v0.2.0.tar.gz 这个二进制包，请大家解压到合适的位置，暂时保存，后续步骤需要使用。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FALCON_HOME=/home/work</span><br><span class="line"><span class="built_in">export</span> WORKSPACE=<span class="variable">$FALCON_HOME</span>/open-falcon</span><br><span class="line">mkdir -p <span class="variable">$WORKSPACE</span></span><br></pre></td></tr></table></figure>
<h3 id="解压二进制包"><a href="#解压二进制包" class="headerlink" title="解压二进制包"></a>解压二进制包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxcf open-falcon-v0.2.0.tar.gz -C <span class="variable">$WORKSPACE</span></span><br></pre></td></tr></table></figure>
<h3 id="在一台机器上启动所有的后端组件"><a href="#在一台机器上启动所有的后端组件" class="headerlink" title="在一台机器上启动所有的后端组件"></a>在一台机器上启动所有的后端组件</h3><blockquote>
<p>首先确认配置文件中数据库账号密码与实际相同，否则需要修改配置文件。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line">grep -Ilr 3306  ./ | xargs -n1 -- sed -i <span class="string">'s/root:password/real_user:real_password/g'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>这里可能会报错，一般都是缺少依赖包，根据提示安装就ok了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line">./open-falcon start										<span class="comment"># 启动open-falcon</span></span><br><span class="line">./open-falcon check								    	<span class="comment"># 检查所有模块的启动状况</span></span><br></pre></td></tr></table></figure>
<h3 id="更多的命令行工具用法"><a href="#更多的命令行工具用法" class="headerlink" title="更多的命令行工具用法"></a>更多的命令行工具用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./open-falcon [start|stop|restart|check|monitor|reload] module</span></span><br><span class="line">./open-falcon start agent</span><br><span class="line"></span><br><span class="line">./open-falcon check</span><br><span class="line">        falcon-graph         UP           25371</span><br><span class="line">          falcon-hbs         UP           25384</span><br><span class="line">        falcon-judge         UP           25395</span><br><span class="line">     falcon-transfer         UP           25403</span><br><span class="line">       falcon-nodata         UP           25411</span><br><span class="line">   falcon-aggregator         UP           25420</span><br><span class="line">        falcon-agent         UP           47073</span><br><span class="line">      falcon-gateway         UP           25440</span><br><span class="line">          falcon-api         UP           25448</span><br><span class="line">        falcon-alarm         UP           25462</span><br><span class="line"></span><br><span class="line">For debugging , You can check <span class="variable">$WorkDir</span>/<span class="variable">$moduleName</span>/<span class="built_in">log</span>/logs/xxx.log</span><br></pre></td></tr></table></figure>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="创建工作目录-1"><a href="#创建工作目录-1" class="headerlink" title="创建工作目录"></a>创建工作目录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HOME=/home/work</span><br><span class="line"><span class="built_in">export</span> WORKSPACE=<span class="variable">$HOME</span>/open-falcon</span><br><span class="line">mkdir -p <span class="variable">$WORKSPACE</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br></pre></td></tr></table></figure>
<h3 id="克隆前端组件代码"><a href="#克隆前端组件代码" class="headerlink" title="克隆前端组件代码"></a>克隆前端组件代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/open-falcon/dashboard.git</span><br></pre></td></tr></table></figure>
<h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt  install -y python-pip python-virtualenv</span><br><span class="line">apt  install -y python-devel</span><br><span class="line">apt  install -y ldap-utils</span><br><span class="line">apt  install -y libmysqld-dev</span><br><span class="line"></span><br><span class="line">apt  install -y linux-headers-4.4.0-83-generic build-essential   <span class="comment"># 这个要看下uname -r的输出来确定 ，根据uname -r 输出的数字 安装时使用tab 补全</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$WORKSPACE</span>/dashboard/</span><br><span class="line">virtualenv ./env</span><br><span class="line"></span><br><span class="line">./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure>
<h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dashboard的配置文件为： <span class="string">'rrd/config.py'</span>，请根据实际情况修改</span><br><span class="line"></span><br><span class="line"><span class="comment">## API_ADDR 表示后端api组件的地址</span></span><br><span class="line">API_ADDR = <span class="string">"http://127.0.0.1:8080/api/v1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 根据实际情况，修改PORTAL_DB_*, 默认用户名为root，默认密码为""</span></span><br><span class="line"><span class="comment">## 根据实际情况，修改ALARM_DB_*, 默认用户名为root，默认密码为""</span></span><br></pre></td></tr></table></figure>
<h3 id="以开发者模式启动"><a href="#以开发者模式启动" class="headerlink" title="以开发者模式启动"></a>以开发者模式启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./env/bin/python wsgi.py</span><br><span class="line"></span><br><span class="line">open http://127.0.0.1:8081 <span class="keyword">in</span> your browser.</span><br></pre></td></tr></table></figure>
<h3 id="在生产环境启动"><a href="#在生产环境启动" class="headerlink" title="在生产环境启动"></a>在生产环境启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash control start</span><br><span class="line"></span><br><span class="line">open http://127.0.0.1:8081 <span class="keyword">in</span> your browser.</span><br></pre></td></tr></table></figure>
<h3 id="停止dashboard运行"><a href="#停止dashboard运行" class="headerlink" title="停止dashboard运行"></a>停止dashboard运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash control stop</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash control tail</span><br></pre></td></tr></table></figure>
<h2 id="Agent修改配置"><a href="#Agent修改配置" class="headerlink" title="Agent修改配置"></a>Agent修改配置</h2><p>agent用于采集机器负载监控指标，比如cpu.idle、load.1min、disk.io.util等等，每隔60秒push给Transfer。agent与Transfer建立了长连接，数据发送速度比较快，agent提供了一个http接口/v1/push用于接收用户手工push的一些数据，然后通过长连接迅速转发给Transfer。</p>
<h2 id="部署说明"><a href="#部署说明" class="headerlink" title="部署说明"></a>部署说明</h2><p>agent需要部署到所有要被监控的机器上，比如公司有10万台机器，那就要部署10万个agent。agent本身资源消耗很少，不用担心。</p>
<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p>配置文件必须叫cfg.json，可以基于cfg.example.json修改</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "debug": true,  # 控制一些debug信息的输出，生产环境通常设置为false</span><br><span class="line">    "hostname": "", # agent采集了数据发给transfer，endpoint就设置为了hostname，默认通过`hostname`获取，如果配置中配置了hostname，就用配置中的</span><br><span class="line">    "ip": "", # agent与hbs心跳的时候会把自己的ip地址发给hbs，agent会自动探测本机ip，如果不想让agent自动探测，可以手工修改该配置</span><br><span class="line">    "plugin": &#123;</span><br><span class="line">        "enabled": false, # 默认不开启插件机制</span><br><span class="line">        "dir": "./plugin",  # 把放置插件脚本的git repo clone到这个目录</span><br><span class="line">        "git": "https://github.com/open-falcon/plugin.git", # 放置插件脚本的git repo地址</span><br><span class="line">        "logs": "./logs" # 插件执行的log，如果插件执行有问题，可以去这个目录看log</span><br><span class="line">    &#125;,</span><br><span class="line">    "heartbeat": &#123;</span><br><span class="line">        "enabled": true,  # 此处enabled要设置为true</span><br><span class="line">        "addr": "127.0.0.1:6030", # hbs的地址，端口是hbs的rpc端口</span><br><span class="line">        "interval": 60, # 心跳周期，单位是秒</span><br><span class="line">        "timeout": 1000 # 连接hbs的超时时间，单位是毫秒</span><br><span class="line">    &#125;,</span><br><span class="line">    "transfer": &#123;</span><br><span class="line">        "enabled": true, </span><br><span class="line">        "addrs": [</span><br><span class="line">            <span class="string">"127.0.0.1:18433"</span></span><br><span class="line">        ],  # transfer的地址，端口是transfer的rpc端口, 可以支持写多个transfer的地址，agent会保证HA</span><br><span class="line">        "interval": 60, # 采集周期，单位是秒，即agent一分钟采集一次数据发给transfer</span><br><span class="line">        "timeout": 1000 # 连接transfer的超时时间，单位是毫秒</span><br><span class="line">    &#125;,</span><br><span class="line">    "http": &#123;</span><br><span class="line">        "enabled": true,  # 是否要监听http端口</span><br><span class="line">        "listen": ":1988",</span><br><span class="line">        "backdoor": false</span><br><span class="line">    &#125;,</span><br><span class="line">    "collector": &#123;</span><br><span class="line">        "ifacePrefix": ["eth", "em"], # 默认配置只会采集网卡名称前缀是eth、em的网卡流量，配置为空就会采集所有的，lo的也会采集。可以从/proc/net/dev看到各个网卡的流量信息</span><br><span class="line">        "mountPoint": []</span><br><span class="line">    &#125;,</span><br><span class="line">    "default_tags": &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    "ignore": &#123;  # 默认采集了200多个metric，可以通过ignore设置为不采集</span><br><span class="line">        "cpu.busy": true,</span><br><span class="line">        "df.bytes.free": true,</span><br><span class="line">        "df.bytes.total": true,</span><br><span class="line">        "df.bytes.used": true,</span><br><span class="line">        "df.bytes.used.percent": true,</span><br><span class="line">        "df.inodes.total": true,</span><br><span class="line">        "df.inodes.free": true,</span><br><span class="line">        "df.inodes.used": true,</span><br><span class="line">        "df.inodes.used.percent": true,</span><br><span class="line">        "mem.memtotal": true,</span><br><span class="line">        "mem.memused": true,</span><br><span class="line">        "mem.memused.percent": true,</span><br><span class="line">        "mem.memfree": true,</span><br><span class="line">        "mem.swaptotal": true,</span><br><span class="line">        "mem.swapused": true,</span><br><span class="line">        "mem.swapfree": true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./open-falcon start agent  启动进程</span><br><span class="line">./open-falcon stop agent  停止进程</span><br><span class="line">./open-falcon monitor agent  查看日志</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>看var目录下的log是否正常，或者浏览器访问其1988端口。另外agent提供了一个<code>--check</code>参数，可以检查agent是否可以正常跑在当前机器上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./falcon-agent --check</span><br></pre></td></tr></table></figure>
<h2 id="v1-push接口"><a href="#v1-push接口" class="headerlink" title="/v1/push接口"></a>/v1/push接口</h2><p>我们设计初衷是不希望用户直接连到Transfer发送数据，而是通过agent的/v1/push接口转发，接口使用范例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ts=`date +%s`; curl -X POST -d <span class="string">"[&#123;\"metric\": \"metric.demo\", \"endpoint\": \"qd-open-falcon-judge01.hd\", \"timestamp\": <span class="variable">$ts</span>,\"step\": 60,\"value\": 9,\"counterType\": \"GAUGE\",\"tags\": \"project=falcon,module=judge\"&#125;]"</span> http://127.0.0.1:1988/v1/push</span><br></pre></td></tr></table></figure>
<p>现在在浏览器打开IP:8081端口</p>
<p>agent配置文件 修改plugin ： true</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/1.jpg" alt="agent"></p>
<p>打开agent IP:1988</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/2.jpg" alt=""></p>
<p>:happy:</p>
]]></content>
      <categories>
        <category>Monitoring</category>
      </categories>
      <tags>
        <tag>Monitoring</tag>
      </tags>
  </entry>
  <entry>
    <title>内存虚拟化</title>
    <url>/2017/08/22/Virtualized-Resource/Memory-virtualization/</url>
    <content><![CDATA[<p>因为虚拟化引入了额外级别的内存映射，所以可以跨虚拟机来管理内存。</p>
<p>虚拟机的一些物理内存可能映射到共享页面或未映射或交换的页面。</p>
<p>主机执行内存管理时无需了解客户机操作系统，也不会干涉客户机操作系统自身的内存管理子系统。</p>
<p>每个虚拟机的VMM保持了从客户机操作系统的物理内存页到基础计算机上物理内存页的映射。</p>
<p>每个虚拟机均有连续的可寻址的物理内存空间，该空间从零开始。每个虚拟机使用的服务器上的基础内存不一定是连续的。</p>
<p>客户机虚拟地址到客户机物理地址的转换由客户机操作系统管理。管理程序仅负责将客户机物理地址转换为计算机地址。硬件辅助的内存虚拟化将利用硬件基础设施生成具有由管理程序维护的客户机页表和嵌套页表的组合映射。</p>
<a id="more"></a>
<p><img src="https://blog-image.nos-eastchina1.126.net/RAM.png" alt=""></p>
<ul>
<li>方框表示页，而箭头表示不同内存的映射。</li>
<li>从客户机虚拟内存到客户机物理内存的箭头表示客户机操作系统中的页表所保持的映射。</li>
<li>从客户机物理内存到计算机内存的箭头表示由VMM保持的映射。</li>
<li>虚线箭头表示从客户机虚拟内存到计算机内存的映射，该映射也由VMM保持。运行虚拟机的基础处理器使用</li>
</ul>
<p>卷影表映射。</p>
<h2 id="硬件辅助的内存虚拟化"><a href="#硬件辅助的内存虚拟化" class="headerlink" title="硬件辅助的内存虚拟化"></a>硬件辅助的内存虚拟化</h2><p>类似于CPU通过使用两层页表来提供对内存虚拟化的硬件支持。</p>
<p>第一层页表存储客户机虚拟-物理转换，而第二层页表存储客户机物理-计算机转换。TLB（translation lookaside buffer，转换旁视缓冲区）是由处理器的内存管理单元（MMU）硬件维护的转换缓存。TBL缺失是缓存中的缺失，而且硬件需要访问内存（可能是多次）来查找所需的转换。如果TLB中没有某个客户机虚拟地址，则硬件会查看这两个页表，将客户机虚拟地址转换成计算机地址。第一层页表由客户机操作系统维护，VMM仅维护第二层页表。</p>
<p><strong>性能注意事项</strong></p>
<p>使用硬件辅助时，会消除软件内存虚拟化的开销，特别是，硬件辅助消除了是卷影页表与客户机页表保持同步所需的开销。但是，使用硬件辅助时TLB缺失延迟时间明显较长。默认情况下，管理程序在硬件辅助模式下使用大页以减少TLB缺失的成本。因此工作负载是否受益于硬件辅助主要取决于在使用软件虚拟化时由内存虚拟化引起的开销。如果工作负载设计少量页表活动（例如进程创建、映射内存页或上下文切换），则软件虚拟化不会引起显著开销，相反，具有大量页表活动的工作负载可能会因使用硬件辅助而受益。</p>
]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>RAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph硬件建议</title>
    <url>/2017/08/20/Linux/storage/Ceph_hardware/</url>
    <content><![CDATA[<p>Ceph被设计为运行在商品硬件上，这使得建立和维护PB级数据集群在经济上是可行的。在规划集群硬件时，您需要平衡许多注意事项，包括故障域和潜在的性能问题。硬件规划应包括在许多主机上分发Ceph守护进程和其他使用Ceph的进程。通常，我们建议在为该类型的守护程序配置的主机上运行特定类型的Cep守护程序。我们建议对其他主机使用您的数据集群（例如OpenStack，CloudStack等）。<br><a id="more"></a></p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>Ceph元数据服务器动态重新分配其负载，这是CPU密集型。因此，您的元数据服务器应具有显着的处理能力（例如，四核或更好的CPU）。Ceph OSD运行<a href="http://docs.ceph.com/docs/master/glossary/#term-rados" target="_blank" rel="noopener">RADOS</a>服务，用<a href="http://docs.ceph.com/docs/master/glossary/#term-crush" target="_blank" rel="noopener">CRUSH</a>计算数据放置，复制数据，并维护自己的集群映射副本。因此，OSD应具有合理的处理能力（例如，双核处理器）。监视器只需维护集群映射的主副本，因此它们不是CPU密集型。您还必须考虑除了Ceph守护进程之外，主机是否将运行CPU密集型进程。例如，如果您的主机将运行计算机虚拟机（例如，OpenStack Nova），则需要确保这些其他进程为Ceph守护程序提供足够的处理能力。我们建议在不同的主机上运行额外的CPU密集型进程。</p>
<h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><p>元数据服务器和监视器必须能够快速地提供数据，所以它们应该有足够的RAM（例如，每个守护程序实例有1GB的RAM）。OSD对于常规操作不需要尽可能多的RAM（例如，每个守护程序实例有500MB的RAM）; 然而，在恢复期间，它们需要显着更多的RAM（例如，每个守护进程每1TB存储约1GB）。通常，更多的RAM是更好的。</p>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>仔细规划数据存储配置。在规划数据存储时需要考虑的重要成本和性能折衷。同时操作系统操作，以及从单个驱动器同时请求多个守护进程的读写操作可能会显着降低性能。</p>
<h2 id="硬盘驱动器"><a href="#硬盘驱动器" class="headerlink" title="硬盘驱动器"></a>硬盘驱动器</h2><p>OSD应该有足够的硬盘驱动器空间用于对象数据。我们建议最低硬盘大小为1TB。考虑大型磁盘的每GB成本优势。我们建议将硬盘驱动器的价格除以千兆字节数来达到每GB的成本，因为较大的驱动器可能会对每GB成本产生重大影响。例如，1 TB的硬盘定价为75.00美元，每千兆字节的成本为0.07美元（即75/1024 = 0.0732美元）。相比之下，3 TB的硬盘价格为150.00美元，每千兆字节的成本为0.05美元（即150美元/ 3072美元= 0.0488美元）。在上述示例中，使用1 TB磁盘通常会将每GB的成本提高40％，从而大大降低了您的集群的成本效益。另外，存储驱动器容量越大，您将需要更多的Ceph OSD守护进程，特别是在重新平衡，回填和恢复过程中。对于1TB的存储空间，一般的经验法则是〜1GB的RAM。</p>
<p>存储驱动器受到查询时间，访问时间，读取和写入时间以及总吞吐量的限制。这些物理限制会影响整个系统的性能 - 特别是在恢复期间 我们建议为操作系统和软件使用专用驱动器，并在主机上运行的每个Ceph OSD守护程序使用一个驱动器。由于在同一驱动器上运行操作系统，多个OSD和/或多个日志，所以会出现大多数“慢OSD”问题。由于在小型集群上排除性能问题的成本可能会超出额外的磁盘驱动器的成本，您可以通过避免超负荷OSD存储驱动器的诱惑来加快集群设计规划。</p>
<p>您可以为每个硬盘驱动器运行多个Ceph OSD守护程序，但这可能会导致资源争用并降低整体吞吐量。您可以将日志和对象数据存储在同一个驱动器上，但这可能会增加对客户端进行写入和确认的时间。Ceph必须写入日志才能确认写。</p>
<p>Ceph最佳实践规定您应该在单独的驱动器上运行操作系统，OSD数据和OSD日志。</p>
<h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p>性能改进的一个机会是使用固态驱动器（SSD）来减少随机访问时间并读取延迟并加速吞吐量。与硬盘驱动器相比，固态硬盘的每千兆字节通常的成本要高出10倍，但固态硬盘的访问时间往往比硬盘驱动器至少要快100倍。</p>
<p>SSD没有移动的机械部件，因此它们不一定受到与硬盘驱动器相同类型的限制。SSD确实有很大的局限性。在评估SSD时，考虑顺序读写的性能很重要。具有400MB / s连续写入吞吐量的SSD可能比在多个OSD存储多个日志时具有120MB / s连续写入吞吐量的SSD具有更好的性能。</p>
<p>由于SSD没有移动的机械部件，因此在Ceph区域使用它们并不使用大量存储空间（例如期刊）是有意义的。相对廉价的SSD可能吸引您的经济感。小心使用 选择与Ceph一起使用的SSD时，可接受的IOPS是不够的。日志和SSD有一些重要的性能注意事项：</p>
<ul>
<li><strong>写入密集型语义：</strong>日记记录涉及写入密集型语义，因此您应该确保选择部署的SSD在写入数据时将与硬盘驱动器相同或更好。即使在加速访问时间的情况下，廉价的SSD也可能会引入写入延迟，因为有时高性能硬盘驱动器可以像市场上可用的一些更经济的SSD一样快速或快速地写入！</li>
<li><strong>顺序写入：</strong>当您将多个期刊存储在SSD上时，您必须考虑到SSD的顺序写入限制，因为它们可能会同时处理写入多个OSD期刊的请求。</li>
<li><strong>分区对齐：</strong> SSD性能的一个常见问题是人们喜欢将驱动器分区为最佳做法，但它们往往忽略了与SSD的正确分区对齐，这可能导致SSD传输数据更慢。确保SSD分区正确对齐。</li>
</ul>
<p>虽然SSD对对象存储成本过高，但OSD可以通过将OSD日记存储在SSD上，并将OSD的对象数据存储在单独的硬盘驱动器上来显着提高性能。所述配置设置默认为。您可以将此路径安装到SSD或SSD分区，以使其不仅仅是与对象数据在同一磁盘上的文件。<code>osd journal``/var/lib/ceph/osd/$cluster-$id/journal</code></p>
<p>Ceph加速CephFS文件系统性能的一种方法是将CephFS元数据的存储与CephFS文件内容的存储隔离开来。Ceph提供<code>metadata</code>CephFS元数据的默认池。您将不必为CephFS元数据创建一个池，但是您可以为仅指向主机的SSD存储介质的CephFS元数据池创建一个CRUSH映射层次结构。有关详细信息，请参阅将 <a href="http://docs.ceph.com/docs/master/rados/operations/crush-map#placing-different-pools-on-different-osds" target="_blank" rel="noopener">池映射到不同类型的OSD</a>。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>磁盘控制器也对写入吞吐量有重大影响。仔细考虑您选择的磁盘控制器，以确保它们不会创建性能瓶颈。</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>您可以为每个主机运行多个OSD，但您应确保OSD硬盘的总吞吐量之和不超过客户端读取或写入数据所需的网络带宽。您还应该考虑集群存储在每个主机上的整体数据的百分比。如果特定主机的百分比较大，并且主机出现故障，则可能会导致诸如超出全部比例的问题，这导致Ceph停止运行，以防止数据丢失的安全预防措施。</p>
<p>当您每个主机运行多个OSD时，还需要确保内核是最新的。有关注意事项的<a href="http://docs.ceph.com/docs/master/start/os-recommendations" target="_blank" rel="noopener">操作系统建议</a>，请参阅<a href="http://docs.ceph.com/docs/master/start/os-recommendations" target="_blank" rel="noopener">操作系统建议书</a><code>glibc</code>， <code>syncfs(2)</code>以确保您的硬件在每个主机运行多个OSD时按预期执行。</p>
<p>具有大量OSD的主机（例如，&gt; 20）可能会产生大量线程，特别是在恢复和重新平衡期间。许多Linux内核的最大线程数默认为相对较小（例如32k）。如果在主机上启动具有大量OSD的OSD时遇到问题，请考虑设置<code>kernel.pid_max</code>为更高数量的线程。理论上限为4,194,303个线程。例如，您可以将以下内容添加到<code>/etc/sysctl.conf</code>文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kernel.pid_max  =  4194303</span><br></pre></td></tr></table></figure>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>我们建议每个主机至少有两个1Gbps网络接口控制器（NIC）。由于大多数商用硬盘驱动器的吞吐量大约为100MB /秒，因此您的网卡应能够处理主机上的OSD磁盘的流量。我们建议至少使用两个NIC来解决公共（前端）网络和集群（后端）网络。集群网络（最好不连接到互联网）处理额外的数据复制负载，并有助于阻止拒绝服务攻击，防止集群实现<code>active + clean</code>作为OSD的放置组的状态在集群中复制数据。考虑从机架中的10Gbps网络开始。通过1Gbps网络复制1TB的数据需要3个小时，3TB（典型的驱动器配置）需要9个小时。相反，使用10Gbps网络，复制时间分别为20分钟和1小时。在一个PB级的集群中，OSD磁盘的故障应该是一种期望，而不是例外。系统管理员将会欣赏从<code>degraded</code>状态恢复的PG <code>active + clean</code>状态尽可能快地考虑到价格/性能的折衷。此外，一些部署工具（例如，戴尔的Crowbar）部署了五个不同的网络，但采用VLAN可以使硬件和网络布线更易于管理。使用802.1q协议的VLAN需要支持VLAN的NIC和交换机。添加的硬件费用可能被网络设置和维护的运营成本节省抵消。当使用VLAN来处理集群和计算堆栈之间的VM流量（例如OpenStack，CloudStack等）时，也值得考虑使用10G以太网。每个网络的机架顶部路由器还需要能够与具有更快吞吐量的脊柱路由器通信，例如40Gbps至100Gbps。</p>
<p>您的服务器硬件应具有底板管理控制器（BMC）。管理和部署工具也可以广泛使用BMC，因此考虑管理带外网络的成本/效益折衷。虚拟机管理程序SSH访问，虚拟机映像上传，操作系统映像安装，管理套接字等可能会对网络造成重大负担。运行三个网络可能看起来像是过度的，但是每个流量路径代表在部署大规模数据集群之前应仔细考虑的潜在容量，吞吐量和/或性能瓶颈。</p>
<h1 id="故障域"><a href="#故障域" class="headerlink" title="故障域"></a>故障域</h1><p>故障域是防止访问一个或多个OSD的任何故障。这可能是主机上的一个停止的守护进程; 硬盘故障，操作系统崩溃，NIC故障，电源故障，网络中断，断电等。在规划硬件需求时，您必须通过将太多的责任放置在太少的故障域中来平衡诱惑，从而降低成本，以及隔离每个潜在故障域的额外成本。</p>
<h1 id="最低硬件建议"><a href="#最低硬件建议" class="headerlink" title="最低硬件建议"></a>最低硬件建议</h1><p>Ceph可以运行在便宜的商品硬件上。小型生产集群和开发集群可以通过适度的硬件成功运行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>处理</th>
<th>标准</th>
<th>最低推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ceph-osd</code></td>
<td>处理器</td>
<td>1x 64位AMD-641x 32位ARM双核或更好</td>
</tr>
<tr>
<td>随机存取存储器</td>
<td>〜1GB，每个守护进程存储1TB</td>
<td></td>
</tr>
<tr>
<td>卷存储</td>
<td>每个守护进程的1x存储驱动器</td>
<td></td>
</tr>
<tr>
<td>日志</td>
<td>每个守护进程1个SSD分区（可选）</td>
<td></td>
</tr>
<tr>
<td>网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td><code>ceph-mon</code></td>
<td>处理器</td>
<td>1x 64位AMD-641x 32位ARM双核或更好</td>
</tr>
<tr>
<td>随机存取存储器</td>
<td>每个守护进程1 GB</td>
<td></td>
</tr>
<tr>
<td>磁盘空间</td>
<td>每个守护进程10 GB</td>
<td></td>
</tr>
<tr>
<td>网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td><code>ceph-mds</code></td>
<td>处理器</td>
<td>1x 64位AMD-64四核1x 32位ARM四核</td>
</tr>
<tr>
<td>随机存取存储器</td>
<td>每个守护进程最小为1 GB</td>
<td></td>
</tr>
<tr>
<td>磁盘空间</td>
<td>每个守护进程1 MB</td>
<td></td>
</tr>
<tr>
<td>网络</td>
<td>2x 1GB以太网网卡</td>
</tr>
</tbody>
</table>
</div>
<h1 id="生产群集示例"><a href="#生产群集示例" class="headerlink" title="生产群集示例"></a>生产群集示例</h1><p>用于PB级数据存储的生产集群也可能使用商品硬件，但是应该具有相当多的内存，处理能力和数据存储以应付大量流量负载。</p>
<h2 id="戴尔示例"><a href="#戴尔示例" class="headerlink" title="戴尔示例"></a>戴尔示例</h2><p>最近（2012）Ceph集群项目正在为Ceph OSD使用两个相当强大的硬件配置，并为显示器配置了较轻的配置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组态</th>
<th>标准</th>
<th>最低推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>戴尔PE R510</td>
<td>处理器</td>
<td>2x 64位四核Xeon CPU</td>
</tr>
<tr>
<td>随机存取存储器</td>
<td>16 GB</td>
<td></td>
</tr>
<tr>
<td>卷存储</td>
<td>8x 2TB驱动器。1个操作系统，7个存储</td>
<td></td>
</tr>
<tr>
<td>客户端网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td>OSD网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td>MGMT。网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td>戴尔PE R515</td>
<td>处理器</td>
<td>1x 六核皓龙CPU</td>
</tr>
<tr>
<td>随机存取存储器</td>
<td>16 GB</td>
<td></td>
</tr>
<tr>
<td>卷存储</td>
<td>12x 3TB驱动器。存储</td>
<td></td>
</tr>
<tr>
<td>操作系统存储</td>
<td>1x 500GB驱动器 操作系统。</td>
<td></td>
</tr>
<tr>
<td>客户端网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td>OSD网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
<tr>
<td>MGMT。网络</td>
<td>2x 1GB以太网网卡</td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
        <tag>Hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx实现HTTP强制跳转HTTPS</title>
    <url>/2017/08/06/https/</url>
    <content><![CDATA[<h1 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h1><p>安装NGINX的还没来得及整理到这个博客，以后再来补，今天主要写跳转的实现，安装通过yum，仅供测试，生产建议编译；</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Centos7<br>ssl<br>nginx</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>浏览器 — 直接访问80 — 跳转https ，<br><a id="more"></a></p>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p><em>不要在意为什么不编译</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install epel*</span><br><span class="line">yum -y install nginx</span><br><span class="line">nginx -v <span class="comment"># 检查是否安装成功</span></span><br></pre></td></tr></table></figure>
<h3 id="生成证书（仅供测试用）"><a href="#生成证书（仅供测试用）" class="headerlink" title="生成证书（仅供测试用）"></a>生成证书（仅供测试用）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mkdir -pv /usr/<span class="built_in">local</span>/src/<span class="built_in">test</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/<span class="built_in">test</span>/</span><br><span class="line">openssl genrsa -des3 -out server.key 1024</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line">openssl rsa -<span class="keyword">in</span> server.key -out server_nopwd.key <span class="comment"># nginx使用的私钥需要去除密码口令</span></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -signkey server_nopwd.key -out server.crt</span><br></pre></td></tr></table></figure>
<p>这时 test目录下应该有四个文件</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/LBjiakjd8B.png?imageslim" alt="mark"></p>
<h3 id="修改NGINX配置文件"><a href="#修改NGINX配置文件" class="headerlink" title="修改NGINX配置文件"></a>修改NGINX配置文件</h3><p>现在我们修改一下nginx.conf 因为是测试所以修改全局文件了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>这里需要启用https的配置，</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/5AACGBDjbi.png?imageslim" alt="mark"></p>
<p>现在我们启动服务测试下，<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld ; systemctl restart nginx</span><br><span class="line">netstat -tunlp | grep 443</span><br></pre></td></tr></table></figure></p>
<p>启动服务如果报错请看清log 并且Double Check 你的配置文件，主要是证书名字和路径<br>检查端口是否开启，<br>接下来 找一台可以跟server通信的客户端 打开<a href="https://ip" target="_blank" rel="noopener">https://ip</a> 测试。<br>可以打开网页 并且是https 那么 https —-OK</p>
<h3 id="http跳转"><a href="#http跳转" class="headerlink" title="http跳转"></a>http跳转</h3><p>这里实现的方式有很多，</p>
<p>这里介绍几种</p>
<h4 id="方式1-rewrite"><a href="#方式1-rewrite" class="headerlink" title="方式1 rewrite"></a>方式1 rewrite</h4><p><img src="https://blog-image.nos-eastchina1.126.net/DjAmehDkDF.png?imageslim" alt="mark"></p>
<p>可以看出，这句话的意思是当你访问http时，通过uri重写的方式直接到https</p>
<p>1,2两种写法，都可以，选一个自己觉得好看的</p>
<p>但是，这是旧版本文档里的写法，</p>
<p>新版本的NGINX已经不推荐这种方式；</p>
<p>推荐方式为下面说的方法2</p>
<h4 id="方法2-return"><a href="#方法2-return" class="headerlink" title="方法2 return"></a>方法2 return</h4><p><img src="https://blog-image.nos-eastchina1.126.net/831bhB1Ebf.png?imageslim" alt="mark"></p>
<p>这种方式也很清晰，访问http时 ，return一个301 直接跳转https，原理就是跟你打网页 没有这个页面 404的效果类似</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/mIKjHA81H8.png?imageslim" alt="mark"></p>
<p>August 7, 2017 1:01 AM</p>
<p>END</p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Https</tag>
        <tag>Redirect</tag>
      </tags>
  </entry>
  <entry>
    <title>一次VDP故障记录</title>
    <url>/2017/08/03/VDP/</url>
    <content><![CDATA[<p>现有vsphere5.5环境，300+ VM ，不少重要业务需要备份，之前部署了三个节点的VDP来备份这些VM，由于标准版VDP有存储容量上的限制（好像可用3T），现在的备份任务只保存三天，正好测试备份产品，准备用测试产品备份现有VDP的备份计划，今天一看vcenter事件，vdp3告警，再往下看，两三天的任务都没正常备份了，坑以后再说，开始说故障处理。</p>
<h1 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h1><p>==vcenter 任务事件告警信息==<br><img src="https://blog-image.nos-eastchina1.126.net/JbHFfeKGec.png?imageslim" alt="mark"><br>检查点过期？马上看前几天的事件，发现近几天的备份都未成功，<br>登录vsphere-web-client 看看vdp上的事件（慢）</p>
<p>VDP的报告截图<br><img src="https://blog-image.nos-eastchina1.126.net/dfm71fh3hc.png?imageslim" alt="mark"></p>
<p>第一反应，完整性检查，但是这不应该需要人员干预阿，But，看以用容量， 2% 再看下最后成功备份的日期，备份保留时间只有三天，第一反应是三天备份失败，备份都被删除了，但是这不科学的阿，</p>
<p><font color=#00ffff size=5>这里说下，最好的处理办法是现在重新部署一个VDP来接管之前的备份任务。</font><br>这里抱着试试看的心态来搞点事情，（<font color=#FF4500 size=4>结果通宵了- -！</font> ）</p>
<blockquote>
<p>顺便证明一波国内某知名搜索引擎有多没用<br> 使用一波搜索引擎，给的答案简直就是所问非所答，只有有关键字就往上靠，搜vdp故障竟让能搜出安装vcenter的文档，（呵呵呵）</p>
</blockquote>
<p>还有什么vmsky阿，太不活跃，看帖子跟学历史似的，<br>gg一波，<br><a id="more"></a></p>
<h1 id="处理思路和流程"><a href="#处理思路和流程" class="headerlink" title="处理思路和流程"></a>处理思路和流程</h1><p>下面说下我处理的思路和流程</p>
<ol>
<li>开始新的备份（反正也没备份集了，这最简单，）</li>
<li>报错说完整性检查状态过时，那就检查一波完整性，那么问题来了，我都没数据了 完整性检查毛线</li>
</ol>
<h2 id="一步一步来"><a href="#一步一步来" class="headerlink" title="一步一步来"></a>一步一步来</h2><ul>
<li>打开web-client ，备份试试，VDP龟速，等一年 终于出了连接备份</li>
<li>点了，等着</li>
<li>报错了， 时间不同步，（这里说下，并不是VDP的始终不准确，而是vcenter的同步频率周期太长，）这就去同步</li>
<li>继续等</li>
<li>等可以点备份了，备份试下，</li>
<li>很好，不让备份，报错内容“vdp应用装置处于一下状态时无法备份 Admin“</li>
<li>VDP状态为Admin时不让开始备份任务，</li>
<li>抱着试试看的心态，我愚蠢的去完整性检查</li>
<li>这回厉害了，等半小时报错，这个故障现象一点信息量都没有（“暂时无法检查，请稍后再试”）</li>
<li>这里本菜鸡懵逼了，开启搜索模式，这里安利一个比官方kb 国内某论坛强一万倍的Communities（<a href="https://communities.vmware.com）" target="_blank" rel="noopener">https://communities.vmware.com）</a><br>首先登陆vdp的shell 先查看下服务的状态，步骤如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpnctl status</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Identity added: /home/dpn/.ssh/dpnid (/home/dpn/.ssh/dpnid)</span><br><span class="line">dpnctl: INFO: gsan status: degraded</span><br><span class="line">dpnctl: INFO: MCS status: up.</span><br><span class="line">dpnctl: INFO: emt status: up.</span><br><span class="line">dpnctl: INFO: Backup scheduler status: up.</span><br><span class="line">dpnctl: INFO: axionfs status: down.</span><br><span class="line">dpnctl: INFO: Maintenance windows scheduler status: enabled.</span><br><span class="line">dpnctl: INFO: Unattended startup status: enabled.</span><br><span class="line">dpnctl: INFO: avinstaller status: up.</span><br><span class="line">dpnctl: INFO: [see <span class="built_in">log</span> file <span class="string">"/usr/local/avamar/var/log/dpnctl.log"</span>]</span><br></pre></td></tr></table></figure>
<p>这里看到gsan状态是degraded 这个应该就是状态一直为admin的原因吧<br>重启下这个服务，然后启动所有服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpnctl stop gsan</span><br><span class="line">dpnctl start all</span><br></pre></td></tr></table></figure>
<p>再看状态为up了，而且我一直看着web-client 突然看到已用容量为90%多，（可能是幻觉吧）<br>服务状态对了，我再去完整性检查试下，点完之后又是等<br><img src="https://blog-image.nos-eastchina1.126.net/cDLCKJKLKi.png?imageslim" alt="mark"><br>这时候在看下服务的状态，又变回去了，我懵了，看着这些VDP报告，估计手动备份肯定也是要gg的<br>我去看log， /var/log/message 没有什么有价值的信息，<br>mail 也没什么信息，<br>/usr/local/avamar/var/log/ 下的日志，也没什么有用的信息</p>
<p>顺手执行了条 df -lh     <del>(不是rm -rf / , chmod -R 000 /)</del></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/JAJ1A9436A.png?imageslim" alt="mark"><br>数据盘全满<br>那么问题来了，为什么在WEB 上没有显示出来了，而且已用空间2% 备份点也一个都没有，<br>现在的思路</p>
<ol>
<li>vdp3与vcenter的认证出了问题，</li>
<li>vdp3的数据过大导致显示为0</li>
<li>BUG</li>
</ol>
<p>现在解决这个问题是矛盾的，<br>首先，正常来如果我的data01 data02  data03 没空间， 删除步骤或者清理步骤，应该是登录web-client 然后完整性检查，或者是去web上删除备份点，<br>我这么直接rm了不知道ok不ok，<br>查找kb和社区，给出的答案就是在shell下强制检查，我无法检查，报错，（有可能是空间不够我做整合或者检查的）<br>还有解决办法是联系技术支持，</p>
<p>好吧不纠结了， 就这样吧<br>一会儿还要上班呢，<br>明天来决定是rm 还是联系技术支持来搞，还是直接重新部署vdp、<br>睡了</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/A5gL4Gh3mE.jpg?imageslim" alt="mark"><br>August 4, 2017 2:53 AM</p>
]]></content>
      <categories>
        <category>Vmware</category>
      </categories>
      <tags>
        <tag>Backup</tag>
        <tag>Vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解数据压缩与重复数据删除(转载)</title>
    <url>/2017/07/28/Linux/storage/data1/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/liuaigui/article/details/6324133" target="_blank" rel="noopener">原文地址：http://blog.csdn.net/liuaigui/article/details/6324133</a></p>
<p><strong>[导读] </strong>数据压缩与重复数据删除两种技术有何区别与联系呢？实际中又该如何正确应用呢？笔者之前对数据压缩原理和技术没有研究，因此做了点功课，查阅整理了相关资料，并与重复数据删除技术进行对比分析。</p>
<p>面对数据的急剧膨胀，企业需要不断购置大量的存储设备来应对不断增长的存储需求。然而，单纯地提高存储容量，这似乎并不能从根本解决问题。首先，存储设备的采购预算越来越高，大多数企业难以承受如此巨大的开支。其次，随着数据中心的扩大，存储管理成本、占用空间、制冷能力、能耗等也都变得越来越严重，其中能耗尤为突出。再者，大量的异构物理存储资源大大增加了存储管理的复杂性，容易造成存储资源浪费和利用效率不高。因此，我们需要另辟蹊径来解决信息的急剧增长问题，堵住数据“井喷”。高效存储理念正是为此而提出的，它旨在缓解存储系统的空间增长问题，缩减数据占用空间，简化存储管理，最大程度地利用已有资源，降低成本。目前业界公认的五项高效存储技术分别是数据压缩、重复数据删除、自动精简配置、自动分层存储和存储虚拟化。目前，数据压缩和重复数据删除是实现数据缩减的两种关键技术。简而言之，数据压缩技术通过对数据重新编码来降低冗余度，而重复数据删除技术侧重于删除重复的数据块，从而实现数据容量缩减的目的。<br><a id="more"></a><br><strong>数据压缩</strong>[1][2]<br>数据压缩的起源可以追溯到信息论之父香农(Shannon)在1947年提出的香农编码。1952年霍夫曼(Huffman)提出了第一种实用性的编码<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>实现了数据压缩，该算法至今仍在广泛使用。1977年以色列数学家Jacob Ziv 和Abraham Lempel提出了一种全新的数据压缩编码方式，Lempel-Ziv系列算法(LZ77和LZ78，以及若干变种)凭借其简单高效等优越特性，最终成为目前主要数据压缩算法的基础。LZ系列算法属于无损数据压缩算法范畴，采用词曲编码技术实现，目前主要包括LZ77、LZSS、LZ78和LZW四种主流算法。可以归纳为两类：<br>第一类词典法的想法是企图查找正在压缩的字符序列是否在前面的输入数据中出现过，如果是，则用指向早期出现过的字符串的“指针”替代重复的字符串。这种编码思想如图1所示。这里的“词典”是隐含的，指用以前处理过的数据。这类编码中的所有算法都是以Abraham Lempel和Jakob Ziv在1977年开发和发表的算法（称为LZ77算法）为基础。此算法的一个改进算法是由Storer和Szymanski在1982年开发的，称为LZSS算法。</p>
<p><img src="http://hi.csdn.net/attachment/201104/14/44164_1302761960VTZC.gif" alt="img"></p>
<p><strong>图1 第一类词典法编码概念</strong></p>
<p>第二类算法的想法是企图从输入的数据中创建一个“短语词典(dictionary of the phrases)”。编码数据过程中当遇到已经在词典中出现的“短语”时，编码器就输出这个词典中的短语的“索引号”，而不是短语本身。这个概念如图2所示。A.Lempel和J.Ziv在1978年首次发表了介绍这种编码方法的文章，称为LZ78。在他们的研究基础上，Terry A.Welch在1984年发表对这种编码算法进行了改进的文章，并首先在高速硬盘控制器上应用了这种算法。因此后来把这种编码方法称为LZW(Lempel-Ziv Walch)压缩编码。</p>
<p><img src="http://hi.csdn.net/attachment/201104/14/44164_1302761976RIic.gif" alt="img"></p>
<p><strong>图2 第二类词典法编码概念</strong></p>
<p>Lempel-Ziv系列算法的基本思路是用位置信息替代原始数据从而实现压缩，解压缩时则根据位置信息实现数据的还原，因此又被称作”字典式”编码。目前存储应用中压缩算法的工业标准(ANSI、QIC、IETF、FRF、TIA/EIA)是LZS(Lempel-Ziv-Stac)，由Stac公司提出并获得专利，当前该专利权的所有者是Hifn, Inc.。数据压缩的应用可以显著降低待处理和存储的数据量，一般情况下可实现2:1 ~ 3:1的压缩比。</p>
<p><strong>LZ77算法</strong>[3]<br>1977年，Jacob Ziv和Abraham Lempel描述了一种基于滑动窗口缓存的技术，该缓存用于保存最近刚刚处理的文本（J. Ziv and A. Lempel, “A Universal Algorithm for Sequential Data Compression”, IEEE Transaction on Information Theory, May 1977）。这个算法一般称为LZ77。LZ77和它的变体发现，在正文流中词汇和短语(GIF中的图像模式)很可能会出现重复。当出现一个重复时，重复的序列可以用一个短的编码来代替。压缩程序扫描这样的重复，同时生成编码来代替重复序列。随着时间的过去，编码可以重用来捕获新的序列。算法必须设计成解压程序能够在编码和原始数据序列推导出当前的映射。</p>
<p><img src="http://hi.csdn.net/attachment/201104/14/44164_13027702616KVm.gif" alt="img"></p>
<p><strong>图3 LZ77算法示意图</strong></p>
<p>LZ77（及其变体）的压缩算法使用了两个缓存。滑动历史缓存包含了前面处理过的N个源字符，前向缓存包含了将要处理的下面L个字符。算法尝试将前向缓存开始的两个或多个字符与滑动历史缓存中的字符串相匹配。如果没有发现匹配，前向缓存的第一个字符作为9 bit的字符输出并且移入滑动窗口，滑动窗口中最久的字符被移出。如果找到匹配，算法继续扫描以找出最长的匹配。然后匹配字符串作为三元组输出（指示标记、指针和长度）。对于K个字符的字符串，滑动窗口中最久的K个字符被移出，并且被编码的K个字符被移入窗口。<br>尽管LZ77是有效的，对于当前的输入情况也是合适的，但是存在一些不足。算法使用了有限的窗口在以前的文本中查找匹配，对于相对于窗口大小来说非常长的文本块，很多可能的匹配就会被丢掉。窗口大小可以增加，但这会带来两个损失：(1)算法的处理时间会增加，因为它必须为滑动窗口的每个位置进行一次与前向缓存的字符串匹配的工作；(2)&lt;指针&gt;字段必须更长，以允许更长的跳转。</p>
<p><strong>LZSS算法</strong>[4]<br>LZS算法基于LZ77实现，主要由两部分构成，滑窗(Sliding Window)和自适应编码(Adaptive Coding)。压缩处理时，在滑窗中查找与待处理数据相同的块，并用该块在滑窗中的偏移值及块长度替代待处理数据，从而实现压缩编码。如果滑窗中没有与待处理数据块相同的字段，或偏移值及长度数据超过被替代数据块的长度，则不进行替代处理。LZS算法的实现非常简洁，处理比较简单，能够适应各种高速应用。</p>
<p>LZ77通过输出真实字符解决了在窗口中出现没有匹配串的问题，但这个解决方案包含有冗余信息。冗余信息表现在两个方面，一是空指针，二是编码器可能输出额外的字符，这种字符可能包含在下一个匹配串中。LZSS算法以比较有效的方法解决这个问题，它的思想是如果匹配串的长度比指针本身的长度长就输出指针，否则就输出真实字符。由于输出的压缩数据流中包含有指针和字符本身，为了区分它们就需要有额外的标志位，即ID位。<br>在相同的计算环境下，LZSS算法可获得比LZ77更高的压缩比，而译码同样简单。这也就是为什么这种算法成为开发新算法的基础。许多后来开发的文档压缩程序都使用了LZSS的思想，例如PKZip，ARJ，LHArc和ZOO等等，其差别仅仅是指针的长短、窗口的大小等有所不同。LZSS同样可以和熵编码联合使用，例如ARJ就与霍夫曼编码联用，而PKZip则与Shannon-Fano联用，它的后续版本也采用霍夫曼编码。</p>
<p><strong>LZ78算法</strong>[5]<br>LZ78的编码思想是不断地从字符流中提取新的“缀-符串(String)”（通俗地理解为新“词条”），然后用“代号”也就是码字(Code word)表示这个“词条”。这样一来，对字符流的编码就变成了用码字(Code word)去替换字符流，生成码字流，从而达到压缩数据的目的。与LZ77相比，LZ78的最大优点是在每个编码步骤中减少了缀-符串(String)比较的数目，而压缩率与LZ77类似。</p>
<p><strong>LZW算法</strong>[6]<br>LZW编码是围绕称为词典的转换表来完成的。这张转换表用来存放称为前缀(Prefix)的字符序列，并且为每个表项分配一个码字(Code word)，或者叫做序号。这张转换表实际上是把8位ASCII字符集进行扩充，增加的符号用来表示在文本或图像中出现的可变长度ASCII字符串。扩充后的代码可用9位、10位、11位、12位甚至更多的位来表示。Welch的论文中用了12位，12位可以有4096个不同的12位代码，这就是说，转换表有4096个表项，其中256个表项用来存放已定义的字符，剩下3840个表项用来存放前缀(Prefix)。<br>LZW编码器(软件编码器或硬件编码器)就是通过管理这个词典完成输入与输出之间的转换。LZW编码器的输入是字符流(Charstream)，字符流可以是用8位ASCII字符组成的字符串，而输出是用n位(例如12位)表示的码字流(Codestream)，码字代表单个字符或多个字符组成的字符串。<br>LZW算法得到普遍采用，它的速度比使用LZ77算法的速度快，因为它不需要执行那么多的缀-符串比较操作。对LZW算法进一步的改进是增加可变的码字长度，以及在词典中删除老的缀-符串。在GIF图像格式和UNIX的压缩程序中已经采用了加上这些改进措施之后的LZW算法。LZW算法取得了专利，专利权的所有者是美国的一个大型计算机公司—Unisys(优利系统公司)，除了商业软件生产公司之外，可以免费使用LZW算法。</p>
<p><strong>重复数据删除</strong>[1][7][8]<br>在备份、归档等实际的存储实践中，人们发现有大量的重复数据块存在，既占用了传输带宽又消耗了相当多的存储资源：有些新文件只是在原有文件上作了部分改动，还有某些文件存在着多份拷贝，如果对所有相同的数据块都只保留一份实例，实际存储的数据量将大大减少—这就是重复数据删除技术的基础。这一做法最早由普林斯顿大学李凯教授(DataDomain的三位创始人之一)提出，称之为全局压缩(Global Compression)，并作为容量优化存储推广到商业应用。<br>重复数据删除（Deduplication）是一种数据缩减技术，可对存储容量进行有效优化。它通过删除数据集中重复的数据，只保留其中一份，从而消除冗余数据，其原理如图4所示。Dedupe技术可以有效提高存储效率和利用率，数据可以缩减到原来的1/20～1/50。这种技术可以很大程度上减少对物理存储空间的需求，减少传输过程中的网络带宽，有效节约设备采购与维护成本。同时它也是一种绿色存储技术，能有效降低能耗。</p>
<p><img src="http://hi.csdn.net/attachment/201001/24/44164_126432902538rO.jpg" alt="img"></p>
<p><strong>图4 重复数据删除技术原理</strong></p>
<p>Dedupe按照消重的粒度可以分为文件级和数据块级。文件级的dedupe技术也称为单一实例存储（SIS, Single Instance Store），数据块级的重复数据删除，其消重粒度更小，可以达到4-24KB之间。显而易见，数据块级可以提供更高的数据消重率，因此目前主流的 dedupe产品都是数据块级的。Dedupe将文件分割成定长或变长的数据块，采用MD5/SHA1等Hash算法为数据块计算指纹（FP, Fingerprint）。可以同时使用两种及以上hash算法计算数据指纹，以获得非常小的数据碰撞发生概率。具有相同指纹的数据块即可认为是相同的数据块，存储系统中仅需要保留一份。这样，一个物理文件在存储系统就对应一个逻辑表示，由一组FP组成的元数据。当进行读取文件时，先读取逻辑文件，然后根据FP序列，从存储系统中取出相应数据块，还原物理文件副本。</p>
<p>Dedupe技术可以帮助众多应用降低数据存储量，节省网络带宽，提高存储效率，减小备份窗口，有效节省成本。Dedupe技术目前最成功的应用领域是数据备份、容灾和归档系统，然而事实上dedupe技术可以用于很多场合，包括在线数据、近线数据、离线数据存储系统，可以在文件系统、卷管理器、NAS、SAN中实施。Dedupe也可以用数据传输与同步，作为一种数据压缩技术可用于数据打包。为什么dedupe技术最成功的应用是数据备份领域，而其他领域应用很少呢？这主要由两方面的原因决定的，一是数据备份应用对数据进行多次备份后，存在大量重复数据，非常适合这种技术。二是dedupe技术的缺陷，主要是数据安全、性能。Dedupe使用hash指纹来识别相同数据，存在产生数据碰撞并导致数据不一致性的可能性。Dedupe需要进行数据块切分、数据块指纹计算和数据块检索，消耗可观的系统资源，对存储系统性能产生影响。</p>
<p>Dedupe的衡量维度主要有两个，即重复数据删除率（Deduplication ratios）和性能。Dedupe性能取决于具体实现技术，而重复数据删除率则由数据自身的特征和应用模式所决定，目前各存储厂商公布的重复数据删除率从20:1到500:1不等。对何种数据进行消重，时间数据还是空间数据，全局数据还是局部数据？何时进行消重，在线还是离线？在何处进行消重，源端还是目标端？如何进行消重？实际应用Dedupe技术时应该考虑各种因素，因为这些因素会直接影响其性能和效果。另外值得一得的是，hash碰撞问题现在还没有根本的解决方法，因此对于关键业务数据应该慎重考虑应用dedupe技术。</p>
<p>存储系统的重复数据删除过程一般是这样的：首先将数据文件分割成一组数据块，为每个数据块计算指纹，然后以指纹为关键字进行Hash查找，匹配则表示该数据块为重复数据块，仅存储数据块索引号，否则则表示该数据块是一个新的唯一块，对数据块进行存储并创建相关元信息。这样，一个物理文件在存储系统就对应一个逻辑表示，由一组FP组成的元数据。当进行读取文件时，先读取逻辑文件，然后根据FP序列，从存储系统中取出相应数据块，还原物理文件副本。从如上过程中可以看出，Dedupe的关键技术主要包括文件数据块切分、数据块指纹计算和数据块检索。</p>
<p>重复数据删除技术的关键在于数据块”指纹”的生成和鉴别。数据块”指纹”是鉴别数据块是否重复的依据，如果不同数据块的”指纹”相同，就会造成内容丢失，产生不可恢复的严重后果。在目前的实际应用中，一般都选择MD5或SHA-1等标准杂凑(hash)算法生成的数据块的摘要(digest)作为”指纹”，以区分不同数据块间存在的差异，从而保证不同数据块之间不会发生冲突。但是，MD5，SHA-1等算法的计算过程非常复杂，纯软件计算很难满足存储应用的性能需求，”指纹”的计算往往成为重复数据删除应用的性能瓶颈。</p>
<p><strong>数据压缩与重复数据删除对比分析</strong><br>数据压缩和重复数据删除技术都着眼于减少数据量，其差别在于数据压缩技术的前提是信息的数据表达存在冗余，以信息论研究作为基础;而重复数据删除的实现依赖数据块的重复出现，是一种实践性技术。然而，通过上面的分析我们发现，这两种技术在本质上却是相同的，即通过检索冗余数据并采用更短的指针来表示来实现缩减数据容量。它们的区别关键在于，消除冗余范围不同，发现冗余方法不同，冗余粒度不同，另外在具体实现方法有诸多不同。<br><strong>(1)消除冗余范围</strong><br>数据压缩通常作用于数据流，消除冗余范围受到滑动窗口或缓存窗口的限制。由于考虑性能因素，这个窗口通常是比较小的，只能对局部数据产生作用，对单个文件效果明显。重复数据删除技术先对所有数据进行分块，然后以数据块为单位在全局范围内进行冗余消除，因此对包含众多文件的全局存储系统，如文件系统，效果更加显著。如果把数据压缩应用于全局，或者把重复数据删除应用于单个文件，则数据缩减效果要大大折扣。</p>
<p><strong>(2)发现冗余方法</strong>数据压缩主要通过串匹配来检索相同数据块，主要采用字符串匹配算法及其变种，这是精确匹配。重复数据删除技术通过数据块的数据指纹来发现相同数据块，数据指纹采用hash函数计算获得，这是模糊匹配。精确匹配实现较为复杂，但精度高，对细粒度消除冗余更为有效；模糊匹配相对简单许多，对大粒度的数据块更加适合，精度方面不够。</p>
<p><strong>(3)冗余粒度</strong>数据压缩的冗余粒度会很小，可以到几个字节这样的小数据块，而且是自适应的，不需要事先指定一个粒度范围。重复数据删除则不同，数据块粒度比较大，通常从512到8K字节不等。数据分块也不是自适应的，对于定长数据块需要事先指定长度，变长数据分块则需要指定上下限范围。更小的数据块粒度会获得更大的数据消冗效果，但计算消耗也更大。</p>
<p><strong>(4)性能瓶颈</strong><br>数据压缩的关键性能瓶颈在于数据串匹配，滑动窗口或缓存窗口越大，这个计算量就会随之大量增加。重复数据删除的性能瓶颈在于数据分块与数据指纹计算，MD5/SHA-1等hash函数的计算复杂性都非常高，非常占用CPU资源。另外，数据指纹需要保存和检索，通常需要大量内存来构建hash表，如果内存有限则会对性能产生严重影响。</p>
<p><strong>(5)数据安全</strong><br>这里的数据压缩都是无损压缩，不会发生数据丢失现象，数据是安全的。重复数据删除的一个问题是，利用hash产生的数据块指纹可能会产生的碰撞，即两个不同的数据块生成了相同的数据指纹。这样，就会造成一个数据块丢失的情况发生，导致数据发生破坏。因此，重复数据删除技术存在数据安全隐患。</p>
<p><strong>(6)应用角度</strong><br>数据压缩直接对流式数据进行处理，不需要事先对全局信息进行分析统计，可以很好地利用流水线或管道方式与其他应用结合使用，或以带内方式透明地作用于存储系统或网络系统。重复数据删除则需要对数据进行分块处理，需要对指纹进行存储和检索，需要对原先物理文件进行逻辑表示。如果现有系统要应用这种技术，则需要对应用进行修改，难以做到透明实现。目前重复数据删除并不是一个通常功能，而更多地以产品形态出现，如存储系统、文件系统或应用系统。因此，数据压缩是一种标准功能，而重复数据删除现在还没有达到这种标准，应用角度来看，数据压缩更为简单。</p>
<p><strong>珠联璧合</strong><br>数据压缩与重复数据删除两种技术具有不同层面的针对性，并能够结合起来使用，从而实现更高的数据缩减比例。值得一提的是，如果同时应用数据压缩和重复数据删除技术，为了降低对系统的处理需求和提高数据压缩比率，通常需要先应用数据删除技术，然后再使用数据压缩技术进一步降低”结构图”和基本数据块的体积。如果顺序颠倒会出现什么样的结果呢？压缩会对数据进行重新编码，从而破坏了数据原生的冗余结构，因此再应用重复数据删除效果则会大打折扣，而且消耗时间也更多。而先执行重复数据删除则不同，它首先消除了冗余数据块，然后应用数据压缩对唯一副本数据块进行再次压缩。这样，两种技术的数据缩减作用得到叠加，而且数据压缩的消耗时间大大降低。因此，先去重后压缩，可以获得更高的数据压缩率和性能。这里我们以gzip和作者自己实现的开源小软件<a href="http://sourceforge.net/projects/deduputil/" target="_blank" rel="noopener">deduputil</a>[8]来验证这个应用经验。</p>
<p>原始数据：<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>-2.6.37内核源码，du -h的容量为1107724KB，约1081.8MB。<br>对<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">linux</a>-2.6.37目录执行time gzip -c -r linux-2.6.37 &gt; linux-2.6.37.gz，压缩得到linux-2.6.37.gz，容量约为264MB，消耗时间152.776s；<br>对linux-2.6.37目录执行time dedup -c -b 4096 linux-2.6.37.ded linux-2.6.37，去重得到linux-2.6.37.ded，容量约为622MB，消耗时间28.890s；<br>对linux-2.6.37.gz执行time dedup -c -b 4096 linux-2.6.37.gz.ded linux-2.6.37.gz，去重得到linux-2.6.37.gz.ded，容量约为241MB，消耗时间7.216；<br>对linux-2.6.37.ded执行time gzip -c linux-2.6.37.ded &gt; linux-2.6.37.ded.gz，压缩得到linux-2.6.36.ded.gz，容量约为176MB，消耗时间38.682；<br>经过实验可得，dedup + gzip得到的linux-2.6.37.ded.gz容量为176MB，消耗时间为67.572秒；gzip + dedup得到的linux-2.6.37.gz.ded容量为241MB，消耗时间为159.992秒。实验数据进一步验证了上述的分析，先数据去重再数据压缩，能够获得更高的数据压缩率和性能。</p>
<p><strong>参考阅读</strong>1 数据缩减技术 <a href="http://tech.watchstor.com/management-116492.htm" target="_blank" rel="noopener">http://tech.watchstor.com/management-116492.htm</a><br>2 数据压缩原理 <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_1.htm" target="_blank" rel="noopener">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_1.htm</a><br>3 LZ77算法 <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_2.htm" target="_blank" rel="noopener">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_2.htm</a><br>4 LZSS算法 <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_3.htm" target="_blank" rel="noopener">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_3.htm</a><br>5 LZ78算法 <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_4.htm" target="_blank" rel="noopener">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_4.htm</a><br>6 LZW算法 <a href="http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_5.htm" target="_blank" rel="noopener">http://jpkc.zust.edu.cn/2007/dmt/course/MMT03_05_5.htm</a><br>7 重复数据删除技术研究 <a href="http://blog.csdn.net/liuben/archive/2010/08/21/5829083.aspx" target="_blank" rel="noopener">http://blog.csdn.net/liuben/archive/2010/08/21/5829083.aspx</a><br>8 高效存储技术研究 <a href="http://blog.csdn.net/liuben/archive/2010/12/08/6064045.aspx" target="_blank" rel="noopener">http://blog.csdn.net/liuben/archive/2010/12/08/6064045.aspx</a><br>8 Deduputil <a href="http://sourceforge.net/projects/deduputil/" target="_blank" rel="noopener">http://sourceforge.net/projects/deduputil/</a></p>
]]></content>
      <categories>
        <category>Backup</category>
      </categories>
      <tags>
        <tag>Backup</tag>
        <tag>数据压缩</tag>
        <tag>重复数据删除</tag>
      </tags>
  </entry>
  <entry>
    <title>重复数据删除和数据压缩之间的确切区别</title>
    <url>/2017/07/28/Linux/storage/Deduplication/</url>
    <content><![CDATA[<p>重复数据删除可以被视为一种高度专门的压缩形式，针对特定的上下文。接下来的长的答案。在对比这些技术之前，让我们来谈谈一些典型的压缩方式。压缩压缩本身是非常多样的。您有有损压缩算法，例如JPEG和MP3，它们使用我们看到或听到的模型来丢弃一些可能对图像或声音不重要的信息，但仍降低了质量。根据您的问题，这些技术大都不在此问题的范围之内。您可能主要关心的是我们所说的通用无损算法，如zip，LZMA，LZ4等，可以以可逆的方式压缩任意文件。通常这些压缩文件至少使用以下非详尽列表中的几种技术：匹配查找 在（重复字节串）中找到冗余，并用较短的序列替换重复。例如，这样的算法可能具有字符串：<code>developers developers developers developers</code>然后用以下代码替换：<code>developers (0,11)(0,22)</code>其中（0,11）表示“从位置0开始重新使用11个字符”。这被称为“匹配发现”或LZ77风格的压缩，是直截了当的。熵编码。您可以从以下字符串开始：<code>AABCABBCABACBAAACBCCAABAAACBAA</code>这看起来很随机，对吧？但是，您可能会注意到，某些字母比其他字母更多出现 - A出现在B和C两倍左右，其他字母根本不会出现！使用该信息，可以选择表示与更少的信息，例如，该串中的字符的编码，A可以使用二进制编码<code>0</code>，而B和C被指派<code>10</code>和<code>11</code>分别。如果你最初每个字符使用8位，这是一个很大的节省。造型大多数数据具有复杂的关系，这些关系不一定很好地被上面简单的技术压缩，而是需要一些类型的模型。例如，您可能有各种模型可以根据相邻像素预测图像中像素的值。您可能有一个模型，根据该句子预测句子中最可能的下一个单词。例如，如果我说：<code>Who let the dogs ___</code>你可能能够高精度地填写空白。这些都不是相互排斥的 - 它们通常以互补的方式使用，并且还有以上没有提及的附加技术。现在，在讨论重复数据删除之前，确切地说，值得注意的是压缩算法的典型特征。这些不是绝对的<em>规则</em>，而是许多压缩算法的常见特征，除非它们被专门设计来避免它们：<em>输入字节和输出字节之间没有简单的关系。</em>输入和输出以复杂的方式相关（不同的是，Base-64编码，其中每3个连续输入字节按顺序对应到4个连续的输出字节）。其含义如下：您经常不能简单地获取压缩数据并解压缩其任意部分，例如“解压缩此文件的最后500个字节”。您可能需要从头开始读取整个压缩文件，或至少从流中的一些着名点开始。未压缩输入的修改可能对压缩输出有任意大的影响。例如，更改输入中的单字节可能会改变输出中的每个后续字节。这通常意味着很难逐渐更新大型压缩流（即，基于对输入的修改）。重复数据删除所以考虑到上述压缩的定义和讨论，重复数据删除通常意味着什么？今天，您通常会在存储设备或体系结构比赛中介绍<em>重复数据删除技术</em>。例如，当存在大量重复数据时，这是一种节省磁盘空间的方法（例如，在SAN上有100个VM映像 - 操作系统和其他常见的可能会有很多重复每个虚拟机上的文件）。重复数据删除是将这种冗余数据仅存储一次的一种方法。实质上，它实现了大规模的上述技术（1），没有上面讨论的一些限制。因此，它只是一种压缩形式，可在大块区域，跨整个驱动器或整个存储主机，甚至跨网络机器集群上运行。现在，您不能只是“gzip”整个驱动器，因为重复数据删除应该是透明的，功能上和性能方面的。文件系统提供的API（例如POSIX或Win32等）允许用户写入文件的任意部分。如果用户修改1GB文件中的1个字节，如果这需要一分钟或更长时间解压缩然后压缩整个文件，那么它们会感到惊讶。因此，重复数据删除工作方式是可以随意访问文件，例如，通过具有使得任何字节的位置可以被定位的索引）。这通常意味着重复数据删除仅适用于大型匹配（块）大小，否则跟踪块的成本变得令人望而却步。一些系统只能检测到符合其他条件的重复，如在文件中具有相同的对齐方式。重复数据消除通常会透明地发生（文件系统的用户不知道），也可能会异步发生：即，当新数据写入时，它首先被视为唯一的，只有稍后才能检查重复数据，并可能与现有数据合并。简而言之，重复数据删除可以被认为是一种类型的压缩的特定应用，调整到将要用于的域中：去除典型压缩算法的一些限制，以换取可接受的性能，但是以牺牲大的重复区域为代价，并且通常避免其他压缩机会，例如 熵编码 或 建模。</p>
]]></content>
      <categories>
        <category>Backup</category>
      </categories>
      <tags>
        <tag>Backup</tag>
      </tags>
  </entry>
  <entry>
    <title>Ceph常用命令</title>
    <url>/2017/07/28/Linux/storage/ceph/</url>
    <content><![CDATA[<p>Whether you want to provide Ceph Object Storage and/or Ceph Block Device services to Cloud Platforms, deploy a Ceph Filesystem or use Ceph for another purpose, all Ceph Storage Cluster deployments begin with setting up each Ceph Node, your network, and the Ceph Storage Cluster. A Ceph Storage Cluster requires at least one Ceph Monitor, Ceph Manager, and Ceph OSD (Object Storage Daemon). The Ceph Metadata Server is also required when running Ceph Filesystem clients.<br><a id="more"></a><br><img src="https://blog-image.nos-eastchina1.126.net/7jFFdagBFi.png" alt="mark"></p>
<ul>
<li><strong>Monitors</strong> : A Ceph Monitor (ceph-mon) maintains maps of the cluster state, including the monitor map, manager map, the OSD map, and the CRUSH map. These maps are critical cluster state required for Ceph daemons to coordinate with each other. Monitors are also responsible for managing authentication between daemons and clients. At least three monitors are normally required for redundancy and high availability.</li>
<li><strong>Managers</strong> : A Ceph Manager daemon (ceph-mgr) is responsible for keeping track of runtime metrics and the current state of the Ceph cluster, including storage utilization, current performance metrics, and system load. The Ceph Manager daemons also host python-based plugins to manage and expose Ceph cluster information, including a web-based dashboard and REST API. At least two managers are normally required for high availability.</li>
<li><strong>Ceph OSDs</strong> : A Ceph OSD (object storage daemon, ceph-osd) stores data, handles data replication, recovery, rebalancing, and provides some monitoring information to Ceph Monitors and Managers by checking other Ceph OSD Daemons for a heartbeat. At least 3 Ceph OSDs are normally required for redundancy and high availability.</li>
<li><strong>MDSs</strong> : A Ceph Metadata Server (MDS, ceph-mds) stores metadata on behalf of the Ceph Filesystem (i.e., Ceph Block Devices and Ceph Object Storage do not use MDS). Ceph Metadata Servers allow POSIX file system users to execute basic commands (like ls, find, etc.) without placing an enormous burden on the Ceph Storage Cluster.</li>
</ul>
<p>Ceph stores data as objects within logical storage pools. Using the CRUSH algorithm, Ceph calculates which placement group should contain the object, and further calculates which Ceph OSD Daemon should store the placement group. The CRUSH algorithm enables the Ceph Storage Cluster to scale, rebalance, and recover dynamically.</p>
<h1 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h1><h2 id="监视器命令"><a href="#监视器命令" class="headerlink" title="监视器命令"></a>监视器命令</h2><p>监视器命令用 <code>ceph</code> 工具发出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph [-m monhost] &#123;<span class="built_in">command</span>&#125;</span><br></pre></td></tr></table></figure>
<p>命令格式通常是（但不总是）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph &#123;subsystem&#125; &#123;<span class="built_in">command</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><p>下列命令显示集群状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph -s</span><br><span class="line">ceph status</span><br></pre></td></tr></table></figure>
<p>下列命令显示集群状态的运行摘要、及主要事件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph -w</span><br></pre></td></tr></table></figure>
<p>下列命令显示监视器法定人数状态，包括哪些监视器参与着、哪个是首领。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph quorum_status</span><br></pre></td></tr></table></figure>
<p>下列命令查询单个监视器状态，包括是否在法定人数里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph [-m monhost] mon_status</span><br></pre></td></tr></table></figure>
<h2 id="认证子系统"><a href="#认证子系统" class="headerlink" title="认证子系统"></a>认证子系统</h2><p>要添加一个 OSD 的密钥环，执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph auth add &#123;osd&#125; &#123;--<span class="keyword">in</span>-file|-i&#125; &#123;path-to-osd-keyring&#125;</span><br></pre></td></tr></table></figure>
<p>要列出集群的密钥及其能力，执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph auth list</span><br></pre></td></tr></table></figure>
<h2 id="归置组子系统"><a href="#归置组子系统" class="headerlink" title="归置组子系统"></a>归置组子系统</h2><p>要显示所有归置组的统计信息，执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump [--format &#123;format&#125;]</span><br></pre></td></tr></table></figure>
<p>可用输出格式有 <code>plain</code> （默认）和 <code>json</code> 。</p>
<p>要显示卡在某状态的所有归置组，执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump_stuck inactive|unclean|stale|undersized|degraded [--format &#123;format&#125;] [-t|--threshold &#123;seconds&#125;]</span><br></pre></td></tr></table></figure>
<p><code>--format</code> 可以是 <code>plain</code> （默认）或 <code>json</code></p>
<p><code>--threshold</code> 定义了多久算“卡住了”（默认 300 秒）</p>
<p><strong>Inactive</strong> 归置组不能处理读或写，因为它们在等待数据及时更新的 OSD 回来。</p>
<p><strong>Unclean</strong> 归置组包含副本数未达期望值的对象，它们应该在恢复中。</p>
<p><strong>Stale</strong> 归置组处于未知状态——归置组所托付的 OSD 有一阵没向监视器报告了（由 <code>mon osd report timeout</code> 配置）。</p>
<p>删除“丢失”对象，或者恢复到其先前状态，可以是前一版本、或如果刚创建就干脆删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg &#123;pgid&#125; mark_unfound_lost revert|delete</span><br></pre></td></tr></table></figure>
<h2 id="OSD-子系统"><a href="#OSD-子系统" class="headerlink" title="OSD 子系统"></a>OSD 子系统</h2><p>查询 OSD 子系统状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd <span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<p>把最新的 OSD 运行图拷贝到一个文件，参见 <a href="http://docs.ceph.com/docs/master/man/8/osdmaptool/" target="_blank" rel="noopener">osdmaptool</a> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd getmap -o file</span><br></pre></td></tr></table></figure>
<p>从最新 OSD 运行图拷出 CRUSH 图：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd getcrushmap -o file</span><br></pre></td></tr></table></figure>
<p>前述功能等价于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd getmap -o /tmp/osdmap</span><br><span class="line">osdmaptool /tmp/osdmap --<span class="built_in">export</span>-crush file</span><br></pre></td></tr></table></figure>
<p>转储 OSD 运行图， <code>-f</code> 的可用格式有 <code>plain</code> 和 <code>json</code> ，如未指定 <code>--format</code> 则转储为纯文本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd dump [--format &#123;format&#125;]</span><br></pre></td></tr></table></figure>
<p>把 OSD 运行图转储为树，每个 OSD 一行、包含权重和状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd tree [--format &#123;format&#125;]</span><br></pre></td></tr></table></figure>
<p>找出某对象在哪里或应该在哪里：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd map &lt;pool-name&gt; &lt;object-name&gt;</span><br></pre></td></tr></table></figure>
<p>增加或挪动一个新 OSD 条目，要给出 id/name/weight 和位置参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd crush <span class="built_in">set</span> &#123;id&#125; &#123;weight&#125; [&#123;loc1&#125; [&#123;loc2&#125; ...]]</span><br></pre></td></tr></table></figure>
<p>从现有 CRUSH 图删除存在的条目（ OSD ）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd crush remove &#123;name&#125;</span><br></pre></td></tr></table></figure>
<p>从现有 CRUSH 图删除存在的空桶：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd crush remove &#123;bucket-name&#125;</span><br></pre></td></tr></table></figure>
<p>把有效的桶从分级结构里的一个位置挪到另一个。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd crush move &#123;id&#125; &#123;loc1&#125; [&#123;loc2&#125; ...]</span><br></pre></td></tr></table></figure>
<p>设置 <code>{name}</code> 所指条目的权重为 <code>{weight}</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd crush reweight &#123;name&#125; &#123;weight&#125;</span><br></pre></td></tr></table></figure>
<p>创建集群快照。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd cluster_snap &#123;name&#125;</span><br></pre></td></tr></table></figure>
<p>把 OSD 标记为丢失，有可能导致永久性数据丢失，慎用！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd lost &#123;id&#125; [--yes-i-really-mean-it]</span><br></pre></td></tr></table></figure>
<p>创建新 OSD 。如果未指定 ID ，有可能的话将自动分配个新 ID 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd create [&#123;uuid&#125;]</span><br></pre></td></tr></table></figure>
<p>删除指定 OSD 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd rm [&#123;id&#125;...]</span><br></pre></td></tr></table></figure>
<p>查询 OSD 运行图里的 max_osd 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd getmaxosd</span><br></pre></td></tr></table></figure>
<p>导入指定 CRUSH 图。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd setcrushmap -i file</span><br></pre></td></tr></table></figure>
<p>设置 OSD 运行图的 <code>max_osd</code> 参数，扩展存储集群时有必要。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd setmaxosd</span><br></pre></td></tr></table></figure>
<p>把 ID 为 <code>{osd-num}</code> 的 OSD 标记为 down 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd down &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>把 OSD <code>{osd-num}</code> 标记为数据分布之外（即不给分配数据）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd out &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>把 OSD <code>{osd-num}</code> 标记为数据分布之内（即分配了数据）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd <span class="keyword">in</span> &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>列出 Ceph 集群载入的类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph class list</span><br></pre></td></tr></table></figure>
<p>设置或清空 OSD 运行图里的暂停标记。若设置了，不会有 IO 请求发送到任何 OSD ；用 <code>unpause</code> 清空此标记会导致重发未决的请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pause</span><br><span class="line">ceph osd unpause</span><br></pre></td></tr></table></figure>
<p>把 <code>{osd-num}</code> 的权重设置为 <code>{weight}</code> ，权重相同的两个 OSD 大致会收到相同的 I/O 请求、并存储相同数量的数据。 <code>ceph osd reweight</code> 命令可给 OSD 设置一个增益权重，有效值在 0 和 1 之间，它使得 CRUSH 重新归置一定数量的、本应该放到此处的数据。它不会影响 crush 图里所分配的权重，在 CRUSH 分布算法没能理想地执行时，它可作为一种纠正手段。比如，假设你的某个 OSD 使用率达到了 90% ，但其它的大致都在 50% ，这时你就可以试着下调此权重来补偿它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd reweight &#123;osd-num&#125; &#123;weight&#125;</span><br></pre></td></tr></table></figure>
<p>重设所有滥用 OSD 的权重，它默认会下调达到平均利用率 120% 的那些OSD ，除非你指定了阀值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd reweight-by-utilization [threshold]</span><br></pre></td></tr></table></figure>
<p>增加、删除黑名单里的地址。增加地址的时候可以指定有效期，否则有效期为 1 小时。黑名单里的地址不允许连接任何 OSD ，此技术常用于防止滞后的元数据服务器“错爱” OSD 上的数据。</p>
<p>这些命令大多只在故障测试时有用，因为黑名单是自动维护的，无需手动干涉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd blacklist add ADDRESS[:source_port] [TIME]</span><br><span class="line">ceph osd blacklist rm ADDRESS[:source_port]</span><br></pre></td></tr></table></figure>
<p>创建/删除存储池快照。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool mksnap &#123;pool-name&#125; &#123;snap-name&#125;</span><br><span class="line">ceph osd pool rmsnap &#123;pool-name&#125; &#123;snap-name&#125;</span><br></pre></td></tr></table></figure>
<p>创建/删除/重命名存储池。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool create &#123;pool-name&#125; pg_num [pgp_num]</span><br><span class="line">ceph osd pool delete &#123;pool-name&#125; [&#123;pool-name&#125; --yes-i-really-really-mean-it]</span><br><span class="line">ceph osd pool rename &#123;old-name&#125; &#123;new-name&#125;</span><br></pre></td></tr></table></figure>
<p>更改存储池设置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool <span class="built_in">set</span> &#123;pool-name&#125; &#123;field&#125; &#123;value&#125;</span><br></pre></td></tr></table></figure>
<p>可用的 field 值有：</p>
<blockquote>
<ul>
<li><code>size</code>: 设置存储池内数据的副本数；</li>
<li><code>crash_replay_interval</code>: 允许客户端重放确认而未提交的请求前等待的时间，秒；</li>
<li><code>pg_num</code>: 归置组数量；</li>
<li><code>pgp_num</code>: 计算归置组存放的有效数量；</li>
<li><code>crush_ruleset</code>: 用于归置映射的规则号。</li>
</ul>
</blockquote>
<p>获取存储池配置值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd pool get &#123;pool-name&#125; &#123;field&#125;</span><br></pre></td></tr></table></figure>
<p>可用的 field 值有：</p>
<blockquote>
<ul>
<li><code>pg_num</code>: 归置组数量；</li>
<li><code>pgp_num</code>: 计算归置组存放的有效数量；</li>
<li><code>lpg_num</code>: 本地归置组数量；</li>
<li><code>lpgp_num</code>: 用于存放本地归置组的数量。</li>
</ul>
</blockquote>
<p>向 OSD <code>{osd-num}</code> 下达一个洗刷命令，用通配符 <code>*</code> 把命令下达到所有 OSD 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd scrub &#123;osd-num&#125;</span><br></pre></td></tr></table></figure>
<p>向 osdN 下达修复命令，用 <code>*</code> 下达到所有 OSD 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph osd repair N</span><br></pre></td></tr></table></figure>
<p>在 osdN 上进行个简单的吞吐量测试，每次写入 <code>BYTES_PER_WRITE</code> 、一共写入 <code>TOTAL_BYTES</code> 。默认以 4MB 增量写入 1GB 。 此压力测试是非破坏性的，不会覆盖已有 OSD 数据，但可能会暂时影响同时访问此 OSD 的客户端性能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph tell osd.N bench [NUMER_OF_OBJECTS] [BYTES_PER_WRITE]</span><br></pre></td></tr></table></figure>
<h2 id="MDS-子系统"><a href="#MDS-子系统" class="headerlink" title="MDS 子系统"></a>MDS 子系统</h2><p>更改在运行 mds 的参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph tell mds.&#123;mds-id&#125; injectargs --&#123;switch&#125; &#123;value&#125; [--&#123;switch&#125; &#123;value&#125;]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph tell mds.0 injectargs --debug_ms 1 --debug_mds 10</span><br></pre></td></tr></table></figure>
<p>打开了调试消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mds <span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<p>显示所有元数据服务器状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mds fail 0</span><br></pre></td></tr></table></figure>
<p>把活跃 MDS 标记为失败，如果有候补此命令会触发故障转移。</p>
<p>Todo</p>
<p> <code>ceph mds</code> 子命令缺少文档：set, dump, getmap, stop, setmap</p>
<h2 id="监视器子系统"><a href="#监视器子系统" class="headerlink" title="监视器子系统"></a>监视器子系统</h2><p>查看监视器状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mon <span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line">2011-12-14 10:40:59.044395 mon &#123;- [mon,<span class="built_in">stat</span>]</span><br><span class="line">2011-12-14 10:40:59.057111 mon.1 -&#125; <span class="string">'e3: 5 mons at &#123;a=10.1.2.3:6789/0,b=10.1.2.4:6789/0,c=10.1.2.5:6789/0,d=10.1.2.6:6789/0,e=10.1.2.7:6789/0&#125;, election epoch 16, quorum 0,1,2,3'</span> (0)</span><br></pre></td></tr></table></figure>
<p>末尾的 <code>quorum</code> 列表列出了当前法定人数里的监视器节点。</p>
<p>也可以更直接地获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ceph quorum_status</span><br><span class="line"></span><br><span class="line">2011-12-14 10:44:20.417705 mon &#123;- [quorum_status]</span><br><span class="line">2011-12-14 10:44:20.431890 mon.0 -&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'&#123; "election_epoch": 10,</span><br><span class="line">  "quorum": [</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        2],</span><br><span class="line">  "monmap": &#123; "epoch": 1,</span><br><span class="line">      "fsid": "444b489c-4f16-4b75-83f0-cb8097468898",</span><br><span class="line">      "modified": "2011-12-12 13:28:27.505520",</span><br><span class="line">      "created": "2011-12-12 13:28:27.505520",</span><br><span class="line">      "mons": [</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6789\/0"&#125;,</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"b"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6790\/0"&#125;,</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"c"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6791\/0"&#125;]&#125;&#125;' (0)</span><br></pre></td></tr></table></figure>
<p>如果法定人数未形成，上述命令会一直等待。</p>
<p>你刚刚连接的监视器的状态（用 <code>-m HOST:PORT</code> 另外指定）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mon_status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2011-12-14 10:45:30.644414 mon &#123;- [mon_status]</span><br><span class="line">2011-12-14 10:45:30.644632 mon.0 -&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'&#123; "name": "a",</span><br><span class="line">  "rank": 0,</span><br><span class="line">  "state": "leader",</span><br><span class="line">  "election_epoch": 10,</span><br><span class="line">  "quorum": [</span><br><span class="line">        0,</span><br><span class="line">        1,</span><br><span class="line">        2],</span><br><span class="line">  "outside_quorum": [],</span><br><span class="line">  "monmap": &#123; "epoch": 1,</span><br><span class="line">      "fsid": "444b489c-4f16-4b75-83f0-cb8097468898",</span><br><span class="line">      "modified": "2011-12-12 13:28:27.505520",</span><br><span class="line">      "created": "2011-12-12 13:28:27.505520",</span><br><span class="line">      "mons": [</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"a"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6789\/0"&#125;,</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"b"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6790\/0"&#125;,</span><br><span class="line">            &#123; <span class="attr">"rank"</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="attr">"name"</span>: <span class="string">"c"</span>,</span><br><span class="line">              "addr": "127.0.0.1:6791\/0"&#125;]&#125;&#125;' (0)</span><br></pre></td></tr></table></figure>
<p>监视器状态转储：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mon dump</span><br><span class="line"></span><br><span class="line">2011-12-14 10:43:08.015333 mon &#123;- [mon,dump]</span><br><span class="line">2011-12-14 10:43:08.015567 mon.0 -&#125; <span class="string">'dumped monmap epoch 1'</span> (0)</span><br><span class="line">epoch 1</span><br><span class="line">fsid 444b489c-4f16-4b75-83f0-cb8097468898</span><br><span class="line">last_changed 2011-12-12 13:28:27.505520</span><br><span class="line">created 2011-12-12 13:28:27.505520</span><br><span class="line">0: 127.0.0.1:6789/0 mon.a</span><br><span class="line">1: 127.0.0.1:6790/0 mon.b</span><br><span class="line">2: 127.0.0.1:6791/0 mon.c</span><br></pre></td></tr></table></figure>
<p><a href="http://docs.ceph.com/docs/master/rados/operations/control/" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Ceph</category>
      </categories>
      <tags>
        <tag>Ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU虚拟化基本知识</title>
    <url>/2017/07/22/Virtualized-Resource/CPU-virtualization/</url>
    <content><![CDATA[<p>CPU 虚拟化着重于性能，只要有可能就会直接在处理器上运行。只要有可能就会使用基础物理资源，且虚拟化层仅在需要时才运行指令，使得虚拟机就像直接在物理机上运行一样。</p>
<p>CPU 虚拟化与仿真不同。ESXi 不使用仿真来运行虚拟 CPU。采用仿真时，所有操作均由仿真器在软件中运行。软件仿真器允许程序在不同于最初编写时所针对的计算机系统上运行。仿真器通过接受相同的数据或输入并获得相同的结果，来模拟或再现原始计算机的行为，从而实现仿真。仿真提供了可移植能力，并在几个不同平台上运行针对一个平台而设计的软件。</p>
<p>CPU 资源过载时，ESXi 主机将在所有虚拟机之间对物理处理器进行时间划分，以便每个虚拟机在运行时就如同具有指定数目的虚拟处理器一样。运行多个虚拟机的 ESXi 主机会为各虚拟机分配一定份额的物理资源。如果使用默认资源分配设置，与同一主机关联的所有虚拟机都将在每个虚拟 CPU 上收到相同份额的 CPU。这意味着单处理器虚拟机分配到的资源只有双处理器虚拟机的一半。<br><a id="more"></a></p>
<h1 id="基于软件的CPU虚拟化"><a href="#基于软件的CPU虚拟化" class="headerlink" title="基于软件的CPU虚拟化"></a>基于软件的CPU虚拟化</h1><p>采用基于软件的CPU虚拟化后，客户机应用程序代码直接在处理器上运行，同时转换客户机特权代码并在处理器上运行转换后的代码。</p>
<p>转换后的代码有点大，通常比本机运行速度慢，因此具有少量特权代码组件的客户机应用程序的运行速度与本机应用程序非常接近，而具有大量特权代码组件（系统调用、陷阱或页面表更新等）的应用程序在虚拟环境中的速度可能比较慢。</p>
<h1 id="硬件辅助的CPU虚拟化"><a href="#硬件辅助的CPU虚拟化" class="headerlink" title="硬件辅助的CPU虚拟化"></a>硬件辅助的CPU虚拟化</h1><p>一些处理器为CPU虚拟化提供硬件辅助。</p>
<p>使用硬件辅助虚拟化时，客户机可以使用独立的执行模式（客户机模式）。应用程序代码或特权代码等客户机代码均在客户机模式下运行，出现某些事件时，处理器提出客户机模式而进入ROOT模式。管理程序将在ROOT模式中执行，确定退出的原因，采取任何必要的措施，并在客户机模式中重新启动客户机。</p>
<p>将硬件辅助用于虚拟化时，不需要转换代码，因此，系统调用或陷阱密集型工作负载在运行时的速度非常接近本机速度。但是，涉及更新页面表一类的一些工作会导致多次退出客户机模式进入ROOT模式。根据退出的次数和退出所用的总时间，硬件辅助虚拟化可以明显提高执行的速度。</p>
<h1 id="CPU虚拟化的性能影响"><a href="#CPU虚拟化的性能影响" class="headerlink" title="CPU虚拟化的性能影响"></a>CPU虚拟化的性能影响</h1><p>根据工作负载和使用的虚拟化类型，CPU虚拟化会增加不同的开销。</p>
<p>如果应用程序的大多数时间用于执行指令而不是等待用户交互、设备输入或数据检索等外部事物，则应用程序受CPU约束。对于此类程序，CPU虚拟化开销包括必须执行的额外指令。此开销应用程序本身可以使用的CPU处理时间。CPU虚拟化开销通常会导致整体性能下降。</p>
<p>对于不受CPU约束的应用，CPU虚拟化可能会提高CPU利用率。如果备用CPU容量可用于吸收开销，则仍然可以在整体吞吐量方面提供不错的性能。</p>
<blockquote>
<p>在单处理器虚拟机（而不是带有多个 CPU 的 SMP 虚拟机）上部署单线程应用程序可获得最佳的性能和资源利用率。</p>
<p>单线程应用程序只能利用单个 CPU。在双处理器虚拟机中部署这些应用程序不会加快应用程序的速度。相反，这样会使得第二个虚拟 CPU 使用本该由其他虚拟机以其他方式使用的物理资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>Virtualization</category>
      </categories>
      <tags>
        <tag>Virtualization</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>linux多网卡bond设置</title>
    <url>/2017/07/20/Linux/network/bond/</url>
    <content><![CDATA[<h1 id="在centso7下，将ens33和ens37两块网卡进行绑定到bond0"><a href="#在centso7下，将ens33和ens37两块网卡进行绑定到bond0" class="headerlink" title="在centso7下，将ens33和ens37两块网卡进行绑定到bond0"></a>在centso7下，将ens33和ens37两块网卡进行绑定到bond0</h1><p>首先备份两块网卡的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts/</span><br><span class="line">mkdir .backup</span><br><span class="line">mv ifcfg-ens33 ifcfg-ens37 ./backup</span><br></pre></td></tr></table></figure>
<p>现在开始生成bond0网卡的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli con add <span class="built_in">type</span> bond ifname bond0  mode active-backup(主备模式)</span><br><span class="line">nmcli con add <span class="built_in">type</span> bond-slave ifname ens33 master bond0(修改ens37网卡名字)</span><br><span class="line">nmcli con add <span class="built_in">type</span> bond-slave ifname ens37 master bond0 (修改ens37网卡名字)</span><br></pre></td></tr></table></figure>
<p>我们可以看到在 /etc/sysconfig/network-scripts/，目录下生成了新的配置文件</p>
<p>我们可以根据自己的需求来更改这个配置文件</p>
<p>就像改ip一样</p>
<p>这是我的配置文件<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-bond-bond0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEVICE=bond0</span><br><span class="line"><span class="comment">#BONDING_OPTS=mode=balance-rr</span></span><br><span class="line">BONDING_OPTS=mode=active-backup</span><br><span class="line">TYPE=Bond</span><br><span class="line">BONDING_MASTER=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=bond-bond0</span><br><span class="line">UUID=e45128b2-257c-442d-ba6d-e80989d7cf92</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.10.109</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.10.1</span><br></pre></td></tr></table></figure></p>
<p>我们再看下ens33和ens37两个网卡的配置文件是什么内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-bond-slave-ens33</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">NAME=bond-slave-ens33</span><br><span class="line">UUID=48448137-1b35-4288-a980-a7545974cb8c</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-bond-slave-ens33</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">NAME=bond-slave-ens37</span><br><span class="line">UUID=181976eb-0dfa-4fb0-8921-80ddd5773415</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">MASTER=bond0</span><br><span class="line">SLAVE=yes</span><br></pre></td></tr></table></figure>
<p> 现在可以重启下网络试下，顺被模拟故障试下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
<p>顺带说下ubuntu16.04的bond方式<br>超级简单<br>只需要向正常修改ip那样 编辑/etc/network/interfaces<br>查看一下我自己测试的配置文件内容，修改位置自行脑补</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="comment"># and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># The primary network interface</span></span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">bond-master bond0</span><br><span class="line"></span><br><span class="line">auto ens34</span><br><span class="line">iface ens34 inet manual</span><br><span class="line">bond-master bond0</span><br><span class="line"></span><br><span class="line">auto bond0</span><br><span class="line">iface bond0 inet static</span><br><span class="line">address 192.168.10.110</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.10.1</span><br><span class="line">dns-nameservers 114.114.114.114</span><br><span class="line">bond-slaves ens33 ens34</span><br><span class="line">bond-lacp-rate 1</span><br><span class="line">bond-mode 1</span><br><span class="line">bond-miimon 100</span><br></pre></td></tr></table></figure>
<p>简单描述下， 我的网卡名字， ens33 ens34<br>我的bond网卡名字 bond0</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bond</tag>
      </tags>
  </entry>
  <entry>
    <title>如何修改swap大小</title>
    <url>/2017/07/14/Linux/storage/swap/</url>
    <content><![CDATA[<p><a href="https://sysctl.me/2017/07/14/Linux/storage/gparted/" target="_blank" rel="noopener">接上集：使用Gparted 实现扩展物理硬盘分区扩容</a></p>
<p>两台机器内存不一样， 通过模板部署并没有觉得便捷，</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/AJeFljA435.png?imageslim" alt="mark"></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/h81JgiahiA.png?imageslim" alt="mark"></p>
<p>先黑一波</p>
<h1 id="swap概念"><a href="#swap概念" class="headerlink" title="swap概念"></a>swap概念</h1><p>Swap分区，即交换区，系统在物理内存不够时，与Swap进行交换。 其实，Swap的调整对Linux服务器，特别是Web服务器的性能至关重要。通过调整Swap，有时可以越过系统性能瓶颈，节省系统升级费用。<br>众所周知，现代操作系统都实现了“虚拟内存”这一技术，不但在功能上突破了物理内存的限制，使程序可以操纵大于实际物理内存的空间，更重要的是，“虚拟内存”是隔离每个进程的安全保护网，使每个进程都不受其它程序的干扰。<br><a id="more"></a></p>
<h2 id="swap大小"><a href="#swap大小" class="headerlink" title="swap大小"></a>swap大小</h2><p>这个之前RHEL 给过建议</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物理内存</th>
<th>交换分区（SWAP）</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;= 4G</td>
<td>至少4G</td>
</tr>
<tr>
<td>4~16G</td>
<td>至少8G</td>
</tr>
<tr>
<td>16G~64G</td>
<td>至少16G</td>
</tr>
<tr>
<td>64G~256G</td>
<td>至少32G</td>
</tr>
</tbody>
</table>
</div>
<p>查看swap的大小命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>
<h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>有三种方法可以对Swap分区扩容</p>
<h3 id="扩展正在使用的Swap的逻辑卷"><a href="#扩展正在使用的Swap的逻辑卷" class="headerlink" title="扩展正在使用的Swap的逻辑卷"></a>扩展正在使用的Swap的逻辑卷</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff -v /dev/mapper/centos-swap    <span class="comment">#关闭swap</span></span><br><span class="line">lvresize -L 8G /dev/mapper/centos-swap   <span class="comment"># 扩展到8G 根据实际情况 | -l +8G 是增加8G</span></span><br><span class="line">mkswap /dev/mapper/centos-swap         <span class="comment">#格式化swap</span></span><br><span class="line">swapon -va <span class="comment"># 启动swap</span></span><br><span class="line">free -m <span class="comment">#查看是否生效</span></span><br></pre></td></tr></table></figure>
<p><code>swap路径根据实际情况修改</code></p>
<h3 id="新建Swap-分区"><a href="#新建Swap-分区" class="headerlink" title="新建Swap 分区"></a>新建Swap 分区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvcreate -n centos-newswap -L 8G  <span class="comment">#新建lvm </span></span><br><span class="line">mkswap /dev/mapper/centos-newswap  <span class="comment">#格式化swap</span></span><br></pre></td></tr></table></figure>
<p><code>将下面这句写入fstab,注意之前的swap</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/VolGroup00/LogVol02 swap swap defaults 0 0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -va <span class="comment"># 启动swap （fstab表里指定的swap）</span></span><br><span class="line">free -m  <span class="comment"># 验证</span></span><br></pre></td></tr></table></figure>
<h3 id="新建Swap-file"><a href="#新建Swap-file" class="headerlink" title="新建Swap file"></a>新建Swap file</h3><p>这个方式不是很推荐，比较麻烦，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/newswap bs=1024 count=8388608 <span class="comment">#8G大小的回环文件 ，根据需求修改，</span></span><br><span class="line">mkswap /newswap   <span class="comment"># 格式化为swap格式</span></span><br><span class="line">swapon /newswap   <span class="comment"># 启用此文件为swap</span></span><br><span class="line">写入fstab （注意之前使用的swap）</span><br><span class="line">free -m  <span class="comment">#验证</span></span><br></pre></td></tr></table></figure>
<p>写入fstab的格式为：</p>
<p><code>设备文件路径  swap  swap  default  0 0</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Partition</tag>
        <tag>Swap</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gparted 实现扩展物理硬盘分区扩容</title>
    <url>/2017/07/14/Linux/storage/gparted/</url>
    <content><![CDATA[<h1 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h1><p>需求：需要一台CentOS6.9 系统盘100G 数据盘1T<br>现状：前天刚做的6.9模板（模板制作参考<a href="http://sysctl.me/2017/07/12/vmawre" target="_blank" rel="noopener">有关Vsphere模板的使用</a>）。<br>搞吧<br>理想剧本：从模板部署虚拟机 修改ip 完事回家，<br>现实版剧本：</p>
<ol>
<li>我靠这模板怎么系统盘才15G，谁做的（<font color=#DC143C size=3 face="黑体">我自己做的</font>）</li>
<li>试试吧，扩容了磁盘，开机磁盘大小对劲，但是怎么搞，我懵逼了，再分个区？加到“/”的VG里，然后扩展VG，在resize LVM？这有点二阿，一个物理设备，分两个PV 加到一个VG里 ，呸，不行，想办法吧~~~</li>
<li>讲道理还有办法，进救援——-&gt;&gt;&gt; umount / ——-&gt;&gt;&gt;&gt;&gt;&gt; 在resize物理分区，那么问题来了，我没有Live CD阿。</li>
<li>同事说：“不能像windows那样直接扩展吗”，我想应该也ok吧，就是没搞过，试试吧 GoGoGo！</li>
<li>不过国内某度这个搜索引擎我真的不想黑你，你这个搜出来的结果让我直接扩vg我是拒绝的，还是谷歌吧，一下子找到了个英文的文档，（英语白痴机器翻译）说是可以类似 diskgenius这种软件安装到救援盘（就是pe），好心大佬还附带了<a href="http://downloads.sourceforge.net/gparted/gparted-live-0.28.1-1-amd64.iso" target="_blank" rel="noopener">下载链接</a></li>
<li>不凑字了，开干。<a id="more"></a>
<h1 id="Live-CD"><a href="#Live-CD" class="headerlink" title="Live CD"></a>Live CD</h1>装载神器gparted的live cd<br><img src="https://blog-image.nos-eastchina1.126.net/ejf4ebJ281.png?imageslim" alt="mark"><br>选择CD-ROM-启动<br><img src="https://blog-image.nos-eastchina1.126.net/IHBBbGj18A.png?imageslim" alt="mark"><br>启动Gparted Live<br><img src="https://blog-image.nos-eastchina1.126.net/633I1GFdi9.png?imageslim" alt="mark"><br>直接ok下一步<br><img src="https://blog-image.nos-eastchina1.126.net/2lHig0jBDJ.png?imageslim" alt="mark"><br>选语言，个人喜好（原谅我英语白痴）<br><img src="https://blog-image.nos-eastchina1.126.net/jkgfC0i4jL.png?imageslim" alt="mark"><br>直接默认下一步<br><img src="https://blog-image.nos-eastchina1.126.net/3JE91clc31.png?imageslim" alt="mark"><br>原来是大便系统，启动Gparted<br><img src="https://blog-image.nos-eastchina1.126.net/1G86hKiiLl.png?imageslim" alt="mark"><br>调整分区大小<br><img src="https://blog-image.nos-eastchina1.126.net/cmKJIa6Fid.png?imageslim" alt="mark"><br>选择大小直接调整<br><img src="https://blog-image.nos-eastchina1.126.net/fJccFfkJej.png" alt="选择大小直接调整"><br>Apply。我好慌阿，还能起来机不？<br><img src="https://blog-image.nos-eastchina1.126.net/57J020d0a4.png?imageslim" alt="mark"><br>来吧 reboot<br><img src="https://blog-image.nos-eastchina1.126.net/EB3HC7jkfm.png?imageslim" alt="mark"></li>
</ol>
<p>开机了，VG的大小已经生效了，（因为我这个”/“分区是lvm的方式，要是非lvm，也可以用这个方式，并且简单到爆炸），</p>
<p>如果你的要扩展的分区不是lvm 那么你已经不用往下看了，继续你的其他工作吧，<br>lvm其实相当于扩展了VG<br>看下刚扩展的VG是不是VFREE已经很大了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgs</span><br></pre></td></tr></table></figure>
<p>lvs看下lv是不是还是老样子（肯定的）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvs</span><br></pre></td></tr></table></figure><br>接下来就是扩展lvm的方式来做了，毫无风险直接干。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvextend -l +100%FREE /dev/VolGroup/lv_root</span><br></pre></td></tr></table></figure><br><code>这里后面的路径跟的是你需要扩展的lv路径</code> </p>
<p>现在lv的大小已经生效了，接下来需要搞下挂在的“/”的大小，<br>这里简单，但是需要看你的文件系统是什么，这里介绍两种，ext4和xfs<br>ext4<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/VolGroup/lv_root</span><br></pre></td></tr></table></figure><br>xfs<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xfs_growfs /dev/mapper/centos-home</span><br></pre></td></tr></table></figure><br><code>后面跟的都是你需要扩容的路径</code></p>
<p>好了，还差点什么，对了，这两台虚拟机实例一个16G内存 一个4G 还得改swap的大小，下集预告<br><a href="https://www.sysctl.me/2017/07/14/Linux/storage/swap/">如何修改swap大小</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title>有关Vsphere模板的使用</title>
    <url>/2017/07/12/About-the-use-of-Vsphere-templates/</url>
    <content><![CDATA[<h1 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h1><p>用了这么久的vsphere 从来没用过模板，感觉很麻烦，windows还要用sysprep重新封装，Linux就不要提了，转换完模板，从模板部署；自己用还好，给别人用每次都要修改密码，不清空udev条目，网卡不能启动，想想都尴尬。<br>今天高人指点，说了说他做linux模板的步骤， 受益匪浅，总结分享。</p>
<p><font color=#00ffff size=4>发现都是废话， 不想看直接跳到最后看干货</font><br><a id="more"></a><br><em>windows就不说了，sysprep重新封装就好，点点点，</em>（推荐使用自定义规范，SID才会出问题）<br>说下linux的模板（仅使用rhel衍生版，6之前的可以使用，7已废弃）</p>
<ul>
<li>首先拿来一个iso</li>
<li>然后安装一个系统，（最小化安装，没用过图形，见笑）</li>
<li>密码，配置，分区，balabala.</li>
<li>完事了。</li>
<li>登录 cp一份ifcfg</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /etc/sysconfig/network-scripts/ifcfg-eth0 ~/</span><br></pre></td></tr></table></figure>
<p>先不用配ip 没用</p>
<ul>
<li>注释两条。mac和uuid</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed  -i <span class="string">'s/^\(HWADDR\|UUID\)/#&amp;/'</span> /etc/sysconfig/network-scripts/ifcfg-xxx   （XXX为需要修改的网卡）</span><br></pre></td></tr></table></figure>
<ul>
<li>清空udev规则</li>
</ul>
<p>Centos6 大概路径 自行tab /etc/udev/rules.d/70-persistent-net.rules</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果你喜欢vim打开然后dd 也可以，</span><br><span class="line">不打开的话就sed</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------------------</span><br><span class="line">sed -i <span class="string">'/^SUBSYSTEM/d'</span> /etc/udev/rules.d/70-persistent-net.rules （Centos6 ）</span><br></pre></td></tr></table></figure>
<p>或者你简单粗暴点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; 你要清空的那个udev文件</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt;  你要清空的那个udev文件</span><br></pre></td></tr></table></figure>
<p>直接清空文件， 注释也没了。。</p>
<h1 id="安装tools"><a href="#安装tools" class="headerlink" title="安装tools"></a>安装tools</h1><p>挂载tools<br>mount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sr0 /mnt</span><br></pre></td></tr></table></figure>
<p>解压&amp;&amp;安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf /mnt/VMwareTools-10.1.6-5214329.tar.gz -C /tmp/</span><br><span class="line">/tmp/vmware-tools-distrib/vmware-install.pl -d</span><br><span class="line">umount</span><br></pre></td></tr></table></figure>
<h1 id="重点来了。"><a href="#重点来了。" class="headerlink" title="重点来了。"></a>重点来了。</h1><p>懒得改密码，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install setuptool ntsysv system-config-securitylevel-tui system-config-network-tui authconfig-gtk system-config-keyboard</span><br><span class="line"></span><br><span class="line">touch /.unconfigured</span><br><span class="line"></span><br><span class="line">rm -rf /etc/ssh/ssh_host_*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init 0</span><br></pre></td></tr></table></figure>
<p>建议封装前，清空下历史命令记录和日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> &gt; /var/<span class="built_in">log</span>/wtmp</span><br><span class="line"><span class="built_in">echo</span> &gt; /var/<span class="built_in">log</span>/btmp</span><br><span class="line"><span class="built_in">history</span> -c</span><br><span class="line"><span class="built_in">echo</span> &gt; ~/.bash_history</span><br></pre></td></tr></table></figure>
<p>好了，可以直接转换模板了，<br>演示效果， 我们开机看下有什么不同</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/CALB2AEBDc.png?imageslim" alt="mark"><br><img src="https://blog-image.nos-eastchina1.126.net/d90fHfa281.png?imageslim" alt="mark"><br><img src="https://blog-image.nos-eastchina1.126.net/Cf24lEeL1g.png?imageslim" alt="mark"><br>好了，</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vsphere</tag>
      </tags>
  </entry>
  <entry>
    <title>RHEL使用Centos的yum源</title>
    <url>/2017/07/08/Linux/rhel/</url>
    <content><![CDATA[<h1 id="查看系统自带的yum组件"><a href="#查看系统自带的yum组件" class="headerlink" title="查看系统自带的yum组件"></a>查看系统自带的yum组件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep yum</span><br><span class="line"></span><br><span class="line">yum-rhn-plugin-2.0.1-5.el7.noarch</span><br><span class="line">yum-metadata-parser-1.1.4-10.el7.x86_64</span><br><span class="line">yum-3.4.3-125.el7.noarch</span><br></pre></td></tr></table></figure>
<h1 id="卸载自带yum组件"><a href="#卸载自带yum组件" class="headerlink" title="卸载自带yum组件"></a>卸载自带yum组件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -aq|grep yum|xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="下载rpm包"><a href="#下载rpm包" class="headerlink" title="下载rpm包"></a>下载rpm包</h1><p>yum-metadata-parser-1.1.4-10.el7.x86_64<br>yum-3.4.3-150.el7.centos.noarch<br>yum-plugin-fastestmirror-1.1.31-40.el7.noarch<br><em>如果最小化安装可能需要安装依赖</em><br>Python-urlgrabber-3.10-8.el7.noarch.rpm<br>python-kitchen-1.1.1-5.el7.noarch.rpm<br>python-iniparse-0.4-9.el7.noarch.rpm</p>
<p>少哪些依赖包会有显示， 直接到镜像站下载包即可，最方便的办法就是提示缺哪个依赖，去镜像站复制rpm包链接 直接在rpm -ivh命令后面加包的链接，（加到不提示依赖为之）</p>
<h1 id="修改yum-repo文件"><a href="#修改yum-repo文件" class="headerlink" title="修改yum.repo文件"></a>修改yum.repo文件</h1><p>安装完yum组件之后<br>下载一份镜像站的repo文件，<br>这里需要修改一个地方<br>将$releasever 修改为 7<br>rhel其他版本对应修改操作系统的大版本号</p>
<p><em>修改后 </em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Base - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/os/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#released updates</span></span><br><span class="line">[updates]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Updates - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/updates/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that may be useful</span></span><br><span class="line">[extras]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Extras - 163.com</span><br><span class="line"><span class="comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras</span></span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/extras/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br><span class="line"></span><br><span class="line"><span class="comment">#additional packages that extend functionality of existing packages</span></span><br><span class="line">[centosplus]</span><br><span class="line">name=CentOS-<span class="variable">$releasever</span> - Plus - 163.com</span><br><span class="line">baseurl=http://mirrors.163.com/centos/7/centosplus/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=http://mirrors.163.com/centos/RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>
<p>将修改后的文件放在/etc/yum.repos目录下，<br><em>测试</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>
<p><a href="http://mirrors.163.com" target="_blank" rel="noopener">镜像站地址</a><br><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">yum.repo文件下载地址</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim Table</title>
    <url>/2017/07/07/vim/</url>
    <content><![CDATA[<h1 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h1><ul>
<li>:<code>help keyword</code> - 打开关键字帮助</li>
<li>:<code>o file</code> - 打开文件</li>
<li>:<code>saveas file</code> - 另存为</li>
<li>:<code>close</code> - 关闭当前窗口</li>
<li><p><code>K</code> - open man page for word under the cursor</p>
<a id="more"></a>
<h1 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h1></li>
<li><p>h - 左移光标</p>
</li>
<li>j - 下移光标</li>
<li>k - 上移光标</li>
<li>l - 右移光标</li>
<li>H - 移动到当前页面顶部</li>
<li>M - 移动到当前页面中间</li>
<li>L - 移动到当前页面底部</li>
<li>w - 移动到下个单词开头</li>
<li>W - 移动到下个单词开头(单词含标点)</li>
<li>e - 移动到下个单词结尾</li>
<li>E - 移动到下个单词结尾(单词含标点)</li>
<li>b - 移动到上个单词结尾</li>
<li>B - 移动到上个单词结尾(单词含标点)</li>
<li>% - move to matching character (default supported pairs: ‘()’, ‘{}’, ‘[]’ - use :h matchpairs in vim for more info)</li>
<li>0 - 移动到行首</li>
<li>^ - 移动到行首的非空白符</li>
<li>$ - 移动到行尾</li>
<li>g_ - 移动到行内最后一个非空白符</li>
<li>gg - 移动到文件第一行</li>
<li>G - 移动到文件最后一行</li>
<li>5G - 移动到第五行</li>
<li>fx - 移动到字符 x 下次出现的位置</li>
<li>tx - 移动到字符 x 下次出现的位置的前一个字符</li>
<li>} - 移动到下一个段落 (当编辑代码时则为函数／代码块)</li>
<li>{ - 移动到上一个段落 (当编辑代码时则为函数／代码块)</li>
<li>zz - 移动屏幕使光标居中</li>
<li>Ctrl + b - 向后滚动一屏</li>
<li>Ctrl + f - 向前滚动一屏</li>
<li>Ctrl + d - 向前滚动半屏</li>
<li>Ctrl + u - 向后滚动半屏</li>
</ul>
<p><em>Tip 命令前追加数字表示命令的重复次数, 比如 4j 表示向下移动四行</em></p>
<h1 id="插入模式-插入-追加文本"><a href="#插入模式-插入-追加文本" class="headerlink" title="插入模式 - 插入/追加文本"></a>插入模式 - 插入/追加文本</h1><ul>
<li>i - 从光标前开始插入字符</li>
<li>I - 从行首开始插入字符</li>
<li>a - 从光标后开始插入字符</li>
<li>A - 从行尾开始插入字符</li>
<li>o - 在当前行之下另起一行, 开始插入字符</li>
<li>O - 在当前行之上另起一行, 开始插入字符</li>
<li>ea - 从当前单词末尾开始插入</li>
<li>Esc - 退出插入模式</li>
</ul>
<h1 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h1><ul>
<li>:e file - 新建缓冲区打开 filename</li>
<li>:bnext or :bn - 切换到下个缓冲区</li>
<li>:bprev or :bp - 切换到上个缓冲区</li>
<li>:bd - 关闭缓冲区</li>
<li>:ls - 列出所有打开的缓冲区</li>
<li>:sp file - 新建缓冲区打开 filename 并水平分割窗口</li>
<li>:vsp file - 新缓冲区打开 filename 并垂直分割窗口</li>
<li>Ctrl + ws - 水平分割窗口</li>
<li>Ctrl + ww - 在窗口间切换</li>
<li>Ctrl + wq - 关闭窗口</li>
<li>Ctrl + wv - 垂直分割窗口</li>
<li>Ctrl + wh - 切换到右侧窗口</li>
<li>Ctrl + wl - 切换到左侧窗口</li>
<li>Ctrl + wj - 切换到下侧窗口</li>
<li>Ctrl + wk - 切换到上侧窗口</li>
</ul>
<h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><ul>
<li>r - 替换当前字符</li>
<li>J - 将下一行合并到当前行</li>
<li>cc - 清空当前行, 然后进入插入模式</li>
<li>cw - 从光标位置开始, 修改单词</li>
<li>c$ - 从光标位置开始, 修改当前行</li>
<li>s - 删除当前字符, 然后进入插入模式</li>
<li>S - 清空当前行, 然后进入插入模式 (同cc)</li>
<li>xp - 当前字符后移</li>
<li>u - 撤销</li>
<li>Ctrl + r - 重复</li>
<li>. - 再次执行上个命令</li>
</ul>
<h1 id="选择文本（可视化模式）"><a href="#选择文本（可视化模式）" class="headerlink" title="选择文本（可视化模式）"></a>选择文本（可视化模式）</h1><ul>
<li>v - 进入可视化模式, 移动光标高亮选择, 然后可以对选择的文本执行命令(比如y-复制)</li>
<li>V - 进入可视化模式(行粒度选择)</li>
<li>o - 切换光标到选择区开头/结尾</li>
<li>Ctrl + v - 进入可视化模式(矩阵选择)</li>
<li>O - 切换光标到选择区的角</li>
<li>aw - 选择当前单词</li>
<li>ab - 选择被 () 包裹的区域(含括号)</li>
<li>aB - 选择被 {} 包裹的区域(含花括号)</li>
<li>ib - 选择被 () 包裹的区域(不含括号)</li>
<li>iB - 选择被 {} 包裹的区域(不含花括号)</li>
<li>Esc - 退出可视化模式</li>
</ul>
<h1 id="可视化模式命令"><a href="#可视化模式命令" class="headerlink" title="可视化模式命令"></a>可视化模式命令</h1><ul>
<li>> - 向右缩进</li>
<li>&lt; - 向左缩进</li>
<li>y - 复制</li>
<li>d - 剪切</li>
<li>~ - 大小写切换</li>
</ul>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul>
<li>:reg - 显示寄存器内容</li>
<li>“xy - 复制内容到寄存器 x</li>
<li>“xp - 粘贴寄存器 x 中的内容</li>
<li>Tip 寄存器被存储在 ~/.viminfo 中, 在下次重启vim时仍会加载</li>
<li>Tip 寄存器 0 存储上一次复制的值</li>
</ul>
<h1 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h1><ul>
<li>:marks - 标记列表</li>
<li>ma - 设置当前位置为标记 a</li>
<li>`a - 跳转到标记 a 的位置</li>
<li>y`a - 复制当前位置到标记 a 的内容</li>
</ul>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><ul>
<li>qa - 录制宏 a</li>
<li>q - 停止录制宏</li>
<li>@a - 执行宏 a</li>
<li>@@ - 重新执行上次执行的宏</li>
</ul>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><ul>
<li>:tabnew or :tabnew file - 在新标签中打开文件</li>
<li>Ctrl + wT - 将窗口变成标签</li>
<li>gt or :tabnext or :tabn - 切换到下一个标签</li>
<li>gT or :tabprev or :tabp - 切换到上一个标签</li>
<li>#gt - 切换到第 # 个标签</li>
<li>:tabmove # - 移动标签到第 # 位(下标从 0 开始)</li>
<li>:tabclose or :tabc - 关闭当前标签</li>
<li>:tabonly or :tabo - 关闭其他标签</li>
<li>:tabdo command - 在所有标签中执行命令 (例如 :tabdo q 关闭所有标签)</li>
</ul>
<h1 id="剪切-复制-粘贴"><a href="#剪切-复制-粘贴" class="headerlink" title="剪切, 复制, 粘贴"></a>剪切, 复制, 粘贴</h1><ul>
<li>yy - 复制当前行</li>
<li>2yy - 复制 2 行</li>
<li>yw - 复制当前单词</li>
<li>y$ - 复制, 从光标位置到行末</li>
<li>p - 在光标后粘贴</li>
<li>P - 在光标前粘贴</li>
<li>dd - 剪切当前行</li>
<li>2dd - 剪切 2 行</li>
<li>dw - 剪切当前单词</li>
<li>D - 剪切, 从光标位置到行末</li>
<li>d$ - 剪切, 从光标位置到行末 (同D)</li>
<li>x - 剪切当前字符</li>
</ul>
<h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><ul>
<li>:w - 保存</li>
<li>:w !sudo tee % - 使用 sudo 保存当前文件</li>
<li>:wq or :x or ZZ - 保存并退出</li>
<li>:q - 退出(修改未保存时警告)</li>
<li>:q! or ZQ - 不保存强制退出</li>
</ul>
<h1 id="查找-替换"><a href="#查找-替换" class="headerlink" title="查找/替换"></a>查找/替换</h1><ul>
<li>/pattern - 查找pattern</li>
<li>?pattern - 向上查找pattern</li>
<li>\vpattern - pattern 中的非字母数字字符被视为正则表达式特殊字符 (不需转义字符)</li>
<li>n - 查找下一个</li>
<li>N - 查找上一个</li>
<li>:%s/old/new/g - 替换全部</li>
<li>:%s/old/new/gc - (逐个)替换</li>
<li>:noh - 移除搜索结果的高亮显示</li>
</ul>
<h1 id="多文件搜索"><a href="#多文件搜索" class="headerlink" title="多文件搜索"></a>多文件搜索</h1><ul>
<li>:vimgrep /pattern/ {file} - 在多个文件中搜索 pattern</li>
<li>e.g. :vimgrep /foo/ <em>*/</em></li>
<li>:cn - 移动至下一个</li>
<li>:cp - 移动至上一个</li>
<li>:copen - 打开搜索结果列表</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Corosync On CentOS</title>
    <url>/2017/06/17/Linux/HA/Corosync/</url>
    <content><![CDATA[<p>前提：</p>
<ol>
<li>本配置共有两个测试节点，分别node1.test.com和node2.test.com，相的IP地址分别为192.168.10.7和192.168.10.8；</li>
<li>集群服务为apache的httpd服务；</li>
<li>提供web服务的地址为192.168.10.11，即vip；</li>
<li>系统为CentOS 6.5 64bits<a id="more"></a>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1></li>
</ol>
<p>为了配置一台Linux主机成为HA的节点，通常需要做出如下的准备工作：</p>
<p>1.所有节点的主机名称和对应的IP地址解析服务可以正常工作，且每个节点的主机名称需要跟”uname -n“命令的结果保持一致；因此，需要保证两个节点上的/etc/hosts文件均为下面的内容：</p>
<blockquote>
<p>192.168.10.7   node1.test.com node1<br>192.168.10.8   node2.test.com node2</p>
</blockquote>
<p>为了使得重新启动系统后仍能保持如上的主机名称，还分别需要在各节点执行类似如下的命令：</p>
<p>Node1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s@\(HOSTNAME=\).*@\1node1.test.com@g'</span>  /etc/sysconfig/network</span><br><span class="line">hostname node1.test.com</span><br></pre></td></tr></table></figure>
<p>Node2：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s@\(HOSTNAME=\).*@\1node2.test.com@g'</span> /etc/sysconfig/network</span><br><span class="line">hostname node2.test.com</span><br></pre></td></tr></table></figure>
<p><em>注：也可用hostnamectl set-hostname HOSTNAME</em><br>2.设定两个节点可以基于密钥进行ssh通信，这可以通过类似如下的命令实现：<br>Node1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line"><span class="comment"># ssh-copy-id -i ~/.ssh/id_rsa.pub root@node2</span></span><br></pre></td></tr></table></figure>
<p>Node2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line"><span class="comment"># ssh-copy-id -i ~/.ssh/id_rsa.pub root@node1</span></span><br></pre></td></tr></table></figure>
<h1 id="配置corosync，（以下命令在node1-test-com上执行）"><a href="#配置corosync，（以下命令在node1-test-com上执行）" class="headerlink" title="配置corosync，（以下命令在node1.test.com上执行）"></a>配置corosync，（以下命令在node1.test.com上执行）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /etc/corosync</span></span><br><span class="line"><span class="comment"># cp corosync.conf.example corosync.conf</span></span><br></pre></td></tr></table></figure>
<p>接着编辑corosync.conf，添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service &#123;</span><br><span class="line">  ver:  0</span><br><span class="line">  name: pacemaker</span><br><span class="line">  <span class="comment"># use_mgmtd: yes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aisexec &#123;</span><br><span class="line">  user: root</span><br><span class="line">  group:  root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并设定此配置文件中 bindnetaddr后面的IP地址为你的网卡所在网络的网络地址，我们这里的两个节点在192.168.10.0网络，因此这里将其设定为192.168.10.0；如下</p>
<blockquote>
<p>bindnetaddr: 192.168.10.0</p>
</blockquote>
<p>生成节点间通信时用到的认证密钥文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># corosync-keygen</span></span><br></pre></td></tr></table></figure>
<p>将corosync和authkey复制至node2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scp -p corosync authkey  node2:/etc/corosync/</span></span><br></pre></td></tr></table></figure>
<p>分别为两个节点创建corosync生成的日志所在的目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir /var/log/cluster</span></span><br><span class="line"><span class="comment"># ssh node2  'mkdir /var/log/cluster'</span></span><br></pre></td></tr></table></figure>
<h1 id="安装crmsh"><a href="#安装crmsh" class="headerlink" title="安装crmsh"></a>安装crmsh</h1><p>RHEL自6.4起不再提供集群的命令行配置工具crmsh，转而使用pcs；如果你习惯了使用crm命令，可下载相关的程序包自行安装即可。crmsh依赖于pssh，因此需要一并下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd /root/cluster</span></span><br><span class="line"><span class="comment"># yum -y --nogpgcheck localinstall crmsh*.rpm pssh*.rpm</span></span><br></pre></td></tr></table></figure>
<h1 id="启动corosync（以下命令在node1上执行）："><a href="#启动corosync（以下命令在node1上执行）：" class="headerlink" title="启动corosync（以下命令在node1上执行）："></a>启动corosync（以下命令在node1上执行）：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/corosync start</span></span><br></pre></td></tr></table></figure>
<p>查看corosync引擎是否正常启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep -e "Corosync Cluster Engine" -e "configuration file" /var/log/cluster/corosync.log</span></span><br><span class="line"></span><br><span class="line">Sep 15 11:37:39 corosync [MAIN  ] Corosync Cluster Engine (<span class="string">'1.4.1'</span>): started and ready to provide service.</span><br><span class="line">Sep 15 11:37:39 corosync [MAIN  ] Successfully <span class="built_in">read</span> main configuration file <span class="string">'/etc/corosync/corosync.conf'</span>.</span><br></pre></td></tr></table></figure>
<p>查看初始化成员节点通知是否正常发出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep  TOTEM  /var/log/cluster/corosync.log</span></span><br><span class="line"></span><br><span class="line">Sep 15 11:37:39 corosync [TOTEM ] Initializing transport (UDP/IP Multicast).</span><br><span class="line">Sep 15 11:37:39 corosync [TOTEM ] Initializing transmit/receive security: libtomcrypt SOBER128/SHA1HMAC (mode 0).</span><br><span class="line">Sep 15 11:37:39 corosync [TOTEM ] The network interface [192.168.10.7] is now up.</span><br><span class="line">Sep 15 11:37:39 corosync [TOTEM ] A processor joined or left the membership and a new membership was formed.</span><br><span class="line">Sep 15 11:37:39 corosync [TOTEM ] A processor joined or left the membership and a new membership was formed.</span><br></pre></td></tr></table></figure>
<p>检查启动过程中是否有错误产生。下面的错误信息表示packmaker不久之后将不再作为corosync的插件运行，因此，建议使用cman作为集群基础架构服务；此处可安全忽略。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep ERROR: /var/log/cluster/corosync.log | grep -v unpack_resources</span></span><br><span class="line"></span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] ERROR: process_ais_conf: You have configured a cluster using the Pacemaker plugin <span class="keyword">for</span> Corosync. The plugin is not supported <span class="keyword">in</span> this environment and will be removed very soon.</span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] ERROR: process_ais_conf:  Please see Chapter 8 of <span class="string">'Clusters from Scratch'</span> (http://www.clusterlabs.org/doc) <span class="keyword">for</span> details on using Pacemaker with CMAN</span><br><span class="line">Sep 15 11:37:40 corosync [pcmk  ] ERROR: pcmk_wait_dispatch: Child process mgmtd exited (pid=2375, rc=100)</span><br></pre></td></tr></table></figure>
<p>查看pacemaker是否正常启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep pcmk_startup /var/log/cluster/corosync.log</span></span><br><span class="line"></span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] info: pcmk_startup: CRM: Initialized</span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] Logging: Initialized pcmk_startup</span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] info: pcmk_startup: Maximum core file size is: 18446744073709551615</span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] info: pcmk_startup: Service: 9</span><br><span class="line">Sep 15 11:37:39 corosync [pcmk  ] info: pcmk_startup: Local hostname: node1.test.com</span><br></pre></td></tr></table></figure>
<p>如果上面命令执行均没有问题，接着可以执行如下命令启动node2上的corosync</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh node2 -- /etc/init.d/corosync start</span></span><br></pre></td></tr></table></figure>
<p>注意：启动node2需要在node1上使用如上命令进行，不要在node2节点上直接启动。下面是node1上的相关日志。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tail /var/log/cluster/corosync.log</span></span><br><span class="line"></span><br><span class="line">Sep 15 12:10:00 [2688] node1.test.com       crmd:     info: do_te_control:  Transitioner is now inactive</span><br><span class="line">Sep 15 12:10:00 [2688] node1.test.com       crmd:     info: update_dc:  Set DC to node2.test.com (3.0.7)</span><br><span class="line">Sep 15 12:10:00 [2683] node1.test.com        cib:     info: cib_process_replace:  Digest matched on replace from node2.test.com: a221b8ae3386d35b263633d8b1fe213f</span><br><span class="line">Sep 15 12:10:00 [2683] node1.test.com        cib:     info: cib_process_replace:  Replaced 0.8.7 with 0.8.7 from node2.test.com</span><br><span class="line">Sep 15 12:10:00 [2688] node1.test.com       crmd:     info: erase_status_tag:   Deleting xpath: //node_state[@uname=<span class="string">'node1.test.com'</span>]/transient_attributes</span><br><span class="line">Sep 15 12:10:00 [2688] node1.test.com       crmd:     info: update_attrd:   Connecting to attrd... 5 retries remaining</span><br><span class="line">Sep 15 12:10:00 [2688] node1.test.com       crmd:   notice: do_state_transition:  State transition S_PENDING -&gt; S_NOT_DC [ input=I_NOT_DC cause=C_HA_MESSAGE origin=do_cl_join_finalize_respond ]</span><br><span class="line">Sep 15 12:10:00 [2686] node1.test.com      attrd:   notice: attrd_local_callback:   Sending full refresh (origin=crmd)</span><br><span class="line">Sep 15 12:10:01 [2686] node1.test.com      attrd:   notice: attrd_trigger_update:   Sending flush op to all hosts <span class="keyword">for</span>: probe_complete (<span class="literal">true</span>)</span><br><span class="line">Sep 15 12:10:01 [2686] node1.test.com      attrd:   notice: attrd_perform_update:   Sent update 5: probe_complete=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>如果安装了crmsh，可使用如下命令查看集群节点的启动状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line"></span><br><span class="line">Last updated: Sun Sep 15 12:12:25 2013</span><br><span class="line">Last change: Sun Sep 15 12:12:18 2013 via cibadmin on node1.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node2.test.com - partition with quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 3 expected votes</span><br><span class="line">0 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node1.test.com node2.test.com ]</span><br></pre></td></tr></table></figure>
<p>从上面的信息可以看出两个节点都已经正常启动，并且集群已经处于正常工作状态。</p>
<p>执行ps auxf命令可以查看corosync启动的各相关进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root      2677  0.5  0.9 618244  4680 ?        Ssl  12:09   0:01 corosync</span><br><span class="line">495       2683  0.3  1.5  87456  7552 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/cib</span><br><span class="line">root      2684  0.0  0.6  81432  3244 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/stonithd</span><br><span class="line">root      2685  0.0  0.6  73088  3120 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/lrmd</span><br><span class="line">495       2686  0.0  0.6  85736  3228 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/attrd</span><br><span class="line">495       2687  0.0  0.5  80876  2764 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/pengine</span><br><span class="line">495       2688  0.0  0.8 102724  4084 ?        S    12:09   0:00  \_ /usr/libexec/pacemaker/crmd</span><br></pre></td></tr></table></figure>
<h1 id="配置集群的工作属性，禁用stonith"><a href="#配置集群的工作属性，禁用stonith" class="headerlink" title="配置集群的工作属性，禁用stonith"></a>配置集群的工作属性，禁用stonith</h1><p>corosync默认启用了stonith，而当前集群并没有相应的stonith设备，因此此默认配置目前尚不可用，这可以通过如下命令验正：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm_verify -L -V</span></span><br><span class="line">   error: unpack_resources:   Resource start-up disabled since no STONITH resources have been defined</span><br><span class="line">   error: unpack_resources:   Either configure some or <span class="built_in">disable</span> STONITH with the stonith-enabled option</span><br><span class="line">   error: unpack_resources:   NOTE: Clusters with shared data need STONITH to ensure data integrity</span><br><span class="line">Errors found during check: config not valid</span><br><span class="line">  -V may provide more details</span><br></pre></td></tr></table></figure>
<p>我们里可以通过如下命令先禁用stonith：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure property stonith-enabled=false</span></span><br></pre></td></tr></table></figure>
<p>使用如下命令查看当前的配置信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure show</span></span><br><span class="line">node node1.test.com</span><br><span class="line">node node2.test.com</span><br><span class="line">property <span class="variable">$id</span>=<span class="string">"cib-bootstrap-options"</span> \</span><br><span class="line">  dc-version=<span class="string">"1.1.8-7.el6-394e906"</span> \</span><br><span class="line">  cluster-infrastructure=<span class="string">"classic openais (with plugin)"</span> \</span><br><span class="line">  expected-quorum-votes=<span class="string">"2"</span> \</span><br><span class="line">  stonith-enabled=<span class="string">"false"</span></span><br></pre></td></tr></table></figure>
<p>从中可以看出stonith已经被禁用。</p>
<p>上面的crm，crm_verify命令是1.0后的版本的pacemaker提供的基于命令行的集群管理工具；可以在集群中的任何一个节点上执行。</p>
<h1 id="为集群添加集群资源"><a href="#为集群添加集群资源" class="headerlink" title="为集群添加集群资源"></a>为集群添加集群资源</h1><p>corosync支持heartbeat，LSB和ocf等类型的资源代理，目前较为常用的类型为LSB和OCF两类，stonith类专为配置stonith设备而用；</p>
<p>可以通过如下命令查看当前集群系统所支持的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm ra classes</span></span><br><span class="line">heartbeat</span><br><span class="line">lsb</span><br><span class="line">ocf / heartbeat pacemaker</span><br><span class="line">stonith</span><br></pre></td></tr></table></figure>
<p>如果想要查看某种类别下的所用资源代理的列表，可以使用类似如下命令实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm ra list lsb</span></span><br><span class="line"><span class="comment"># crm ra list ocf heartbeat</span></span><br><span class="line"><span class="comment"># crm ra list ocf pacemaker</span></span><br><span class="line"><span class="comment"># crm ra list stonith</span></span><br><span class="line"><span class="comment"># crm ra info [class:[provider:]]resource_agent</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm ra info ocf:heartbeat:IPaddr</span></span><br></pre></td></tr></table></figure>
<p>接下来要创建的web集群创建一个IP地址资源，以在通过集群提供web服务时使用；这可以通过如下方式实现：</p>
<p>语法：</p>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">primitive apcfence stonith:apcsmart \</span><br><span class="line">         params ttydev=/dev/ttyS0 hostlist=<span class="string">"node1 node2"</span> \</span><br><span class="line">         op start timeout=60s \</span><br><span class="line">         op monitor interval=30m timeout=60s</span><br></pre></td></tr></table></figure>
<h1 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure primitive WebIP ocf:heartbeat:IPaddr params ip=192.168.10.11</span></span><br></pre></td></tr></table></figure>
<p>通过如下的命令执行结果可以看出此资源已经在node1.test.com上启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line">Last updated: Sun Sep 15 12:25:54 2013</span><br><span class="line">Last change: Sun Sep 15 12:25:50 2013 via cibadmin on node1.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node2.test.com - partition with quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">1 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node1.test.com node2.test.com ]</span><br><span class="line">WebIP  (ocf::heartbeat:IPaddr):  Started node1.test.com</span><br></pre></td></tr></table></figure>
<p>当然，也可以在node1上执行ifconfig命令看到此地址已经在eth0的别名上生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># ifconfig</span></span><br><span class="line">eth0:0    Link encap:Ethernet  HWaddr 00:0C:29:62:DE:4C  </span><br><span class="line">          inet addr:192.168.10.11  Bcast:192.168.0.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br></pre></td></tr></table></figure>
<p>而后我们到node2上通过如下命令停止node1上的corosync服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh node1 -- /etc/init.d/corosync stop</span></span><br></pre></td></tr></table></figure>
<p>查看集群工作状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line">Last updated: Sun Sep 15 12:32:10 2013</span><br><span class="line">Last change: Sun Sep 15 12:31:46 2013 via cibadmin on node1.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node2.test.com - partition WITHOUT quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">1 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node2.test.com ]</span><br><span class="line">OFFLINE: [ node1.test.com ]</span><br></pre></td></tr></table></figure>
<p>上面的信息显示node1.test.com已经离线，但资源WebIP却没能在node2.test.com上启动。这是因为此时的集群状态为”WITHOUT quorum”，即已经失去了quorum，此时集群服务本身已经不满足正常运行的条件，这对于只有两节点的集群来讲是不合理的。因此，我们可以通过如下的命令来修改忽略quorum不能满足的集群状态检查：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure property no-quorum-policy=ignore</span></span><br></pre></td></tr></table></figure>
<p>片刻之后，集群就会在目前仍在运行中的节点node2上启动此资源了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line">Last updated: Mon Jul  8 19:14:30 2013</span><br><span class="line">Last change: Sun Sep 15 15:16:37 2013 via cibadmin on node2.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1.test.com - partition with quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">1 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node1.test.com node2.test.com ]</span><br><span class="line"></span><br><span class="line">WebIP  (ocf::heartbeat:IPaddr):  Started node2.test.com</span><br></pre></td></tr></table></figure>
<p>好了，验正完成后，我们正常启动node1.test.com:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ssh node1 -- /etc/init.d/corosync start</span></span><br></pre></td></tr></table></figure>
<p>正常启动node1.test.com后，集群资源WebIP很可能会重新从node2.test.com转移回node1.test.com。资源的这种在节点间每一次的来回流动都会造成那段时间内其无法正常被访问，所以，我们有时候需要在资源因为节点故障转移到其它节点后，即便原来的节点恢复正常也禁止资源再次流转回来。这可以通过定义资源的黏性(stickiness)来实现。在创建资源时或在创建资源后，都可以指定指定资源黏性。</p>
<p>资源黏性值范围及其作用：<br>0：这是默认选项。资源放置在系统中的最适合位置。这意味着当负载能力“较好”或较差的节点变得可用时才转移资源。此选项的作用基本等同于自动故障回复，只是资源可能会转移到非之前活动的节点上；<br>大于0：资源更愿意留在当前位置，但是如果有更合适的节点可用时会移动。值越高表示资源越愿意留在当前位置；<br>小于0：资源更愿意移离当前位置。绝对值越高表示资源越愿意离开当前位置；<br>INFINITY：如果不是因节点不适合运行资源（节点关机、节点待机、达到migration-threshold 或配置更改）而强制资源转移，资源总是留在当前位置。此选项的作用几乎等同于完全禁用自动故障回复；<br>-INFINITY：资源总是移离当前位置；</p>
<p>我们这里可以通过以下方式为资源指定默认黏性值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure rsc_defaults resource-stickiness=100</span></span><br></pre></td></tr></table></figure>
<p>结合上面已经配置好的IP地址资源，将此集群配置成为一个active/passive模型的web（httpd）服务集群</p>
<p>为了将此集群启用为web（httpd）服务器集群，我们得先在各节点上安装httpd，并配置其能在本地各自提供一个测试页面。</p>
<p>Node1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install httpd</span></span><br><span class="line"><span class="comment"># echo "&lt;h1&gt;node1.test.com&lt;/h1&gt;" &gt; /var/www/html/index.html</span></span><br></pre></td></tr></table></figure>
<p>Node2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install httpd</span></span><br><span class="line"><span class="comment"># echo "&lt;h1&gt;node2.test.com&lt;/h1&gt;" &gt; /var/www/html/index.html</span></span><br></pre></td></tr></table></figure>
<p>而后在各节点手动启动httpd服务，并确认其可以正常提供服务。接着使用下面的命令停止httpd服务，并确保其不会自动启动（在两个节点各执行一遍）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/init.d/httpd stop</span></span><br><span class="line"><span class="comment"># chkconfig httpd off</span></span><br></pre></td></tr></table></figure>
<p>接下来我们将此httpd服务添加为集群资源。将httpd添加为集群资源有两处资源代理可用：lsb和ocf:heartbeat，为了简单起见，我们这里使用lsb类型：</p>
<p>首先可以使用如下命令查看lsb类型的httpd资源的语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm ra info lsb:httpd</span></span><br><span class="line">start and stop Apache HTTP Server (lsb:httpd)</span><br><span class="line"></span><br><span class="line">The Apache HTTP Server is an efficient and extensible  \</span><br><span class="line">         server implementing the current HTTP standards.</span><br><span class="line"></span><br><span class="line">Operations<span class="string">' defaults (advisory minimum):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    start         timeout=15</span></span><br><span class="line"><span class="string">    stop          timeout=15</span></span><br><span class="line"><span class="string">    status        timeout=15</span></span><br><span class="line"><span class="string">    restart       timeout=15</span></span><br><span class="line"><span class="string">    force-reload  timeout=15</span></span><br><span class="line"><span class="string">    monitor       timeout=15 interval=15</span></span><br></pre></td></tr></table></figure>
<p>接下来新建资源WebSite：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure primitive WebServer lsb:httpd</span></span><br><span class="line"></span><br><span class="line">查看配置文件中生成的定义：</span><br><span class="line">node node1.test.com</span><br><span class="line">node node2.test.com</span><br><span class="line">primitive WebIP ocf:heartbeat:IPaddr \</span><br><span class="line">  params ip=<span class="string">"192.168.10.11"</span></span><br><span class="line">primitive WebServer lsb:httpd</span><br><span class="line">property <span class="variable">$id</span>=<span class="string">"cib-bootstrap-options"</span> \</span><br><span class="line">  dc-version=<span class="string">"1.1.8-7.el6-394e906"</span> \</span><br><span class="line">  cluster-infrastructure=<span class="string">"classic openais (with plugin)"</span> \</span><br><span class="line">  expected-quorum-votes=<span class="string">"2"</span> \</span><br><span class="line">  stonith-enabled=<span class="string">"false"</span> \</span><br><span class="line">  no-quorum-policy=<span class="string">"ignore"</span> \</span><br><span class="line">  last-lrm-refresh=<span class="string">"1373281380"</span></span><br><span class="line">rsc_defaults <span class="variable">$id</span>=<span class="string">"rsc-options"</span> \</span><br><span class="line">  resource-stickiness=<span class="string">"100"</span></span><br></pre></td></tr></table></figure>
<p>查看资源的启用状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line">Last updated: Mon Jul  8 19:21:29 2013</span><br><span class="line">Last change: Sun Sep 15 15:22:13 2013 via cibadmin on node2.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1.test.com - partition with quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">2 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node1.test.com node2.test.com ]</span><br><span class="line"></span><br><span class="line">WebIP  (ocf::heartbeat:IPaddr):  Started node1.test.com</span><br><span class="line">WebServer  (lsb:httpd):  Started node2.test.com</span><br></pre></td></tr></table></figure>
<p>从上面的信息中可以看出WebIP和WebServer有可能会分别运行于两个节点上，这对于通过此IP提供Web服务的应用来说是不成立的，即此两者资源必须同时运行在某节点上。</p>
<p>由此可见，即便集群拥有所有必需资源，但它可能还无法进行正确处理。资源约束则用以指定在哪些群集节点上运行资源，以何种顺序装载资源，以及特定资源依赖于哪些其它资源。pacemaker共给我们提供了三种资源约束方法：</p>
<ol>
<li>Resource Location（资源位置）：定义资源可以、不可以或尽可能在哪些节点上运行；</li>
<li>Resource Collocation（资源排列）：排列约束用以定义集群资源可以或不可以在某个节点上同时运行；</li>
<li>Resource Order（资源顺序）：顺序约束定义集群资源在节点上启动的顺序；</li>
</ol>
<p>定义约束时，还需要指定分数。各种分数是集群工作方式的重要组成部分。其实，从迁移资源到决定在已降级集群中停止哪些资源的整个过程是通过以某种方式修改分数来实现的。分数按每个资源来计算，资源分数为负的任何节点都无法运行该资源。在计算出资源分数后，集群选择分数最高的节点。INFINITY（无穷大）目前定义为 1,000,000。加减无穷大遵循以下3个基本规则：</p>
<ol>
<li>任何值 + 无穷大 = 无穷大</li>
<li>任何值 - 无穷大 = -无穷大</li>
<li>无穷大 - 无穷大 = -无穷大</li>
</ol>
<p>定义资源约束时，也可以指定每个约束的分数。分数表示指派给此资源约束的值。分数较高的约束先应用，分数较低的约束后应用。通过使用不同的分数为既定资源创建更多位置约束，可以指定资源要故障转移至的目标节点的顺序。</p>
<p>因此，对于前述的WebIP和WebServer可能会运行于不同节点的问题，可以通过以下命令来解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure colocation websserver-with-webip INFINITY: WebServer WebIP</span></span><br></pre></td></tr></table></figure>
<p>如下的状态信息显示，两个资源已然运行于同一个节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm status</span></span><br><span class="line">Last updated: Mon Jul  8 19:27:47 2013</span><br><span class="line">Last change: Sun Sep 15 15:29:55 2013 via cibadmin on node2.test.com</span><br><span class="line">Stack: classic openais (with plugin)</span><br><span class="line">Current DC: node1.test.com - partition with quorum</span><br><span class="line">Version: 1.1.8-7.el6-394e906</span><br><span class="line">2 Nodes configured, 2 expected votes</span><br><span class="line">2 Resources configured.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Online: [ node1.test.com node2.test.com ]</span><br><span class="line"></span><br><span class="line">WebIP  (ocf::heartbeat:IPaddr):  Started node1.test.com</span><br><span class="line">WebServer  (lsb:httpd):  Started node1.test.com</span><br></pre></td></tr></table></figure>
<p>接着，我们还得确保WebSite在某节点启动之前得先启动WebIP，这可以使用如下命令实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure order webserver-after-webip mandatory: WebIP WebServer</span></span><br></pre></td></tr></table></figure>
<p>此外，由于HA集群本身并不强制每个节点的性能相同或相近，所以，某些时候我们可能希望在正常时服务总能在某个性能较强的节点上运行，这可以通过位置约束来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure location prefer-node1 WebServer rule 200: node1.test.com</span></span><br></pre></td></tr></table></figure>
<p>这条命令实现了将WebSite约束在node1上，且指定其分数为200；</p>
<p>最终的配置结果如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># crm configure show</span></span><br><span class="line">node node1.test.com</span><br><span class="line">node node2.test.com \</span><br><span class="line">  attributes standby=<span class="string">"off"</span></span><br><span class="line">primitive WebIP ocf:heartbeat:IPaddr \</span><br><span class="line">  params ip=<span class="string">"192.168.10.11"</span></span><br><span class="line">primitive WebServer lsb:httpd</span><br><span class="line">location prefer-node1 WebServer \</span><br><span class="line">  rule <span class="variable">$id</span>=<span class="string">"prefer-node1-rule"</span> 200: <span class="comment">#uname eq node1.test.com</span></span><br><span class="line">colocation websserver-with-webip inf: WebServer WebIP</span><br><span class="line">order webserver-after-webip inf: WebIP WebServer</span><br><span class="line">property <span class="variable">$id</span>=<span class="string">"cib-bootstrap-options"</span> \</span><br><span class="line">  dc-version=<span class="string">"1.1.8-7.el6-394e906"</span> \</span><br><span class="line">  cluster-infrastructure=<span class="string">"classic openais (with plugin)"</span> \</span><br><span class="line">  expected-quorum-votes=<span class="string">"2"</span> \</span><br><span class="line">  stonith-enabled=<span class="string">"false"</span> \</span><br><span class="line">  no-quorum-policy=<span class="string">"ignore"</span> \</span><br><span class="line">  last-lrm-refresh=<span class="string">"1373281380"</span></span><br><span class="line">rsc_defaults <span class="variable">$id</span>=<span class="string">"rsc-options"</span> \</span><br><span class="line">  resource-stickiness=<span class="string">"100"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充知识：<br>多播地址(multicast address)即组播地址，是一组主机的标示符，它已经加入到一个多播组中。在以太网中，多播地址是一个48位的标示符，命名了一组应该在这个网络中应用接收到一个分组的站点。在IPv4中，它历史上被叫做D类地址，一种类型的IP地址，它的范围从224.0.0.0到239.255.255.255，或，等同的，在224.0.0.0/4。在IPv6，多播地址都有前缀ff00::/8。</p>
<p>多播是第一个字节的最低位为1的所有地址，例如01-12-0f-00-00-02。广播地址是全1的48位地址，也属于多播地址。但是广播又是多播中的特例，就像是正方形属于长方形，但是正方形有长方形没有的特点。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Corosync</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobbler</title>
    <url>/2017/06/17/Linux/Cobbler/</url>
    <content><![CDATA[<p>Cobbler:</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><em>前提：cobbler由epel源提供，故此需要事先配置指向epel的yum源方可进行类似下面的安装过程。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install cobbler cobbler-web pykickstart debmirror</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># service httpd start</span></span><br><span class="line"><span class="comment"># service cobblerd start</span></span><br></pre></td></tr></table></figure>
<p>执行“cobbler check命令检查存的问题，而后逐一按提示解决之。常见的问题如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 : The <span class="string">'server'</span> field <span class="keyword">in</span> /etc/cobbler/settings must be <span class="built_in">set</span> to something other than localhost, or kickstarting features will not work.  This should be a resolvable hostname or IP <span class="keyword">for</span> the boot server as reachable by all machines that will use it.</span><br><span class="line">2 : For PXE to be functional, the <span class="string">'next_server'</span> field <span class="keyword">in</span> /etc/cobbler/settings must be <span class="built_in">set</span> to something other than 127.0.0.1, and should match the IP of the boot server on the PXE network.</span><br><span class="line">3 : some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run <span class="string">'cobbler get-loaders'</span> to download them, or, <span class="keyword">if</span> you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files <span class="keyword">in</span> this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The <span class="string">'cobbler get-loaders'</span> <span class="built_in">command</span> is the easiest way to resolve these requirements.</span><br><span class="line">4 : change <span class="string">'disable'</span> to <span class="string">'no'</span> <span class="keyword">in</span> /etc/xinetd.d/rsync</span><br><span class="line">5 : comment <span class="string">'dists'</span> on /etc/debmirror.conf <span class="keyword">for</span> proper debian support</span><br><span class="line">6 : comment <span class="string">'arches'</span> on /etc/debmirror.conf <span class="keyword">for</span> proper debian support</span><br><span class="line">7 : The default password used by the sample templates <span class="keyword">for</span> newly installed machines (default_password_crypted <span class="keyword">in</span> /etc/cobbler/settings) is still <span class="built_in">set</span> to <span class="string">'cobbler'</span> and should be changed, try: <span class="string">"openssl passwd -1 -salt 'random-phrase-here' 'your-password-here'"</span> to generate new one</span><br><span class="line">8 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them</span><br><span class="line"></span><br><span class="line">Restart cobblerd and <span class="keyword">then</span> run <span class="string">'cobbler sync'</span> to apply changes.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上各问题的解决方法如下所示：</p>
<ol>
<li>修改/etc/cobbler/settings文件中的server参数的值为提供cobbler服务的主机相应的IP地址或主机名，如172.16.100.15；</li>
<li>修改/etc/cobbler/settings文件中的next_server参数的值为提供PXE服务的主机相应的IP地址，如172.16.100.16；</li>
<li>如果当前节点可以访问互联网，执行“cobbler get-loaders”命令即可；否则，需要安装syslinux程序包，而后复制/usr/share/syslinux/{pxelinux.0,memu.c32}等文件至/var/lib/cobbler/loaders/目录中；</li>
<li>执行“chkconfig rsync on”命令即可；</li>
<li>注释/etc/debmirror.conf文件中的“@dists=”sid”;”一行；</li>
<li>注释/etc/debmirror.conf文件中的“@arches=”i386”;”一行；</li>
<li>执行“openssl passwd -1 -salt $(openssl rand -hex 4)”生成密码，并用其替换/etc/cobbler/settings文件中default_password_crypted参数的值；</li>
<li>执行“yum install cman fence-agents”命令安装相应的程序包即可；</li>
</ol>
<p>接着重启cobblerd，而后执行“cobbler sync”同步新的配置至cobbler。</p>
<h2 id="配置及启动cobbler所依赖的各服务"><a href="#配置及启动cobbler所依赖的各服务" class="headerlink" title="配置及启动cobbler所依赖的各服务"></a>配置及启动cobbler所依赖的各服务</h2><p>cobbler的运行依赖于dhcp、tftp、rsync及dns服务。其中dhcp可由dhcpd(isc)提供，也可由dnsmasq提供；tftp可由tftp-server程序包提供，也可由cobbler自带的tftp功能提供；rsync由rsync程序包提供；dns可由bind提供，也可由dnsmasq提供。</p>
<p>cobbler可自行管理这些服务中的部分甚至是全部，但需要配置/etc/cobbler/settings文件中的“manage_dhcp”、“manage_tftpd”、“manage_rsync”和“manage_dns”分别进行定义。另外，由于每种服务都有着不同的实现方式，如若需要进行自定义，需要通过修改/etc/cobbler/modules.conf配置文件中各服务的模块参数的值来实现。</p>
<p>本文采用了独立管理的方式，即不通过cobbler来管理这些服务。</p>
<h3 id="配置dhcp服务"><a href="#配置dhcp服务" class="headerlink" title="配置dhcp服务"></a>配置dhcp服务</h3><p>定义好所需的“subnet”及其它参数或选项，而后启动dhcpd守护进程即可。本示例中所用的dhcpd的配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">option domain-name <span class="string">"magedu.com"</span>;</span><br><span class="line">option domain-name-servers 192.168.10.254,172.16.0.1;</span><br><span class="line"></span><br><span class="line">default-lease-time 43200;</span><br><span class="line">max-lease-time 86400;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-facility local7;</span><br><span class="line"></span><br><span class="line">subnet 172.16.0.0 netmask 255.255.0.0 &#123;</span><br><span class="line">    range 172.16.100.121 172.16.100200;</span><br><span class="line">    option routers 172.16.100.7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next-server 172.16.100.7;</span><br><span class="line">filename=<span class="string">"pxelinux.0"</span>;</span><br></pre></td></tr></table></figure>
<p>接着使用“service dhcpd start”启动服务即可。</p>
<h2 id="配置tftp服务"><a href="#配置tftp服务" class="headerlink" title="配置tftp服务"></a>配置tftp服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chkconfig tftp on</span></span><br><span class="line"><span class="comment"># service xinetd restart</span></span><br></pre></td></tr></table></figure>
<h1 id="配置cobbler"><a href="#配置cobbler" class="headerlink" title="配置cobbler"></a>配置cobbler</h1><p><em>cobbler的各主要组件间的关系如下图所示。</em></p>
<p><img src="https://blog-image.nos-eastchina1.126.net/EbCj2b6D5I.jpg?imageslim" alt="mark"></p>
<h2 id="管理distro"><a href="#管理distro" class="headerlink" title="管理distro"></a>管理distro</h2><p>使cobbler变得可用的第一步为定义distro，其可以通过为其指定外部的安装引导内核及ramdisk文件的方式实现。而如果已经有完整的系统安装树（如CentOS6的安装镜像）则推荐使用import直接导入的方式进行。</p>
<p>例如，对于已经挂载至/media/cdrom目录的CentOS 6.5 x86_64的安装镜像，则可以使用类似如下命令进行导入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cobbler import --name=centos-6.5-x86_64 --path=/media/cdrom</span></span><br></pre></td></tr></table></figure>
<p>可使用“cobbler distro list”列出所有的distro。</p>
<p>如果有kickstart文件，也可以使用“—kickstart=/path/to/kickstart_file”进行导入，因此import会自动为导入的distro生成一个profile。</p>
<h2 id="管理profile"><a href="#管理profile" class="headerlink" title="管理profile"></a>管理profile</h2><p>cobbler使用profile来为特定的需求类别提供所需要安装配置，即在distro的基础上通过提供kickstart文件来生成一个特定的系统安装配置。distro的profile可以出现在PXE的引导菜单中作为安装的选择之一。</p>
<p>因此，如果需要为前面创建的centos-6.5-x86_64这个distro提供一个可引导安装条目，其用到的kickstart文件为/tmp/centos-6.5-x86_64.cfg(只提供了最基本的程序包)，则可通过如下命令实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cobbler profile add --name=centos-6.5-x86_64-basic --distro=centos-6.5-x86_64 --kickstart=/tmp/centos-6.5-x86_64.cfg</span></span><br></pre></td></tr></table></figure>
<p>可使用“cobbler profile list”查看已经创建的profile。</p>
<h1 id="使用cobbler-web"><a href="#使用cobbler-web" class="headerlink" title="使用cobbler_web"></a>使用cobbler_web</h1><h2 id="配置cobbler-web的认证功能"><a href="#配置cobbler-web的认证功能" class="headerlink" title="配置cobbler_web的认证功能"></a>配置cobbler_web的认证功能</h2><p>cobbler_web支持多种认证方式，如authn_configfile、authn_ldap或authn_pam等，默认为authn_denyall，即拒绝所有用户登录。下面说明两种能认证用户登录cobbler_web的方式。</p>
<h3 id="使用authn-pam模块认证cobbler-web用户"><a href="#使用authn-pam模块认证cobbler-web用户" class="headerlink" title="使用authn_pam模块认证cobbler_web用户"></a>使用authn_pam模块认证cobbler_web用户</h3><p>首先修改modules中[authentication]段的module参数的值为authn_pam。</p>
<p>接着添加系统用户，用户名和密码按需设定即可，例如下面的命令所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># useradd cblradmin</span></span><br><span class="line"><span class="comment"># echo 'cblrpass' | passwd --stdin cblradmin</span></span><br></pre></td></tr></table></figure>
<p>而后将cblradmin用户添加至cobbler_web的admin组中。修改/etc/cobbler/users.conf文件，将cblradmin用户名添加为admin参数的值即可，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[admins]</span><br><span class="line">admin = <span class="string">"cblradmin"</span></span><br></pre></td></tr></table></figure>
<p>最后重启cobblerd服务，通过<br><a href="http://YOUR_COBBLERD_IP/cobbler_web访问即可" target="_blank" rel="noopener">http://YOUR_COBBLERD_IP/cobbler_web访问即可</a></p>
<h3 id="使用authn-configfile模块认证cobbler-web用户"><a href="#使用authn-configfile模块认证cobbler-web用户" class="headerlink" title="使用authn_configfile模块认证cobbler_web用户"></a>使用authn_configfile模块认证cobbler_web用户</h3><p>首先修改modules中[authentication]段的module参数的值为authn_configfile。</p>
<p>接着创建其认证文件/etc/cobbler/users.digest，并添加所需的用户即可。需要注意的是，添加第一个用户时，需要为htdigest命令使用“-c”选项，后续添加其他用户时不能再使用；另外，cobbler_web的realm只能为Cobbler。如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># htdigest -c /etc/cobbler/users.digest Cobbler cblradmin</span></span><br></pre></td></tr></table></figure>
<p>最后重启cobblerd服务，通过<a href="http://YOUR_COBBLERD_IP/cobbler_web访问即可。" target="_blank" rel="noopener">http://YOUR_COBBLERD_IP/cobbler_web访问即可。</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cobbler</tag>
      </tags>
  </entry>
  <entry>
    <title>Keepalived</title>
    <url>/2017/06/10/LB/Keepalived/</url>
    <content><![CDATA[<h1 id="VRRP概述"><a href="#VRRP概述" class="headerlink" title="VRRP概述"></a>VRRP概述</h1><p>LAN客户端判定哪个路由器应该为其到达目标主机的下一跳网关的方式有动态及静态决策两种方式，其中，常见的动态路由发现方式有如下几种：<br>1、Proxy ARP —— 客户端使用ARP协议获取其想要到达的目标，而后，由某路由以其MAC地址响应此ARP请求；<br>2、Routing Protocol —— 客户端监听动态路由更新(如通过RIP或OSPF协议)并以之重建自己的路由表；<br>3、ICMP IRDP (Router Discovery Protocol) 客户端 —— 客户端主机运行一个ICMP路由发现客户端程序；</p>
<p>动态路由发现协议的不足之处在于它会导致在客户端引起一定的配置和处理方面的开销，并且，如果路由器故障，切换至其它路由器的过程会比较慢。解决此类问题的一个方案是为客户端静态配置默认路由设备，这大大简化了客户端的处理过程，但也会带来单点故障类的问题。默认网关故障时，LAN客户端仅能实现本地通信。</p>
<p>VRRP可以通过在一组路由器(一个VRRP组)之间共享一个虚拟IP(VIP)解决静态配置的问题，此时仅需要客户端以VIP作为其默认网关即可。</p>
<p>图1显示了一个基本的VLAN拓扑，其中，Router A、B、C共同组成一个VRRP组，其VIP为10.110.10.1，配置在路由器A的物理接口上，因此A为master路由器，B和C为backup路由器。VRRP组中，master(路由器A)负责负责转发发往VIP地址的报文，客户端HostA、HostB、HostC都以此VIP作为其默认网关。一旦master故障，backup路由器B和C中具有最高优先级的路由器将成为master并接管VIP地址，而当原来的master路由器A重新上线时，其将重新成为master路由器。<br><img src="https://blog-image.nos-eastchina1.126.net/CELgCDEDiE.jpg?imageslim" alt="mark"></p>
<p>VRRP是一个“选举”协议，它能够动态地将一个虚拟路由器的责任指定至同一个VRRP组中的其它路由器上，从而消除了静态路由配置的单点故障。<br><a id="more"></a></p>
<h1 id="VRRP术语"><a href="#VRRP术语" class="headerlink" title="VRRP术语"></a>VRRP术语</h1><p>VRRP虚拟路由(VRRP router)：<font color=IndianRed>(摘自Wikipedia)</font><br>The Virtual Router Redundancy Protocol (VRRP) is a computer networking protocol that provides for automatic assignment of available Internet Protocol (IP) routers to participating hosts. This increases the availability and reliability of routing paths via automatic default gateway selections on an IP subnetwork.</p>
<p>The protocol achieves this by creation of virtual routers, which are an abstract representation of multiple routers, i.e. master and backup routers, acting as a group. The default gateway of a participating host is assigned to the virtual router instead of a physical router. If the physical router that is routing packets on behalf of the virtual router fails, another physical router is selected to automatically replace it. The physical router that is forwarding packets at any given time is called the master router.</p>
<p>VRRP provides information on the state of a router, not the routes processed and exchanged by that router. Each VRRP instance is limited, in scope, to a single subnet. It does not advertise IP routes beyond that subnet or affect the routing table in any way. VRRP can be used in Ethernet, MPLS and token ring networks with Internet Protocol Version 4 (IPv4), as well as IPv6.</p>
<p>The protocol is described in Internet Engineering Task Force (IETF) publication RFC 5798, which is an open standard, but Cisco claims that a similar protocol with essentially the same facility is patented and licensed;[1] however in reply to a direct request Robert Barr of Cisco replied in 2001 that they will not assert any patent claims unless someone tried to assert a claim against Cisco.[2] IBM also claims covering patents and their statement is readable on the IETF webpage.<br>英语极渣，摘取原文。</p>
<h1 id="VRRP的优势"><a href="#VRRP的优势" class="headerlink" title="VRRP的优势"></a>VRRP的优势</h1><ol>
<li>冗余：可以使用多个路由器设备作为LAN客户端的默认网关，大大降低了默认网关成为单点故障的可能性；</li>
<li>负载共享：允许来自LAN客户端的流量由多个路由器设备所共享；</li>
<li>多VRRP组：在一个路由器物理接口上可配置多达255个VRRP组；</li>
<li>多IP地址：基于接口别名在同一个物理接口上配置多个IP地址，从而支持在同一个物理接口上接入多个子网；</li>
<li>抢占：在master故障时允许优先级更高的backup成为master；</li>
<li>通告协议：使用IANA所指定的组播地址224.0.0.18进行VRRP通告；</li>
<li>VRRP追踪：基于接口状态来改变其VRRP优先级来确定最佳的VRRP路由器成为master；</li>
<li>IP地址拥有者（IP Address Owner）：如果一个VRRP设备将虚拟路由器IP地址作为真实的接口地址，则该设备被称为IP地址拥有者。如果IP地址拥有者是可用的，通常它将成为Master。</li>
</ol>
<p>配置keepalived为实现haproxy高可用的配置文件示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">         test@163.com</span><br><span class="line">         test@126.com</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from test@qq.com </span><br><span class="line">   smtp_connect_timeout 3</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script &quot;killall -0 haproxy&quot;</span><br><span class="line">    interval 1</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_mantaince_down &#123;</span><br><span class="line">   script &quot;[[ -f &#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot;</span><br><span class="line">   interval 1</span><br><span class="line">   weight -2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    interface eth0</span><br><span class="line">    state MASTER  # BACKUP for slave routers</span><br><span class="line">    priority 101  # 100 for BACKUP</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    garp_master_delay 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass password</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">       eth0</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        172.16.100.1&#x2F;16 dev eth0 label eth0:0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy</span><br><span class="line">        chk_mantaince_down</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;</span><br><span class="line">    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;</span><br><span class="line">    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：</em></p>
<ol>
<li>上面的state为当前节点的起始状态，通常在master/slave的双节点模型中，其一个默认为MASTER，而别一个默认为BACKUP。</li>
<li>priority为当关节点在当前虚拟路由器中的优先级，master的优先级应该大于slave的；</li>
</ol>
<h1 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h1><h2 id="notify-sh脚本的简单示例："><a href="#notify-sh脚本的简单示例：" class="headerlink" title="notify.sh脚本的简单示例："></a>notify.sh脚本的简单示例：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Goooo Goooo@gmail.com</span></span><br><span class="line"><span class="comment"># description: An example of notify script</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">vip=172.16.100.1</span><br><span class="line">contact=<span class="string">'root@localhost'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">notify</span></span>() &#123;</span><br><span class="line">    mailsubject=<span class="string">"`hostname` to be <span class="variable">$1</span>: <span class="variable">$vip</span> floating"</span></span><br><span class="line">    mailbody=<span class="string">"`date '+%F %H:%M:%S'`: vrrp transition, `hostname` changed to be <span class="variable">$1</span>"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$mailbody</span> | mail -s <span class="string">"<span class="variable">$mailsubject</span>"</span> <span class="variable">$contact</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    master)</span><br><span class="line">        notify master</span><br><span class="line">        /etc/rc.d/init.d/haproxy start</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    backup)</span><br><span class="line">        notify backup</span><br><span class="line">        /etc/rc.d/init.d/haproxy stop</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    fault)</span><br><span class="line">        notify fault</span><br><span class="line">        /etc/rc.d/init.d/haproxy stop</span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'Usage: `basename $0` &#123;master|backup|fault&#125;'</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h2 id="配置keepalived为实现haproxy高可用的双主模型配置文件示例"><a href="#配置keepalived为实现haproxy高可用的双主模型配置文件示例" class="headerlink" title="配置keepalived为实现haproxy高可用的双主模型配置文件示例"></a>配置keepalived为实现haproxy高可用的双主模型配置文件示例</h2><p><em>说明：其基本实现思想为创建两个虚拟路由器，并以两个节点互为主从。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived   </span><br><span class="line">  </span><br><span class="line">global_defs &#123;  </span><br><span class="line">   notification_email &#123;  </span><br><span class="line">        test@foxmail.com</span><br><span class="line">         test@126.com  </span><br><span class="line">   &#125;  </span><br><span class="line">   notification_email_from test@qq.com </span><br><span class="line">   smtp_connect_timeout 3  </span><br><span class="line">   smtp_server 127.0.0.1  </span><br><span class="line">   router_id LVS_DEVEL  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">vrrp_script chk_haproxy &#123;  </span><br><span class="line">    script &quot;killall -0 haproxy&quot;  </span><br><span class="line">    interval 1  </span><br><span class="line">    weight 2  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">vrrp_script chk_mantaince_down &#123;</span><br><span class="line">   script &quot;[[ -f &#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot;</span><br><span class="line">   interval 1</span><br><span class="line">   weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;  </span><br><span class="line">    interface eth0  </span><br><span class="line">    state MASTER  # BACKUP for slave routers</span><br><span class="line">    priority 101  # 100 for BACKUP</span><br><span class="line">    virtual_router_id 51 </span><br><span class="line">    garp_master_delay 1 </span><br><span class="line">  </span><br><span class="line">    authentication &#123;  </span><br><span class="line">        auth_type PASS  </span><br><span class="line">        auth_pass password  </span><br><span class="line">    &#125;  </span><br><span class="line">    track_interface &#123;  </span><br><span class="line">       eth0    </span><br><span class="line">    &#125;  </span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        172.16.100.1&#x2F;16 dev eth0 label eth0:0 </span><br><span class="line">    &#125;  </span><br><span class="line">    track_script &#123;  </span><br><span class="line">        chk_haproxy  </span><br><span class="line">        chk_mantaince_down</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">    notify_master &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh master&quot;  </span><br><span class="line">    notify_backup &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh backup&quot;  </span><br><span class="line">    notify_fault &quot;&#x2F;etc&#x2F;keepalived&#x2F;notify.sh fault&quot;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">vrrp_instance VI_2 &#123;  </span><br><span class="line">    interface eth0  </span><br><span class="line">    state BACKUP  # BACKUP for slave routers</span><br><span class="line">    priority 100  # 100 for BACKUP</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    garp_master_delay 1 </span><br><span class="line">  </span><br><span class="line">    authentication &#123;  </span><br><span class="line">        auth_type PASS  </span><br><span class="line">        auth_pass password  </span><br><span class="line">    &#125;  </span><br><span class="line">    track_interface &#123;  </span><br><span class="line">       eth0    </span><br><span class="line">    &#125;  </span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        172.16.100.2&#x2F;16 dev eth0 label eth0:1</span><br><span class="line">    &#125;  </span><br><span class="line">    track_script &#123;  </span><br><span class="line">        chk_haproxy  </span><br><span class="line">        chk_mantaince_down</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>说明：</em><br>1、对于VI_1和VI_2来说，两个节点要互为主从关系；</p>
<h2 id="LVS-keepalived的实现"><a href="#LVS-keepalived的实现" class="headerlink" title="LVS + keepalived的实现"></a>LVS + keepalived的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived  </span><br><span class="line">  </span><br><span class="line">global_defs &#123;  </span><br><span class="line">   notification_email &#123;  </span><br><span class="line">         test@foxmail.com</span><br><span class="line">         test@126.com  </span><br><span class="line">   &#125;  </span><br><span class="line">   notification_email_from test@qq.com </span><br><span class="line">   smtp_connect_timeout 3  </span><br><span class="line">   smtp_server 127.0.0.1  </span><br><span class="line">   router_id LVS_DEVEL  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">vrrp_script chk_schedown &#123;</span><br><span class="line">   script &quot;[[ -f &#x2F;etc&#x2F;keepalived&#x2F;down ]] &amp;&amp; exit 1 || exit 0&quot;</span><br><span class="line">   interval 2</span><br><span class="line">   weight -2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;  </span><br><span class="line">    interface eth0  </span><br><span class="line">    state MASTER  </span><br><span class="line">    priority 101</span><br><span class="line">    virtual_router_id 51 </span><br><span class="line">    garp_master_delay 1 </span><br><span class="line"> </span><br><span class="line">    authentication &#123;  </span><br><span class="line">        auth_type PASS  </span><br><span class="line">        auth_pass password  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    track_interface &#123;  </span><br><span class="line">       eth0    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;  </span><br><span class="line">        172.16.100.1&#x2F;16 dev eth0 label eth0:0</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    track_script &#123;  </span><br><span class="line">        chk_schedown</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virtual_server 172.16.100.1 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 50</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">#    sorry_server 192.168.200.200 1358</span><br><span class="line"></span><br><span class="line">    real_server 172.16.100.11 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path &#x2F;</span><br><span class="line">              status_code 200</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 172.16.100.12 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            url &#123; </span><br><span class="line">              path &#x2F;</span><br><span class="line">              status_code 200</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用TCP_CHECK检测各realserver的健康状态，那么，上面关于realserver部分的定义也可以替换为如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual_server 172.16.100.1 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr </span><br><span class="line">    lb_kind DR</span><br><span class="line">    persistence_timeout 300</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    sorry_server 127.0.0.1 80</span><br><span class="line"></span><br><span class="line">    real_server 172.16.100.11 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">	    	    tcp_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 172.16.100.12 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">	    	    connect_port 80</span><br><span class="line">            connect_timeout 3</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>说明：其中的sorry_server是用于定义所有realserver均出现故障时所用的服务器。</em></p>
<h1 id="keepalived通知脚本进阶示例"><a href="#keepalived通知脚本进阶示例" class="headerlink" title="keepalived通知脚本进阶示例"></a>keepalived通知脚本进阶示例</h1><p>下面的脚本可以接受选项，其中：<br>-s, —service SERVICE,…：指定服务脚本名称，当状态切换时可自动启动、重启或关闭此服务；<br>-a, —address VIP: 指定相关虚拟路由器的VIP地址；<br>-m, —mode {mm|mb}：指定虚拟路由的模型，mm表示主主，mb表示主备；它们表示相对于同一种服务而方，其VIP的工作类型；<br>-n, —notify {master|backup|fault}：指定通知的类型，即vrrp角色切换的目标角色；<br>-h, —help：获取脚本的使用帮助；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: test</span></span><br><span class="line"><span class="comment"># description: An example of notify script</span></span><br><span class="line"><span class="comment"># Usage: notify.sh -m|--mode &#123;mm|mb&#125; -s|--service SERVICE1,... -a|--address VIP  -n|--notify &#123;master|backup|falut&#125; -h|--help </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#contact='linuxedu@foxmail.com'</span></span><br><span class="line">helpflag=0</span><br><span class="line">serviceflag=0</span><br><span class="line">modeflag=0</span><br><span class="line">addressflag=0</span><br><span class="line">notifyflag=0</span><br><span class="line"></span><br><span class="line">contact=<span class="string">'root@localhost'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Usage: notify.sh [-m|--mode &#123;mm|mb&#125;] [-s|--service SERVICE1,...] &lt;-a|--address VIP&gt;  &lt;-n|--notify &#123;master|backup|falut&#125;&gt;"</span> </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Usage: notify.sh -h|--help"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ParseOptions</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> I=1;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$#</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ <span class="variable">$I</span> -le <span class="variable">$#</span> ]; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	  -s|--service)</span><br><span class="line">		[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">return</span> 3</span><br><span class="line"> 	    serviceflag=1</span><br><span class="line"> 		services=(`<span class="built_in">echo</span> <span class="variable">$2</span>|awk -F<span class="string">","</span> <span class="string">'&#123;for(i=1;i&lt;=NF;i++) print $i&#125;'</span>`)</span><br><span class="line">		<span class="built_in">shift</span> 2 ;;</span><br><span class="line">	  -h|--<span class="built_in">help</span>)</span><br><span class="line"> 		helpflag=1</span><br><span class="line">		<span class="built_in">return</span> 0</span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">		;;</span><br><span class="line">	  -a|--address)</span><br><span class="line">		[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">return</span> 3</span><br><span class="line">	    addressflag=1</span><br><span class="line">		vip=<span class="variable">$2</span></span><br><span class="line">		<span class="built_in">shift</span> 2</span><br><span class="line">		;;</span><br><span class="line">	  -m|--mode)</span><br><span class="line">		[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">return</span> 3</span><br><span class="line">		mode=<span class="variable">$2</span></span><br><span class="line">		<span class="built_in">shift</span> 2</span><br><span class="line">		;;</span><br><span class="line">	  -n|--notify)</span><br><span class="line">		[ <span class="variable">$#</span> -lt 2 ] &amp;&amp; <span class="built_in">return</span> 3</span><br><span class="line">		notifyflag=1</span><br><span class="line">		notify=<span class="variable">$2</span></span><br><span class="line">		<span class="built_in">shift</span> 2</span><br><span class="line">		;;</span><br><span class="line">	  *)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"Wrong options..."</span></span><br><span class="line">		Usage</span><br><span class="line">		<span class="built_in">return</span> 7</span><br><span class="line">		;;</span><br><span class="line">       <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#workspace=$(dirname $0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">RestartService</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> [ -x /etc/rc.d/init.d/<span class="variable">$I</span> ]; <span class="keyword">then</span></span><br><span class="line">        /etc/rc.d/init.d/<span class="variable">$I</span> restart</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$I</span> is not a valid service..."</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">StopService</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -gt 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> [ -x /etc/rc.d/init.d/<span class="variable">$I</span> ]; <span class="keyword">then</span></span><br><span class="line">        /etc/rc.d/init.d/<span class="variable">$I</span> stop</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$I</span> is not a valid service..."</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Notify</span></span>() &#123;</span><br><span class="line">    mailsubject=<span class="string">"`hostname` to be <span class="variable">$1</span>: <span class="variable">$vip</span> floating"</span></span><br><span class="line">    mailbody=<span class="string">"`date '+%F %H:%M:%S'`, vrrp transition, `hostname` changed to be <span class="variable">$1</span>."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$mailbody</span> | mail -s <span class="string">"<span class="variable">$mailsubject</span>"</span> <span class="variable">$contact</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main Function</span></span><br><span class="line">ParseOptions <span class="variable">$@</span></span><br><span class="line">[ $? -ne 0 ] &amp;&amp; Usage &amp;&amp; <span class="built_in">exit</span> 5</span><br><span class="line"></span><br><span class="line">[ <span class="variable">$helpflag</span> -eq 1 ] &amp;&amp; Usage &amp;&amp; <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$addressflag</span> -ne 1 -o <span class="variable">$notifyflag</span> -ne 1 ]; <span class="keyword">then</span></span><br><span class="line">  Usage</span><br><span class="line">  <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mode=<span class="variable">$&#123;mode:-mb&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$notify</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">'master'</span>)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$serviceflag</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">      RestartService <span class="variable">$&#123;services[*]&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  Notify master</span><br><span class="line">  ;;</span><br><span class="line"><span class="string">'backup'</span>)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$serviceflag</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$mode</span>"</span> == <span class="string">'mb'</span> ]; <span class="keyword">then</span></span><br><span class="line">      StopService <span class="variable">$&#123;services[*]&#125;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      RestartService <span class="variable">$&#123;services[*]&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  Notify backup</span><br><span class="line">  ;;</span><br><span class="line"><span class="string">'fault'</span>)</span><br><span class="line">  Notify fault</span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  Usage</span><br><span class="line">  <span class="built_in">exit</span> 4</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>在keepalived.conf配置文件中，其调用方法如下所示：<br>++    notify_master “/etc/keepalived/notify.sh -n master -a 172.16.100.1”<br>    notify_backup “/etc/keepalived/notify.sh -n backup -a 172.16.100.1”<br>    notify_fault “/etc/keepalived/notify.sh -n fault -a 172.16.100.1”  ++</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置函数</title>
    <url>/2017/05/30/Program-design/Python/Built-in-functions/</url>
    <content><![CDATA[<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><a id="more"></a>
<ul>
<li>abs：绝对值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">""" Return the absolute value of the argument. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;abs(<span class="number">-4</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>divmod：返回两个数值的商和余数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divmod</span><span class="params">(x, y)</span>:</span> <span class="comment"># known case of builtins.divmod</span></span><br><span class="line">    <span class="string">""" Return the tuple (x//y, x%y).  Invariant: div*y + mod == x. """</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;divmod(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;divmod(<span class="number">7</span>,<span class="number">1.5</span>)</span><br><span class="line">(<span class="number">4.0</span>, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>max：返回可迭代对象中的元素中的最大值或者所有参数的最大值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span><span class="params">(*args, key=None)</span>:</span> <span class="comment"># known special case of max</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    max(iterable, *[, default=obj, key=func]) -&gt; value</span></span><br><span class="line"><span class="string">    max(arg1, arg2, *args, *[, key=func]) -&gt; value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    With a single iterable argument, return its biggest item. The</span></span><br><span class="line"><span class="string">    default keyword-only argument specifies an object to return if</span></span><br><span class="line"><span class="string">    the provided iterable is empty.</span></span><br><span class="line"><span class="string">    With two or more arguments, return the largest argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 传入3个参数 取3个中较大者</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="string">'1234'</span>) <span class="comment"># 传入1个可迭代对象，取其最大元素值</span></span><br><span class="line"><span class="string">'4'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="number">-1</span>,<span class="number">0</span>) <span class="comment"># 数值默认去数值较大者</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(<span class="number">-1</span>,<span class="number">0</span>,key = abs) <span class="comment"># 传入了求绝对值函数，则参数都会进行求绝对值后再取较大者</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>min：返回可迭代对象中的元素中的最小值或者所有参数的最小值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(*args, key=None)</span>:</span> <span class="comment"># known special case of min</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    min(iterable, *[, default=obj, key=func]) -&gt; value</span></span><br><span class="line"><span class="string">    min(arg1, arg2, *args, *[, key=func]) -&gt; value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    With a single iterable argument, return its smallest item. The</span></span><br><span class="line"><span class="string">    default keyword-only argument specifies an object to return if</span></span><br><span class="line"><span class="string">    the provided iterable is empty.</span></span><br><span class="line"><span class="string">    With two or more arguments, return the smallest argument.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="string">""" Return the absolute value of the argument. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 传入3个参数 取3个中较小者</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(<span class="string">'1234'</span>) <span class="comment"># 传入1个可迭代对象，取其最小元素值</span></span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(<span class="number">-1</span>,<span class="number">-2</span>) <span class="comment"># 数值默认去数值较小者</span></span><br><span class="line"><span class="number">-2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(<span class="number">-1</span>,<span class="number">-2</span>,key = abs)  <span class="comment"># 传入了求绝对值函数，则参数都会进行求绝对值后再取较小者</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pow：返回两个数值的幂运算值或其与指定整数的模值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Equivalent to x**y (with two arguments) or x**y % z (with three arguments)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Some types, such as ints, are able to use a more efficient algorithm when</span></span><br><span class="line"><span class="string">    invoked using the three argument form.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>round：对浮点数四舍五入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span><span class="params">(number, ndigits=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    round(number[, ndigits]) -&gt; number</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Round a number to a given precision in decimal digits (default 0 digits).</span></span><br><span class="line"><span class="string">    This returns an int when called with one argument, otherwise the</span></span><br><span class="line"><span class="string">    same type as the number. ndigits may be negative.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;round(<span class="number">4.33</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;&gt;round(<span class="number">1.44443326</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">1.4444</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sum：对元素类型是数值的可迭代对象中的每个元素求和</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the sum of a 'start' value (default: 0) plus an iterable of numbers</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When the iterable is empty, return the start value.</span></span><br><span class="line"><span class="string">    This function is intended specifically for use with numeric values and may</span></span><br><span class="line"><span class="string">    reject non-numeric types.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))  <span class="comment"># 传入可迭代对象</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum((<span class="number">1.5</span>,<span class="number">2.5</span>,<span class="number">3.5</span>,<span class="number">4.5</span>))  <span class="comment"># 元素类型必须是数值型</span></span><br><span class="line"><span class="number">12.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">-10</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul>
<li>bool：根据传入的参数的逻辑值创建一个新的布尔值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool() <span class="comment">#未传入参数</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">0</span>) <span class="comment">#数值0、空序列等值为False</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(<span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>int：根据传入的参数创建一个新的整数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, base=<span class="number">10</span>)</span>:</span> <span class="comment"># known special case of int.__init__</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">int(x=0) -&gt; integer</span></span><br><span class="line"><span class="string">int(x, base=10) -&gt; integer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Convert a number or string to an integer, or return 0 if no arguments</span></span><br><span class="line"><span class="string">are given.  If x is a number, return x.__int__().  For floating point</span></span><br><span class="line"><span class="string">numbers, this truncates towards zero.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If x is not a number or if base is given, then x must be a string,</span></span><br><span class="line"><span class="string">bytes, or bytearray instance representing an integer literal in the</span></span><br><span class="line"><span class="string">given base.  The literal can be preceded by '+' or '-' and be surrounded</span></span><br><span class="line"><span class="string">by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.</span></span><br><span class="line"><span class="string">Base 0 means to interpret the base from the string as an integer literal.</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>int('0b100', base=0)</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string"># (copied from class doc)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int() <span class="comment">#不传入参数时，得到结果0。</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3.6</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>float：根据传入的参数创建一个新的浮点数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>float() <span class="comment">#不提供参数的时候，返回0.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="number">3</span>)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="string">'3'</span>)</span><br><span class="line"><span class="number">3.0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>complex：根据传入参数创建一个新的复数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex() <span class="comment">#当两个参数都不提供时，返回复数 0j。</span></span><br><span class="line"><span class="number">0j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="string">'1+2j'</span>) <span class="comment">#传入字符串创建复数</span></span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">#传入数值创建复数</span></span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>str：返回一个对象的字符串表现形式(给用户)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str()</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="literal">None</span>)</span><br><span class="line"><span class="string">'None'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">'abc'</span>)</span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">123</span>)</span><br><span class="line"><span class="string">'123'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>bytearray：根据传入的参数创建一个新的字节数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytearray(<span class="string">'中文'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line">bytearray(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>bytes：根据传入的参数创建一个新的不可变字节数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes(<span class="string">'中文'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>memoryview：根据传入的参数创建一个新的内存查看对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = memoryview(<span class="string">b'abcefg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v[<span class="number">1</span>]</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v[<span class="number">-1</span>]</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ord：返回Unicode字符对应的整数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ord</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">""" Return the Unicode code point for a one-character string. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure>
<ul>
<li>chr：返回整数所对应的Unicode字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">""" Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">97</span>) <span class="comment">#参数类型为整数</span></span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>bin：将整数转换成2进制字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown; <span class="doctag">NOTE:</span> unreliably restored from __doc__ </span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the binary representation of an integer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       &gt;&gt;&gt; bin(2796202)</span></span><br><span class="line"><span class="string">       '0b1010101010101010101010'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">3</span>)</span><br><span class="line"><span class="string">'0b11'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>oct：将整数转化成8进制数字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">oct</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown; <span class="doctag">NOTE:</span> unreliably restored from __doc__ </span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the octal representation of an integer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       &gt;&gt;&gt; oct(342391)</span></span><br><span class="line"><span class="string">       '0o1234567'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">10</span>)</span><br><span class="line"><span class="string">'0o12'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hex：将整数转换成16进制字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown; <span class="doctag">NOTE:</span> unreliably restored from __doc__ </span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the hexadecimal representation of an integer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       &gt;&gt;&gt; hex(12648430)</span></span><br><span class="line"><span class="string">       '0xc0ffee'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">15</span>)</span><br><span class="line"><span class="string">'0xf'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tuple：根据传入的参数创建一个新的元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple() <span class="comment">#不传入参数，创建空元组</span></span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(<span class="string">'121'</span>) <span class="comment">#传入可迭代对象。使用其元素创建新的元组</span></span><br><span class="line">(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'1'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>list：根据传入的参数创建一个新的列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;list() <span class="comment"># 不传入参数，创建空列表</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(<span class="string">'abcd'</span>) <span class="comment"># 传入可迭代对象，使用其元素创建新的列表</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>dict：根据传入的参数创建一个新的字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict() <span class="comment"># 不传入任何参数时，返回空字典。</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(a = <span class="number">1</span>,b = <span class="number">2</span>) <span class="comment">#  可以传入键值对创建字典。</span></span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(zip([<span class="string">'a'</span>,<span class="string">'b'</span>],[<span class="number">1</span>,<span class="number">2</span>])) <span class="comment"># 可以传入映射函数创建字典。</span></span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(((<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>))) <span class="comment"># 可以传入可迭代对象创建字典。</span></span><br><span class="line">&#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set：根据传入的参数创建一个新的集合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;set() <span class="comment"># 不传入参数，创建空集合</span></span><br><span class="line">set()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set(range(<span class="number">10</span>)) <span class="comment"># 传入可迭代对象，创建集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>frozenset：根据传入的参数创建一个新的不可变集合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = frozenset(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">frozenset(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>enumerate：根据可迭代对象创建枚举对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>)) <span class="comment">#指定起始值</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>range：根据传入的参数创建一个新的range对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = range(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b,c <span class="comment"># 分别输出a,b,c</span></span><br><span class="line">(range(<span class="number">0</span>, <span class="number">10</span>), range(<span class="number">1</span>, <span class="number">10</span>), range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a),list(b),list(c) <span class="comment"># 分别输出a,b,c的元素</span></span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>iter：根据传入的参数创建一个新的可迭代对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iter</span><span class="params">(source, sentinel=None)</span>:</span> <span class="comment"># known special case of iter</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    iter(iterable) -&gt; iterator</span></span><br><span class="line"><span class="string">    iter(callable, sentinel) -&gt; iterator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Get an iterator from an object.  In the first form, the argument must</span></span><br><span class="line"><span class="string">    supply its own iterator, or be a sequence.</span></span><br><span class="line"><span class="string">    In the second form, the callable is called until it returns the sentinel.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = iter(<span class="string">'abcd'</span>) <span class="comment">#字符串序列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    next(a)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<ul>
<li>slice：根据传入的参数创建一个新的切片对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = slice(<span class="number">5</span>) <span class="comment"># 定义c1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1</span><br><span class="line">slice(<span class="literal">None</span>, <span class="number">5</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c2 = slice(<span class="number">2</span>,<span class="number">5</span>) <span class="comment"># 定义c2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c2</span><br><span class="line">slice(<span class="number">2</span>, <span class="number">5</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c3 = slice(<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>) <span class="comment"># 定义c3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c3</span><br><span class="line">slice(<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>super：根据传入的参数创建一个新的子类和父类关系的代理对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, type1=None, type2=None)</span>:</span> <span class="comment"># known special case of super.__init__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    super() -&gt; same as super(__class__, &lt;first argument&gt;)</span></span><br><span class="line"><span class="string">    super(type) -&gt; unbound super object</span></span><br><span class="line"><span class="string">    super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span></span><br><span class="line"><span class="string">    super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span></span><br><span class="line"><span class="string">    Typical use to call a cooperative superclass method:</span></span><br><span class="line"><span class="string">    class C(B):</span></span><br><span class="line"><span class="string">        def meth(self, arg):</span></span><br><span class="line"><span class="string">            super().meth(arg)</span></span><br><span class="line"><span class="string">    This works for class methods too:</span></span><br><span class="line"><span class="string">    class C(B):</span></span><br><span class="line"><span class="string">        @classmethod</span></span><br><span class="line"><span class="string">        def cmeth(cls, arg):</span></span><br><span class="line"><span class="string">            super().cmeth(arg)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    # (copied from class doc)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line">        super().__init__()</span><br></pre></td></tr></table></figure>
<ul>
<li>object：创建一个新的object对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = object()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name = <span class="string">'kim'</span> <span class="comment"># 不能设置属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#9&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.name = <span class="string">'kim'</span></span><br><span class="line">AttributeError: <span class="string">'object'</span> object has no attribute <span class="string">'name'</span></span><br></pre></td></tr></table></figure>
<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><ul>
<li>help：返回对象的帮助信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">str</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">str</span><span class="params">(object=<span class="string">''</span>)</span> -&gt; str</span></span><br><span class="line"><span class="class"> |  str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Create a new string object from the given object. If encoding or</span></span><br><span class="line"><span class="class"> |  errors is specified, then the object must expose a data buffer</span></span><br><span class="line"><span class="class"> |  that will be decoded using the given encoding and error handler.</span></span><br><span class="line"><span class="class"> |  Otherwise, returns the result of object.__str__() (if defined)</span></span><br><span class="line"><span class="class"> |  or repr(object).</span></span><br><span class="line"><span class="class"> |  encoding defaults to sys.getdefaultencoding().</span></span><br><span class="line"><span class="class"> |  errors defaults to 'strict'.</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Methods defined here:</span></span><br><span class="line"> |  </span><br><span class="line"> |  __add__(self, value, /)</span><br><span class="line"> |      Return self+value.</span><br><span class="line"> |  </span><br><span class="line">  ***************************</span><br></pre></td></tr></table></figure>
<ul>
<li>dir：返回对象或者当前作用域内的属性列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dir</span><span class="params">(p_object=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    dir([object]) -&gt; list of strings</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If called without an argument, return the names in the current scope.</span></span><br><span class="line"><span class="string">    Else, return an alphabetized list of names comprising (some of) the attributes</span></span><br><span class="line"><span class="string">    of the given object, and of attributes reachable from it.</span></span><br><span class="line"><span class="string">    If the object supplies a method named __dir__, it will be used; otherwise</span></span><br><span class="line"><span class="string">    the default dir() logic is used and returns:</span></span><br><span class="line"><span class="string">      for a module object: the module's attributes.</span></span><br><span class="line"><span class="string">      for a class object:  its attributes, and recursively the attributes</span></span><br><span class="line"><span class="string">        of its bases.</span></span><br><span class="line"><span class="string">      for any other object: its attributes, its class's attributes, and</span></span><br><span class="line"><span class="string">        recursively the attributes of its class's base classes.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math</span><br><span class="line">&lt;module <span class="string">'math'</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(math)</span><br><span class="line">[<span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'acos'</span>, <span class="string">'acosh'</span>, <span class="string">'asin'</span>, <span class="string">'asinh'</span>, <span class="string">'atan'</span>, <span class="string">'atan2'</span>, <span class="string">'atanh'</span>, <span class="string">'ceil'</span>, <span class="string">'copysign'</span>, <span class="string">'cos'</span>, <span class="string">'cosh'</span>, <span class="string">'degrees'</span>, <span class="string">'e'</span>, <span class="string">'erf'</span>, <span class="string">'erfc'</span>, <span class="string">'exp'</span>, <span class="string">'expm1'</span>, <span class="string">'fabs'</span>, <span class="string">'factorial'</span>, <span class="string">'floor'</span>, <span class="string">'fmod'</span>, <span class="string">'frexp'</span>, <span class="string">'fsum'</span>, <span class="string">'gamma'</span>, <span class="string">'gcd'</span>, <span class="string">'hypot'</span>, <span class="string">'inf'</span>, <span class="string">'isclose'</span>, <span class="string">'isfinite'</span>, <span class="string">'isinf'</span>, <span class="string">'isnan'</span>, <span class="string">'ldexp'</span>, <span class="string">'lgamma'</span>, <span class="string">'log'</span>, <span class="string">'log10'</span>, <span class="string">'log1p'</span>, <span class="string">'log2'</span>, <span class="string">'modf'</span>, <span class="string">'nan'</span>, <span class="string">'pi'</span>, <span class="string">'pow'</span>, <span class="string">'radians'</span>, <span class="string">'sin'</span>, <span class="string">'sinh'</span>, <span class="string">'sqrt'</span>, <span class="string">'tan'</span>, <span class="string">'tanh'</span>, <span class="string">'trunc'</span>]</span><br><span class="line"><span class="string">'0xf'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>id：返回对象的唯一标识符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">id</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the identity of an object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is guaranteed to be unique among simultaneously existing objects.</span></span><br><span class="line"><span class="string">    (CPython uses the object's memory address.)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"test"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">1621561598112</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hash：获取对象的哈希值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hash</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the hash value for the given object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Two objects that compare equal must also have the same hash value, but the</span></span><br><span class="line"><span class="string">    reverse is not necessarily true.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="string">'study'</span>)</span><br><span class="line"><span class="number">-3947515207446763768</span></span><br></pre></td></tr></table></figure>
<ul>
<li>type：返回对象的类型，或者根据传入的参数创建一个新的类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, what, bases=None, dict=None)</span>:</span> <span class="comment"># known special case of type.__init__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    type(object_or_name, bases, dict)</span></span><br><span class="line"><span class="string">    type(object) -&gt; the object's type</span></span><br><span class="line"><span class="string">    type(name, bases, dict) -&gt; a new type</span></span><br><span class="line"><span class="string">    # (copied from class doc)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">1</span>) <span class="comment"># 返回对象的类型</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#使用<span class="title">type</span>函数创建类型<span class="title">D</span>，含有属性<span class="title">InfoD</span></span></span><br><span class="line">&gt;&gt;&gt; D = type('D',(A,B),dict(InfoD='some thing defined in D'))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.InfoD</span><br><span class="line"><span class="string">'some thing defined in D'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>len：返回对象的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">len</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">""" Return the number of items in a container. """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'abcd'</span>) <span class="comment"># 字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(bytes(<span class="string">'abcd'</span>,<span class="string">'utf-8'</span>)) <span class="comment"># 字节数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># 列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(range(<span class="number">1</span>,<span class="number">5</span>)) <span class="comment"># range对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>,<span class="string">'d'</span>:<span class="number">4</span>&#125;) <span class="comment"># 字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;) <span class="comment"># 集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(frozenset(<span class="string">'abcd'</span>)) <span class="comment">#不可变集合</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ascii：返回对象的可打印表字符串表现方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ascii</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return an ASCII-only representation of an object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    As repr(), return a string containing a printable representation of an</span></span><br><span class="line"><span class="string">    object, but escape the non-ASCII characters in the string returned by</span></span><br><span class="line"><span class="string">    repr() using \\x, \\u or \\U escapes. This generates a string similar</span></span><br><span class="line"><span class="string">    to that returned by repr() in Python 2.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="number">1</span>)</span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'&amp;'</span>)</span><br><span class="line"><span class="string">"'&amp;'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="number">9000000</span>)</span><br><span class="line"><span class="string">'9000000'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'中文'</span>) <span class="comment">#非ascii字符</span></span><br><span class="line"><span class="string">"'\\u4e2d\\u6587'"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>format：格式化显示值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return value.__format__(format_spec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    format_spec defaults to the empty string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串可以提供的参数 's' None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="string">'some string'</span>,<span class="string">'s'</span>)</span><br><span class="line"><span class="string">'some string'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="string">'some string'</span>)</span><br><span class="line"><span class="string">'some string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#整形数值可以提供的参数有 'b' 'c' 'd' 'o' 'x' 'X' 'n' None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3</span>,<span class="string">'b'</span>) <span class="comment">#转换成二进制</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">97</span>,<span class="string">'c'</span>) <span class="comment">#转换unicode成字符</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>,<span class="string">'d'</span>) <span class="comment">#转换成10进制</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>,<span class="string">'o'</span>) <span class="comment">#转换成8进制</span></span><br><span class="line"><span class="string">'13'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>,<span class="string">'x'</span>) <span class="comment">#转换成16进制 小写字母表示</span></span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>,<span class="string">'X'</span>) <span class="comment">#转换成16进制 大写字母表示</span></span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>,<span class="string">'n'</span>) <span class="comment">#和d一样</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">11</span>) <span class="comment">#默认和d一样</span></span><br><span class="line"><span class="string">'11'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浮点数可以提供的参数有 'e' 'E' 'f' 'F' 'g' 'G' 'n' '%' None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">314159267</span>,<span class="string">'e'</span>) <span class="comment">#科学计数法，默认保留6位小数</span></span><br><span class="line"><span class="string">'3.141593e+08'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">314159267</span>,<span class="string">'0.2e'</span>) <span class="comment">#科学计数法，指定保留2位小数</span></span><br><span class="line"><span class="string">'3.14e+08'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">314159267</span>,<span class="string">'0.2E'</span>) <span class="comment">#科学计数法，指定保留2位小数，采用大写E表示</span></span><br><span class="line"><span class="string">'3.14E+08'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">314159267</span>,<span class="string">'f'</span>) <span class="comment">#小数点计数法，默认保留6位小数</span></span><br><span class="line"><span class="string">'314159267.000000'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.14159267000</span>,<span class="string">'f'</span>) <span class="comment">#小数点计数法，默认保留6位小数</span></span><br><span class="line"><span class="string">'3.141593'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.14159267000</span>,<span class="string">'0.8f'</span>) <span class="comment">#小数点计数法，指定保留8位小数</span></span><br><span class="line"><span class="string">'3.14159267'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.14159267000</span>,<span class="string">'0.10f'</span>) <span class="comment">#小数点计数法，指定保留10位小数</span></span><br><span class="line"><span class="string">'3.1415926700'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.14e+1000000</span>,<span class="string">'F'</span>)  <span class="comment">#小数点计数法，无穷大转换成大小字母</span></span><br><span class="line"><span class="string">'INF'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#g的格式化比较特殊，假设p为格式中指定的保留小数位数，先尝试采用科学计数法格式化，得到幂指数exp，如果-4&lt;=exp&lt;p，则采用小数计数法，并保留p-1-exp位小数，否则按小数计数法计数，并按p-1保留小数位数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.1g'</span>) <span class="comment">#p=1,exp=-5 ==》 -4&lt;=exp&lt;p不成立，按科学计数法计数，保留0位小数点</span></span><br><span class="line"><span class="string">'3e-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.2g'</span>) <span class="comment">#p=1,exp=-5 ==》 -4&lt;=exp&lt;p不成立，按科学计数法计数，保留1位小数点</span></span><br><span class="line"><span class="string">'3.1e-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.3g'</span>) <span class="comment">#p=1,exp=-5 ==》 -4&lt;=exp&lt;p不成立，按科学计数法计数，保留2位小数点</span></span><br><span class="line"><span class="string">'3.14e-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.3G'</span>) <span class="comment">#p=1,exp=-5 ==》 -4&lt;=exp&lt;p不成立，按科学计数法计数，保留0位小数点，E使用大写</span></span><br><span class="line"><span class="string">'3.14E-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.1415926777</span>,<span class="string">'.1g'</span>) <span class="comment">#p=1,exp=0 ==》 -4&lt;=exp&lt;p成立，按小数计数法计数，保留0位小数点</span></span><br><span class="line"><span class="string">'3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.1415926777</span>,<span class="string">'.2g'</span>) <span class="comment">#p=1,exp=0 ==》 -4&lt;=exp&lt;p成立，按小数计数法计数，保留1位小数点</span></span><br><span class="line"><span class="string">'3.1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">3.1415926777</span>,<span class="string">'.3g'</span>) <span class="comment">#p=1,exp=0 ==》 -4&lt;=exp&lt;p成立，按小数计数法计数，保留2位小数点</span></span><br><span class="line"><span class="string">'3.14'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.1n'</span>) <span class="comment">#和g相同</span></span><br><span class="line"><span class="string">'3e-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>,<span class="string">'.3n'</span>) <span class="comment">#和g相同</span></span><br><span class="line"><span class="string">'3.14e-05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">0.00003141566</span>) <span class="comment">#和g相同</span></span><br><span class="line"><span class="string">'3.141566e-05'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>vars：返回当前作用域内的局部变量和其值组成的字典，或者返回对象的属性列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vars</span><span class="params">(p_object=None)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    vars([object]) -&gt; dictionary</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Without arguments, equivalent to locals().</span></span><br><span class="line"><span class="string">    With an argument, equivalent to object.__dict__.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#作用于类实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(a)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name = <span class="string">'Kim'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.__dict__</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Kim'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(a)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Kim'</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反射操作"><a href="#反射操作" class="headerlink" title="反射操作"></a>反射操作</h1><ul>
<li>__import__：动态导入模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__import__</span><span class="params">(name, globals=None, locals=None, fromlist=<span class="params">()</span>, level=<span class="number">0</span>)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Import a module. Because this function is meant for use by the Python</span></span><br><span class="line"><span class="string">    interpreter and not for general use it is better to use</span></span><br><span class="line"><span class="string">    importlib.import_module() to programmatically import a module.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The globals argument is only used to determine the context;</span></span><br><span class="line"><span class="string">    they are not modified.  The locals argument is unused.  The fromlist</span></span><br><span class="line"><span class="string">    should be a list of names to emulate ``from name import ...'', or an</span></span><br><span class="line"><span class="string">    empty list to emulate ``import name''.</span></span><br><span class="line"><span class="string">    When importing a module from a package, note that __import__('A.B', ...)</span></span><br><span class="line"><span class="string">    returns package A when fromlist is empty, but its submodule B when</span></span><br><span class="line"><span class="string">    fromlist is not empty.  Level is used to determine whether to perform </span></span><br><span class="line"><span class="string">    absolute or relative imports. 0 is absolute while a positive number</span></span><br><span class="line"><span class="string">    is the number of parent directories to search relative to the current module.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = __import__(<span class="string">'index'</span>)</span><br><span class="line">index.sayHello()</span><br></pre></td></tr></table></figure>
<ul>
<li>isinstance：判断对象是否是类或者类型元组中任意类元素的实例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isinstance</span><span class="params">(x, A_tuple)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether an object is an instance of a class or of a subclass thereof.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to</span></span><br><span class="line"><span class="string">    check against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)</span></span><br><span class="line"><span class="string">    or ...`` etc.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">1</span>,int)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">1</span>,str)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">1</span>,(int,str))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>issubclass：判断类是否是另外一个类或者类型元组中任意类元素的子类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">issubclass</span><span class="params">(x, A_tuple)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether 'cls' is a derived from another class or is the same class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to</span></span><br><span class="line"><span class="string">    check against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)</span></span><br><span class="line"><span class="string">    or ...`` etc.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(bool,int)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(bool,str)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issubclass(bool,(str,int))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>hasattr：检查对象是否含有属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasattr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether the object has an attribute with the given name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This is done by calling getattr(obj, name) and catching AttributeError.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义类A</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Aim'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(s,<span class="string">'name'</span>) <span class="comment">#a含有name属性</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(s,<span class="string">'age'</span>) <span class="comment">#a不含有age属性</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getattr：获取对象的属性值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getattr</span><span class="params">(object, name, default=None)</span>:</span> <span class="comment"># known special case of getattr</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    getattr(object, name[, default]) -&gt; value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.</span></span><br><span class="line"><span class="string">    When a default argument is given, it is returned when the attribute doesn't</span></span><br><span class="line"><span class="string">    exist; without it, an exception is raised in that case.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义类Student</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s,<span class="string">'name'</span>) <span class="comment">#存在属性name</span></span><br><span class="line"><span class="string">'Aim'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s,<span class="string">'age'</span>,<span class="number">6</span>) <span class="comment">#不存在属性age，但提供了默认值，返回默认值</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s,<span class="string">'age'</span>) <span class="comment">#不存在属性age，未提供默认值，调用报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#17&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    getattr(s,<span class="string">'age'</span>)</span><br><span class="line">AttributeError: <span class="string">'Stduent'</span> object has no attribute <span class="string">'age'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>setattr：设置对象的属性值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setattr</span><span class="params">(x, y, v)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Sets the named attribute on the given object to the specified value.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    setattr(x, 'y', v) is equivalent to ``x.y = v''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Student(<span class="string">'xie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">'xie'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(a,<span class="string">'name'</span>,<span class="string">'wang'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">'wang'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delattr：删除对象的属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delattr</span><span class="params">(x, y)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Deletes the named attribute from the given object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    delattr(x, 'y') is equivalent to ``del x.y''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义类A</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello'</span>,self.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试属性和方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line"><span class="string">'小麦'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sayHello()</span><br><span class="line">hello 小麦</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delattr(a,<span class="string">'name'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.name</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#47&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.name</span><br><span class="line">AttributeError: <span class="string">'A'</span> object has no attribute <span class="string">'name'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>callable：检测对象是否可被调用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callable</span><span class="params">(i_e_, some_kind_of_function)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether the object is callable (i.e., some kind of function).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that classes are callable, as are instances of classes with a</span></span><br><span class="line"><span class="string">    __call__() method.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="comment">#定义类B</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'instances are callable now.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(B) <span class="comment">#类B是可调用对象</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B() <span class="comment">#调用类B</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(b) <span class="comment">#实例b是可调用对象</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b() <span class="comment">#调用实例b成功</span></span><br><span class="line">instances are callable now.</span><br></pre></td></tr></table></figure>
<h1 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h1><ul>
<li>globals：返回当前作用域内的全局变量和其值组成的字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">globals</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the dictionary containing the current scope's global variables.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NOTE: Updates to this dictionary *will* affect name lookups in the current</span></span><br><span class="line"><span class="string">    global scope and vice-versa.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;<span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals() <span class="comment">#多了一个a</span></span><br><span class="line">&#123;<span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>locals：返回当前作用域内的局部变量和其值组成的字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locals</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a dictionary containing the current scope's local variables.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    NOTE: Whether or not updates to this dictionary will affect name lookups in</span></span><br><span class="line"><span class="string">    the local scope and vice-versa is *implementation dependent* and not</span></span><br><span class="line"><span class="string">    covered by any backwards compatibility guarantees.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;<span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals() <span class="comment">#多了一个a</span></span><br><span class="line">&#123;<span class="string">'__spec__'</span>: <span class="literal">None</span>, <span class="string">'__package__'</span>: <span class="literal">None</span>, <span class="string">'__builtins__'</span>: &lt;module <span class="string">'builtins'</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'__name__'</span>: <span class="string">'__main__'</span>, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__loader__'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">_frozen_importlib</span>.<span class="title">BuiltinImporter</span>'&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="交互操作"><a href="#交互操作" class="headerlink" title="交互操作"></a>交互操作</h1><ul>
<li>print：向标准输出对象打印输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span> <span class="comment"># known special case of print</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">    Optional keyword arguments:</span></span><br><span class="line"><span class="string">    file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">    sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">    end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">    flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,sep = <span class="string">'+'</span>)</span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,sep = <span class="string">'+'</span>,end = <span class="string">'=?'</span>)</span><br><span class="line">1+2+3=?</span><br></pre></td></tr></table></figure>
<ul>
<li>input：读取用户输入值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Read a string from standard input.  The trailing newline is stripped.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The prompt string, if given, is printed to standard output without a</span></span><br><span class="line"><span class="string">    trailing newline before reading input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.</span></span><br><span class="line"><span class="string">    On *nix systems, readline is used if available.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = input(<span class="string">'please input your name:'</span>)</span><br><span class="line">please input your name:Xie</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'Xie'</span></span><br></pre></td></tr></table></figure>
<h1 id="编译执行"><a href="#编译执行" class="headerlink" title="编译执行"></a>编译执行</h1><ul>
<li>compile：将字符串编译为代码或者AST对象，使之能够通过exec语句来执行或者eval进行求值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compile source into a code object that can be executed by exec() or eval().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The source code may represent a Python module, statement or expression.</span></span><br><span class="line"><span class="string">    The filename will be used for run-time error messages.</span></span><br><span class="line"><span class="string">    The mode must be 'exec' to compile a module, 'single' to compile a</span></span><br><span class="line"><span class="string">    single (interactive) statement, or 'eval' to compile an expression.</span></span><br><span class="line"><span class="string">    The flags argument, if present, controls which future statements influence</span></span><br><span class="line"><span class="string">    the compilation of the code.</span></span><br><span class="line"><span class="string">    The dont_inherit argument, if true, stops the compilation inheriting</span></span><br><span class="line"><span class="string">    the effects of any future statements in effect in the code calling</span></span><br><span class="line"><span class="string">    compile; if absent or false these statements do influence the compilation,</span></span><br><span class="line"><span class="string">    in addition to any features explicitly specified.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#流程语句使用exec</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code1 = <span class="string">'for i in range(0,10): print (i)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>compile1 = compile(code1,<span class="string">''</span>,<span class="string">'exec'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">exec</span> (compile1)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#简单求值表达式用eval</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code2 = <span class="string">'1 + 2 + 3 + 4'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>compile2 = compile(code2,<span class="string">''</span>,<span class="string">'eval'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(compile2)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>eval：执行动态表达式求值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Evaluate the given source in the context of globals and locals.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The source may be a string representing a Python expression</span></span><br><span class="line"><span class="string">    or a code object as returned by compile().</span></span><br><span class="line"><span class="string">    The globals must be a dictionary and locals can be any mapping,</span></span><br><span class="line"><span class="string">    defaulting to the current globals and locals.</span></span><br><span class="line"><span class="string">    If only globals is given, locals defaults to it.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'1+2+3+4'</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>exec：执行动态语句块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Execute the given source in the context of globals and locals.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The source may be a string representing one or more Python statements</span></span><br><span class="line"><span class="string">    or a code object as returned by compile().</span></span><br><span class="line"><span class="string">    The globals must be a dictionary and locals can be any mapping,</span></span><br><span class="line"><span class="string">    defaulting to the current globals and locals.</span></span><br><span class="line"><span class="string">    If only globals is given, locals defaults to it.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(<span class="string">'a=1+2'</span>) <span class="comment">#执行语句</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>repr：返回一个对象的字符串表现形式(给解释器)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repr</span><span class="params">(obj)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return the canonical string representation of the object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For many object types, including most builtins, eval(repr(obj)) == obj.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'some text'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(a)</span><br><span class="line"><span class="string">'some text'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(a)</span><br><span class="line"><span class="string">"'some text'"</span></span><br></pre></td></tr></table></figure>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ul>
<li>property：标示属性的装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fget is a function to be used for getting an attribute value, and likewise</span></span><br><span class="line"><span class="string">    fset is a function for setting, and fdel a function for del'ing, an</span></span><br><span class="line"><span class="string">    attribute.  Typical use is to define a managed attribute x:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        def getx(self): return self._x</span></span><br><span class="line"><span class="string">        def setx(self, value): self._x = value</span></span><br><span class="line"><span class="string">        def delx(self): del self._x</span></span><br><span class="line"><span class="string">        x = property(getx, setx, delx, "I'm the 'x' property.")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Decorators make defining new properties or modifying existing ones easy:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        @property</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            "I am the 'x' property."</span></span><br><span class="line"><span class="string">            return self._x</span></span><br><span class="line"><span class="string">        @x.setter</span></span><br><span class="line"><span class="string">        def x(self, value):</span></span><br><span class="line"><span class="string">            self._x = value</span></span><br><span class="line"><span class="string">        @x.deleter</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            del self._x</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._name = <span class="string">''</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""i'm the 'name' property."""</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'name can not be None'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._name = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = C()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.name <span class="comment"># 访问属性</span></span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.name = <span class="literal">None</span> <span class="comment"># 设置属性时进行验证</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#84&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    c.name = <span class="literal">None</span></span><br><span class="line">  File <span class="string">"&lt;pyshell#81&gt;"</span>, line <span class="number">11</span>, <span class="keyword">in</span> name</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">'name can not be None'</span>)</span><br><span class="line">RuntimeError: name can <span class="keyword">not</span> be <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.name = <span class="string">'Xie'</span> <span class="comment"># 设置属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.name <span class="comment"># 访问属性</span></span><br><span class="line"><span class="string">'Xie'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> c.name <span class="comment"># 删除属性，不提供deleter则不能删除</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#87&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">del</span> c.name</span><br><span class="line">AttributeError: can<span class="string">'t delete attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; c.name</span></span><br><span class="line"><span class="string">'</span>Xie<span class="string">'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>classmethod：标示方法为类方法的装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    classmethod(function) -&gt; method</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Convert a function to be a class method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A class method receives the class as implicit first argument,</span></span><br><span class="line"><span class="string">    just like an instance method receives the instance.</span></span><br><span class="line"><span class="string">    To declare a class method, use this idiom:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      class C:</span></span><br><span class="line"><span class="string">          @classmethod</span></span><br><span class="line"><span class="string">          def f(cls, arg1, arg2, ...):</span></span><br><span class="line"><span class="string">              ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()).  The instance is ignored except for its class.</span></span><br><span class="line"><span class="string">    If a class method is called for a derived class, the derived class</span></span><br><span class="line"><span class="string">    object is passed as the implied first argument.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class methods are different than C++ or Java static methods.</span></span><br><span class="line"><span class="string">    If you want those, see the staticmethod builtin.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls,arg1)</span>:</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(arg1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.f(<span class="string">'类对象调用类方法'</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">C</span>'&gt;</span></span><br><span class="line"><span class="class">类对象调用类方法</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.f(<span class="string">'类实例对象调用类方法'</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">C</span>'&gt;</span></span><br><span class="line"><span class="class">类实例对象调用类方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>staticmethod：标示方法为静态方法的装饰器</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    staticmethod(function) -&gt; method</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Convert a function to be a static method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A static method does not receive an implicit first argument.</span></span><br><span class="line"><span class="string">    To declare a static method, use this idiom:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         class C:</span></span><br><span class="line"><span class="string">             @staticmethod</span></span><br><span class="line"><span class="string">             def f(arg1, arg2, ...):</span></span><br><span class="line"><span class="string">                 ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()).  The instance is ignored except for its class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Static methods in Python are similar to those found in Java or C++.</span></span><br><span class="line"><span class="string">    For a more advanced concept, see the classmethod builtin.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用装饰器定义静态方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(lang)</span>:</span></span><br><span class="line">        print(lang)</span><br><span class="line">        <span class="keyword">if</span> lang == <span class="string">'en'</span>:</span><br><span class="line">            print(<span class="string">'Welcome!'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'你好！'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.sayHello(<span class="string">'en'</span>) <span class="comment">#类调用,'en'传给了lang参数</span></span><br><span class="line">en</span><br><span class="line">Welcome!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Student(<span class="string">'Xie'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.sayHello(<span class="string">'wang'</span>)  <span class="comment">#类实例对象调用,'zh'传给了lang参数</span></span><br><span class="line">wang</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack介绍</title>
    <url>/2017/05/30/OpenStackjs/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&#8195;OpenStack是一个由NASA（美国国家航空航天局）和Rackspace合作研发并发起的，以Apache许可证授权的自由软件和开放源代码项目。</p>
<p>&#8195;OpenStack是一个开源的云计算管理平台项目，由几个主要的组件组合起来完成具体工作。OpenStack支持几乎所有类型的云环境，项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。OpenStack通过各种互补的服务提供了基础设施即服务（IaaS）的解决方案，每个服务提供API以进行集成。</p>
<p>&#8195;OpenStack是一个旨在为公共及私有云的建设与管理提供软件的开源项目。它的社区拥有超过130家企业及1350位开发者，这些机构与个人都将OpenStack作为基础设施即服务（IaaS）资源的通用前端。OpenStack项目的首要任务是简化云的部署过程并为其带来良好的可扩展性。本文希望通过提供必要的指导信息，帮助大家利用OpenStack前端来设置及管理自己的公共云或私有云。</p>
<p>&#8195;OpenStack云计算平台，帮助服务商和企业内部实现类似于 Amazon EC2 和 S3 的云基础架构服务(Infrastructure as a Service, IaaS)。OpenStack 包含两个主要模块：Nova 和 Swift，前者是 NASA 开发的虚拟服务器部署和业务计算模块；后者是 Rackspace开发的分布式云存储模块，两者可以一起用，也可以分开单独用。OpenStack除了有 Rackspace 和 NASA 的大力支持外，还有包括 Dell、Citrix、 Cisco、 Canonical等重量级公司的贡献和支持，发展速度非常快，有取代另一个业界领先开源云平台 Eucalyptus 的态势。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/236dF788fA.png?imageslim" alt="mark"></p>
<h1 id="功能组件介绍"><a href="#功能组件介绍" class="headerlink" title="功能组件介绍"></a>功能组件介绍</h1><h2 id="Keystone-身份认证-Identity-service"><a href="#Keystone-身份认证-Identity-service" class="headerlink" title="Keystone 身份认证 (Identity service)"></a>Keystone 身份认证 (Identity service)</h2><p>&#8195;Keystone套件作为OpenStack的身份认证服务，具有中央目录能查看哪位使用者可存取哪些服务，并且提供了多种验证方式，包括使用者帐号密码、Token以及类似AWS的登入机制。另外，Keystone可以整合现有的中央控管系统，像是LDAP（轻型目录访问协议）。</p>
<blockquote>
<p>类似Amazon AWS 的IAM<br><a id="more"></a></p>
<h2 id="Nova-计算组件-Compute"><a href="#Nova-计算组件-Compute" class="headerlink" title="Nova 计算组件(Compute)"></a>Nova 计算组件(Compute)</h2></blockquote>
<p>&#8195;Nova主要担任着部署与管理虚拟机角色。Nova提供了一套API来开发额外的应用程式，IT人员可以透过网页介面来查看与管理资源状态，且可以控制启动、停止、调整虚拟机。</p>
<p>&#8195;IT人员可将Nova套件部署在多家厂商的虚拟化平台上，目前来说以KVM和Xen虚拟化平台最为稳定。除了支援不同的虚拟化平台之外，在硬体架构的部份，OpenStack支援x86架构、ARM架构等。另外Nova套件还支援Linux羽量级的虚拟化技术LXC，能够在切割虚拟机时，分出更多的虚拟化执行环境。</p>
<p>&#8195;此外，Nova套件还具有管理LAN网路的功能，可程式化的分配IP位址与VLAN，快速部署网路与资安功能。Nova套件还可将某几台虚拟机器设为群组，和不同群组作隔离，并有基于角色的访问控制（RBAC）功能，可根据使用者的角色确保可存取的资源为何。</p>
<blockquote>
<p>类似Amazon AWS 的EC2。</p>
</blockquote>
<h2 id="Horizon-仪表盘组件-Dashboard"><a href="#Horizon-仪表盘组件-Dashboard" class="headerlink" title="Horizon 仪表盘组件(Dashboard)"></a>Horizon 仪表盘组件(Dashboard)</h2><p>&#8195;Horizon组件提供IT人员一套图形化的页面，让IT人员可以综观云端服务目前的规模与状态，并且能够统一存取、部署与管理所有云端服务所使用到的资源。</p>
<p>&#8195;Horizon组件是个可扩展的网页式Application。所以Horizon套件可以整合第三方的服务或是产品，像是计费、监控或是额外的管理工具。</p>
<blockquote>
<p>类似Amazon AWS 的Console。</p>
</blockquote>
<h2 id="Neutron-网络组件-Networking"><a href="#Neutron-网络组件-Networking" class="headerlink" title="Neutron 网络组件(Networking)"></a>Neutron 网络组件(Networking)</h2><p>&#8195;Neutron组件为其它OpenStack服务提供网络连接及服务（Network-Connectivity-as-a-Service）功能。比如OpenStack运算，为租户提供API定义网络和使用。基于插件式的架构，使其支持众多的网络供应商和技术，，IT人员可分配IP位址、静态IP或是动态IP。且IT人员也可以使用SDN技术，像是OpenFlow协定来打造更大规模或是多租户的网络环境。</p>
<p>&#8195;此外，允许部署和管理其他网路服务，像是入侵侦测系统（IDS）、负载平衡、防火墙、VPN等。</p>
<blockquote>
<p>类似Amazon AWS 的VPC。</p>
</blockquote>
<h2 id="Swift-对象储存组件-Object-Storage"><a href="#Swift-对象储存组件-Object-Storage" class="headerlink" title="Swift 对象储存组件(Object Storage)"></a>Swift 对象储存组件(Object Storage)</h2><p>&#8195;Swift组件提供可扩展的分布式存储平台，以防止单点故障的情况发生。使用者可透过API进行存取，可存放非结构化的资料，像是图片、网页、日志等，并可作为应用程序资料备份、归档以及保留之用。</p>
<p>通过Swift组件，可让业界标准的设备存放PB等级的资料量。而且，当新增服务器后，储存群集可轻易的横向扩展。</p>
<p>&#8195;此外，因为Swift组件是通过软件的逻辑，确保资料被复制与分布在不同设备上，这可让企业使用较便宜的设备，节省成本。</p>
<blockquote>
<p>类似Amazon AWS 的S3。</p>
</blockquote>
<h2 id="Cinder-块储存组件-Block-Storage"><a href="#Cinder-块储存组件-Block-Storage" class="headerlink" title="Cinder 块储存组件(Block Storage)"></a>Cinder 块储存组件(Block Storage)</h2><p>&#8195;Cinder组件允许块储存设备能够整合商业化的企业储存平台，像是NetApp、Nexenta、SolidFire等。区块储存系统可让IT人员设置服务器和块储存设备的各项指令，包括建立、连接和分离等，并整合了运算套件，可让IT人员查看储存设备的容量使用状态。</p>
<p>&#8195;Cinder组件并提供快照管理功能，可保护虚拟机器上的资料，作为系统恢复时使用，快照甚至可用来建立一个新的块储存容量。</p>
<blockquote>
<p>类似Amazon AWS 的EBS。</p>
</blockquote>
<h2 id="Ceilometer-资料监控计量组件-Telemetry"><a href="#Ceilometer-资料监控计量组件-Telemetry" class="headerlink" title="Ceilometer 资料监控计量组件(Telemetry)"></a>Ceilometer 资料监控计量组件(Telemetry)</h2><p>&#8195;Ceilometer提供OpenStack云端服务监控与测量OpenStack的使用，来收集CPU与网络的使用资料，以提供收费计价（Billing）、评测（Benchmarking）等使用，或是使用这些资料当作评估系统延展性以及进行系统相关统计之用。</p>
<h2 id="Heat-编排模板组件-Orchestration"><a href="#Heat-编排模板组件-Orchestration" class="headerlink" title="Heat 编排模板组件(Orchestration)"></a>Heat 编排模板组件(Orchestration)</h2><p>&#8195;Heat主要提供一个以模板（Templeate）为基础的架构来描述云端的应用，模板中可以让使用者建立如虚拟映像实体（Instance）、浮动IP位址、安全组（Security Group）或是使用者等OpenStack各种资源，也就是说，Heat让使用者可以设定一个云端应用模板，来串连建立设定相关所需的OpenStack服务资源，而不必一个个分别去建立设定。</p>
<h2 id="Sahara-数据组件-Data-Processing"><a href="#Sahara-数据组件-Data-Processing" class="headerlink" title="Sahara 数据组件(Data Processing)"></a>Sahara 数据组件(Data Processing)</h2><p>&#8195;Sahara目的是提供给搭建Haddoop 分布式集群的工程师能用简单的概念，就能在OpenStack上面部署和管理「Haddoop分布式集群」。Sahara也提供了MapR Distribution、Spark、Cloudera、Hortonworks插件，替IT人员打造一系列Hadoop ecosystem。</p>
<h2 id="Trove-数据库服务组件-Database-as-a-Service"><a href="#Trove-数据库服务组件-Database-as-a-Service" class="headerlink" title="Trove 数据库服务组件(Database as a Service)"></a>Trove 数据库服务组件(Database as a Service)</h2><p>&#8195;Trove主要负责衔接与简化实际数据库的使用，提供OpenStack各个服务一个具延展性且可靠的云端数据库服务（Cloud Database-as-a-Service），Database服务包含了衔接传统关系型数据库（RDBMS）与新型非关系型数据库（NoSQL）。</p>
<h4 id="Ironic-裸机部署组件-Bare-Metal"><a href="#Ironic-裸机部署组件-Bare-Metal" class="headerlink" title="Ironic 裸机部署组件(Bare Metal )"></a>Ironic 裸机部署组件(Bare Metal )</h4><p>&#8195;Ironic裸机部署功能，在Kilo版中释出，IT人员可以在实体服务器自动化部署OpenStack，等于能用管理虚拟机器的方式，来管理实体服务器，有助于一次部署大量OpenStack主机来满足大型IaaS环境的需要。</p>
<h2 id="Zaqar-消息队列服务-Message-service"><a href="#Zaqar-消息队列服务-Message-service" class="headerlink" title="Zaqar 消息队列服务(Message service)"></a>Zaqar 消息队列服务(Message service)</h2><p>&#8195;Zaqar是对Web开发人员提供了多租户（Multi tenant）的消息队列服务。它结合开创了Amazon的SQS产品与附加的语义来支援事件的广播想法。</p>
<p>本服务拥有一个完全基于RESTful 的API，开发人员可使用他们的Saas 与行动应用程式的各种元件之间的消息发送，透过使用多种通讯模式。这个API 是一种高效的消息传送引擎设计，充分的考虑可扩展性与安全性。</p>
<p>&#8195;然而其他OpenStack 的套件可以与Zaqar 的表面事件End users 进行整合以及与访客的Agent运作于『Over-cloud』层。云端公司可以利用Zaqar提供如同SQS 与SNS给他们的客户。</p>
<h2 id="Barbican-秘钥管理服务-Key-management"><a href="#Barbican-秘钥管理服务-Key-management" class="headerlink" title="Barbican 秘钥管理服务(Key management)"></a>Barbican 秘钥管理服务(Key management)</h2><p>&#8195;Barbican 是一个以REST API 设计来进行安全储存、配置以及机密的管理，如密码、加密秘钥以及X.509 凭证。其目的是为了适用于所有环境，包含大型短暂性云端。</p>
<h2 id="Designate-DNS管理服务-DNS"><a href="#Designate-DNS管理服务-DNS" class="headerlink" title="Designate DNS管理服务(DNS)"></a>Designate DNS管理服务(DNS)</h2><p>&#8195;Designate 提供了DNSaaS 服务于OpenStack 上，包含以下几项功能：</p>
<ul>
<li><p>使用REST API 管理domain/record</p>
</li>
<li><p>多租户</p>
</li>
<li><p>整合Keystone 验证</p>
</li>
<li><p>以框架来整合Nova 与Neutrion 的通知（自动产生记录）</p>
</li>
<li><p>支援立即可用的PowerDNS 与Bind9</p>
</li>
</ul>
<h2 id="Magnum-容器即服务-Containers-service"><a href="#Magnum-容器即服务-Containers-service" class="headerlink" title="Magnum 容器即服务(Containers service)"></a>Magnum 容器即服务(Containers service)</h2><p>&#8195;Magnum是一个OpenStack API服务，是由OpenStack Containers Team开发作为Container orchestration的引擎，诸如Docker、Kubernetes这一类别可以在Openstack上作为资源。</p>
<p>&#8195;Magnum 使用Heat 来编排一个OS Image，其中包含Docker 以及Kubernetes，并执行Image 于任何的虚拟机或Bare Metal 集群配置。</p>
<h2 id="Murano-应用程序目录服务-Application-Catalog"><a href="#Murano-应用程序目录服务-Application-Catalog" class="headerlink" title="Murano 应用程序目录服务(Application Catalog)"></a>Murano 应用程序目录服务(Application Catalog)</h2><p>&#8195;Murano 引入一个Application Catalog 于OpenStack，使应用程序开发人员与管理人员，可以快速的发布各种已就绪的应用程序，并以目录方式进行分类。</p>
<p>&#8195;使用者、包括没经验的人可以通过统一的框架与API 实现应用程式的快速部署与应用程序的生命周期管理，来降低应用程式对底层平台（IaaS 层）的依赖。</p>
<p><em>END</em></p>
]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack网络基础-Neutron</title>
    <url>/2017/05/28/OpenStacknetwork/</url>
    <content><![CDATA[<p>&#8195;Neutron 的设计目标是实现“网络即服务”，为了达到这一目标，在设计上遵循了基于“软件定义网络”实现网络虚拟化的原则，在实现上充分利用了 Linux 系统上的各种网络相关的技术。</p>
<ul>
<li>bridge：网桥，Linux中用于表示一个能连接不同网络设备的虚拟设备，linux中传统实现的网桥类似一个hub设备，而ovs管理的网桥一般类似交换机。</li>
<li>br-int：bridge-integration，综合网桥，常用于表示实现主要内部网络功能的网桥。</li>
<li>br-ex：bridge-external，外部网桥，通常表示负责跟外部网络通信的网桥。</li>
<li>GRE：General Routing Encapsulation，一种通过封装来实现隧道的方式。在openstack中一般是基于L3的gre，即original pkt/GRE/IP/Ethernet</li>
<li>VETH：虚拟ethernet接口，通常以pair的方式出现，一端发出的网包，会被另一端接收，可以形成两个网桥之间的通道。</li>
<li>qvb：neutron veth, Linux Bridge-side</li>
<li>qvo：neutron veth, OVS-side</li>
<li>TAP设备：模拟一个二层的网络设备，可以接受和发送二层网包。</li>
<li>TUN设备：模拟一个三层的网络设备，可以接受和发送三层网包。</li>
<li>iptables：Linux 上常见的实现安全策略的防火墙软件。</li>
<li>Vlan：虚拟 Lan，同一个物理 Lan 下用标签实现隔离，可用标号为1-4094。</li>
<li>VXLAN：一套利用 UDP 协议作为底层传输协议的 Overlay 实现。一般认为作为 VLan 技术的延伸或替代者。</li>
<li>namespace：用来实现隔离的一套机制，不同 namespace 中的资源之间彼此不可见。</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><a id="more"></a>
<p>&#8195;Neutron管理下面的实体：</p>
<ul>
<li>网络：隔离的 L2 域，可以是虚拟、逻辑或交换。</li>
<li>子网：隔离的 L3 域，IP 地址块。其中每个机器有一个 IP，同一个子网的主机彼此 L3 可见。</li>
<li>端口：网络上虚拟、逻辑或交换端口。 所有这些实体都是虚拟的，拥有自动生成的唯一标示id，支持CRUD功能，并在数据库中跟踪记录状态。</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>&#8195;隔离的 L2 广播域，一般是创建它的用户所有。用户可以拥有多个网络。网络是最基础的，子网和端口都需要关联到网络上。<br>&#8195;网络上可以有多个子网。同一个网络上的主机一般可以通过交换机或路由器连通起来。</p>
<h2 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h2><p>&#8195;隔离的 L3 域，子网代表了一组分配了 IP 的虚拟机。每个子网必须有一个 CIDR 和关联到一个网络。IP 可以从 CIDR 或者用户指定池中选取。<br>&#8195;子网可能会有一个网关、一组 DNS 和主机路由。不同子网之间 L3 是互相不可见的，必须通过一个三层网关（即路由器）经过 L3 上进行通信。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>&#8195;可以进出流量的接口，往往绑定上若干 MAC 地址和 IP 地址，以进行寻址。一般为虚拟交换机上的虚拟接口。<br>&#8195;虚拟机挂载网卡到端口上，通过端口访问网络。当端口有 IP 的时候，意味着它属于某个子网。</p>
<h1 id="抽象系统架构"><a href="#抽象系统架构" class="headerlink" title="抽象系统架构"></a>抽象系统架构</h1><p>&#8195;无论哪种具体的网络虚拟化实现，一个简化和抽象后的系统架构可以表述为下图所示。<br><img src="https://blog-image.nos-eastchina1.126.net/CdDaeGDB05.png?imageslim" alt="mark"><br>&#8195;在启用 DVR 特性（J 版本以后支持）之前，所有流量（东西向、南北向）都需要经过网络节点的转发；DVR 特性则允许东西向流量和带有 Floating IP 的南北向流量不经过网络节点的转发，直接从计算节点的外部网络出去。</p>
<p><img src="https://blog-image.nos-eastchina1.126.net/61Ib1lI1bB.png?imageslim" alt="mark"></p>
]]></content>
      <categories>
        <category>OpenStack</category>
      </categories>
      <tags>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>The Python Tutorial</title>
    <url>/2017/05/20/Program-design/Python/PythonTu/</url>
    <content><![CDATA[<p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。<br>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。<br>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。<br>Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。<br>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。<br>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。<br><a id="more"></a></p>
<h1 id="Python-发展历史"><a href="#Python-发展历史" class="headerlink" title="Python 发展历史"></a>Python 发展历史</h1><p>Python 是由 Guido van Rossum 在八十年代末和九十年代初，在荷兰国家数学和计算机科学研究所设计出来的。<br>Python 本身也是由诸多其他语言发展而来的,这包括 ABC、Modula-3、C、C++、Algol-68、SmallTalk、Unix shell 和其他的脚本语言等等。<br>像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。<br>现在 Python 是由一个核心开发团队在维护，Guido van Rossum 仍然占据着至关重要的作用，指导其进展。</p>
<h1 id="Python-特点"><a href="#Python-特点" class="headerlink" title="Python 特点"></a>Python 特点</h1><p>1.易于学习：Python有相对较少的关键字，结构简单，和一个明确定义的语法，学习起来更加简单。<br>2.易于阅读：Python代码定义的更清晰。<br>3.易于维护：Python的成功在于它的源代码是相当容易维护的。<br>4.一个广泛的标准库：Python的最大的优势之一是丰富的库，跨平台的，在UNIX，Windows和Macintosh兼容很好。<br>5.互动模式：互动模式的支持，您可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。<br>6.可移植：基于其开放源代码的特性，Python已经被移植（也就是使其工作）到许多平台。<br>7.可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用C或C++完成那部分程序，然后从你的Python程序中调用。<br>8.数据库：Python提供所有主要的商业数据库的接口。<br>9.GUI编程：Python支持GUI可以创建和移植到许多系统调用。<br>10.可嵌入: 你可以将Python嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中文编码</title>
    <url>/2017/05/20/Program-design/Python/pythonzw/</url>
    <content><![CDATA[<p>Python 输出 “Hello, World!”，英文没有问题，但是如果你输出中文字符”你好，世界”就有可能会碰到中文编码问题。<br>Python 文件中如果未指定编码，在执行过程会出现报错：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"你好，世界"</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上程序执行输出结果为：</p>
<pre><code>File &quot;test.py&quot;, line 2
SyntaxError: Non-ASCII character &#39;\xe4&#39; in file test.py on line 2, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details
</code></pre><p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。<br>解决方法为只要在文件开头加入 # -<em>- coding: UTF-8 -</em>- 或者 #coding=utf-8 就行了。<br>实例(Python 2.0+)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"你好，世界"</span>;</span><br></pre></td></tr></table></figure>
<p>运行实例 »<br>输出结果为：</p>
<pre><code>你好，世界
</code></pre><p>所以如果大家在学习过程中，代码中包含中文，就需要在头部指定编码。<br>注意：Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。<br>注意：如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现类似以下错误信息：</p>
<pre><code>SyntaxError: (unicode error) ‘utf-8’ codec can’t decode byte 0xc4 in position 0:
invalid continuation byte
</code></pre><p>Pycharm 设置步骤：<br>进入 file &gt; Settings，在输入框搜索 encoding。<br>找到 Editor &gt; File encodings，将 IDE Encoding 和 Project Encoding 设置为utf-8。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible</title>
    <url>/2017/05/19/IaC/Ansible/Ansible/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&#8194;&#8194;Ansible is a radically simple configuration-management, application deployment, task-execution, and multinode orchestration engine.</p>
<p>Design Principles</p>
<p>&#8194;Have a dead simple setup process and a minimal learning curve<br>&#8194;Be super fast &amp; parallel by default<br>&#8194;Require no server or client daemons; use existing SSHd<br>&#8194;Use a language that is both machine and human friendly<br>&#8194;Focus on security and easy auditability/review/rewriting of content<br>&#8194;Manage remote machines instantly, without bootstrapping<br>&#8194;Allow module development in any dynamic language, not just Python<br>&#8194;Be usable as non-root<br>&#8194;Be the easiest IT automation system to use, ever.<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&#8194;&#8194;ansible依赖于Python 2.6或更高的版本、paramiko、PyYAML及Jinja2。</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>&#8194;&#8194;解决依赖关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install python-jinja2 PyYAML python-paramiko python-babel python-crypto</span></span><br><span class="line"><span class="comment"># tar xf ansible-1.5.4.tar.gz</span></span><br><span class="line"><span class="comment"># cd ansible-1.5.4</span></span><br><span class="line"><span class="comment"># python setup.py build</span></span><br><span class="line"><span class="comment"># python setup.py install</span></span><br><span class="line"><span class="comment"># mkdir /etc/ansible</span></span><br><span class="line"><span class="comment"># cp -r examples/* /etc/ansible</span></span><br></pre></td></tr></table></figure>
<h2 id="rpm包安装"><a href="#rpm包安装" class="headerlink" title="rpm包安装"></a>rpm包安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install ansible</span></span><br></pre></td></tr></table></figure>
<p><em>注意：不同版本的ansible的功能差异可能较大。</em></p>
<h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>&#8194;&#8194;ansible通过ssh实现配置管理、应用部署、任务执行等功能，因此，需要事先配置ansible端能基于密钥认证的方式联系各被管理节点。</p>
<p>&#8194;&#8194;ansible <host-pattern>&#8194;[-f forks]&#8194;[-m module_name]&#8194;[-a args]<br><em>-m module：默认为command</em></p>
<p>&#8194;&#8194;ansible-doc: Show Ansible module documentation<br>&#8194;&#8194;-l, —list&#8194;&#8194;&#8194;&#8194;&#8194;List available modules<br>&#8194;&#8194;-s, —snippet&#8194;Show playbook snippet for specified module(s)</p>
<h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><h2 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h2><p>&#8194;&#8194;YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。</p>
<p>&#8194;&#8194;YAML Ain’t Markup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。其特性：</p>
<p>&#8194;&#8194;YAML的可读性好<br>&#8194;&#8194;YAML和脚本语言的交互性好<br>&#8194;&#8194;YAML使用实现语言的数据类型<br>&#8194;&#8194;YAML有一个一致的信息模型<br>&#8194;&#8194;YAML易于实现<br>&#8194;&#8194;YAML可以基于流来处理<br>&#8194;&#8194;YAML表达能力强，扩展性好</p>
<p>更多的内容及规范参见<a href="http://www.yaml.org。" target="_blank" rel="noopener">http://www.yaml.org。</a></p>
<h2 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h2><p>&#8194;&#8194;YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔。下面是一个示例。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Smith</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">41</span></span><br><span class="line"><span class="attr">gender:</span> <span class="string">Male</span></span><br><span class="line"><span class="attr">spouse:</span></span><br><span class="line">   	<span class="attr">name:</span> <span class="string">Jane</span> <span class="string">Smith</span></span><br><span class="line">   	<span class="attr">age:</span> <span class="number">37</span></span><br><span class="line">   	<span class="attr">gender:</span> <span class="string">Female</span></span><br><span class="line"><span class="attr">children:</span></span><br><span class="line">   	<span class="bullet">-</span>   <span class="attr">name:</span> <span class="string">Jimmy</span> <span class="string">Smith</span></span><br><span class="line">       	<span class="attr">age:</span> <span class="number">17</span></span><br><span class="line">       	<span class="attr">gender:</span> <span class="string">Male</span></span><br><span class="line">   	<span class="bullet">-</span>   <span class="attr">name:</span> <span class="string">Jenny</span> <span class="string">Smith</span></span><br><span class="line">       	<span class="string">age</span> <span class="number">13</span></span><br><span class="line">       	<span class="attr">gender:</span> <span class="string">Female</span></span><br></pre></td></tr></table></figure>
<p><em>YAML文件扩展名通常为.yaml，如example.yaml</em></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列表的所有元素均使用“-”打头，例如：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A list of tasty fruits</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Apple</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Orange</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Strawberry</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Mango</span></span><br></pre></td></tr></table></figure></p>
<h3 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h3><p>字典通过key与valuef进行标识，例如：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># An employee record</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Example</span> <span class="string">Developer</span></span><br><span class="line"><span class="attr">job:</span> <span class="string">Developer</span></span><br><span class="line"><span class="attr">skill:</span> <span class="string">Elite</span></span><br></pre></td></tr></table></figure></p>
<p>也可以将key:value放置于{}中进行表示，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># An employee record</span></span><br><span class="line"><span class="string">&#123;name:</span> <span class="string">Example</span> <span class="string">Developer,</span> <span class="attr">job:</span> <span class="string">Developer,</span> <span class="attr">skill:</span> <span class="string">Elite&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Ansible基础元素"><a href="#Ansible基础元素" class="headerlink" title="Ansible基础元素"></a>Ansible基础元素</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p><em>变量名仅能由字母、数字和下划线组成，且只能以字母开头。</em></p>
<h3 id="facts"><a href="#facts" class="headerlink" title="facts"></a>facts</h3><p><em>facts是由正在通信的远程目标主机发回的信息，这些信息被保存在ansible变量中。要获取指定的远程主机所支持的所有facts，可使用如下命令进行：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ansible hostname -m setup</span></span><br></pre></td></tr></table></figure>
<h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><p>把任务的输出定义为变量，然后用于其他任务，示例如下:</p>
<pre><code>  tasks:
     - shell: /usr/bin/foo
       register: foo_result
       ignore_errors: True
</code></pre><h5 id="5-1-4-通过命令行传递变量"><a href="#5-1-4-通过命令行传递变量" class="headerlink" title="5.1.4 通过命令行传递变量"></a>5.1.4 通过命令行传递变量</h5><p>在运行playbook的时候也可以传递一些变量供playbook使用，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook test.yml --extra-vars <span class="string">"hosts=test user=test"</span></span><br></pre></td></tr></table></figure>
<h3 id="通过roles传递变量"><a href="#通过roles传递变量" class="headerlink" title="通过roles传递变量"></a>通过roles传递变量</h3><p>当给一个主机应用角色的时候可以传递变量，然后在角色内使用这些变量，示例如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">foo_app_instance,</span> <span class="attr">dir:</span> <span class="string">'/web/htdocs/a.com'</span><span class="string">,</span>  <span class="attr">port:</span> <span class="number">8080</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h2><p>ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名。默认的inventory file为/etc/ansible/hosts。</p>
<p>inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成。</p>
<h3 id="inventory文件格式"><a href="#inventory文件格式" class="headerlink" title="inventory文件格式"></a>inventory文件格式</h3><p>inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ntp.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[webservers]</span></span><br><span class="line"><span class="string">webnode1:2222</span></span><br><span class="line"><span class="string">www.test.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[dbservers]</span></span><br><span class="line"><span class="string">db1.ansible.com</span></span><br><span class="line"><span class="string">db2.ansible.com</span></span><br><span class="line"><span class="string">db3.mysql.com</span></span><br></pre></td></tr></table></figure>
<p>如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[webservers]</span></span><br><span class="line"><span class="string">www[01:50].example.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[databases]</span></span><br><span class="line"><span class="string">db-[a:f].example.com</span></span><br></pre></td></tr></table></figure>
<h3 id="主机变量"><a href="#主机变量" class="headerlink" title="主机变量"></a>主机变量</h3><p>可以在inventory中定义主机时为其添加主机变量以便于在playbook中使用。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[webservers]</span></span><br><span class="line"><span class="string">www1.example.com</span> <span class="string">http_port=80</span> <span class="string">maxRequestsPerChild=808</span></span><br><span class="line"><span class="string">www2.example.com</span> <span class="string">http_port=8080</span> <span class="string">maxRequestsPerChild=909</span></span><br></pre></td></tr></table></figure>
<h3 id="组变量"><a href="#组变量" class="headerlink" title="组变量"></a>组变量</h3><p>组变量是指赋予给指定组内所有主机上的在playbook中可用的变量。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[webservers]</span></span><br><span class="line"><span class="string">www1.example.com</span></span><br><span class="line"><span class="string">www2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[webservers:vars]</span></span><br><span class="line"><span class="string">ntp_server=ntp.example.com</span></span><br><span class="line"><span class="string">nfs_server=nfs.example.com</span></span><br></pre></td></tr></table></figure>
<h3 id="组嵌套"><a href="#组嵌套" class="headerlink" title="组嵌套"></a>组嵌套</h3><p>inventory中，组还可以包含其它的组，并且也可以向组中的主机指定变量。不过，这些变量只能在ansible-playbook中使用，而ansible不支持。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[apache]</span></span><br><span class="line"><span class="string">httpd1.example.com</span></span><br><span class="line"><span class="string">httpd2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[nginx]</span></span><br><span class="line"><span class="string">ngx1.example.com</span></span><br><span class="line"><span class="string">ngx2.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="string">[webservers:children]</span></span><br><span class="line"><span class="string">apache</span></span><br><span class="line"><span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="string">[webservers:vars]</span></span><br><span class="line"><span class="string">ntp_server=ntp.example.com</span></span><br></pre></td></tr></table></figure>
<h3 id="inventory参数"><a href="#inventory参数" class="headerlink" title="inventory参数"></a>inventory参数</h3><p>ansible基于ssh连接inventory中指定的远程主机时，还可以通过参数指定其交互方式；这些参数如下所示：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">ansible_ssh_host</span></span><br><span class="line">  <span class="string">The</span> <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">host</span> <span class="string">to</span> <span class="string">connect</span> <span class="string">to,</span> <span class="string">if</span> <span class="string">different</span> <span class="string">from</span> <span class="string">the</span> <span class="string">alias</span> <span class="string">you</span> <span class="string">wish</span> <span class="string">to</span> <span class="string">give</span> <span class="string">to</span> <span class="string">it.</span></span><br><span class="line"><span class="string">ansible_ssh_port</span></span><br><span class="line">  <span class="string">The</span> <span class="string">ssh</span> <span class="string">port</span> <span class="string">number,</span> <span class="string">if</span> <span class="string">not</span> <span class="number">22</span></span><br><span class="line"><span class="string">ansible_ssh_user</span></span><br><span class="line">  <span class="string">The</span> <span class="string">default</span> <span class="string">ssh</span> <span class="string">user</span> <span class="string">name</span> <span class="string">to</span> <span class="string">use.</span></span><br><span class="line"><span class="string">ansible_ssh_pass</span></span><br><span class="line">  <span class="string">The</span> <span class="string">ssh</span> <span class="string">password</span> <span class="string">to</span> <span class="string">use</span> <span class="string">(this</span> <span class="string">is</span> <span class="string">insecure,</span> <span class="string">we</span> <span class="string">strongly</span> <span class="string">recommend</span> <span class="string">using</span> <span class="string">--ask-pass</span> <span class="string">or</span> <span class="string">SSH</span> <span class="string">keys)</span></span><br><span class="line"><span class="string">ansible_sudo_pass</span></span><br><span class="line">  <span class="string">The</span> <span class="string">sudo</span> <span class="string">password</span> <span class="string">to</span> <span class="string">use</span> <span class="string">(this</span> <span class="string">is</span> <span class="string">insecure,</span> <span class="string">we</span> <span class="string">strongly</span> <span class="string">recommend</span> <span class="string">using</span> <span class="string">--ask-sudo-pass)</span></span><br><span class="line"><span class="string">ansible_connection</span></span><br><span class="line">  <span class="string">Connection</span> <span class="string">type</span> <span class="string">of</span> <span class="string">the</span> <span class="string">host.</span> <span class="string">Candidates</span> <span class="string">are</span> <span class="string">local,</span> <span class="string">ssh</span> <span class="string">or</span> <span class="string">paramiko.</span>  <span class="string">The</span> <span class="string">default</span> <span class="string">is</span> <span class="string">paramiko</span> <span class="string">before</span> <span class="string">Ansible</span> <span class="number">1.2</span><span class="string">,</span> <span class="string">and</span> <span class="string">'smart'</span> <span class="string">afterwards</span> <span class="string">which</span> <span class="string">detects</span> <span class="string">whether</span> <span class="string">usage</span> <span class="string">of</span> <span class="string">'ssh'</span> <span class="string">would</span> <span class="string">be</span> <span class="string">feasible</span> <span class="string">based</span> <span class="string">on</span> <span class="string">whether</span> <span class="string">ControlPersist</span> <span class="string">is</span> <span class="string">supported.</span></span><br><span class="line"><span class="string">ansible_ssh_private_key_file</span></span><br><span class="line">  <span class="string">Private</span> <span class="string">key</span> <span class="string">file</span> <span class="string">used</span> <span class="string">by</span> <span class="string">ssh.</span>  <span class="string">Useful</span> <span class="string">if</span> <span class="string">using</span> <span class="string">multiple</span> <span class="string">keys</span> <span class="string">and</span> <span class="string">you</span> <span class="string">don't</span> <span class="string">want</span> <span class="string">to</span> <span class="string">use</span> <span class="string">SSH</span> <span class="string">agent.</span></span><br><span class="line"><span class="string">ansible_shell_type</span></span><br><span class="line">  <span class="string">The</span> <span class="string">shell</span> <span class="string">type</span> <span class="string">of</span> <span class="string">the</span> <span class="string">target</span> <span class="string">system.</span> <span class="string">By</span> <span class="string">default</span> <span class="string">commands</span> <span class="string">are</span> <span class="string">formatted</span> <span class="string">using</span> <span class="string">'sh'</span><span class="string">-style</span> <span class="string">syntax</span> <span class="string">by</span> <span class="string">default.</span> <span class="string">Setting</span> <span class="string">this</span> <span class="string">to</span> <span class="string">'csh'</span> <span class="string">or</span> <span class="string">'fish'</span> <span class="string">will</span> <span class="string">cause</span> <span class="string">commands</span> <span class="string">executed</span> <span class="string">on</span> <span class="string">target</span> <span class="string">systems</span> <span class="string">to</span> <span class="string">follow</span> <span class="string">those</span> <span class="string">shell's</span> <span class="string">syntax</span> <span class="string">instead.</span></span><br><span class="line"><span class="string">ansible_python_interpreter</span></span><br><span class="line">  <span class="string">The</span> <span class="string">target</span> <span class="string">host</span> <span class="string">python</span> <span class="string">path.</span> <span class="string">This</span> <span class="string">is</span> <span class="string">useful</span> <span class="string">for</span> <span class="string">systems</span> <span class="string">with</span> <span class="string">more</span></span><br><span class="line">  <span class="string">than</span> <span class="string">one</span> <span class="string">Python</span> <span class="string">or</span> <span class="string">not</span> <span class="string">located</span> <span class="string">at</span> <span class="string">"/usr/bin/python"</span> <span class="string">such</span> <span class="string">as</span> <span class="string">\*BSD,</span> <span class="string">or</span> <span class="string">where</span> <span class="string">/usr/bin/python</span></span><br><span class="line">  <span class="string">is</span> <span class="string">not</span> <span class="string">a</span> <span class="number">2.</span><span class="string">X</span> <span class="string">series</span> <span class="string">Python.</span>  <span class="string">We</span> <span class="string">do</span> <span class="string">not</span> <span class="string">use</span> <span class="string">the</span> <span class="string">"/usr/bin/env"</span> <span class="string">mechanism</span> <span class="string">as</span> <span class="string">that</span> <span class="string">requires</span> <span class="string">the</span> <span class="string">remote</span> <span class="string">user's</span></span><br><span class="line">  <span class="string">path</span> <span class="string">to</span> <span class="string">be</span> <span class="string">set</span> <span class="string">right</span> <span class="string">and</span> <span class="string">also</span> <span class="string">assumes</span> <span class="string">the</span> <span class="string">"python"</span> <span class="string">executable</span> <span class="string">is</span> <span class="string">named</span> <span class="string">python,</span> <span class="string">where</span> <span class="string">the</span> <span class="string">executable</span> <span class="string">might</span></span><br><span class="line">  <span class="string">be</span> <span class="string">named</span> <span class="string">something</span> <span class="string">like</span> <span class="string">"python26"</span><span class="string">.</span></span><br><span class="line"><span class="string">ansible\_\*\_interpreter</span></span><br><span class="line">  <span class="string">Works</span> <span class="string">for</span> <span class="string">anything</span> <span class="string">such</span> <span class="string">as</span> <span class="string">ruby</span> <span class="string">or</span> <span class="string">perl</span> <span class="string">and</span> <span class="string">works</span> <span class="string">just</span> <span class="string">like</span> <span class="string">ansible_python_interpreter.</span></span><br><span class="line">  <span class="string">This</span> <span class="string">replaces</span> <span class="string">shebang</span> <span class="string">of</span> <span class="string">modules</span> <span class="string">which</span> <span class="string">will</span> <span class="string">run</span> <span class="string">on</span> <span class="string">that</span> <span class="string">host.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p>如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试。</p>
<h3 id="when语句"><a href="#when语句" class="headerlink" title="when语句"></a>when语句</h3><p>在task后添加when子句即可使用条件测试；when语句支持Jinja2表达式语法。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">"shutdown Debian flavored systems"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">/sbin/shutdown</span> <span class="string">-h</span> <span class="string">now</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">ansible_os_family</span> <span class="string">==</span> <span class="string">"Debian"</span></span><br></pre></td></tr></table></figure>
<p>when语句中还可以使用Jinja2的大多“filter”，例如要忽略此前某语句的错误并基于其结果（failed或者sucess）运行后面指定的语句，可使用类似如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/false</span></span><br><span class="line">    <span class="attr">register:</span> <span class="string">result</span></span><br><span class="line">    <span class="attr">ignore_errors:</span> <span class="literal">True</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/something</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">result|failed</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/something_else</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">result|success</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span> <span class="string">/bin/still/something_else</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">result|skipped</span></span><br></pre></td></tr></table></figure>
<p>此外，when语句中还可以使用facts或playbook中定义的变量。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br><span class="line">  <span class="attr">with_items:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">testuser1</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">testuser2</span></span><br></pre></td></tr></table></figure>
<p>上面语句的功能等同于下面的语句：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">testuser1</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=testuser1</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">user</span> <span class="string">testuser2</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=testuser2</span> <span class="string">state=present</span> <span class="string">groups=wheel</span></span><br></pre></td></tr></table></figure>
<p>事实上，with_items中可以使用元素还可为hashes，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">add</span> <span class="string">several</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">name=&#123;&#123;</span> <span class="string">item.name</span> <span class="string">&#125;&#125;</span> <span class="string">state=present</span> <span class="string">groups=&#123;&#123;</span> <span class="string">item.groups</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">with_items:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser1'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'wheel'</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">name:</span> <span class="string">'testuser2'</span><span class="string">,</span> <span class="attr">groups:</span> <span class="string">'root'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>ansible的循环机制还有更多的高级功能，具体请参见官方文档（<a href="http://docs.ansible.com/playbooks_loops.html）。" target="_blank" rel="noopener">http://docs.ansible.com/playbooks_loops.html）。</a></p>
<h1 id="ansible-playbooks"><a href="#ansible-playbooks" class="headerlink" title="ansible playbooks"></a>ansible playbooks</h1><p>playbook是由一个或多个“play”组成的列表。play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏。下面是一个简单示例。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webnodes</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">http_port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">max_clients:</span> <span class="number">256</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">at</span> <span class="string">the</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line">    <span class="attr">yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>
<h2 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h2><h3 id="Hosts和Users"><a href="#Hosts和Users" class="headerlink" title="Hosts和Users"></a>Hosts和Users</h3><p>playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，其可以是一个或多个由冒号分隔主机组；remote_user则用于指定远程主机上的执行任务的用户。如上面示例中的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webnodes</span></span><br><span class="line">	  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="string">不过，remote_user也可用于各task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户。</span></span><br><span class="line"></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webnodes</span></span><br><span class="line">		  <span class="attr">remote_user:</span> <span class="string">test</span></span><br><span class="line">		  <span class="attr">tasks:</span></span><br><span class="line">		    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span> <span class="string">connection</span></span><br><span class="line">		      <span class="attr">ping:</span></span><br><span class="line">		      <span class="attr">remote_user:</span> <span class="string">test</span></span><br><span class="line">		      <span class="attr">sudo:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<h3 id="任务列表和action"><a href="#任务列表和action" class="headerlink" title="任务列表和action"></a>任务列表和action</h3><p>play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。在运行自下而下某playbook时，如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可。</p>
<p>task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致。</p>
<p>每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出。</p>
<p>定义task的可以使用“action: module options”或“module: options”的格式，推荐使用后者以实现向后兼容。如果action一行的内容过多，也中使用在行首使用几个空白字符进行换行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">    <span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">make</span> <span class="string">sure</span> <span class="string">apache</span> <span class="string">is</span> <span class="string">running</span></span><br><span class="line">  <span class="attr">service:</span> <span class="string">name=httpd</span> <span class="string">state=running</span></span><br></pre></td></tr></table></figure>
<p>在众多模块中，只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">    <span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">disable</span> <span class="string">selinux</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">/sbin/setenforce</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果命令或脚本的退出码不为零，可以使用如下方式替代：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">    <span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br></pre></td></tr></table></figure>
<p>或者使用ignore_errors来忽略错误信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="attr">tasks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">/usr/bin/somecommand</span></span><br><span class="line">  <span class="attr">ignore_errors:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="handlers"><a href="#handlers" class="headerlink" title="handlers"></a>handlers</h3><p>用于当关注的资源发生变化时采取一定的操作。</p>
<p>“notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，取而代之，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">template</span> <span class="string">configuration</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">template:</span> <span class="string">src=template.j2</span> <span class="string">dest=/etc/foo.conf</span></span><br><span class="line">  <span class="attr">notify:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">restart</span> <span class="string">apache</span></span><br></pre></td></tr></table></figure>
<p>handler是task列表，这些task与前述的task并没有本质上的不同。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">memcached</span></span><br><span class="line">      <span class="attr">service:</span>  <span class="string">name=memcached</span> <span class="string">state=restarted</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">apache</span></span><br><span class="line">      <span class="attr">service:</span> <span class="string">name=apache</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>
<p>案例：<br>heartbeat.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">hbhosts</span></span><br><span class="line">  <span class="attr">remote_user:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ensure</span> <span class="string">heartbeat</span> <span class="string">latest</span> <span class="string">version</span></span><br><span class="line">      <span class="attr">yum:</span> <span class="string">name=heartbeat</span> <span class="string">state=present</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">authkeys</span> <span class="string">configure</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/root/hb_conf/authkeys</span> <span class="string">dest=/etc/ha.d/authkeys</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">authkeys</span> <span class="string">mode</span> <span class="number">600</span></span><br><span class="line">      <span class="attr">file:</span> <span class="string">path=/etc/ha.d/authkeys</span> <span class="string">mode=600</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">restart</span> <span class="string">heartbeat</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ha.cf</span> <span class="string">configure</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">copy:</span> <span class="string">src=/root/hb_conf/ha.cf</span> <span class="string">dest=/etc/ha.d/ha.cf</span></span><br><span class="line">      <span class="attr">notify:</span></span><br><span class="line">       	<span class="bullet">-</span> <span class="string">restart</span> <span class="string">heartbeat</span></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">  	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restart</span> <span class="string">heartbeat</span></span><br><span class="line">  	  <span class="attr">service:</span> <span class="string">name=heartbeat</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure>
<h1 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h1><p>ansilbe自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中。</p>
<p>一个roles的案例如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">site.yml</span></span><br><span class="line"><span class="string">webservers.yml</span></span><br><span class="line"><span class="string">fooservers.yml</span></span><br><span class="line"><span class="string">roles/</span></span><br><span class="line">   <span class="string">common/</span></span><br><span class="line">     <span class="string">files/</span></span><br><span class="line">     <span class="string">templates/</span></span><br><span class="line">     <span class="string">tasks/</span></span><br><span class="line">     <span class="string">handlers/</span></span><br><span class="line">     <span class="string">vars/</span></span><br><span class="line">     <span class="string">meta/</span></span><br><span class="line">   <span class="string">webservers/</span></span><br><span class="line">     <span class="string">files/</span></span><br><span class="line">     <span class="string">templates/</span></span><br><span class="line">     <span class="string">tasks/</span></span><br><span class="line">     <span class="string">handlers/</span></span><br><span class="line">     <span class="string">vars/</span></span><br><span class="line">     <span class="string">meta/</span></span><br></pre></td></tr></table></figure>
<p>而在playbook中，可以这样使用roles：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">webservers</span></span><br></pre></td></tr></table></figure>
<p>也可以向roles传递参数，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">common</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">foo_app_instance,</span> <span class="attr">dir:</span> <span class="string">'/opt/a'</span><span class="string">,</span>  <span class="attr">port:</span> <span class="number">5000</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">foo_app_instance,</span> <span class="attr">dir:</span> <span class="string">'/opt/b'</span><span class="string">,</span>  <span class="attr">port:</span> <span class="number">5001</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>甚至也可以条件式地使用roles，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">roles:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">&#123;</span> <span class="attr">role:</span> <span class="string">some_role,</span> <span class="attr">when:</span> <span class="string">"ansible_os_family == 'RedHat'"</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建role的步骤"><a href="#创建role的步骤" class="headerlink" title="创建role的步骤"></a>创建role的步骤</h2><p>(1) 创建以roles命名的目录；<br>(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等；<br>(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建；<br>(4) 在playbook文件中，调用各角色；</p>
<h2 id="role内各目录中可用的文件"><a href="#role内各目录中可用的文件" class="headerlink" title="role内各目录中可用的文件"></a>role内各目录中可用的文件</h2><p>&#8194;&#8194;tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件；<br>&#8194;&#8194;files目录：存放由copy或script等模块调用的文件；<br>&#8194;&#8194;templates目录：template模块会自动在此目录中寻找Jinja2模板文件；<br>&#8194;&#8194;handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；在handler中使用include包含的其它的handler文件也应该位于此目录中；<br>&#8194;&#8194;vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；<br>&#8194;&#8194;meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持；<br>&#8194;&#8194;default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件；</p>
<h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><p>tags用于让用户选择运行或路过playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断。</p>
<h1 id="Jinja2相关"><a href="#Jinja2相关" class="headerlink" title="Jinja2相关"></a>Jinja2相关</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>&#8194;&#8194;表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python 对象。下面 的字面量是可用的:</p>
<pre><code>“Hello World”:
双引号或单引号中间的一切都是字符串。无论何时你需要在模板中使用一个字 符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），它们都是 有用的。

42 / 42.23:
直接写下数值就可以创建整数和浮点数。如果有小数点，则为浮点数，否则为 整数。记住在 Python 里， 42 和 42.0 是不一样的。

[‘list’, ‘of’, ‘objects’]:
一对中括号括起来的东西是一个列表。列表用于存储和迭代序列化的数据。例如 你可以容易地在 for 循环中用列表和元组创建一个链接的列表:

&lt;ul&gt;
{% for href, caption in [('index.html', 'Index'), ('about.html', 'About'),
	                         ('downloads.html', 'Downloads')] %}
    &lt;li&gt;&lt;a href=&quot;{{ href }}&quot;&gt;{{ caption }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;

(‘tuple’, ‘of’, ‘values’):
元组与列表类似，只是你不能修改元组。如果元组中只有一个项，你需要以逗号 结尾它。元组通常用于表示两个或更多元素的项。更多细节见上面的例子。

{‘dict’: ‘of’, ‘key’: ‘and’, ‘value’: ‘pairs’}:
Python 中的字典是一种关联键和值的结构。键必须是唯一的，并且键必须只有一个 值。字典在模板中很少使用，罕用于诸如 xmlattr() 过滤器之类。

true / false:
true 永远是 true ，而 false 始终是 false 。
</code></pre><h4 id="9-2-算术运算"><a href="#9-2-算术运算" class="headerlink" title="9.2 算术运算"></a>9.2 算术运算</h4><p>Jinja 允许你用计算值。这在模板中很少用到，但是为了完整性允许其存在。支持下面的 运算符:</p>
<pre><code>+
    把两个对象加到一起。通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接它们。无论如何这不是首选的连接字符串的方式！连接字符串见 ~ 运算符。 {{ 1 + 1 }} 等于 2 。
-
    用第一个数减去第二个数。 {{ 3 - 2 }} 等于 1 。
/
    对两个数做除法。返回值会是一个浮点数。 {{ 1 / 2 }} 等于 {{ 0.5 }} 。
//
    对两个数做除法，返回整数商。 {{ 20 // 7 }} 等于 2 。
%
    计算整数除法的余数。 {{ 11 % 7 }} 等于 4 。
*
    用右边的数乘左边的操作数。 {{ 2 * 2 }} 会返回 4 。也可以用于重 复一个字符串多次。 {{ ‘=’ * 80 }} 会打印 80 个等号的横条。
**
    取左操作数的右操作数次幂。 {{ 2**3 }} 会返回 8 。
</code></pre><h4 id="9-3-比较操作符"><a href="#9-3-比较操作符" class="headerlink" title="9.3 比较操作符"></a>9.3 比较操作符</h4><pre><code>==
    比较两个对象是否相等。
!=
    比较两个对象是否不等。
&gt;
    如果左边大于右边，返回 true 。
&gt;=
    如果左边大于等于右边，返回 true 。
&lt;
    如果左边小于右边，返回 true 。
&lt;=
    如果左边小于等于右边，返回 true 。
</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式:</p>
<pre><code>and
    如果左操作数和右操作数同为真，返回 true 。
or
    如果左操作数和右操作数有一个为真，返回 true 。
not
    对一个表达式取反（见下）。
(expr)
    表达式组。
</code></pre>]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
</search>
